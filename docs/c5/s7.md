# 5.7. 冒泡排序

**5.7. The Bubble Sort**

<!--冒泡排序需要-->
<script src="../js/animationbase.js"></script>
<script src="../js/sortmodels.js"></script>
<script src="../js/sortviewers.js"></script>

=== "中文"

    The **bubble sort** makes multiple passes through a list. It compares adjacent items and exchanges those that are out of order. Each pass through the list places the next largest value in its proper place. In essence, each item bubbles up to the location where it belongs.
    
    `Figure 1` shows the first pass of a bubble sort. The shaded items are being compared to see if they are out of order. If there are $n$ items in the list, then there are $n-1$ pairs of items that need to be compared on the first pass. It is important to note that once the largest value in the list is part of a pair, it will continually be moved along until the pass is complete.
        
    <figure markdown="span">
        ![Image title](./imgs/bubblepass.png)
        <figcaption markdown="span">Figure 1: Bubble Sort: The First Pass</figcaption>
    </figure>
    
    At the start of the second pass, the largest value is now in place. There are $n-1$ items left to sort, meaning that there will be $n-2$ pairs. Since each pass places the next largest value in place, the total number of passes necessary will be $n-1$. After completing the $n-1$ passes, the smallest item must be in the correct position with no further processing required. `ActiveCode 1` shows the complete ``bubble_sort`` function. It takes the list as a parameter and modifies it by exchanging items as necessary.
    
    The exchange operation, sometimes called a *swap*, is slightly different in Python than in most other programming languages. Typically, swapping two elements in a list requires a temporary variable (an additional memory location). A code fragment such as
    
    ```pycon
        temp = a_list[i]
        a_list[i] = a_list[j]
        a_list[j] = temp
    ```
    
    will exchange the $i$-th and $j$-th items in the list. Without the temporary storage, one of the values would be overwritten.
    
    In Python, it is possible to perform simultaneous assignment. The statement ``a, b = b, a`` will result in two assignment statements being done at the same time (see `Figure 2`). Using simultaneous assignment, the exchange operation can be done in one statement.
    
    Lines 5--7 in `ActiveCode 1` perform the exchange of the $i$ and $(i+1)$-th items using the three-step procedure described earlier. Note that we could also have used the simultaneous assignment to swap the items.
        
    <figure markdown="span">
        ![Image title](./imgs/swap.png)
        <figcaption markdown="span">Figure 2: Exchanging Two Values in Python</figcaption>
    </figure>
    
    The following activecode example shows the complete ``bubble_sort`` function working on the list shown above.
    
    ```python title="Activity: 5.7.1 The Bubble Sort Implementation" linenums="1"
    def bubble_sort(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    temp = a_list[j]
                    a_list[j] = a_list[j + 1]
                    a_list[j + 1] = temp
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    bubble_sort(a_list)
    print(a_list)
    ```
    
    The following animation shows ``bubble_sort`` in action.
    
    <div id="bubble_anim1" class="">
        <canvas id="bubble_anim1_canvas" width="400" height="400" style="border:4px solid blue"></canvas>
        <br>
        <button onclick="bubble_anim1_anim = bubble_anim_init('bubble_anim1')" style="border: 1px solid black;     background-color: buttonface; padding: 2px;">Initialize</button>
        <button onclick="bubble_anim1_anim.run('bubble_anim1_anim')" style="border: 1px solid black; background-color: buttonface; padding: 2px;" class="">Run</button>
        <button onclick="bubble_anim1_anim.stop()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Stop</button> <br>
        <button onclick="bubble_anim1_anim.begin()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Beginning</button>
        <button onclick="bubble_anim1_anim.forward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Forward</button>
        <button onclick="bubble_anim1_anim.backward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Backward</button>
        <button onclick="bubble_anim1_anim.end()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">End</button>
        <script>
        bubble_anim_init = function(divid)
        {
           var a = new Animator(new BubbleSortModel(), new BarViewer(), divid)
           a.init()
           return a
        }
        </script>
    </div>                   
    
     For more detail, CodeLens 1 allows you to step through the algorithm.
    
    ```python title="Tracing the Bubble Sort" linenums="1"
    def bubble_sort(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    temp = a_list[j]
                    a_list[j] = a_list[j + 1]
                    a_list[j + 1] = temp
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    bubble_sort(a_list)
    print(a_list)
    ```
    
    To analyze the bubble sort, we should note that regardless of how the items are arranged in the initial list, $n - 1$ passes will be made to sort a list of size $n$. `Table 1` shows the number of comparisons for each pass. The total number of comparisons is the sum of the first $n - 1$ integers. Recall that the sum of the first $n$ integers is $\frac{1}{2}n^{2} + \frac{1}{2}n$. The sum of the first $n - 1$ integers is $\frac{1}{2}n^{2} + \frac{1}{2}n - n$, which is $\frac{1}{2}n^{2} - \frac{1}{2}n$. This is still $O(n^{2})$ comparisons. In the best case, if the list is already ordered, no exchanges will be made. However, in the worst case, every comparison will cause an exchange. On average, we exchange half of the time.
    
    **Table 1: Comparisons for Each Pass of Bubble Sort**
        
    | **Pass** | **Comparisons** |
    | -------- | --------------- |
    | 1        | $n-1$           |
    | 2        | $n-2$           |
    | 3        | $n-3$           |
    | ...      | ...             |
    | $n-1$    | $1$             |
        
    
    
    A bubble sort is often considered the most inefficient sorting method since it must exchange items before the final location is known. These “wasted” exchange operations are very costly. However, because the bubble sort makes passes through the entire unsorted portion of the list, it has the capability to do something most sorting algorithms cannot. In particular, if during a pass there are no exchanges, then we know that the list must be sorted. A bubble sort can be modified to stop early if it finds that the list has become sorted. This means that for lists that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted list and stop. `ActiveCode 2` shows this modification, which is often referred to as the **short bubble**.
    
    ```python title="Activity: 5.7.2 The Short Bubble Sort Implementation" linenums="1"
    def bubble_sort_short(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            exchanges = False
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    exchanges = True
                    a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]
            if not exchanges:
                break
    
    
    a_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]
    bubble_sort_short(a_list)
    print(a_list)
    ```
        
    Finally, here is ``bubble_sort_short`` in CodeLens (CodeLens 2)..
    
    ```python title="Tracing the Short Bubble Sort" linenums="1"
    def bubble_sort_short(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            exchanges = False
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    exchanges = True
                    a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]
            if not exchanges:
                break
    
    
    a_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]
    bubble_sort_short(a_list)
    print(a_list)
    ```
     
    !!! info "Self Check"
    
        Suppose you have the following list of numbers to sort: <br>
        [19, 1, 9, 7, 3, 10, 13, 15, 8, 12] which list represents the partially sorted list after three complete passes of bubble sort?
    
        - answer a: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
        - answer b: [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]
        - answer c: [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]
        - answer d: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
    
        correct: b
        
        - feedback a:  This answer represents three swaps.  A pass means that you continue swapping all the way to the end of the list.
        - feedback b:  Very Good
        - feedback c: A bubble sort contines to swap numbers up to index position passnum.  But remember that passnum starts at the length of the list - 1.
        - feedback d: You have been doing an insertion sort, not a bubble sort.
    

=== "英文"

    The **bubble sort** makes multiple passes through a list. It compares adjacent items and exchanges those that are out of order. Each pass through the list places the next largest value in its proper place. In essence, each item bubbles up to the location where it belongs.
    
    `Figure 1` shows the first pass of a bubble sort. The shaded items are being compared to see if they are out of order. If there are $n$ items in the list, then there are $n-1$ pairs of items that need to be compared on the first pass. It is important to note that once the largest value in the list is part of a pair, it will continually be moved along until the pass is complete.
        
    <figure markdown="span">
        ![Image title](./imgs/bubblepass.png)
        <figcaption markdown="span">Figure 1: Bubble Sort: The First Pass</figcaption>
    </figure>
    
    At the start of the second pass, the largest value is now in place. There are $n-1$ items left to sort, meaning that there will be $n-2$ pairs. Since each pass places the next largest value in place, the total number of passes necessary will be $n-1$. After completing the $n-1$ passes, the smallest item must be in the correct position with no further processing required. `ActiveCode 1` shows the complete ``bubble_sort`` function. It takes the list as a parameter and modifies it by exchanging items as necessary.
    
    The exchange operation, sometimes called a *swap*, is slightly different in Python than in most other programming languages. Typically, swapping two elements in a list requires a temporary variable (an additional memory location). A code fragment such as
    
    ```pycon
        temp = a_list[i]
        a_list[i] = a_list[j]
        a_list[j] = temp
    ```
    
    will exchange the $i$-th and $j$-th items in the list. Without the temporary storage, one of the values would be overwritten.
    
    In Python, it is possible to perform simultaneous assignment. The statement ``a, b = b, a`` will result in two assignment statements being done at the same time (see `Figure 2`). Using simultaneous assignment, the exchange operation can be done in one statement.
    
    Lines 5--7 in `ActiveCode 1` perform the exchange of the $i$ and $(i+1)$-th items using the three-step procedure described earlier. Note that we could also have used the simultaneous assignment to swap the items.
        
    <figure markdown="span">
        ![Image title](./imgs/swap.png)
        <figcaption markdown="span">Figure 2: Exchanging Two Values in Python</figcaption>
    </figure>
    
    The following activecode example shows the complete ``bubble_sort`` function working on the list shown above.
    
    ```python title="Activity: 5.7.1 The Bubble Sort Implementation" linenums="1"
    def bubble_sort(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    temp = a_list[j]
                    a_list[j] = a_list[j + 1]
                    a_list[j + 1] = temp
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    bubble_sort(a_list)
    print(a_list)
    ```
    
    The following animation shows ``bubble_sort`` in action.
    
    <div id="bubble_anim" class="">
        <canvas id="bubble_anim_canvas" width="400" height="400" style="border:4px solid blue"></canvas>
        <br>
        <button onclick="bubble_anim_anim = bubble_anim_init('bubble_anim')" style="border: 1px solid black;     background-color: buttonface; padding: 2px;">Initialize</button>
        <button onclick="bubble_anim_anim.run('bubble_anim_anim')" style="border: 1px solid black; background-color: buttonface; padding: 2px;" class="">Run</button>
        <button onclick="bubble_anim_anim.stop()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Stop</button> <br>
        <button onclick="bubble_anim_anim.begin()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Beginning</button>
        <button onclick="bubble_anim_anim.forward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Forward</button>
        <button onclick="bubble_anim_anim.backward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Backward</button>
        <button onclick="bubble_anim_anim.end()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">End</button>
        <script>
        bubble_anim_init = function(divid)
        {
           var a = new Animator(new BubbleSortModel(), new BarViewer(), divid)
           a.init()
           return a
        }
        </script>
    </div>                   
    
     For more detail, CodeLens 1 allows you to step through the algorithm.
    
    ```python title="Tracing the Bubble Sort" linenums="1"
    def bubble_sort(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    temp = a_list[j]
                    a_list[j] = a_list[j + 1]
                    a_list[j + 1] = temp
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    bubble_sort(a_list)
    print(a_list)
    ```
    
    To analyze the bubble sort, we should note that regardless of how the items are arranged in the initial list, $n - 1$ passes will be made to sort a list of size $n$. `Table 1` shows the number of comparisons for each pass. The total number of comparisons is the sum of the first $n - 1$ integers. Recall that the sum of the first $n$ integers is $\frac{1}{2}n^{2} + \frac{1}{2}n$. The sum of the first $n - 1$ integers is $\frac{1}{2}n^{2} + \frac{1}{2}n - n$, which is $\frac{1}{2}n^{2} - \frac{1}{2}n$. This is still $O(n^{2})$ comparisons. In the best case, if the list is already ordered, no exchanges will be made. However, in the worst case, every comparison will cause an exchange. On average, we exchange half of the time.
    
    **Table 1: Comparisons for Each Pass of Bubble Sort**
        
    | **Pass** | **Comparisons** |
    | -------- | --------------- |
    | 1        | $n-1$           |
    | 2        | $n-2$           |
    | 3        | $n-3$           |
    | ...      | ...             |
    | $n-1$    | $1$             |
        
    
    
    A bubble sort is often considered the most inefficient sorting method since it must exchange items before the final location is known. These “wasted” exchange operations are very costly. However, because the bubble sort makes passes through the entire unsorted portion of the list, it has the capability to do something most sorting algorithms cannot. In particular, if during a pass there are no exchanges, then we know that the list must be sorted. A bubble sort can be modified to stop early if it finds that the list has become sorted. This means that for lists that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted list and stop. `ActiveCode 2` shows this modification, which is often referred to as the **short bubble**.
    
    ```python title="Activity: 5.7.2 The Short Bubble Sort Implementation" linenums="1"
    def bubble_sort_short(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            exchanges = False
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    exchanges = True
                    a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]
            if not exchanges:
                break
    
    
    a_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]
    bubble_sort_short(a_list)
    print(a_list)
    ```
        
    Finally, here is ``bubble_sort_short`` in CodeLens (CodeLens 2)..
    
    ```python title="Tracing the Short Bubble Sort" linenums="1"
    def bubble_sort_short(a_list):
        for i in range(len(a_list) - 1, 0, -1):
            exchanges = False
            for j in range(i):
                if a_list[j] > a_list[j + 1]:
                    exchanges = True
                    a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]
            if not exchanges:
                break
    
    
    a_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]
    bubble_sort_short(a_list)
    print(a_list)
    ```
     
    !!! info "Self Check"
    
        Suppose you have the following list of numbers to sort: <br>
        [19, 1, 9, 7, 3, 10, 13, 15, 8, 12] which list represents the partially sorted list after three complete passes of bubble sort?
    
        - answer a: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
        - answer b: [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]
        - answer c: [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]
        - answer d: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
    
        correct: b
        
        - feedback a:  This answer represents three swaps.  A pass means that you continue swapping all the way to the end of the list.
        - feedback b:  Very Good
        - feedback c: A bubble sort contines to swap numbers up to index position passnum.  But remember that passnum starts at the length of the list - 1.
        - feedback d: You have been doing an insertion sort, not a bubble sort.
    