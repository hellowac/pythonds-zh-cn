# 5.8. 选择排序

**5.8. The Selection Sort**

<!--泡排序需要-->
<script src="../js/animationbase.js"></script>
<script src="../js/sortmodels.js"></script>
<script src="../js/sortviewers.js"></script>

=== "中文"
    
    The **selection sort** improves on the bubble sort by making only one exchange for every pass through the list. In order to do this, a selection sort looks for the largest value as it makes a pass and, after completing the pass, places it in the proper location. As with a bubble sort, after the first pass, the largest item is in the correct place. After the second pass, the next largest is in place. This process continues and requires $n - 1$ passes to sort $n$ items, since the final item must be in place after the $(n - 1)$-th pass.
    
    `Figure 3` shows the entire sorting process for the selection sort. On each pass, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. The function is shown in `ActiveCode 1`.
            
    <figure markdown="span">
        ![Image title](./imgs/selectionsortnew.png)
        <figcaption markdown="span">Figure 3: Selection Sort: Complete</figcaption>
    </figure>
    
    ```python title="Activity: 5.8.1 Selection Sort" linenums="1"
    def selection_sort(a_list):
        for i, item in enumerate(a_list):
            min_idx = len(a_list) - 1
            for j in range(i, len(a_list)):
                if a_list[j] < a_list[min_idx]:
                    min_idx = j
            if min_idx != i:
                a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    selection_sort(a_list)
    print(a_list)
    ```
    
    <div id="selection_anim1" class="">
        <canvas id="selection_anim1_canvas" width="400" height="400" style="border:4px solid blue"></canvas>
        <br>
        <button onclick="selection_anim1_anim = selection_anim_init('selection_anim1')" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Initialize</button>
        <button onclick="selection_anim1_anim.run('selection_anim1_anim')" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Run</button>
        <button onclick="selection_anim1_anim.stop()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Stop</button> <br>
        <button onclick="selection_anim1_anim.begin()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Beginning</button>
        <button onclick="selection_anim1_anim.forward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Forward</button>
        <button onclick="selection_anim1_anim.backward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Backward</button>
        <button onclick="selection_anim1_anim.end()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">End</button>
        <script>
        selection_anim_init = function(divid)
        {
           var a = new Animator(new SelectionSortModel(), new BarViewer(), divid)
           a.init()
           return a
        }
        </script>
    </div>
       
    
    For more detail, CodeLens 3 allows you to step through the algorithm.
    
    ```python title="Tracing the Selection Sort" linenums="1"
    def selection_sort(a_list):
        for i, item in enumerate(a_list):
            min_idx = len(a_list) - 1
            for j in range(i, len(a_list)):
                if a_list[j] < a_list[min_idx]:
                    min_idx = j
            if min_idx != i:
                a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    selection_sort(a_list)
    print(a_list)
    ```
    
    You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also $O(n^{2})$. However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies. In fact, for our list, the bubble sort makes 20 exchanges, while the selection sort makes only 8.
    
    
    !!! info "Self Check"
        
        Suppose you have the following list of numbers to sort:
        
        [11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which list represents the partially sorted list after three complete passes of selection sort?
    
        - answer a: [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]
        - answer b: [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]
        - answer c: [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]
        - answer d: [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]
    
        correct: d
    
        - feedback a: Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps
        - feedback b: This looks like an insertion sort.
        - feedback c: This one looks similar to the correct answer but instead of swapping the numbers have been shifted to the left to make room for the correct numbers.
        - feedback d: Selection sort improves upon bubble sort by making fewer swaps.
    
        

=== "英文"
    
    The **selection sort** improves on the bubble sort by making only one exchange for every pass through the list. In order to do this, a selection sort looks for the largest value as it makes a pass and, after completing the pass, places it in the proper location. As with a bubble sort, after the first pass, the largest item is in the correct place. After the second pass, the next largest is in place. This process continues and requires $n - 1$ passes to sort $n$ items, since the final item must be in place after the $(n - 1)$-th pass.
    
    `Figure 3` shows the entire sorting process for the selection sort. On each pass, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. The function is shown in `ActiveCode 1`.
            
    <figure markdown="span">
        ![Image title](./imgs/selectionsortnew.png)
        <figcaption markdown="span">Figure 3: Selection Sort: Complete</figcaption>
    </figure>
    
    ```python title="Activity: 5.8.1 Selection Sort" linenums="1"
    def selection_sort(a_list):
        for i, item in enumerate(a_list):
            min_idx = len(a_list) - 1
            for j in range(i, len(a_list)):
                if a_list[j] < a_list[min_idx]:
                    min_idx = j
            if min_idx != i:
                a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]
    
    
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    selection_sort(a_list)
    print(a_list)
    ```
    
    <div id="selection_anim" class="">
        <canvas id="selection_anim_canvas" width="400" height="400" style="border:4px solid blue"></canvas>
        <br>
        <button onclick="selection_anim_anim = selection_anim_init('selection_anim')" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Initialize</button>
        <button onclick="selection_anim_anim.run('selection_anim_anim')" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Run</button>
        <button onclick="selection_anim_anim.stop()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Stop</button> <br>
        <button onclick="selection_anim_anim.begin()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Beginning</button>
        <button onclick="selection_anim_anim.forward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Forward</button>
        <button onclick="selection_anim_anim.backward()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">Step Backward</button>
        <button onclick="selection_anim_anim.end()" style="border: 1px solid black; background-color: buttonface; padding: 2px;">End</button>
        <script>
        selection_anim_init = function(divid)
        {
           var a = new Animator(new SelectionSortModel(), new BarViewer(), divid)
           a.init()
           return a
        }
        </script>
    </div>
       
    
    For more detail, CodeLens 3 allows you to step through the algorithm.
    
    ```python title="Tracing the Selection Sort" linenums="1"
    def selection_sort(a_list):
        for i, item in enumerate(a_list):
            min_idx = len(a_list) - 1
            for j in range(i, len(a_list)):
                if a_list[j] < a_list[min_idx]:
                    min_idx = j
            if min_idx != i:
                a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]
    a_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    selection_sort(a_list)
    print(a_list)
    ```
    
    You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also $O(n^{2})$. However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies. In fact, for our list, the bubble sort makes 20 exchanges, while the selection sort makes only 8.
    
    
    !!! info "Self Check"
        
        Suppose you have the following list of numbers to sort:
        
        [11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which list represents the partially sorted list after three complete passes of selection sort?
    
        - answer a: [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]
        - answer b: [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]
        - answer c: [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]
        - answer d: [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]
    
        correct: d
    
        - feedback a: Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps
        - feedback b: This looks like an insertion sort.
        - feedback c: This one looks similar to the correct answer but instead of swapping the numbers have been shifted to the left to make room for the correct numbers.
        - feedback d: Selection sort improves upon bubble sort by making fewer swaps.
    
        

