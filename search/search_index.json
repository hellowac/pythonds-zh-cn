{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u901a\u8fc7python\u89e3\u51b3\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784\u95ee\u9898","text":"<p>Problem Solving with Algorithms and Data Structures using Python</p> \u4e2d\u6587\u82f1\u6587 <p>\u7531Brad Miller\u548cDavid Ranum\u64b0\u5199\uff0c\u6765\u81eaLuther College</p> <p>\u4f5c\u4e1a</p> <p>Gerry Jenkins\u5f55\u5236\u4e86\u4e00\u7cfb\u5217\u7cbe\u5f69\u7684YouTube\u89c6\u9891\uff0c\u652f\u6301\u672c\u4e66\u4e2d\u6240\u6709\u7ae0\u8282\u7684\u5b66\u4e60\u3002</p> <p>By Brad Miller and David Ranum, Luther College</p> <ul> <li>Assignments</li> </ul> <p>There is a wonderful collection of YouTube videos recorded by Gerry Jenkins to support all of the chapters in this text.</p>"},{"location":"#1-\u5f15\u8a00","title":"1. \u5f15\u8a00","text":"<p>1.Introduction</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>1.1. \u76ee\u6807 </li> <li>1.2. \u5165\u95e8 </li> <li>1.3. \u4ec0\u4e48\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\uff1f </li> <li>1.4. \u4ec0\u4e48\u662f\u7f16\u7a0b\uff1f </li> <li>1.5. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u6570\u636e\u7ed3\u6784\u548c\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff1f </li> <li>1.6. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u7b97\u6cd5\uff1f </li> <li>1.7. Python\u57fa\u7840\u56de\u987e </li> <li>1.8. \u6570\u636e\u5165\u95e8 <ul> <li>1.8.1. \u5185\u5efa\u7684\u539f\u5b50\u6570\u636e\u7c7b\u578b </li> <li>1.8.2. \u5185\u5efa\u7684\u96c6\u5408\u6570\u636e\u7c7b\u578b </li> </ul> </li> <li>1.9. \u8f93\u5165\u548c\u8f93\u51fa <ul> <li>1.9.1. \u5b57\u7b26\u4e32\u683c\u5f0f\u5316 </li> </ul> </li> <li>1.10. \u63a7\u5236\u7ed3\u6784 </li> <li>1.11. \u5f02\u5e38\u5904\u7406 </li> <li>1.12. \u5b9a\u4e49\u51fd\u6570 </li> <li>1.13. Python\u4e2d\u7684\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff1a\u5b9a\u4e49\u7c7b <ul> <li>1.13.1. \u4e00\u4e2a\u5206\u6570\u7c7b </li> <li>1.13.2. \u7ee7\u627f\uff1a\u903b\u8f91\u95e8\u548c\u7535\u8def </li> </ul> </li> <li>1.14. \u603b\u7ed3</li> <li>1.15. \u5173\u952e\u672f\u8bed </li> <li>1.16. \u7ec3\u4e60</li> </ul> <ul> <li>1.1. Objectives</li> <li>1.2. Getting Started</li> <li>1.3. What Is Computer Science?</li> <li>1.4. What Is Programming?</li> <li>1.5. Why Study Data Structures and Abstract Data Types?</li> <li>1.6. Why Study Algorithms?</li> <li>1.7. Review of Basic Python</li> <li>1.8. Getting Started with Data<ul> <li>1.8.1. Built-in Atomic Data Types</li> <li>1.8.2. Built-in Collection Data Types</li> </ul> </li> <li>1.9. Input and Output<ul> <li>1.9.1. String Formatting</li> </ul> </li> <li>1.10. Control Structures</li> <li>1.11. Exception Handling</li> <li>1.12. Defining Functions</li> <li>1.13. Object-Oriented Programming in Python: Defining Classes<ul> <li>1.13.1. A Fraction Class</li> <li>1.13.2. Inheritance: Logic Gates and Circuits</li> </ul> </li> <li>1.14. Summary</li> <li>1.15. Key Terms</li> <li>1.16. Exercises</li> </ul>"},{"location":"#2-\u7b97\u6cd5\u5206\u6790","title":"2. \u7b97\u6cd5\u5206\u6790","text":"<p>2. Algorithm Analysis</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>2.1. \u76ee\u6807 </li> <li>2.2. \u4ec0\u4e48\u662f\u7b97\u6cd5\u5206\u6790\uff1f </li> <li>2.3. \u5927O\u7b26\u53f7 </li> <li>2.4. \u4e00\u4e2a\u5b57\u8c1c\u68c0\u6d4b\u4f8b\u5b50 <ul> <li>2.4.1. \u89e3\u51b3\u65b9\u68481\uff1a\u5b57\u8c1c\u68c0\u6d4b\u9010\u4e00\u68c0\u67e5 </li> <li>2.4.2. \u89e3\u51b3\u65b9\u68482\uff1a\u6392\u5e8f\u548c\u6bd4\u8f83 </li> <li>2.4.3. \u89e3\u51b3\u65b9\u68483\uff1a\u66b4\u529b\u7834\u89e3 </li> <li>2.4.4. \u89e3\u51b3\u65b9\u68484\uff1a\u8ba1\u6570\u548c\u6bd4\u8f83 </li> </ul> </li> <li>2.5. Python\u6570\u636e\u7ed3\u6784\u7684\u6027\u80fd </li> <li>2.6. \u5217\u8868 </li> <li>2.7. \u5b57\u5178 </li> <li>2.8. \u603b\u7ed3 </li> <li>2.9. \u5173\u952e\u672f\u8bed </li> <li>2.10. \u7ec3\u4e60</li> </ul> <ul> <li>2.1. Objectives</li> <li>2.2. What Is Algorithm Analysis?</li> <li>2.3. Big O Notation</li> <li>2.4. An Anagram Detection Example<ul> <li>2.4.1. Solution 1: Anagram Detection Checking Off</li> <li>2.4.2. Anagram Detection Solution 2: Sort and Compare</li> <li>2.4.3. Anagram Detection Solution 3: Brute Force</li> <li>2.4.4. Anagram Detection Solution 4: Count and Compare</li> </ul> </li> <li>2.5. Performance of Python Data Structures</li> <li>2.6. Lists</li> <li>2.7. Dictionaries</li> <li>2.8. Summary</li> <li>2.9. Key Terms</li> <li>2.10. Exercises</li> </ul>"},{"location":"#3-\u57fa\u672c\u6570\u636e\u7ed3\u6784","title":"3. \u57fa\u672c\u6570\u636e\u7ed3\u6784","text":"<p>3. Basic Data Structures</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>3.1. \u76ee\u6807 </li> <li>3.2. \u4ec0\u4e48\u662f\u7ebf\u6027\u7ed3\u6784\uff1f </li> <li>3.3. \u6808 </li> <li>3.4. \u6808\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.5. \u7528Python\u5b9e\u73b0\u6808 </li> <li>3.6. \u7b80\u5355\u7684\u62ec\u53f7\u5339\u914d </li> <li>3.7. \u7b26\u53f7\u5339\u914d\uff08\u4e00\u822c\u60c5\u51b5\uff09 </li> <li>3.8. \u5c06\u5341\u8fdb\u5236\u6570\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u6570 </li> <li>3.9. \u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f <ul> <li>3.9.1. \u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u524d\u7f00\u548c\u540e\u7f00 </li> <li>3.9.2. \u4e00\u822c\u7684\u4e2d\u7f00\u8f6c\u540e\u7f00\u8f6c\u6362 </li> <li>3.9.3. \u540e\u7f00\u8868\u8fbe\u5f0f\u6c42\u503c </li> </ul> </li> <li>3.10. \u961f\u5217 </li> <li>3.11. \u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.12. \u7528Python\u5b9e\u73b0\u961f\u5217 </li> <li>3.13. \u961f\u5217\u6a21\u62df\uff1a\u70eb\u624b\u5c71\u828b\u6e38\u620f </li> <li>3.14. \u961f\u5217\u6a21\u62df\uff1a\u6253\u5370\u4efb\u52a1 <ul> <li>3.14.1. \u4e3b\u8981\u6a21\u62df\u6b65\u9aa4 </li> <li>3.14.2. Python\u5b9e\u73b0 </li> <li>3.14.3. \u8ba8\u8bba </li> </ul> </li> <li>3.15. \u53cc\u7aef\u961f\u5217 </li> <li>3.16. \u53cc\u7aef\u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.17. \u7528Python\u5b9e\u73b0\u53cc\u7aef\u961f\u5217 </li> <li>3.18. \u56de\u6587\u68c0\u6d4b\u5668 </li> <li>3.19. \u5217\u8868 </li> <li>3.20. \u65e0\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.21. \u7528\u94fe\u8868\u5b9e\u73b0\u65e0\u5e8f\u5217\u8868 <ul> <li>3.21.1. \u8282\u70b9\u7c7b </li> <li>3.21.2. \u65e0\u5e8f\u5217\u8868\u7c7b </li> </ul> </li> <li>3.22. \u6709\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.23. \u5b9e\u73b0\u6709\u5e8f\u5217\u8868 <ul> <li>3.23.1. \u94fe\u8868\u5206\u6790 </li> </ul> </li> <li>3.24. \u603b\u7ed3 </li> <li>3.25. \u5173\u952e\u672f\u8bed </li> <li>3.26. \u7ec3\u4e60</li> </ul> <ul> <li>3.1. Objectives</li> <li>3.2. What Are Linear Structures?</li> <li>3.3. Stacks</li> <li>3.4. The Stack Abstract Data Type</li> <li>3.5. Implementing a Stack in Python</li> <li>3.6. Simple Balanced Parentheses</li> <li>3.7. Balanced Symbols (A General Case)</li> <li>3.8. Converting Decimal Numbers to Binary Numbers</li> <li>3.9. Infix, Prefix, and Postfix Expressions<ul> <li>3.9.1. Conversion of Infix Expressions to Prefix and Postfix</li> <li>3.9.2. General Infix-to-Postfix Conversion</li> <li>3.9.3. Postfix Evaluation</li> </ul> </li> <li>3.10. Queues</li> <li>3.11. The Queue Abstract Data Type</li> <li>3.12. Implementing a Queue in Python</li> <li>3.13. Queue Simulation: Hot Potato</li> <li>3.14. Queue Simulation: Printing Tasks<ul> <li>3.14.1. Main Simulation Steps</li> <li>3.14.2. Python Implementation</li> <li>3.14.3. Discussion</li> </ul> </li> <li>3.15. Deques</li> <li>3.16. The Deque Abstract Data Type</li> <li>3.17. Implementing a Deque in Python</li> <li>3.18. Palindrome Checker</li> <li>3.19. Lists</li> <li>3.20. The Unordered List Abstract Data Type</li> <li>3.21. Implementing an Unordered List: Linked Lists<ul> <li>3.21.1. The Node Class</li> <li>3.21.2. The UnorderedList Class</li> </ul> </li> <li>3.22. The Ordered List Abstract Data Type</li> <li>3.23. Implementing an Ordered List<ul> <li>3.23.1. Analysis of Linked Lists</li> </ul> </li> <li>3.24. Summary</li> <li>3.25. Key Terms</li> <li>3.26. Exercises</li> </ul>"},{"location":"#4-\u9012\u5f52","title":"4. \u9012\u5f52","text":"<p>4. Recursion</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>4.1. \u76ee\u6807 </li> <li>4.2. \u4ec0\u4e48\u662f\u9012\u5f52\uff1f </li> <li>4.3. \u8ba1\u7b97\u4e00\u4e2a\u6570\u5217\u7684\u548c </li> <li>4.4. \u9012\u5f52\u7684\u4e09\u6761\u6cd5\u5219 </li> <li>4.5. \u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u4efb\u610f\u8fdb\u5236\u7684\u5b57\u7b26\u4e32 </li> <li>4.6. \u6808\u5e27\uff1a\u5b9e\u73b0\u9012\u5f52 </li> <li>4.7. \u9012\u5f52\u7684\u53ef\u89c6\u5316 </li> <li>4.8. \u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62 </li> <li>4.9. \u590d\u6742\u7684\u9012\u5f52\u95ee\u9898 </li> <li>4.10. \u6c49\u8bfa\u5854\u95ee\u9898 </li> <li>4.11. \u8ff7\u5bab\u63a2\u7d22 </li> <li>4.12. \u52a8\u6001\u89c4\u5212 </li> <li>4.13. \u603b\u7ed3 </li> <li>4.14. \u5173\u952e\u672f\u8bed </li> <li>4.15. \u7ec3\u4e60</li> </ul> <ul> <li>4.1. Objectives</li> <li>4.2. What Is Recursion?</li> <li>4.3. Calculating the Sum of a List of Numbers</li> <li>4.4. The Three Laws of Recursion</li> <li>4.5. Converting an Integer to a String in Any Base</li> <li>4.6. Stack Frames: Implementing Recursion</li> <li>4.7. Visualizing Recursion</li> <li>4.8. Sierpinski Triangle</li> <li>4.9. Complex Recursive Problems</li> <li>4.10. Tower of Hanoi</li> <li>4.11. Exploring a Maze</li> <li>4.12. Dynamic Programming</li> <li>4.13. Summary</li> <li>4.14. Key Terms</li> <li>4.15. Exercises</li> </ul>"},{"location":"#5-\u641c\u7d22\u4e0e\u6392\u5e8f","title":"5. \u641c\u7d22\u4e0e\u6392\u5e8f","text":"<p>5. Searching and Sorting</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>5.1. \u76ee\u6807</li> <li>5.2. \u641c\u7d22</li> <li>5.3. \u987a\u5e8f\u641c\u7d22<ul> <li>5.3.1. \u987a\u5e8f\u641c\u7d22\u7684\u5206\u6790</li> </ul> </li> <li>5.4. \u4e8c\u5206\u641c\u7d22<ul> <li>5.4.1. \u4e8c\u5206\u641c\u7d22\u7684\u5206\u6790</li> </ul> </li> <li>5.5. \u54c8\u5e0c<ul> <li>5.5.1. \u54c8\u5e0c\u51fd\u6570</li> <li>5.5.2. \u78b0\u649e\u89e3\u51b3</li> <li>5.5.3. \u5b9e\u73b0Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b</li> <li>5.5.4. \u54c8\u5e0c\u5206\u6790</li> </ul> </li> <li>5.6. \u6392\u5e8f</li> <li>5.7. \u5192\u6ce1\u6392\u5e8f</li> <li>5.8. \u9009\u62e9\u6392\u5e8f</li> <li>5.9. \u63d2\u5165\u6392\u5e8f</li> <li>5.10. \u5e0c\u5c14\u6392\u5e8f</li> <li>5.11. \u5f52\u5e76\u6392\u5e8f</li> <li>5.12. \u5feb\u901f\u6392\u5e8f</li> <li>5.13. \u603b\u7ed3</li> <li>5.14. \u5173\u952e\u672f\u8bed</li> <li>5.15. \u7ec3\u4e60</li> </ul> <ul> <li>5.1. Objectives</li> <li>5.2. Searching</li> <li>5.3. The Sequential Search<ul> <li>5.3.1. Analysis of Sequential Search</li> </ul> </li> <li>5.4. The Binary Search<ul> <li>5.4.1. Analysis of Binary Search</li> </ul> </li> <li>5.5. Hashing<ul> <li>5.5.1. Hash Functions</li> <li>5.5.2. Collision Resolution</li> <li>5.5.3. Implementing the Map Abstract Data Type</li> <li>5.5.4. Analysis of Hashing</li> </ul> </li> <li>5.6. Sorting</li> <li>5.7. The Bubble Sort</li> <li>5.8. The Selection Sort</li> <li>5.9. The Insertion Sort</li> <li>5.10. The Shell Sort</li> <li>5.11. The Merge Sort</li> <li>5.12. The Quicksort</li> <li>5.13. Summary</li> <li>5.14. Key Terms</li> <li>5.15. Exercises</li> </ul>"},{"location":"#6-\u6811\u548c\u6811\u7b97\u6cd5","title":"6. \u6811\u548c\u6811\u7b97\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <ul> <li>6.1. \u76ee\u6807</li> <li>6.2. \u6811\u7684\u793a\u4f8b</li> <li>6.3. \u8bcd\u6c47\u548c\u5b9a\u4e49</li> <li>6.4. \u5b9e\u73b0</li> <li>6.5. \u5217\u8868\u8868\u793a\u6cd5</li> <li>6.6. \u8282\u70b9\u4e0e\u5f15\u7528</li> <li>6.7. \u89e3\u6790\u6811</li> <li>6.8. \u6811\u904d\u5386</li> <li>6.9. \u4f7f\u7528\u4e8c\u53c9\u5806\u7684\u4f18\u5148\u961f\u5217</li> <li>6.10. \u4e8c\u53c9\u5806\u64cd\u4f5c</li> <li>6.11. \u4e8c\u53c9\u5806\u5b9e\u73b0<ul> <li>6.11.1. \u7ed3\u6784\u5c5e\u6027</li> <li>6.11.2. \u5806\u5e8f\u5c5e\u6027</li> <li>6.11.3. \u5806\u64cd\u4f5c</li> </ul> </li> <li>6.12. \u4e8c\u53c9\u641c\u7d22\u6811</li> <li>6.13. \u641c\u7d22\u6811\u64cd\u4f5c</li> <li>6.14. \u641c\u7d22\u6811\u5b9e\u73b0</li> <li>6.15. \u641c\u7d22\u6811\u5206\u6790</li> <li>6.16. \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811</li> <li>6.17. AVL\u6811\u6027\u80fd</li> <li>6.18. AVL\u6811\u5b9e\u73b0</li> <li>6.19. Map ADT\u5b9e\u73b0\u603b\u7ed3</li> <li>6.20. \u603b\u7ed3</li> <li>6.21. \u5173\u952e\u672f\u8bed</li> <li>6.22. \u7ec3\u4e60</li> </ul> <ul> <li>6.1. Objectives</li> <li>6.2. Examples of Trees</li> <li>6.3. Vocabulary and Definitions</li> <li>6.4. Implementation</li> <li>6.5. List of Lists Representation</li> <li>6.6. Nodes and References</li> <li>6.7. Parse Tree</li> <li>6.8. Tree Traversals</li> <li>6.9. Priority Queues with Binary Heaps</li> <li>6.10. Binary Heap Operations</li> <li>6.11. Binary Heap Implementation<ul> <li>6.11.1. The Structure Property</li> <li>6.11.2. The Heap Order Property</li> <li>6.11.3. Heap Operations</li> </ul> </li> <li>6.12. Binary Search Trees</li> <li>6.13. Search Tree Operations</li> <li>6.14. Search Tree Implementation</li> <li>6.15. Search Tree Analysis</li> <li>6.16. Balanced Binary Search Trees</li> <li>6.17. AVL Tree Performance</li> <li>6.18. AVL Tree Implementation</li> <li>6.19. Summary of Map ADT Implementations</li> <li>6.20. Summary</li> <li>6.21. Key Terms</li> <li>6.22. Exercises</li> </ul>"},{"location":"#7-\u56fe\u548c\u56fe\u7b97\u6cd5","title":"7. \u56fe\u548c\u56fe\u7b97\u6cd5","text":"<p>7. Graphs and Graphing Algorithms</p> \u4e2d\u6587\u82f1\u6587 <p>7.1. \u76ee\u6807 7.2. \u8bcd\u6c47\u548c\u5b9a\u4e49 7.3. \u56fe\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b 7.4. \u90bb\u63a5\u77e9\u9635 7.5. \u90bb\u63a5\u8868 7.6. \u5b9e\u73b0 7.7. \u5b57\u68af\u95ee\u9898 7.8. \u6784\u5efa\u5b57\u68af\u56fe 7.9. \u5b9e\u73b0\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 7.10. \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790 7.11. \u9a91\u58eb\u5de1\u6e38\u95ee\u9898 7.12. \u6784\u5efa\u9a91\u58eb\u5de1\u6e38\u56fe 7.13. \u5b9e\u73b0\u9a91\u58eb\u5de1\u6e38 7.14. \u9a91\u58eb\u5de1\u6e38\u5206\u6790 7.15. \u4e00\u822c\u7684\u6df1\u5ea6\u4f18\u5148\u641c\u7d22 7.16. \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790 7.17. \u62d3\u6251\u6392\u5e8f 7.18. \u5f3a\u8fde\u901a\u5206\u91cf 7.19. \u6700\u77ed\u8def\u5f84\u95ee\u9898 7.20. Dijkstra\u7b97\u6cd5 7.21. Dijkstra\u7b97\u6cd5\u5206\u6790 7.22. Prim\u751f\u6210\u6811\u7b97\u6cd5 7.23. \u603b\u7ed3 7.24. \u5173\u952e\u672f\u8bed 7.25. \u7ec3\u4e60</p> <ul> <li>7.1. Objectives</li> <li>7.2. Vocabulary and Definitions</li> <li>7.3. The Graph Abstract Data Type</li> <li>7.4. An Adjacency Matrix</li> <li>7.5. An Adjacency List</li> <li>7.6. Implementation</li> <li>7.7. The Word Ladder Problem</li> <li>7.8. Building the Word Ladder Graph</li> <li>7.9. Implementing Breadth-First Search</li> <li>7.10. Breadth-First Search Analysis</li> <li>7.11. The Knight\u2019s Tour Problem</li> <li>7.12. Building the Knight\u2019s Tour Graph</li> <li>7.13. Implementing Knight\u2019s Tour</li> <li>7.14. Knight\u2019s Tour Analysis</li> <li>7.15. General Depth-First Search</li> <li>7.16. Depth-First Search Analysis</li> <li>7.17. Topological Sorting</li> <li>7.18. Strongly Connected Components</li> <li>7.19. Shortest Path Problems</li> <li>7.20. Dijkstra\u2019s Algorithm</li> <li>7.21. Analysis of Dijkstra\u2019s Algorithm</li> <li>7.22. Prim\u2019s Spanning Tree Algorithm</li> <li>7.23. Summary</li> <li>7.24. Key Terms</li> <li>7.25. Exercises</li> </ul>"},{"location":"#8-\u9ad8\u7ea7\u4e3b\u9898","title":"8. \u9ad8\u7ea7\u4e3b\u9898","text":"<p>8. Advanced Topics</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>8.1. \u76ee\u6807</li> <li>8.2. Python\u5217\u8868\u518d\u63a2</li> <li>8.3. \u9012\u5f52\u518d\u63a2<ul> <li>8.3.1. \u6a21\u8fd0\u7b97\u5b9a\u7406</li> <li>8.3.2. \u6a21\u5e42\u8fd0\u7b97</li> <li>8.3.3. \u6700\u5927\u516c\u7ea6\u6570\u4e0e\u4e58\u6cd5\u9006\u5143</li> <li>8.3.4. RSA\u7b97\u6cd5</li> </ul> </li> <li>8.4. \u5b57\u5178\u518d\u63a2\uff1a\u8df3\u8868<ul> <li>8.4.1. Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b</li> <li>8.4.2. \u7528Python\u5b9e\u73b0\u5b57\u5178</li> </ul> </li> <li>8.5. \u6811\u518d\u63a2\uff1a\u56fe\u50cf\u91cf\u5316<ul> <li>8.5.1. \u6570\u5b57\u56fe\u50cf\u5feb\u901f\u56de\u987e</li> <li>8.5.2. \u56fe\u50cf\u91cf\u5316</li> <li>8.5.3. \u4f7f\u7528\u516b\u53c9\u6811\u7684\u6539\u8fdb\u91cf\u5316\u7b97\u6cd5</li> </ul> </li> <li>8.6. \u56fe\u518d\u63a2\uff1a\u6a21\u5f0f\u5339\u914d<ul> <li>8.6.1. \u751f\u7269\u5b57\u7b26\u4e32</li> <li>8.6.2. \u7b80\u5355\u6bd4\u8f83</li> <li>8.6.3. \u4f7f\u7528\u56fe\uff1a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a</li> <li>8.6.4. \u4f7f\u7528\u56fe\uff1aKnuth-Morris-Pratt\u7b97\u6cd5</li> </ul> </li> </ul> <ul> <li>8.1. Objectives</li> <li>8.2. Python Lists Revisited</li> <li>8.3. Recursion Revisited<ul> <li>8.3.1. Modular Arithmetic Theorems</li> <li>8.3.2. Modular Exponentiation</li> <li>8.3.3. The Greatest Common Divisor and Multiplicative Inverses</li> <li>8.3.4. RSA Algorithm</li> </ul> </li> <li>8.4. Dictionaries Revisited: Skip Lists<ul> <li>8.4.1. The Map Abstract Data Type</li> <li>8.4.2. Implementing a Dictionary in Python</li> </ul> </li> <li>8.5. Trees Revisited: Quantizing Images<ul> <li>8.5.1. A Quick Review of Digital Images</li> <li>8.5.2. Quantizing an Image</li> <li>8.5.3. An Improved Quantization Algorithm Using Octrees</li> </ul> </li> <li>8.6. Graphs Revisited: Pattern Matching<ul> <li>8.6.1. Biological Strings</li> <li>8.6.2. Simple Comparison</li> <li>8.6.3. Using Graphs: Finite State Automata</li> <li>8.6.4. Using Graphs: Knuth-Morris-Pratt</li> </ul> </li> </ul>"},{"location":"#\u81f4\u8c22","title":"\u81f4\u8c22","text":"<p>Acknowledgements</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u975e\u5e38\u611f\u8c22Franklin Beedle Publishers\u5141\u8bb8\u6211\u4eec\u514d\u8d39\u63d0\u4f9b\u8fd9\u672c\u4e92\u52a8\u6559\u6750\u7684\u5728\u7ebf\u7248\u672c\u3002\u8fd9\u4e2a\u7248\u672c\u732e\u7ed9\u6211\u4eec\u7684\u7b2c\u4e00\u4f4d\u7f16\u8f91Jim Leisy\uff0c\u4ed6\u5e0c\u671b\u6211\u4eec\u201c\u6539\u53d8\u4e16\u754c\u201d\u3002</p> <p>We are very grateful to Franklin Beedle Publishers for allowing us to make this interactive textbook freely available. This online version is dedicated to the memory of our first editor, Jim Leisy, who wanted us to \u201cchange the world.\u201d</p>"},{"location":"c1/","title":"1. \u5f15\u8a00","text":"<p>1.Introduction</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>1.1. \u76ee\u6807 </li> <li>1.2. \u5165\u95e8 </li> <li>1.3. \u4ec0\u4e48\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\uff1f </li> <li>1.4. \u4ec0\u4e48\u662f\u7f16\u7a0b\uff1f </li> <li>1.5. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u6570\u636e\u7ed3\u6784\u548c\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff1f </li> <li>1.6. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u7b97\u6cd5\uff1f </li> <li>1.7. Python\u57fa\u7840\u56de\u987e </li> <li>1.8. \u6570\u636e\u5165\u95e8 <ul> <li>1.8.1. \u5185\u5efa\u7684\u539f\u5b50\u6570\u636e\u7c7b\u578b </li> <li>1.8.2. \u5185\u5efa\u7684\u96c6\u5408\u6570\u636e\u7c7b\u578b </li> </ul> </li> <li>1.9. \u8f93\u5165\u548c\u8f93\u51fa <ul> <li>1.9.1. \u5b57\u7b26\u4e32\u683c\u5f0f\u5316 </li> </ul> </li> <li>1.10. \u63a7\u5236\u7ed3\u6784 </li> <li>1.11. \u5f02\u5e38\u5904\u7406 </li> <li>1.12. \u5b9a\u4e49\u51fd\u6570 </li> <li>1.13. Python\u4e2d\u7684\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff1a\u5b9a\u4e49\u7c7b <ul> <li>1.13.1. \u4e00\u4e2a\u5206\u6570\u7c7b </li> <li>1.13.2. \u7ee7\u627f\uff1a\u903b\u8f91\u95e8\u548c\u7535\u8def </li> </ul> </li> <li>1.14. \u603b\u7ed3</li> <li>1.15. \u5173\u952e\u672f\u8bed </li> <li>1.16. \u7ec3\u4e60</li> </ul> <ul> <li>1.1. Objectives</li> <li>1.2. Getting Started</li> <li>1.3. What Is Computer Science?</li> <li>1.4. What Is Programming?</li> <li>1.5. Why Study Data Structures and Abstract Data Types?</li> <li>1.6. Why Study Algorithms?</li> <li>1.7. Review of Basic Python</li> <li>1.8. Getting Started with Data<ul> <li>1.8.1. Built-in Atomic Data Types</li> <li>1.8.2. Built-in Collection Data Types</li> </ul> </li> <li>1.9. Input and Output<ul> <li>1.9.1. String Formatting</li> </ul> </li> <li>1.10. Control Structures</li> <li>1.11. Exception Handling</li> <li>1.12. Defining Functions</li> <li>1.13. Object-Oriented Programming in Python: Defining Classes<ul> <li>1.13.1. A Fraction Class</li> <li>1.13.2. Inheritance: Logic Gates and Circuits</li> </ul> </li> <li>1.14. Summary</li> <li>1.15. Key Terms</li> <li>1.16. Exercises</li> </ul>"},{"location":"c1/s1/","title":"1.1. \u76ee\u6807","text":"<p>1.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>\u56de\u987e\u8ba1\u7b97\u673a\u79d1\u5b66\u3001\u7f16\u7a0b\u548c\u89e3\u51b3\u95ee\u9898\u7684\u601d\u60f3\u3002</li> <li>\u7406\u89e3\u62bd\u8c61\u53ca\u5176\u5728\u89e3\u51b3\u95ee\u9898\u8fc7\u7a0b\u4e2d\u6240\u626e\u6f14\u7684\u89d2\u8272\u3002</li> <li>\u7406\u89e3\u5e76\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7684\u6982\u5ff5\u3002</li> <li>\u56de\u987ePython\u7f16\u7a0b\u8bed\u8a00\u3002</li> </ul> <ul> <li>To review the ideas of computer science, programming, and problem-solving.</li> <li>To understand abstraction and the role it plays in the problem-solving process.</li> <li>To understand and implement the notion of an abstract data type.</li> <li>To review the Python programming language.</li> </ul>"},{"location":"c1/s10/","title":"1.10. \u63a7\u5236\u7ed3\u6784","text":"<p>1.10. Control Structures</p> \u4e2d\u6587\u82f1\u6587 <p>\u6b63\u5982\u6211\u4eec\u4e4b\u524d\u63d0\u5230\u7684\uff0c\u7b97\u6cd5\u9700\u8981\u4e24\u4e2a\u91cd\u8981\u7684\u63a7\u5236\u7ed3\u6784\uff1a\u8fed\u4ee3(iteration)\u548c\u9009\u62e9(selection)\u3002 Python \u4ee5\u5404\u79cd\u5f62\u5f0f\u652f\u6301\u8fd9\u4e24\u8005\u3002 \u7a0b\u5e8f\u5458\u53ef\u4ee5\u9009\u62e9\u5bf9\u4e8e\u7ed9\u5b9a\u60c5\u51b5\u6700\u6709\u7528\u7684\u8bed\u53e5\u3002</p> <p>\u5bf9\u4e8e\u8fed\u4ee3\uff0cPython \u63d0\u4f9b\u4e86\u4e00\u4e2a\u6807\u51c6\u7684<code>while</code>\u8bed\u53e5\u548c\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684<code>for</code>\u8bed\u53e5\u3002 \u53ea\u8981\u6761\u4ef6\u8ba1\u7b97\u7ed3\u679c\u4e3a<code>True</code>\uff0cwhile \u8bed\u53e5\u5c31\u4f1a\u91cd\u590d\u4e00\u6bb5\u4ee3\u7801\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; counter = 1\n&gt;&gt;&gt; while counter &lt;= 5:\n...     print(\"Hello, world\")\n...     counter = counter + 1\n... \nHello, world\nHello, world\nHello, world\nHello, world\nHello, world\n</code></pre> <p>\u6253\u5370\u51fa\u4e94\u6b21<code>Hello, world</code>\u77ed\u8bed\u3002 <code>while</code> \u8bed\u53e5\u4e0a\u7684\u6761\u4ef6\u5728\u6bcf\u6b21\u91cd\u590d\u5f00\u59cb\u65f6\u8fdb\u884c\u8bc4\u4f30\u3002 \u5982\u679c\u6761\u4ef6\u8ba1\u7b97\u7ed3\u679c\u4e3a<code>True</code>\uff0c\u5219\u8bed\u53e5\u7684\u4e3b\u4f53\u5c06\u6267\u884c\u3002 \u7531\u4e8e Python \u8bed\u8a00\u5f3a\u5236\u6267\u884c\u5f3a\u5236\u7f29\u8fdb\u6a21\u5f0f\uff0c\u56e0\u6b64\u5f88\u5bb9\u6613\u770b\u5230 Python while \u8bed\u53e5\u7684\u7ed3\u6784\u3002</p> <p>while \u8bed\u53e5\u662f\u4e00\u79cd\u975e\u5e38\u901a\u7528\u7684\u8fed\u4ee3\u7ed3\u6784\uff0c\u6211\u4eec\u5c06\u5728\u8bb8\u591a\u4e0d\u540c\u7684\u7b97\u6cd5\u4e2d\u4f7f\u7528\u5b83\u3002 \u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u590d\u5408\u6761\u4ef6\u5c06\u63a7\u5236\u8fed\u4ee3\u3002 \u4e00\u4e2a\u7247\u6bb5\u5982</p> <pre><code>while counter &lt;= 10 and not done:\n...\n</code></pre> <p>\u53ea\u4f1a\u5728\u6761\u4ef6\u7684\u4e24\u4e2a\u90e8\u5206\u90fd\u6ee1\u8db3\u7684\u60c5\u51b5\u4e0b\u624d\u6267\u884c\u8bed\u53e5\u4e3b\u4f53\u3002 \u53d8\u91cf<code>counter</code>\u7684\u503c\u9700\u8981\u5c0f\u4e8e\u6216\u7b49\u4e8e10\uff0c\u5e76\u4e14\u53d8\u91cf<code>done</code>\u7684\u503c\u9700\u8981\u4e3a<code>False</code>\uff08<code>not False</code>\u662f <code>True</code>\uff09\uff0c\u8fd9\u6837<code>True and True</code> \u5c31\u4f1a\u5f97\u5230<code>True</code>\u3002</p> <p>\u5c3d\u7ba1\u8fd9\u79cd\u7c7b\u578b\u7684\u6784\u9020\u5728\u591a\u79cd\u60c5\u51b5\u4e0b\u90fd\u975e\u5e38\u6709\u7528\uff0c\u4f46\u53e6\u4e00\u79cd\u8fed\u4ee3\u7ed3\u6784<code>for</code>\u8bed\u53e5\u53ef\u4ee5\u4e0e\u8bb8\u591a Python \u96c6\u5408\u7ed3\u5408\u4f7f\u7528\u3002 <code>for</code> \u8bed\u53e5\u53ef\u7528\u4e8e\u8fed\u4ee3\u96c6\u5408\u7684\u6210\u5458\uff0c\u53ea\u8981\u96c6\u5408\u662f\u4e00\u4e2a\u5e8f\u5217\u3002 \u6240\u4ee5\uff0c\u4e3e\u4f8b\u6765\u8bf4\uff0c</p> <pre><code>&gt;&gt;&gt; for item in [1, 3, 6, 2, 5]:\n...    print(item)\n...\n1\n3\n6\n2\n5\n</code></pre> <p>\u5c06\u53d8\u91cf<code>item</code>\u6307\u5b9a\u4e3a\u5217\u8868 <code>[1, 3, 6, 2, 5]</code> \u4e2d\u7684\u6bcf\u4e2a\u8fde\u7eed\u503c\u3002 \u7136\u540e\u6267\u884c\u8fed\u4ee3\u7684\u4e3b\u4f53\u3002 \u8fd9\u9002\u7528\u4e8e\u4efb\u4f55\u5e8f\u5217\u96c6\u5408\uff08\u5217\u8868\u3001\u5143\u7ec4\u548c\u5b57\u7b26\u4e32\uff09\u3002</p> <p><code>for</code> \u8bed\u53e5\u7684\u5e38\u89c1\u7528\u9014\u662f\u5728\u4e00\u7cfb\u5217\u503c\u4e0a\u5b9e\u73b0\u660e\u786e\u7684\u8fed\u4ee3\u3002 \u8be5\u58f0\u660e</p> <pre><code>&gt;&gt;&gt; for item in range(5):\n...    print(item ** 2)\n...\n0\n1\n4\n9\n16\n</code></pre> <p>\u5c06\u6267\u884c<code>print</code>\u51fd\u6570\u4e94\u6b21\u3002 <code>range</code>\u51fd\u6570\u5c06\u8fd4\u56de\u4e00\u4e2a\u8868\u793a\u5e8f\u5217 0\u30011\u30012\u30013\u30014 \u7684\u8303\u56f4\u5bf9\u8c61\uff0c\u6bcf\u4e2a\u503c\u5c06\u5206\u914d\u7ed9\u53d8\u91cf<code>item</code>\u3002 \u7136\u540e\u5bf9\u8be5\u503c\u8fdb\u884c\u5e73\u65b9\u5e76\u6253\u5370\u3002</p> <p>\u6b64\u8fed\u4ee3\u7ed3\u6784\u7684\u53e6\u4e00\u4e2a\u6709\u7528\u7248\u672c\u7528\u4e8e\u5904\u7406\u5b57\u7b26\u4e32\u7684\u6bcf\u4e2a\u5b57\u7b26\u3002 \u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u8fed\u4ee3\u5b57\u7b26\u4e32\u5217\u8868\uff0c\u5e76\u901a\u8fc7\u5c06\u6bcf\u4e2a\u5b57\u7b26\u4e32\u9644\u52a0\u5230\u5217\u8868\u6765\u5904\u7406\u6bcf\u4e2a\u5b57\u7b26\u4e32\u3002 \u7ed3\u679c\u662f\u6240\u6709\u5355\u8bcd\u4e2d\u6240\u6709\u5b57\u6bcd\u7684\u5217\u8868\u3002</p> \u5904\u7406\u5b57\u7b26\u4e32\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26(Activecode 8)<pre><code>word_list = [\"cat\", \"dog\", \"rabbit\"]\nletter_list = [ ]\nfor a_word in word_list:\n    for a_letter in a_word:\n        letter_list.append(a_letter)\nprint(letter_list)\n</code></pre> <p>\u9009\u62e9\u8bed\u53e5\u5141\u8bb8\u7a0b\u5e8f\u5458\u63d0\u51fa\u95ee\u9898\uff0c\u7136\u540e\u6839\u636e\u7ed3\u679c\u6267\u884c\u4e0d\u540c\u7684\u64cd\u4f5c\u3002 \u5927\u591a\u6570\u7f16\u7a0b\u8bed\u8a00\u63d0\u4f9b\u4e86\u8fd9\u4e2a\u6709\u7528\u7ed3\u6784\u7684\u4e24\u4e2a\u7248\u672c\uff1a<code>if...else</code>\u548c<code>if</code>\u3002 \u4e8c\u8fdb\u5236\u9009\u62e9\u7684\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\u4f7f\u7528<code>if...else</code>\u8bed\u53e5\u3002</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; if n &lt; 0:\n...   print(\"Sorry, value is negative\")\n... else:\n...   print(math.sqrt(n))\n... \n4.0\n</code></pre> <p>\u5728\u6b64\u793a\u4f8b\u4e2d\uff0c\u68c0\u67e5<code>n</code>\u5f15\u7528\u7684\u5bf9\u8c61\u4ee5\u67e5\u770b\u5b83\u662f\u5426\u5c0f\u4e8e\u96f6\u3002 \u5982\u679c\u662f\uff0c\u5219\u4f1a\u6253\u5370\u4e00\u6761\u6d88\u606f\uff0c\u6307\u51fa\u7ed3\u679c\u662f\u5426\u5b9a\u7684\u3002 \u5982\u679c\u4e0d\u662f\uff0c\u5219\u8be5\u8bed\u53e5\u6267\u884c<code>else</code>\u5b50\u53e5\u5e76\u8ba1\u7b97\u5e73\u65b9\u6839\u3002</p> <p>\u4e0e\u4efb\u4f55\u63a7\u5236\u7ed3\u6784\u4e00\u6837\uff0c\u9009\u62e9\u7ed3\u6784\u53ef\u4ee5\u5d4c\u5957\uff0c\u4ee5\u4fbf\u4e00\u4e2a\u95ee\u9898\u7684\u7ed3\u679c\u6709\u52a9\u4e8e\u51b3\u5b9a\u662f\u5426\u8be2\u95ee\u4e0b\u4e00\u4e2a\u95ee\u9898\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe<code>score</code>\u662f\u4e00\u4e2a\u53d8\u91cf\uff0c\u4fdd\u5b58\u5bf9\u8ba1\u7b97\u673a\u79d1\u5b66\u6d4b\u8bd5\u5206\u6570\u7684\u5f15\u7528\u3002</p> <pre><code>&gt;&gt;&gt; if score &gt;= 90:\n...     print(\"A\")\n... else:\n...     if score &gt;= 80:\n...         print(\"B\")\n...     else:\n...         if score &gt;= 70:\n...             print(\"C\")\n...         else:\n...             if score &gt;= 60:\n...                 print(\"D\")\n...             else:\n...                 print(\"F\")\n</code></pre> <p>\u8be5\u7247\u6bb5\u5c06\u901a\u8fc7\u6253\u5370\u83b7\u5f97\u7684\u5b57\u6bcd\u7b49\u7ea7\u6765\u5bf9\u79f0\u4e3a\u201c\u5206\u6570(score)\u201d\u7684\u503c\u8fdb\u884c\u5206\u7c7b\u3002 \u5982\u679c\u5206\u6570\u5927\u4e8e\u6216\u7b49\u4e8e 90\uff0c\u5219\u8bed\u53e5\u5c06\u6253\u5370\u201cA\u201d\u3002 \u5982\u679c\u4e0d\u662f\uff08<code>else</code>\uff09\uff0c\u5219\u8be2\u95ee\u4e0b\u4e00\u4e2a\u95ee\u9898\u3002 \u5982\u679c\u5206\u6570\u5927\u4e8e\u6216\u7b49\u4e8e 80\uff0c\u90a3\u4e48\u5b83\u5fc5\u987b\u5728 80 \u5230 89 \u4e4b\u95f4\uff0c\u56e0\u4e3a\u7b2c\u4e00\u4e2a\u95ee\u9898\u7684\u7b54\u6848\u662f\u9519\u8bef\u7684\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6253\u5370\u201cB\u201d\u3002 \u60a8\u53ef\u4ee5\u770b\u5230\uff0cPython \u7f29\u8fdb\u6a21\u5f0f\u6709\u52a9\u4e8e\u7406\u89e3<code>if</code>\u548c<code>else</code>\u4e4b\u95f4\u7684\u5173\u8054\uff0c\u800c\u4e0d\u9700\u8981\u4efb\u4f55\u989d\u5916\u7684\u8bed\u6cd5\u5143\u7d20\u3002</p> <p>\u8fd9\u79cd\u7c7b\u578b\u7684\u5d4c\u5957\u9009\u62e9\u7684\u66ff\u4ee3\u8bed\u6cd5\u4f7f\u7528<code>elif</code>\u5173\u952e\u5b57\u3002 \u5c06<code>else</code>\u548c\u4e0b\u4e00\u4e2a<code>if</code>\u7ec4\u5408\u8d77\u6765\uff0c\u4ee5\u4fbf\u6d88\u9664\u989d\u5916\u5d4c\u5957\u7ea7\u522b\u7684\u9700\u8981\u3002 \u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u6240\u6709\u5176\u4ed6\u6761\u4ef6\u5747\u5931\u8d25\uff0c\u6700\u540e\u7684<code>else</code>\u4ecd\u7136\u9700\u8981\u63d0\u4f9b\u9ed8\u8ba4\u60c5\u51b5\u3002</p> <pre><code>&gt;&gt;&gt; if score &gt;= 90:\n...     print(\"A\")\n... elif score &gt;= 80:\n...     print(\"B\")\n... elif score &gt;= 70:\n...     print(\"C\")\n... elif score &gt;= 60:\n...     print(\"D\")\n... else:\n...     print(\"F\")\n</code></pre> <p>Python \u8fd8\u6709\u4e00\u4e2a\u5355\u5411\u9009\u62e9\u7ed3\u6784\uff0c\u5373<code>if</code>\u8bed\u53e5\u3002 \u4f7f\u7528\u6b64\u8bed\u53e5\uff0c\u5982\u679c\u6761\u4ef6\u4e3a\u771f\uff0c\u5219\u6267\u884c\u64cd\u4f5c\u3002 \u5728\u6761\u4ef6\u4e3a\u5047\u7684\u60c5\u51b5\u4e0b\uff0c\u5904\u7406\u7b80\u5355\u5730\u7ee7\u7eed\u5230<code>if</code>\u4e4b\u540e\u7684\u4e0b\u4e00\u4e2a\u8bed\u53e5\u3002 \u4f8b\u5982\uff0c\u4ee5\u4e0b\u7247\u6bb5\u5c06\u9996\u5148\u68c0\u67e5\u53d8\u91cf\u201cn\u201d\u7684\u503c\u662f\u5426\u4e3a\u8d1f\u6570\u3002 \u5982\u679c\u662f\uff0c\u5219\u901a\u8fc7\u7edd\u5bf9\u503c\u51fd\u6570\u5bf9\u5176\u8fdb\u884c\u4fee\u6539\u3002 \u65e0\u8bba\u5982\u4f55\uff0c\u4e0b\u4e00\u6b65\u662f\u8ba1\u7b97\u5e73\u65b9\u6839\u3002</p> <pre><code>if n &lt; 0:\n    n = abs(n)\nprint(math.sqrt(n))\n</code></pre> <p>\u81ea\u68c0</p> <p>\u901a\u8fc7\u5c1d\u8bd5\u4ee5\u4e0b\u7ec3\u4e60\u6765\u6d4b\u8bd5\u60a8\u5bf9\u6211\u4eec\u8fc4\u4eca\u4e3a\u6b62\u6240\u6db5\u76d6\u5185\u5bb9\u7684\u7406\u89e3\u3002 \u4fee\u6539 Activecode 8 \u4e2d\u7684\u4ee3\u7801\uff0c\u4ee5\u4fbf\u6700\u7ec8\u5217\u8868\u4ec5\u5305\u542b\u6bcf\u4e2a\u5b57\u6bcd\u7684\u4e00\u4e2a\u526f\u672c\u3002</p> <pre><code># the answer is: ['c', 'a', 't', 'd', 'o', 'g', 'r', 'b', 'i']\n</code></pre> <p></p> <p>\u56de\u5230\u5217\u8868\uff0c\u8fd8\u6709\u4e00\u79cd\u521b\u5efa\u5217\u8868\u7684\u66ff\u4ee3\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u4f7f\u7528\u8fed\u4ee3\u548c\u9009\u62e9\u7ed3\u6784\uff0c\u79f0\u4e3a\u5217\u8868\u63a8\u5bfc\u5f0f(list comprehension)\u3002 \u5217\u8868\u63a8\u5bfc\u5f0f\u5141\u8bb8\u60a8\u6839\u636e\u67d0\u4e9b\u5904\u7406\u6216\u9009\u62e9\u6807\u51c6\u8f7b\u677e\u521b\u5efa\u5217\u8868\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u6211\u4eec\u60f3\u521b\u5efa\u524d 10 \u4e2a\u5b8c\u5168\u5e73\u65b9\u6570\u7684\u5217\u8868\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528<code>for</code>\u8bed\u53e5\uff1a</p> <pre><code>&gt;&gt;&gt; sq_list = []\n&gt;&gt;&gt; for x in range(1, 11):\n...     sq_list.append(x * x)\n... \n&gt;&gt;&gt; sq_list\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\uff0c\u6211\u4eec\u53ef\u4ee5\u4e00\u6b65\u5b8c\u6210\u6b64\u64cd\u4f5c\uff0c\u5982\u4e0b\u6240\u793a</p> <pre><code>&gt;&gt;&gt; sq_list=[x * x for x in range(1, 11)]\n&gt;&gt;&gt; sq_list\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>\u53d8\u91cf<code>x</code>\u91c7\u7528\u7531<code>for</code>\u7ed3\u6784\u6307\u5b9a\u7684\u4ece1\u523010\u7684\u503c\u3002 \u7136\u540e\u8ba1\u7b97<code>x * x</code>\u7684\u503c\u5e76\u5c06\u5176\u6dfb\u52a0\u5230\u6b63\u5728\u6784\u9020\u7684\u5217\u8868\u4e2d\u3002</p> <p>\u5217\u8868\u63a8\u5bfc\u5f0f\u7684\u901a\u7528\u8bed\u6cd5\u8fd8\u5141\u8bb8\u6dfb\u52a0\u9009\u62e9\u6807\u51c6\uff0c\u4ee5\u4fbf\u4ec5\u6dfb\u52a0\u67d0\u4e9b\u9879\u76ee\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; sq_list=[x * x for x in range(1,11) if x % 2 != 0]\n&gt;&gt;&gt; sq_list\n[1, 9, 25, 49, 81]\n</code></pre> <p>\u6b64\u5217\u8868\u63a8\u5bfc\u5f0f\u6784\u9020\u4e00\u4e2a\u4ec5\u5305\u542b 1 \u5230 10 \u8303\u56f4\u5185\u7684\u5947\u6570\u7684\u5e73\u65b9\u7684\u5217\u8868\u3002\u4efb\u4f55\u652f\u6301\u8fed\u4ee3\u7684\u5e8f\u5217\u90fd\u53ef\u4ee5\u5728\u5217\u8868\u63a8\u5bfc\u5f0f\u4e2d\u4f7f\u7528\u6765\u6784\u9020\u65b0\u5217\u8868\u3002</p> <pre><code>&gt;&gt;&gt;[ch.upper() for ch in 'comprehension' if ch not in 'aeiou']\n['C', 'M', 'P', 'R', 'H', 'N', 'S', 'N']\n</code></pre> <p>\u81ea\u68c0</p> <p>\u901a\u8fc7\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\u91cd\u505a Activecode 1 \u6765\u6d4b\u8bd5\u60a8\u5bf9\u5217\u8868\u63a8\u5bfc\u5f0f\u7684\u7406\u89e3\u3002 \u5bf9\u4e8e\u989d\u5916\u7684\u6311\u6218\uff0c\u770b\u770b\u60a8\u662f\u5426\u80fd\u5f04\u6e05\u695a\u5982\u4f55\u5220\u9664\u91cd\u590d\u9879\u3002</p> <pre><code># the answer is: ['c', 'a', 't', 'd', 'o', 'g', 'r', 'a', 'b', 'b', 'i', 't']\n</code></pre> <p></p> <p>As we noted earlier, algorithms require two important control structures: iteration and selection. Both of these are supported by Python in various forms. The programmer can choose the statement that is most useful for the given circumstance.</p> <p>For iteration, Python provides a standard <code>while</code> statement and a very powerful <code>for</code> statement. The while statement repeats a body of code as long as a condition evaluates to <code>True</code>. For example,</p> <pre><code>&gt;&gt;&gt; counter = 1\n&gt;&gt;&gt; while counter &lt;= 5:\n...     print(\"Hello, world\")\n...     counter = counter + 1\n... \nHello, world\nHello, world\nHello, world\nHello, world\nHello, world\n</code></pre> <p>prints out the phrase <code>Hello, world</code> five times. The condition on the <code>while</code> statement is evaluated at the start of each repetition. If the condition evaluates to <code>True</code>, the body of the statement will execute. It is easy to see the structure of a Python <code>while</code> statement due to the mandatory indentation pattern that the language enforces.</p> <p>The <code>while</code> statement is a very general-purpose iterative structure that we will use in a number of different algorithms. In many cases, a compound condition will control the iteration. A fragment such as</p> <pre><code>while counter &lt;= 10 and not done:\n...\n</code></pre> <p>would cause the body of the statement to be executed only in the case where both parts of the condition are satisfied. The value of the variable <code>counter</code> would need to be less than or equal to 10, and the value of the variable <code>done</code> would need to be <code>False</code> (<code>not False</code> is <code>True</code>) so that <code>True and True</code> results in <code>True</code>.</p> <p>Even though this type of construct is very useful in a wide variety of situations, another iterative structure, the <code>for</code> statement, can be used in conjunction with many of the Python collections. The <code>for</code> statement can be used to iterate over the members of a collection, so long as the collection is a sequence. So, for example,</p> <pre><code>&gt;&gt;&gt; for item in [1, 3, 6, 2, 5]:\n...    print(item)\n...\n1\n3\n6\n2\n5\n</code></pre> <p>assigns the variable <code>item</code> to be each successive value in the list [1, 3, 6, 2, 5]. The body of the iteration is then executed. This works for any collection that is a sequence (lists, tuples, and strings).</p> <p>A common use of the <code>for</code> statement is to implement definite iteration over a range of values. The statement</p> <pre><code>&gt;&gt;&gt; for item in range(5):\n...    print(item ** 2)\n...\n0\n1\n4\n9\n16\n</code></pre> <p>will perform the <code>print</code> function five times. The <code>range</code> function will return a range object representing the sequence 0, 1, 2, 3, 4 and each value will be assigned to the variable <code>item</code>. This value is then squared and printed.</p> <p>Another useful version of this iteration structure is used to process each character of a string. The following code fragment iterates over a list of strings and for each string processes each character by appending it to a list. The result is a list of all the letters in all of the words.</p> Processing Each Character in a List of Strings<pre><code>word_list = [\"cat\", \"dog\", \"rabbit\"]\nletter_list = [ ]\nfor a_word in word_list:\n    for a_letter in a_word:\n        letter_list.append(a_letter)\nprint(letter_list)\n</code></pre> <p>Selection statements allow programmers to ask questions and then, based on the result, perform different actions. Most programming languages provide two versions of this useful construct: the <code>if...else</code> and the <code>if</code>. A simple example of a binary selection uses the <code>if...else</code> statement.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; if n &lt; 0:\n...   print(\"Sorry, value is negative\")\n... else:\n...   print(math.sqrt(n))\n... \n4.0\n</code></pre> <p>In this example, the object referred to by <code>n</code> is checked to see if it is less than zero. If it is, a message is printed stating that it is negative. If it is not, the statement performs the <code>else</code> clause and computes the square root.</p> <p>Selection constructs, as with any control construct, can be nested so that the result of one question helps decide whether to ask the next. For example, assume that <code>score</code> is a variable holding a reference to a score for a computer science test.</p> <pre><code>&gt;&gt;&gt; if score &gt;= 90:\n...     print(\"A\")\n... else:\n...     if score &gt;= 80:\n...         print(\"B\")\n...     else:\n...         if score &gt;= 70:\n...             print(\"C\")\n...         else:\n...             if score &gt;= 60:\n...                 print(\"D\")\n...             else:\n...                 print(\"F\")\n</code></pre> <p>This fragment will classify a value called <code>score</code> by printing the letter grade earned. If the score is greater than or equal to 90, the statement will print <code>A</code>. If it is not (<code>else</code>), the next question is asked. If the score is greater than or equal to 80, then it must be between 80 and 89 since the answer to the first question was false. In this case print <code>B</code> is printed. You can see that the Python indentation pattern helps to make sense of the association between <code>if</code> and <code>else</code> without requiring any additional syntactic elements.</p> <p>An alternative syntax for this type of nested selection uses the <code>elif</code> keyword. The <code>else</code> and the next <code>if</code> are combined so as to eliminate the need for additional nesting levels. Note that the final <code>else</code> is still necessary to provide the default case if all other conditions fail.</p> <pre><code>&gt;&gt;&gt; if score &gt;= 90:\n...     print(\"A\")\n... elif score &gt;= 80:\n...     print(\"B\")\n... elif score &gt;= 70:\n...     print(\"C\")\n... elif score &gt;= 60:\n...     print(\"D\")\n... else:\n...     print(\"F\")\n</code></pre> <p>Python also has a single-way selection construct, the <code>if</code> statement. With this statement, if the condition is true, an action is performed. In the case where the condition is false, processing simply continues on to the next statement after the <code>if</code>. For example, the following fragment will first check to see if the value of a variable <code>n</code> is negative. If it is, then it is modified by the absolute value function. Regardless, the next action is to compute the square root.</p> <pre><code>if n &lt; 0:\n    n = abs(n)\nprint(math.sqrt(n))\n</code></pre> <p>Self Check</p> <p>Test your understanding of what we have covered so far by trying the following exercise.  Modify the code from Activecode 8 so that the final list only contains a single copy of each letter.</p> <pre><code># the answer is: ['c', 'a', 't', 'd', 'o', 'g', 'r', 'b', 'i']\n</code></pre> <p></p> <p>Returning to lists, there is an alternative method for creating a list that uses iteration and selection constructs known as a list comprehension. A list comprehension allows you to easily create a list based on some processing or selection criteria. For example, if we would like to create a list of the first 10 perfect squares, we could use a <code>for</code> statement:</p> <pre><code>&gt;&gt;&gt; sq_list = []\n&gt;&gt;&gt; for x in range(1, 11):\n...     sq_list.append(x * x)\n... \n&gt;&gt;&gt; sq_list\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>Using a list comprehension, we can do this in one step as</p> <pre><code>&gt;&gt;&gt; sq_list=[x * x for x in range(1, 11)]\n&gt;&gt;&gt; sq_list\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n</code></pre> <p>The variable <code>x</code> takes on the values 1 through 10 as specified by the <code>for</code> construct. The value of <code>x * x</code> is then computed and added to the list that is being constructed.</p> <p>The general syntax for a list comprehension also allows a selection criteria to be added so that only certain items get added. For example,</p> <pre><code>&gt;&gt;&gt; sq_list=[x * x for x in range(1,11) if x % 2 != 0]\n&gt;&gt;&gt; sq_list\n[1, 9, 25, 49, 81]\n</code></pre> <p>This list comprehension constructs a list that contains the squares of only the odd numbers in the range from 1 to 10. Any sequence that supports iteration can be used within a list comprehension to construct a new list.</p> <pre><code>&gt;&gt;&gt;[ch.upper() for ch in 'comprehension' if ch not in 'aeiou']\n['C', 'M', 'P', 'R', 'H', 'N', 'S', 'N']\n</code></pre> <p>Self Check</p> <p>Test your understanding of list comprehensions by redoing Activecode 1 using list comprehensions.  For an extra challenge, see if you can figure out how to remove the duplicates.</p> <pre><code># the answer is: ['c', 'a', 't', 'd', 'o', 'g', 'r', 'a', 'b', 'b', 'i', 't']\n</code></pre> <p></p>"},{"location":"c1/s11/","title":"1.11. \u5f02\u5e38\u5904\u7406","text":"<p>1.11. Exception Handling</p> \u4e2d\u6587\u82f1\u6587 <p>\u7f16\u5199\u7a0b\u5e8f\u65f6\u901a\u5e38\u4f1a\u51fa\u73b0\u4e24\u79cd\u7c7b\u578b\u7684\u9519\u8bef\u3002 \u7b2c\u4e00\u4e2a\u88ab\u79f0\u4e3a \u8bed\u6cd5\u9519\u8bef(syntax error) \uff0c\u4ec5\u4ec5\u610f\u5473\u7740\u7a0b\u5e8f\u5458\u5728\u8bed\u53e5\u6216\u8868\u8fbe\u5f0f\u7684\u7ed3\u6784\u4e2d\u72af\u4e86\u9519\u8bef\u3002 \u4f8b\u5982\uff0c\u7f16\u5199 for \u8bed\u53e5\u800c\u5fd8\u8bb0\u5192\u53f7\u662f\u4e0d\u6b63\u786e\u7684\u3002</p> <pre><code>&gt;&gt;&gt; for i in range(10)\nFile \"&lt;stdin&gt;\", line 1\n    for i in range(10)\n                    ^\nSyntaxError: invalid syntax\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cPython\u89e3\u91ca\u5668\u53d1\u73b0\u5b83\u65e0\u6cd5\u5b8c\u6210\u8fd9\u6761\u6307\u4ee4\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u5b83\u4e0d\u7b26\u5408\u8bed\u8a00\u7684\u89c4\u5219\u3002 \u5f53\u60a8\u7b2c\u4e00\u6b21\u5b66\u4e60\u8bed\u8a00\u65f6\uff0c\u8bed\u6cd5\u9519\u8bef\u901a\u5e38\u4f1a\u66f4\u9891\u7e41\u3002</p> <p>\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u9519\u8bef\u79f0\u4e3a\u903b\u8f91\u9519\u8bef(logic error)\uff0c\u8868\u793a\u7a0b\u5e8f\u6267\u884c\u4f46\u7ed9\u51fa\u9519\u8bef\u7ed3\u679c\u7684\u60c5\u51b5\u3002 \u8fd9\u53ef\u80fd\u662f\u7531\u4e8e\u5e95\u5c42\u7b97\u6cd5\u4e2d\u7684\u9519\u8bef\u6216\u8be5\u7b97\u6cd5\u7684\u7ffb\u8bd1\u4e2d\u7684\u9519\u8bef\u9020\u6210\u7684\u3002 \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u903b\u8f91\u9519\u8bef\u4f1a\u5bfc\u81f4\u975e\u5e38\u7cdf\u7cd5\u7684\u60c5\u51b5\uff0c\u4f8b\u5982\u5c1d\u8bd5\u9664\u4ee5\u96f6\u6216\u5c1d\u8bd5\u8bbf\u95ee\u5217\u8868\u4e2d\u7684\u9879\u76ee\uff0c\u4f46\u8be5\u9879\u76ee\u7684\u7d22\u5f15\u8d85\u51fa\u4e86\u5217\u8868\u7684\u8fb9\u754c\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u903b\u8f91\u9519\u8bef\u4f1a\u5bfc\u81f4\u8fd0\u884c\u65f6\u9519\u8bef\uff0c\u4ece\u800c\u5bfc\u81f4\u7a0b\u5e8f\u7ec8\u6b62\u3002 \u8fd9\u4e9b\u7c7b\u578b\u7684\u8fd0\u884c\u65f6\u9519\u8bef\u901a\u5e38\u79f0\u4e3a\u5f02\u5e38\u3002</p> <p>\u5927\u591a\u6570\u65f6\u5019\uff0c\u521d\u7ea7\u7a0b\u5e8f\u5458\u53ea\u662f\u5c06\u5f02\u5e38\u89c6\u4e3a\u5bfc\u81f4\u6267\u884c\u7ed3\u675f\u7684\u81f4\u547d\u8fd0\u884c\u65f6\u9519\u8bef\u3002 \u7136\u800c\uff0c\u5927\u591a\u6570\u7f16\u7a0b\u8bed\u8a00\u90fd\u63d0\u4f9b\u4e86\u4e00\u79cd\u5904\u7406\u8fd9\u4e9b\u9519\u8bef\u7684\u65b9\u6cd5\uff0c\u5141\u8bb8\u7a0b\u5e8f\u5458\u8fdb\u884c\u67d0\u79cd\u7c7b\u578b\u7684\u5e72\u9884\uff08\u5982\u679c\u4ed6\u4eec\u613f\u610f\u7684\u8bdd\uff09\u3002 \u6b64\u5916\uff0c\u5982\u679c\u7a0b\u5e8f\u5458\u5728\u7a0b\u5e8f\u6267\u884c\u4e2d\u68c0\u6d4b\u5230\u6709\u5fc5\u8981\u7684\u60c5\u51b5\uff0c\u5219\u53ef\u4ee5\u521b\u5efa\u81ea\u5df1\u7684\u5f02\u5e38\u3002</p> <p>\u5f53\u5f02\u5e38\u53d1\u751f\u65f6\uff0c\u6211\u4eec\u8bf4\u5b83\u5df2\u88ab\u5f15\u53d1(raised)\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528<code>try</code>\u8bed\u53e5\u5904\u7406(handle)\u5f15\u53d1\u7684\u5f02\u5e38\u3002 \u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u4f1a\u8bdd\uff0c\u8be5\u4f1a\u8bdd\u8981\u6c42\u7528\u6237\u63d0\u4f9b\u4e00\u4e2a\u6574\u6570\uff0c\u7136\u540e\u8c03\u7528\u6570\u5b66\u5e93\u4e2d\u7684\u5e73\u65b9\u6839\u51fd\u6570\u3002 \u5982\u679c\u7528\u6237\u8f93\u5165\u5927\u4e8e\u6216\u7b49\u4e8e0\u7684\u503c\uff0c\u5219\u6253\u5370\u5c06\u663e\u793a\u5e73\u65b9\u6839\u3002 \u4f46\u662f\uff0c\u5982\u679c\u7528\u6237\u8f93\u5165\u8d1f\u503c\uff0c\u5e73\u65b9\u6839\u51fd\u6570\u5c06\u62a5\u544a<code>ValueError</code>\u5f02\u5e38\u3002</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; a_number = int(input(\"Please enter an integer \"))\nPlease enter an integer -23\n&gt;&gt;&gt; print(math.sqrt(a_number))\nTraceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: math domain error\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ece<code>try</code>\u5757\u4e2d\u8c03\u7528<code>print</code>\u51fd\u6570\u6765\u5904\u7406\u6b64\u5f02\u5e38\u3002 \u76f8\u5e94\u7684<code>except</code>\u5757 \u6355\u83b7(catches) \u5f02\u5e38\uff0c\u5e76\u5728\u53d1\u751f\u5f02\u5e38\u65f6\u5411\u7528\u6237\u6253\u5370\u4e00\u6761\u6d88\u606f\u3002 \u4f8b\u5982\uff1a</p> <pre><code>&gt;&gt;&gt; try:\n...   print(math.sqrt(a_number))\n... except:\n...   print(\"Bad value for the square root function\")\n...   print(\"Using the absolute value instead\")\n...   print(math.sqrt(abs(a_number)))\n... \nBad value for the square root function\nUsing the absolute value instead\n4.795831523312719\n</code></pre> <p>\u5c06\u6355\u83b7<code>sqrt</code>\u5f15\u53d1\u5f02\u5e38\u7684\u4e8b\u5b9e\uff0c\u5e76\u5c06\u6d88\u606f\u6253\u5370\u56de\u7528\u6237\u5e76\u4f7f\u7528\u7edd\u5bf9\u503c\u6765\u786e\u4fdd\u6211\u4eec\u6b63\u5728\u53d6\u975e\u8d1f\u6570\u7684\u5e73\u65b9\u6839\u3002 \u8fd9\u610f\u5473\u7740\u7a0b\u5e8f\u4e0d\u4f1a\u7ec8\u6b62\uff0c\u800c\u662f\u7ee7\u7eed\u6267\u884c\u4e0b\u4e00\u6761\u8bed\u53e5\u3002</p> <p>\u7a0b\u5e8f\u5458\u4e5f\u6709\u53ef\u80fd\u901a\u8fc7\u4f7f\u7528<code>raise</code>\u8bed\u53e5\u5f15\u8d77\u8fd0\u884c\u65f6\u5f02\u5e38\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u68c0\u67e5\u8be5\u503c\uff0c\u7136\u540e\u5f15\u53d1\u81ea\u5df1\u7684\u5f02\u5e38\uff0c\u800c\u4e0d\u662f\u4f7f\u7528\u8d1f\u6570\u8c03\u7528\u5e73\u65b9\u6839\u51fd\u6570\u3002 \u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\u663e\u793a\u4e86\u521b\u5efa\u65b0\u7684<code>RuntimeError</code>\u5f02\u5e38\u7684\u7ed3\u679c\u3002 \u8bf7\u6ce8\u610f\uff0c\u7a0b\u5e8f\u4ecd\u7136\u4f1a\u7ec8\u6b62\uff0c\u4f46\u73b0\u5728\u5bfc\u81f4\u7ec8\u6b62\u7684\u5f02\u5e38\u662f\u7531\u7a0b\u5e8f\u5458\u663e\u5f0f\u521b\u5efa\u7684\u3002</p> <pre><code>&gt;&gt;&gt; if a_number &lt; 0:\n...   raise RuntimeError(\"You can't use a negative number\")\n... else:\n...   print(math.sqrt(a_number))\n... \nTraceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nRuntimeError: You can't use a negative number\n</code></pre> <p>\u9664\u4e86\u4e0a\u9762\u663e\u793a\u7684<code>RuntimeError</code>\u4e4b\u5916\uff0c\u8fd8\u53ef\u4ee5\u5f15\u53d1\u591a\u79cd\u5f02\u5e38\u3002 \u6709\u5173\u6240\u6709\u53ef\u7528\u5f02\u5e38\u7c7b\u578b\u7684\u5217\u8868\u4ee5\u53ca\u5982\u4f55\u521b\u5efa\u81ea\u5df1\u7684\u5f02\u5e38\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Python \u53c2\u8003\u624b\u518c\u3002</p> <p>There are two types of errors that typically occur when writing programs. The first, known as a syntax error, simply means that the programmer has made a mistake in the structure of a statement or expression. For example, it is incorrect to write a for statement and forget the colon.</p> <pre><code>&gt;&gt;&gt; for i in range(10)\nFile \"&lt;stdin&gt;\", line 1\n    for i in range(10)\n                    ^\nSyntaxError: invalid syntax\n</code></pre> <p>In this case, the Python interpreter has found that it cannot complete the processing of this instruction since it does not conform to the rules of the language. Syntax errors are usually more frequent when you are first learning a language.</p> <p>The other type of error, known as a logic error, denotes a situation where the program executes but gives the wrong result. This can be due to an error in the underlying algorithm or an error in your translation of that algorithm. In some cases, logic errors lead to very bad situations such as trying to divide by zero or trying to access an item in a list where the index of the item is outside the bounds of the list. In this case, the logic error leads to a runtime error that causes the program to terminate. These types of runtime errors are typically called exceptions.</p> <p>Most of the time, beginning programmers simply think of exceptions as fatal runtime errors that cause the end of execution. However, most programming languages provide a way to deal with these errors that will allow the programmer to have some type of intervention if they so choose. In addition, programmers can create their own exceptions if they detect a situation in the program execution that warrants it.</p> <p>When an exception occurs, we say that it has been raised. You can handle the exception that has been raised by using a <code>try</code> statement. For example, consider the following session that asks the user for an integer and then calls the square root function from the math library. If the user enters a value that is greater than or equal to 0, the print will show the square root. However, if the user enters a negative value, the square root function will report a <code>ValueError</code> exception.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; a_number = int(input(\"Please enter an integer \"))\nPlease enter an integer -23\n&gt;&gt;&gt; print(math.sqrt(a_number))\nTraceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: math domain error\n</code></pre> <p>We can handle this exception by calling the <code>print</code> function from within a <code>try</code> block. A corresponding <code>except</code> block \u201ccatches\u201d the exception and prints a message back to the user in the event that an exception occurs. For example:</p> <pre><code>&gt;&gt;&gt; try:\n...   print(math.sqrt(a_number))\n... except:\n...   print(\"Bad value for the square root function\")\n...   print(\"Using the absolute value instead\")\n...   print(math.sqrt(abs(a_number)))\n... \nBad value for the square root function\nUsing the absolute value instead\n4.795831523312719\n</code></pre> <p>will catch the fact that an exception is raised by <code>sqrt</code> and will instead print the messages back to the user and use the absolute value to be sure that we are taking the square root of a non-negative number. This means that the program will not terminate but instead will continue on to the next statements.</p> <p>It is also possible for a programmer to cause a runtime exception by using the <code>raise</code> statement. For example, instead of calling the square root function with a negative number, we could have checked the value first and then raised our own exception. The code fragment below shows the result of creating a new <code>RuntimeError</code> exception. Note that the program would still terminate, but now the exception that caused the termination is something explicitly created by the programmer.</p> <pre><code>&gt;&gt;&gt; if a_number &lt; 0:\n...   raise RuntimeError(\"You can't use a negative number\")\n... else:\n...   print(math.sqrt(a_number))\n... \nTraceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nRuntimeError: You can't use a negative number\n</code></pre> <p>There are many kinds of exceptions that can be raised in addition to the <code>RuntimeError</code> shown above. See the Python reference manual for a list of all the available exception types and for how to create your own.</p>"},{"location":"c1/s12/","title":"1.12. \u5b9a\u4e49\u51fd\u6570","text":"<p>1.12. Defining Functions</p> \u4e2d\u6587\u82f1\u6587 <p>\u524d\u9762\u7684\u8fc7\u7a0b\u62bd\u8c61\u793a\u4f8b\u8c03\u7528\u6570\u5b66\u6a21\u5757\u4e2d\u540d\u4e3a<code>sqrt</code>\u7684 Python \u51fd\u6570\u6765\u8ba1\u7b97\u5e73\u65b9\u6839\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5b9a\u4e49\u51fd\u6570\u6765\u9690\u85cf\u4efb\u4f55\u8ba1\u7b97\u7684\u7ec6\u8282\u3002 \u51fd\u6570\u5b9a\u4e49\u9700\u8981\u4e00\u4e2a\u540d\u79f0\u3001\u4e00\u7ec4\u53c2\u6570\u548c\u4e00\u4e2a\u51fd\u6570\u4f53\u3002 \u5b83\u8fd8\u53ef\u4ee5\u663e\u5f0f\u8fd4\u56de\u4e00\u4e2a\u503c\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u5b9a\u4e49\u7684\u7b80\u5355\u51fd\u6570\u8fd4\u56de\u4f20\u9012\u7ed9\u5b83\u7684\u503c\u7684\u5e73\u65b9\u3002</p> <pre><code>&gt;&gt;&gt; def square(n):\n...    return n ** 2\n...\n&gt;&gt;&gt; square(3)\n9\n&gt;&gt;&gt; square(square(3))\n81\n</code></pre> <p>\u8be5\u51fd\u6570\u5b9a\u4e49\u7684\u8bed\u6cd5\u5305\u62ec\u540d\u79f0<code>square</code>\u548c\u5e26\u62ec\u53f7\u7684\u5f62\u5f0f\u53c2\u6570\u5217\u8868\u3002 \u5bf9\u4e8e\u8fd9\u4e2a\u51fd\u6570\uff0c<code>n</code>\u662f\u552f\u4e00\u7684\u5f62\u5f0f\u53c2\u6570\uff0c\u8fd9\u8868\u660e<code>square</code>\u53ea\u9700\u8981\u4e00\u4e2a\u6570\u636e\u6765\u5b8c\u6210\u5b83\u7684\u5de5\u4f5c\u3002 \u9690\u85cf\u5728\u201c\u76d2\u5b50\u5185(inside the box)\u201d\u7684\u7ec6\u8282\u53ea\u662f\u7b80\u5355\u5730\u8ba1\u7b97<code>n**2</code>\u7684\u7ed3\u679c\u5e76\u8fd4\u56de\u5b83\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8981\u6c42 Python \u73af\u5883\u8bc4\u4f30\u5b83\u5e76\u4f20\u9012\u5b9e\u9645\u53c2\u6570\u503c\uff08\u5728\u672c\u4f8b\u4e2d\u4e3a<code>3</code>\uff09\u6765\u8c03\u7528<code>square</code>\u51fd\u6570\u3002 \u8bf7\u6ce8\u610f\uff0c\u5bf9<code>square</code>\u7684\u8c03\u7528\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8be5\u6574\u6570\u53ef\u4ee5\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8c03\u7528\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u4e00\u79cd\u540d\u4e3a\u725b\u987f\u6cd5\u6216\u725b\u987f-\u62c9\u592b\u68ee\u6cd5\uff08\u4ee5\u827e\u8428\u514b\u00b7\u725b\u987f\u548c\u7ea6\u745f\u592b\u00b7\u62c9\u592b\u68ee\u547d\u540d\uff09\u7684\u4f17\u6240\u5468\u77e5\u7684\u6280\u672f\u6765\u5b9e\u73b0\u6211\u4eec\u81ea\u5df1\u7684\u5e73\u65b9\u6839\u51fd\u6570\u3002 \u7528\u4e8e\u8fd1\u4f3c\u5e73\u65b9\u6839\u7684\u725b\u987f-\u62c9\u592b\u68ee\u65b9\u6cd5\u6267\u884c\u8fed\u4ee3\u8ba1\u7b97\uff0c\u6536\u655b\u4e8e\u6b63\u786e\u503c\u3002 \u65b9\u7a0b \\(newguess = \\frac {1}{2} * (oldguess + \\frac {n}{oldguess})\\) \u53d6\u503c \\(n\\) \u5e76\u901a\u8fc7\u5c06\u6bcf\u4e2a \\(newguess\\) \u8bbe\u4e3a \\(oldguess\\) \u6765\u91cd\u590d\u731c\u6d4b\u5e73\u65b9\u6839 \u968f\u540e\u7684\u8fed\u4ee3\u3002 \u8fd9\u91cc\u4f7f\u7528\u7684\u521d\u59cb\u731c\u6d4b\u662f\\(\\frac {n}{2}\\)\u3002 \u201cListing 1\u201d\u663e\u793a\u4e86\u4e00\u4e2a\u51fd\u6570\u5b9a\u4e49\uff0c\u5b83\u63a5\u53d7\u503c \\(n\\) \u5e76\u5728\u8fdb\u884c 20 \u6b21\u731c\u6d4b\u540e\u8fd4\u56de \\(n\\) \u7684\u5e73\u65b9\u6839\u3002 \u540c\u6837\uff0c\u725b\u987f-\u62c9\u592b\u68ee\u65b9\u6cd5\u7684\u7ec6\u8282\u9690\u85cf\u5728\u51fd\u6570\u5b9a\u4e49\u4e2d\uff0c\u7528\u6237\u65e0\u9700\u4e86\u89e3\u6709\u5173\u5b9e\u73b0\u7684\u4efb\u4f55\u4fe1\u606f\u5373\u53ef\u4f7f\u7528\u8be5\u51fd\u6570\u8fbe\u5230\u5176\u9884\u671f\u76ee\u7684\u3002 \u201cListing 1\u201d\u8fd8\u663e\u793a\u4e86\u4f7f\u7528<code>#</code>\u5b57\u7b26\u4f5c\u4e3a\u6ce8\u91ca\u6807\u8bb0\u3002 \u4e00\u884c\u4e2d<code>#</code>\u540e\u9762\u7684\u4efb\u4f55\u5b57\u7b26\u90fd\u5c06\u88ab\u5ffd\u7565\u3002</p> <p>Listing 1</p> <pre><code>def square_root(n):\n    root = n / 2  # initial guess will be 1/2 of n\n    for k in range(20):\n        root = (1 / 2) * (root + (n / root))\n\n    return root\n</code></pre> <pre><code>&gt;&gt;&gt; square_root(9)\n3.0\n&gt;&gt;&gt; square_root(4563)\n67.54998149518622\n</code></pre> <p>\u81ea\u68c0</p> <p>\u8fd9\u662f\u4e00\u4e2a\u81ea\u6211\u68c0\u67e5\uff0c\u771f\u6b63\u6db5\u76d6\u4e86\u8fc4\u4eca\u4e3a\u6b62\u7684\u6240\u6709\u5185\u5bb9\u3002 \u4f60\u53ef\u80fd\u542c\u8bf4\u8fc7\u65e0\u9650\u7334\u5b50\u5b9a\u7406\uff1f \u8be5\u5b9a\u7406\u6307\u51fa\uff0c\u4e00\u53ea\u7334\u5b50\u5728\u6253\u5b57\u673a\u952e\u76d8\u4e0a\u968f\u673a\u6572\u51fb\u6309\u952e\u65e0\u9650\u957f\u7684\u65f6\u95f4\uff0c\u51e0\u4e4e\u80af\u5b9a\u4f1a\u952e\u5165\u7ed9\u5b9a\u7684\u6587\u672c\uff0c\u4f8b\u5982\u5a01\u5ec9\u00b7\u838e\u58eb\u6bd4\u4e9a\u7684\u5168\u96c6\u3002 \u597d\u5427\uff0c\u5047\u8bbe\u6211\u4eec\u7528 Python \u51fd\u6570\u66ff\u6362\u7334\u5b50\u3002 \u4f60\u8ba4\u4e3a\u4e00\u4e2a Python \u51fd\u6570\u751f\u6210\u838e\u58eb\u6bd4\u4e9a\u7684\u4e00\u53e5\u8bdd\u9700\u8981\u591a\u957f\u65f6\u95f4\uff1f \u6211\u4eec\u8981\u547d\u4e2d\u7684\u53e5\u5b50\u662f\uff1a\u201c\u6211\u8ba4\u4e3a\u5b83\u5c31\u50cf\u4e00\u53ea\u9ec4\u9f20\u72fc(methinks it is like a weasel)\u201d</p> <p>\u60a8\u4e0d\u4f1a\u60f3\u5728\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c\u8fd9\u4e2a\uff0c\u6240\u4ee5\u542f\u52a8\u60a8\u6700\u559c\u6b22\u7684 Python IDE\u3002 \u6211\u4eec\u6a21\u62df\u8fd9\u4e2a\u7684\u65b9\u6cd5\u662f\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u901a\u8fc7\u4ece\u5b57\u6bcd\u8868\u4e2d\u7684 26 \u4e2a\u5b57\u6bcd\u52a0\u4e0a\u7a7a\u683c\u4e2d\u9009\u62e9\u968f\u673a\u5b57\u6bcd\u6765\u751f\u6210 28 \u4e2a\u5b57\u7b26\u957f\u7684\u5b57\u7b26\u4e32\u3002 \u6211\u4eec\u5c06\u7f16\u5199\u53e6\u4e00\u4e2a\u51fd\u6570\uff0c\u901a\u8fc7\u5c06\u968f\u673a\u751f\u6210\u7684\u5b57\u7b26\u4e32\u4e0e\u76ee\u6807\u8fdb\u884c\u6bd4\u8f83\u6765\u5bf9\u6bcf\u4e2a\u751f\u6210\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u8bc4\u5206\u3002</p> <p>\u7b2c\u4e09\u4e2a\u51fd\u6570\u5c06\u91cd\u590d\u8c03\u7528\u751f\u6210\u548c\u8bc4\u5206\uff0c\u7136\u540e\u5982\u679c 100% \u7684\u5b57\u6bcd\u6b63\u786e\uff0c\u6211\u4eec\u5c31\u5b8c\u6210\u4e86\u3002 \u5982\u679c\u5b57\u6bcd\u4e0d\u6b63\u786e\uff0c\u90a3\u4e48\u6211\u4eec\u5c06\u751f\u6210\u4e00\u4e2a\u5168\u65b0\u7684\u5b57\u7b26\u4e32\u3002\u4e3a\u4e86\u66f4\u5bb9\u6613\u5730\u8ddf\u8e2a\u7a0b\u5e8f\u7684\u8fdb\u5ea6\uff0c\u7b2c\u4e09\u4e2a\u51fd\u6570\u5e94\u8be5\u6253\u5370\u51fa\u8fc4\u4eca\u4e3a\u6b62\u751f\u6210\u7684\u6700\u4f73\u5b57\u7b26\u4e32\u53ca\u5176\u6bcf 1000 \u6b21\u5c1d\u8bd5\u7684\u5206\u6570\u3002</p> <p>\u81ea\u68c0\u6311\u6218</p> <p>\u770b\u770b\u662f\u5426\u53ef\u4ee5\u901a\u8fc7\u4fdd\u7559\u6b63\u786e\u7684\u5b57\u6bcd\u5e76\u4ec5\u4fee\u6539\u8fc4\u4eca\u4e3a\u6b62\u6700\u4f73\u5b57\u7b26\u4e32\u4e2d\u7684\u4e00\u4e2a\u5b57\u7b26\u6765\u6539\u8fdb\u81ea\u68c0\u4e2d\u7684\u7a0b\u5e8f\u3002 \u8fd9\u662f\u201c\u722c\u5c71(hill climbing)\u201d\u7b97\u6cd5\u4e2d\u7684\u4e00\u79cd\u7b97\u6cd5\uff0c\u5373\u6211\u4eec\u4ec5\u4fdd\u7559\u6bd4\u524d\u4e00\u4e2a\u66f4\u597d\u7684\u7ed3\u679c\u3002</p> <p></p> <p>The earlier example of procedural abstraction called upon a Python function called <code>sqrt</code> from the math module to compute the square root. In general, we can hide the details of any computation by defining a function. A function definition requires a name, a group of parameters, and a body. It may also explicitly return a value. For example, the simple function defined below returns the square of the value you pass into it.</p> <pre><code>&gt;&gt;&gt; def square(n):\n...    return n ** 2\n...\n&gt;&gt;&gt; square(3)\n9\n&gt;&gt;&gt; square(square(3))\n81\n</code></pre> <p>The syntax for this function definition includes the name, <code>square</code>, and a parenthesized list of formal parameters. For this function, <code>n</code> is the only formal parameter, which suggests that <code>square</code> needs only one piece of data to do its work. The details, hidden \u201cinside the box,\u201d simply compute the result of <code>n**2</code> and return it. We can invoke or call the <code>square</code> function by asking the Python environment to evaluate it, passing an actual parameter value, in this case, <code>3</code>. Note that the call to <code>square</code> returns an integer that can in turn be passed to another invocation.</p> <p>We could implement our own square root function by using a well-known technique called Newton's method or the Newton\u2013Raphson method, named after Isaac Newton and Joseph Raphson. The Newton\u2013Raphson method for approximating square roots performs an iterative computation that converges on the correct value. The equation \\(newguess = \\frac {1}{2} * (oldguess + \\frac {n}{oldguess})\\) takes a value \\(n\\) and repeatedly guesses the square root by making each \\(newguess\\) the \\(oldguess\\) in the subsequent iteration. The initial guess used here is \\(\\frac {n}{2}\\). <code>Listing 1</code> shows a function definition that accepts a value \\(n\\) and returns the square root of \\(n\\) after making 20 guesses. Again, the details of the Newton\u2013Raphson method are hidden inside the function definition and the user does not have to know anything about the implementation to use the function for its intended purpose. <code>Listing 1</code> also shows the use of the <code>#</code> character as a comment marker. Any characters that follow the <code>#</code> on a line are ignored.</p> <p>Listing 1</p> <pre><code>def square_root(n):\n    root = n / 2  # initial guess will be 1/2 of n\n    for k in range(20):\n        root = (1 / 2) * (root + (n / root))\n\n    return root\n</code></pre> <pre><code>&gt;&gt;&gt; square_root(9)\n3.0\n&gt;&gt;&gt; square_root(4563)\n67.54998149518622\n</code></pre> <p>Self Check</p> <p>Here's a self check that really covers everything so far.  You may have heard of the infinite monkey theorem?  The theorem states that a monkey hitting keys at random on a typewriter keyboard for an infinite amount of time will almost surely type a given text, such as the complete works of William Shakespeare.  Well, suppose we replace a monkey with a Python function.  How long do you think it would take for a Python function to generate just one sentence of Shakespeare?  The sentence we'll shoot for is:  \"methinks it is like a weasel\"</p> <p>You're not going to want to run this one in the browser, so fire up your favorite Python IDE.  The way we'll simulate this is to write a function that generates a string that is 28 characters long by choosing random letters from the 26 letters in the alphabet plus the space.  We'll write another function that will score each generated string by comparing the randomly generated string to the goal.</p> <p>A third function will repeatedly call generate and score, then if 100% of the letters are correct we are done.  If the letters are not correct then we will generate a whole new string.To make it easier to follow your program's progress this third function should print out the best string generated so far and its score every 1000 tries.</p> <p>Self Check Challenge</p> <p>See if you can improve upon the program in the self check by keeping letters that are correct and only modifying one character in the best string so far.  This is a type of algorithm in the class of 'hill climbing' algorithms, that is we only keep the result if it is better than the previous one.</p> <p></p>"},{"location":"c1/s13/","title":"1.13. Python\u4e2d\u7684\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff1a\u5b9a\u4e49\u7c7b","text":"<p>1.13. Object-Oriented Programming in Python: Defining Classes</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u4e4b\u524d\u8bf4\u8fc7Python\u662f\u4e00\u79cd\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u3002 \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u5df2\u7ecf\u4f7f\u7528\u4e86\u8bb8\u591a\u5185\u7f6e\u7c7b\u6765\u5c55\u793a\u6570\u636e\u548c\u63a7\u5236\u7ed3\u6784\u7684\u793a\u4f8b\u3002 \u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u8bed\u8a00\u4e2d\u6700\u5f3a\u5927\u7684\u529f\u80fd\u4e4b\u4e00\u662f\u80fd\u591f\u5141\u8bb8\u7a0b\u5e8f\u5458\uff08\u95ee\u9898\u89e3\u51b3\u8005\uff09\u521b\u5efa\u65b0\u7c7b\u6765\u5bf9\u89e3\u51b3\u95ee\u9898\u6240\u9700\u7684\u6570\u636e\u8fdb\u884c\u5efa\u6a21\u3002</p> <p>\u8bf7\u8bb0\u4f4f\uff0c\u6211\u4eec\u4f7f\u7528\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u6765\u63d0\u4f9b\u6570\u636e\u5bf9\u8c61\u7684\u5916\u89c2\uff08\u5176\u72b6\u6001\uff09\u53ca\u5176\u529f\u80fd\uff08\u5176\u65b9\u6cd5\uff09\u7684\u903b\u8f91\u63cf\u8ff0\u3002 \u901a\u8fc7\u6784\u5efa\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7684\u7c7b\uff0c\u7a0b\u5e8f\u5458\u53ef\u4ee5\u5229\u7528\u62bd\u8c61\u8fc7\u7a0b\uff0c\u540c\u65f6\u63d0\u4f9b\u5728\u7a0b\u5e8f\u4e2d\u5b9e\u9645\u4f7f\u7528\u62bd\u8c61\u6240\u9700\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u6bcf\u5f53\u6211\u4eec\u60f3\u8981\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u65f6\uff0c\u6211\u4eec\u90fd\u4f1a\u4f7f\u7528\u4e00\u4e2a\u65b0\u7c7b\u6765\u5b9e\u73b0\u3002</p> <p>We stated earlier that Python is an object-oriented programming language. So far, we have used a number of built-in classes to show examples of data and control structures. One of the most powerful features in an object-oriented programming language is the ability to allow a programmer (problem solver) to create new classes that model data that is needed to solve the problem.</p> <p>Remember that we use abstract data types to provide the logical description of what a data object looks like (its state) and what it can do (its methods). By building a class that implements an abstract data type, a programmer can take advantage of the abstraction process and at the same time provide the details necessary to actually use the abstraction in a program. Whenever we want to implement an abstract data type, we will do so with a new class.</p>"},{"location":"c1/s13/#1131-\u4e00\u4e2a\u5206\u6570\u7c7b","title":"1.13.1. \u4e00\u4e2a\u5206\u6570\u7c7b","text":"<p>1.13.1. A Fraction Class</p> \u4e2d\u6587\u82f1\u6587 <p>\u663e\u793a\u5b9e\u73b0\u7528\u6237\u5b9a\u4e49\u7c7b\u7684\u7ec6\u8282\u7684\u4e00\u4e2a\u975e\u5e38\u5e38\u89c1\u7684\u793a\u4f8b\u662f\u6784\u9020\u4e00\u4e2a\u7c7b\u6765\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u201cFraction\u201d\u3002 \u6211\u4eec\u5df2\u7ecf\u770b\u5230Python\u63d0\u4f9b\u4e86\u8bb8\u591a\u6570\u5b57\u7c7b\u4f9b\u6211\u4eec\u4f7f\u7528\u3002 \u7136\u800c\uff0c\u6709\u65f6\u6700\u5408\u9002\u7684\u505a\u6cd5\u662f\u80fd\u591f\u521b\u5efa\u5bf9\u7528\u6237\u6765\u8bf4\u770b\u8d77\u6765\u50cf\u5206\u6570\u7684\u6570\u636e\u5bf9\u8c61\u3002</p> <p>\u8bf8\u5982 \\(\\frac {3}{5}\\) \u4e4b\u7c7b\u7684\u5206\u6570\u7531\u4e24\u90e8\u5206\u7ec4\u6210\u3002 \u6700\u4e0a\u9762\u7684\u503c\u79f0\u4e3a\u5206\u5b50\uff0c\u53ef\u4ee5\u662f\u4efb\u4f55\u6574\u6570\u3002 \u5e95\u90e8\u7684\u503c\u79f0\u4e3a\u5206\u6bcd\uff0c\u53ef\u4ee5\u662f\u4efb\u4f55\u5927\u4e8e 0 \u7684\u6574\u6570\uff08\u8d1f\u5206\u6570\u7684\u5206\u5b50\u4e3a\u8d1f\uff09\u3002 \u5c3d\u7ba1\u53ef\u4ee5\u4e3a\u4efb\u4f55\u5206\u6570\u521b\u5efa\u6d6e\u70b9\u8fd1\u4f3c\u503c\uff0c\u4f46\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5e0c\u671b\u5c06\u5206\u6570\u8868\u793a\u4e3a\u7cbe\u786e\u503c\u3002</p> <p>\u201cFraction\u201d \u7c7b\u578b\u7684\u64cd\u4f5c\u5c06\u5141\u8bb8\u201cFraction\u201d \u6570\u636e\u5bf9\u8c61\u7684\u884c\u4e3a\u4e0e\u4efb\u4f55\u5176\u4ed6\u6570\u503c\u76f8\u540c\u3002 \u6211\u4eec\u9700\u8981\u80fd\u591f\u8fdb\u884c\u5206\u6570\u7684\u52a0\u3001\u51cf\u3001\u4e58\u3001\u9664\u8fd0\u7b97\u3002 \u6211\u4eec\u8fd8\u5e0c\u671b\u80fd\u591f\u4f7f\u7528\u6807\u51c6\u7684\u201c\u659c\u6760\u201d\u5f62\u5f0f\u663e\u793a\u5206\u6570\uff0c\u4f8b\u5982 \u2157\u3002 \u6b64\u5916\uff0c\u6240\u6709\u5206\u6570\u65b9\u6cd5\u90fd\u5e94\u4ee5\u6700\u4f4e\u9879\u8fd4\u56de\u7ed3\u679c\uff0c\u4ee5\u4fbf\u65e0\u8bba\u6267\u884c\u4ec0\u4e48\u8ba1\u7b97\uff0c\u6211\u4eec\u603b\u662f\u4f1a\u5f97\u5230\u6700\u5e38\u89c1\u7684\u5f62\u5f0f\u3002</p> <p>\u5728Python\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u63d0\u4f9b\u4e00\u4e2a\u540d\u79f0\u548c\u4e00\u7ec4\u8bed\u6cd5\u4e0a\u4e0e\u51fd\u6570\u5b9a\u4e49\u7c7b\u4f3c\u7684\u65b9\u6cd5\u5b9a\u4e49\u6765\u5b9a\u4e49\u4e00\u4e2a\u65b0\u7c7b\u3002 \u5bf9\u4e8e\u8fd9\u4e2a\u4f8b\u5b50\uff0c</p> <pre><code>class Fraction:\n    # the methods go here\n</code></pre> <p>\u4e3a\u6211\u4eec\u5b9a\u4e49\u65b9\u6cd5\u63d0\u4f9b\u4e86\u6846\u67b6\u3002 \u6240\u6709\u7c7b\u90fd\u5e94\u8be5\u63d0\u4f9b\u7684\u7b2c\u4e00\u4e2a\u65b9\u6cd5\u662f\u6784\u9020\u51fd\u6570\u3002 \u6784\u9020\u51fd\u6570\u5b9a\u4e49\u4e86\u521b\u5efa\u6570\u636e\u5bf9\u8c61\u7684\u65b9\u5f0f\u3002 \u8981\u521b\u5efa\u201cFraction\u201d\u5bf9\u8c61\uff0c\u6211\u4eec\u9700\u8981\u63d0\u4f9b\u4e24\u4e2a\u6570\u636e\uff0c\u5206\u5b50\u548c\u5206\u6bcd\u3002 \u5728 Python \u4e2d\uff0c\u6784\u9020\u51fd\u6570\u65b9\u6cd5\u59cb\u7ec8\u79f0\u4e3a<code>__init__</code>\uff08\u201cinit\u201d\u524d\u540e\u5404\u6709\u4e24\u4e2a\u4e0b\u5212\u7ebf\uff09\uff0c\u5982\u201c\u6e05\u5355 2\u201d\u6240\u793a\u3002</p> <p>\u6e05\u5355 2</p> <pre><code>class Fraction:\n    \"\"\"Class Fraction\"\"\"\n    def __init__(self, top, bottom):\n        \"\"\"Constructor definition\"\"\"\n        self.num = top\n        self.den = bottom\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5f62\u5f0f\u53c2\u6570\u5217\u8868\u5305\u542b\u4e09\u4e2a\u9879\u76ee\uff08\u201cself\u201d\u3001\u201ctop\u201d\u3001\u201cbottom\u201d\uff09\u3002 \u201cself\u201d \u662f\u4e00\u4e2a\u7279\u6b8a\u53c2\u6570\uff0c\u59cb\u7ec8\u7528\u4f5c\u5bf9\u8c61\u672c\u8eab\u7684\u5f15\u7528\u3002 \u5b83\u5fc5\u987b\u59cb\u7ec8\u662f\u7b2c\u4e00\u4e2a\u5f62\u5f0f\u53c2\u6570\uff1b \u7136\u800c\uff0c\u5728\u8c03\u7528\u65f6\u6c38\u8fdc\u4e0d\u4f1a\u7ed9\u5b83\u4e00\u4e2a\u5b9e\u9645\u7684\u53c2\u6570\u503c\u3002 \u5982\u524d\u6240\u8ff0\uff0c\u5206\u6570\u9700\u8981\u4e24\u4e2a\u72b6\u6001\u6570\u636e\uff1a\u5206\u5b50\u548c\u5206\u6bcd\u3002 \u6784\u9020\u51fd\u6570\u4e2d\u7684\u7b26\u53f7\u201cself.num\u201d\u5c06\u201cFraction\u201d\u5bf9\u8c61\u5b9a\u4e49\u4e3a\u5177\u6709\u4e00\u4e2a\u540d\u4e3a\u201cnum\u201d\u7684\u5185\u90e8\u6570\u636e\u5bf9\u8c61\u4f5c\u4e3a\u5176\u72b6\u6001\u7684\u4e00\u90e8\u5206\u3002 \u540c\u6837\uff0c\u201cself.den\u201d\u521b\u5efa\u5206\u6bcd\u3002 \u4e24\u4e2a\u5f62\u5f0f\u53c2\u6570\u7684\u503c\u6700\u521d\u5206\u914d\u7ed9\u72b6\u6001\uff0c\u5141\u8bb8\u65b0\u7684\u201cFraction\u201d\u5bf9\u8c61\u77e5\u9053\u5176\u8d77\u59cb\u503c\u3002</p> <p>\u8981\u521b\u5efa\u201cFraction\u201d\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u5fc5\u987b\u8c03\u7528\u6784\u9020\u51fd\u6570\u3002 \u8fd9\u662f\u901a\u8fc7\u4f7f\u7528\u7c7b\u7684\u540d\u79f0\u5e76\u4f20\u9012\u5fc5\u8981\u72b6\u6001\u7684\u5b9e\u9645\u503c\u6765\u5b9e\u73b0\u7684\uff08\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u4ece\u4e0d\u76f4\u63a5\u201c\u8c03\u7528(invoke) <code>__init__</code> \u201d\uff09\u3002 \u4f8b\u5982\uff0c</p> <pre><code>    my_fraction = Fraction(3, 5)\n</code></pre> <p>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>my_fraction</code> \u7684\u5bf9\u8c61\uff0c\u8868\u793a\u5206\u6570 \\(`\\frac {3}{5}\\) \uff08\u4e94\u5206\u4e4b\u4e09\uff09\u3002 \u201c\u56fe 5\u201d\u663e\u793a\u4e86\u8be5\u5bf9\u8c61\u73b0\u5728\u7684\u5b9e\u73b0\u60c5\u51b5\u3002</p> <p> \u56fe 5\uff1a\u201cFraction\u201d\u7c7b\u7684\u5b9e\u4f8b </p> <p>\u63a5\u4e0b\u6765\u6211\u4eec\u9700\u8981\u505a\u7684\u662f\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u6240\u9700\u7684\u884c\u4e3a\u3002 \u9996\u5148\uff0c\u8003\u8651\u4e00\u4e0b\u5f53\u6211\u4eec\u5c1d\u8bd5\u6253\u5370\u201cFraction\u201d\u5bf9\u8c61\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002</p> <pre><code>&gt;&gt;&gt; my_fraction = Fraction(3, 5)\n&gt;&gt;&gt; print(my_fraction)\n&lt;__main__.Fraction object at 0x103203eb8&gt;\n</code></pre> <p>\u201cFraction\u201d \u5bf9\u8c61\u201cmy_fraction\u201d \u4e0d\u77e5\u9053\u5982\u4f55\u54cd\u5e94\u6b64\u6253\u5370\u8bf7\u6c42\u3002 \u201cprint\u201d\u51fd\u6570\u8981\u6c42\u5bf9\u8c61\u5c06\u81ea\u8eab\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\uff0c\u4ee5\u4fbf\u53ef\u4ee5\u5c06\u8be5\u5b57\u7b26\u4e32\u5199\u5165\u8f93\u51fa\u3002 my_fraction \u552f\u4e00\u7684\u9009\u62e9\u662f\u663e\u793a\u5b58\u50a8\u5728\u53d8\u91cf\u4e2d\u7684\u5b9e\u9645\u5f15\u7528\uff08\u5730\u5740\u672c\u8eab\uff09\u3002 \u8fd9\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\u3002</p> <p>\u6211\u4eec\u6709\u4e24\u79cd\u65b9\u6cd5\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u4e00\u79cd\u662f\u5b9a\u4e49\u4e00\u4e2a\u540d\u4e3a\u201cshow\u201d\u7684\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u5141\u8bb8\u201cFraction\u201d\u5bf9\u8c61\u5c06\u5176\u81ea\u8eab\u6253\u5370\u4e3a\u5b57\u7b26\u4e32\u3002 \u6211\u4eec\u53ef\u4ee5\u5b9e\u73b0\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5982\u201c\u6e05\u5355 3\u201d\u6240\u793a\u3002 \u5982\u679c\u6211\u4eec\u50cf\u4ee5\u524d\u4e00\u6837\u521b\u5efa\u4e00\u4e2a\u201cFraction\u201d\u5bf9\u8c61\uff0c\u6211\u4eec\u53ef\u4ee5\u8981\u6c42\u5b83\u663e\u793a\u81ea\u5df1\uff08\u6362\u53e5\u8bdd\u8bf4\uff0c\u4ee5\u6b63\u786e\u7684\u683c\u5f0f\u6253\u5370\u81ea\u5df1\uff09\u3002 \u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u901a\u5e38\u4e0d\u8d77\u4f5c\u7528\u3002 \u4e3a\u4e86\u4f7f\u6253\u5370\u6b63\u5e38\u5de5\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u201cFraction\u201d\u7c7b\u5982\u4f55\u5c06\u5176\u81ea\u8eab\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002 \u8fd9\u5c31\u662f\u201cprint\u201d\u51fd\u6570\u5b8c\u6210\u5176\u5de5\u4f5c\u6240\u9700\u8981\u7684\u3002</p> <p>\u6e05\u5355 3</p> <pre><code>def show(self):\n    print(f\"{self.num}/{self.den}\")\n</code></pre> <pre><code>&gt;&gt;&gt; my_fraction = Fraction(3, 5)\n&gt;&gt;&gt; my_fraction.show()\n3/5\n&gt;&gt;&gt; print(my_fraction)\n&lt;__main__.Fraction object at 0x40bce9ac&gt;\n</code></pre> <p>\u5728Python\u4e2d\uff0c\u6240\u6709\u7c7b\u90fd\u63d0\u4f9b\u4e86\u4e00\u7ec4\u6807\u51c6\u65b9\u6cd5\uff0c\u4f46\u8fd9\u4e9b\u65b9\u6cd5\u53ef\u80fd\u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c\u3002 \u5176\u4e2d\u4e4b\u4e00<code>__str__</code>\u662f\u5c06\u5bf9\u8c61\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u7684\u65b9\u6cd5\u3002 \u6b63\u5982\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u7684\uff0c\u6b64\u65b9\u6cd5\u7684\u9ed8\u8ba4\u5b9e\u73b0\u662f\u8fd4\u56de\u5b9e\u4f8b\u5730\u5740\u5b57\u7b26\u4e32\u3002 \u6211\u4eec\u9700\u8981\u505a\u7684\u662f\u4e3a\u8fd9\u4e2a\u65b9\u6cd5\u63d0\u4f9b\u4e00\u4e2a\u66f4\u597d\u7684\u5b9e\u73b0\u3002 \u6211\u4eec\u4f1a\u8bf4\u8fd9\u4e2a\u5b9e\u73b0\u8986\u76d6(overrides)\u524d\u4e00\u4e2a\u5b9e\u73b0\uff0c\u6216\u8005\u5b83\u91cd\u65b0\u5b9a\u4e49\u4e86\u65b9\u6cd5\u7684\u884c\u4e3a\u3002</p> <p>\u4e3a\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u5b9a\u4e49\u4e00\u4e2a\u540d\u4e3a<code>__str__</code>\u7684\u65b9\u6cd5\uff0c\u5e76\u4e3a\u5176\u63d0\u4f9b\u4e00\u4e2a\u65b0\u7684\u5b9e\u73b0\uff0c\u5982\u201c\u6e05\u5355 4\u201d\u6240\u793a\u3002 \u9664\u4e86\u7279\u6b8a\u53c2\u6570\u201cself\u201d\u4e4b\u5916\uff0c\u8fd9\u4e2a\u5b9a\u4e49\u4e0d\u9700\u8981\u4efb\u4f55\u5176\u4ed6\u4fe1\u606f\u3002 \u53cd\u8fc7\u6765\uff0c\u8be5\u65b9\u6cd5\u5c06\u901a\u8fc7\u5c06\u6bcf\u6bb5\u5185\u90e8\u72b6\u6001\u6570\u636e\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u4f7f\u7528\u5b57\u7b26\u4e32\u8fde\u63a5\u5728\u5b57\u7b26\u4e32\u4e4b\u95f4\u653e\u7f6e\u201c/\u201d\u5b57\u7b26\u6765\u6784\u5efa\u5b57\u7b26\u4e32\u8868\u793a\u5f62\u5f0f\u3002 \u6bcf\u5f53\u8981\u6c42\u201cFraction\u201d\u5bf9\u8c61\u5c06\u5176\u81ea\u8eab\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u65f6\uff0c\u90fd\u4f1a\u8fd4\u56de\u7ed3\u679c\u5b57\u7b26\u4e32\u3002 \u8bf7\u6ce8\u610f\u8be5\u51fd\u6570\u7684\u5404\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002</p> <p>\u6e05\u5355 4</p> <pre><code>def __str__(self):\n    return f\"{self.num}/{self.den}\"\n</code></pre> <pre><code>&gt;&gt;&gt; my_fraction = Fraction(3, 5)\n&gt;&gt;&gt; print(my_fraction)\n3/5\n&gt;&gt;&gt; print(f\"I ate {my_fraction} of pizza\")\nI ate 3/5 of pizza\n&gt;&gt;&gt; my_fraction.__str__()\n'3/5'\n&gt;&gt;&gt; str(my_fraction)\n'3/5'\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u4e3a\u65b0\u7684\u201cFraction\u201d\u7c7b\u91cd\u5199\u8bb8\u591a\u5176\u4ed6\u65b9\u6cd5\u3002 \u5176\u4e2d\u6700\u91cd\u8981\u7684\u4e00\u4e9b\u662f\u57fa\u672c\u7b97\u672f\u8fd0\u7b97\u3002 \u6211\u4eec\u5e0c\u671b\u80fd\u591f\u521b\u5efa\u4e24\u4e2a\u201cFraction\u201d\u5bf9\u8c61\uff0c\u7136\u540e\u4f7f\u7528\u6807\u51c6\u201c+\u201d\u7b26\u53f7\u5c06\u5b83\u4eec\u52a0\u5728\u4e00\u8d77\u3002 \u6b64\u65f6\uff0c\u5982\u679c\u6211\u4eec\u5c1d\u8bd5\u5c06\u4e24\u4e2a\u5206\u6570\u76f8\u52a0\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u4ee5\u4e0b\u7ed3\u679c\uff1a</p> <pre><code>&gt;&gt;&gt; f1 = Fraction(1, 4)\n&gt;&gt;&gt; f2 = Fraction(1, 2)\n&gt;&gt;&gt; f1 + f2\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'Fraction' and 'Fraction'\n</code></pre> <p>\u5982\u679c\u4ed4\u7ec6\u89c2\u5bdf\u8be5\u9519\u8bef\uff0c\u60a8\u4f1a\u53d1\u73b0\u95ee\u9898\u5728\u4e8e\u201c+\u201d\u8fd0\u7b97\u7b26\u4e0d\u7406\u89e3\u201cFraction\u201d\u64cd\u4f5c\u6570\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e3a\u201cFraction\u201d\u7c7b\u63d0\u4f9b\u4e00\u4e2a\u8986\u76d6\u52a0\u6cd5\u65b9\u6cd5\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 \u5728Python\u4e2d\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u88ab\u79f0\u4e3a<code>__add__</code>\uff0c\u5b83\u9700\u8981\u4e24\u4e2a\u53c2\u6570\u3002 \u7b2c\u4e00\u4e2a\u201cself\u201d\u59cb\u7ec8\u662f\u5fc5\u9700\u7684\uff0c\u7b2c\u4e8c\u4e2a\u8868\u793a\u8868\u8fbe\u5f0f\u4e2d\u7684\u53e6\u4e00\u4e2a\u64cd\u4f5c\u6570\u3002 \u4f8b\u5982\uff0c</p> <pre><code>f1.__add__(f2)\n</code></pre> <p>\u4f1a\u8981\u6c42 <code>Fraction</code> \u5bf9\u8c61 <code>f1</code> \u5c06 <code>Fraction</code> \u5bf9\u8c61 <code>f2</code> \u6dfb\u52a0\u5230\u81ea\u8eab\u3002 \u8fd9\u53ef\u4ee5\u7528\u6807\u51c6\u7b26\u53f7<code>f1 + f2</code>\u6765\u5199\u3002</p> <p>\u4e24\u4e2a\u5206\u6570\u5fc5\u987b\u5177\u6709\u76f8\u540c\u7684\u5206\u6bcd\u624d\u80fd\u76f8\u52a0\u3002 \u786e\u4fdd\u5b83\u4eec\u5177\u6709\u76f8\u540c\u5206\u6bcd\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u662f\u7b80\u5355\u5730\u4f7f\u7528\u4e24\u4e2a\u5206\u6bcd\u7684\u4e58\u79ef\u4f5c\u4e3a\u516c\u5206\u6bcd\uff0c\u4ee5\u4fbf \\(\\frac {a}{b} + \\frac {c}{d} = \\frac {ad}{bd} + \\frac {cb}{bd} = \\frac{ad+cb}{bd}\\)\u3002 \u5176\u5b9e\u73b0\u5982\u201c\u6e05\u5355 5\u201d\u6240\u793a\u3002 \u52a0\u6cd5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u201cFraction\u201d\u5bf9\u8c61\uff0c\u5176\u4e2d\u5305\u542b\u603b\u548c\u7684\u5206\u5b50\u548c\u5206\u6bcd\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7f16\u5199\u5305\u542b\u5206\u6570\u7684\u6807\u51c6\u7b97\u672f\u8868\u8fbe\u5f0f\uff0c\u5206\u914d\u52a0\u6cd5\u7ed3\u679c\uff0c\u7136\u540e\u6253\u5370\u7ed3\u679c\u6765\u4f7f\u7528\u6b64\u65b9\u6cd5\u3002</p> <p>\u6e05\u5355 5</p> <pre><code>def __add__(self, other_fraction):\n    new_num = self.num *other_fraction.den + \\\n                self.den* other_fraction.num\n    new_den = self.den * other_fraction.den\n\n    return Fraction(new_num, new_den)\n</code></pre> <pre><code>&gt;&gt;&gt; f1 = Fraction(1, 4)\n&gt;&gt;&gt; f2 = Fraction(1, 2)\n&gt;&gt;&gt; print(f1 + f2)\n6/8\n</code></pre> <p>\u52a0\u6cd5\u65b9\u6cd5\u5982\u6211\u4eec\u6240\u613f\uff0c\u4f46\u6709\u4e00\u70b9\u53ef\u4ee5\u505a\u5f97\u66f4\u597d\u3002 \u8bf7\u6ce8\u610f\uff0c\\(6/8\\) \u662f\u6b63\u786e\u7684\u7ed3\u679c (\\(\\frac {1}{4} + \\frac {1}{2}\\))\uff0c\u4f46\u5b83\u4e0d\u662f\u201c\u6700\u4f4e\u9879\u201d\u8868\u793a\u5f62\u5f0f\u3002 \u6700\u597d\u7684\u4ee3\u8868\u662f \\(3/4\\)\u3002 \u4e3a\u4e86\u786e\u4fdd\u6211\u4eec\u7684\u7ed3\u679c\u59cb\u7ec8\u662f\u6700\u4f4e\u7684\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u77e5\u9053\u5982\u4f55\u51cf\u5c11\u5206\u6570\u7684\u8f85\u52a9\u51fd\u6570\u3002 \u8be5\u51fd\u6570\u9700\u8981\u5bfb\u627e\u6700\u5927\u516c\u7ea6\u6570\uff08GCD\uff09\u3002 \u7136\u540e\u6211\u4eec\u53ef\u4ee5\u5c06\u5206\u5b50\u548c\u5206\u6bcd\u9664\u4ee5 GCD\uff0c\u7ed3\u679c\u5c06\u7b80\u5316\u4e3a\u6700\u4f4e\u9879\u3002</p> <p>\u5bfb\u627e\u6700\u5927\u516c\u7ea6\u6570\u7684\u6700\u8457\u540d\u7b97\u6cd5\u662f\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff0c\u8be5\u7b97\u6cd5\u5c06\u5728\u7b2c 8 \u7ae0\u4e2d\u8be6\u7ec6\u8ba8\u8bba\u3002\u5b83\u6307\u51fa\u4e24\u4e2a\u6574\u6570 \\(m\\) \u548c \\(n\\) \u7684\u6700\u5927\u516c\u7ea6\u6570\u662f \\(n\\)\uff0c\u5982\u679c \\(n\\) \u5e73\u5206\\(m\\)\u3002 \u4f46\u662f\uff0c\u5982\u679c \\(n\\) \u4e0d\u80fd\u6574\u9664 \\(m\\)\uff0c\u5219\u7b54\u6848\u662f \\(n\\) \u7684\u6700\u5927\u516c\u7ea6\u6570\u548c \\(m\\) \u9664\u4ee5 \\(n\\) \u7684\u4f59\u6570\u3002 \u6211\u4eec\u5c06\u5728\u8fd9\u91cc\u7b80\u5355\u5730\u63d0\u4f9b\u4e00\u4e2a\u8fed\u4ee3\u5b9e\u73b0\uff08\u53c2\u89c1\u201cActiveCode 1\u201d\uff09\u3002 \u8bf7\u6ce8\u610f\uff0cGCD \u7b97\u6cd5\u7684\u8fd9\u79cd\u5b9e\u73b0\u4ec5\u5728\u5206\u6bcd\u4e3a\u6b63\u65f6\u624d\u6709\u6548\u3002 \u8fd9\u5bf9\u4e8e\u6211\u4eec\u7684\u5206\u6570\u7c7b\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\uff0c\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u8bf4\u8fc7\u8d1f\u5206\u6570\u5c06\u7531\u8d1f\u5206\u5b50\u8868\u793a\u3002</p> \u6700\u5927\u516c\u7ea6\u6570\u51fd\u6570<pre><code>def gcd(m, n):\n    while m % n != 0:\n        m, n = n, m % n\n    return n\n\nprint(gcd(20, 10))\n</code></pre> <p>\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570\u6765\u5e2e\u52a9\u51cf\u5c11\u4efb\u4f55\u5206\u6570\u3002 \u4e3a\u4e86\u5c06\u5206\u6570\u8f6c\u5316\u4e3a\u6700\u7b80\u5f62\u5f0f\uff0c\u6211\u4eec\u5c06\u5206\u5b50\u548c\u5206\u6bcd\u9664\u4ee5\u5b83\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\u3002 \u56e0\u6b64\uff0c\u5bf9\u4e8e\u5206\u6570 \\(6/8\\)\uff0c\u6700\u5927\u516c\u7ea6\u6570\u662f 2\u3002\u5c06\u9876\u90e8\u548c\u5e95\u90e8\u9664\u4ee5 2 \u521b\u5efa\u4e00\u4e2a\u65b0\u5206\u6570 \\(3/4\\)\uff08\u53c2\u89c1\u201c\u6e05\u5355 6\u201d\uff09\u3002</p> <p>\u6e05\u5355 6</p> <pre><code>def __add__(self, other_fraction):\n    new_num = self.num * other_fraction.den + \\\n                    self.den * other_fraction.num\n    new_den = self.den * other_fraction.den\n    common = gcd(new_num, new_den)\n    return Fraction(new_num // common, new_den // common)\n</code></pre> <p>\u6211\u4eec\u7684\u201cFraction\u201d\u5bf9\u8c61\u73b0\u5728\u6709\u4e24\u4e2a\u975e\u5e38\u6709\u7528\u7684\u65b9\u6cd5\uff0c\u5982\u201c\u56fe 6\u201d\u6240\u793a\u3002</p> <p> \u56fe 6\uff1a\u5177\u6709\u4e24\u4e2a\u65b9\u6cd5\u7684\u201cFraction\u201d\u7c7b\u7684\u5b9e\u4f8b </p> <pre><code>&gt;&gt;&gt; f1 = Fraction(1, 4)\n&gt;&gt;&gt; f2 = Fraction(1, 2)\n&gt;&gt;&gt; print(f1 + f2)\n3/4\n</code></pre> <p>\u6211\u4eec\u9700\u8981\u5728\u793a\u4f8b\u201cFraction\u201d\u7c7b\u4e2d\u5305\u542b\u7684\u53e6\u4e00\u7ec4\u65b9\u6cd5\u5c06\u5141\u8bb8\u4e24\u4e2a\u5206\u6570\u76f8\u4e92\u6bd4\u8f83\u3002 \u5047\u8bbe\u6211\u4eec\u6709\u4e24\u4e2a\u201cFraction\u201d\u5bf9\u8c61\uff0c\u201cf1\u201d\u548c\u201cf2\u201d\u3002 \u4ec5\u5f53\u5b83\u4eec\u662f\u5bf9\u540c\u4e00\u5bf9\u8c61\u7684\u5f15\u7528\u65f6\uff0c\u201cf1==f2\u201d\u624d\u4f1a\u4e3a\u201cTrue\u201d\u3002 \u5728\u6b64\u5b9e\u73b0\u4e0b\uff0c\u5177\u6709\u76f8\u540c\u5206\u5b50\u548c\u5206\u6bcd\u7684\u4e24\u4e2a\u4e0d\u540c\u5bf9\u8c61\u5c06\u4e0d\u76f8\u7b49\u3002 \u8fd9\u79f0\u4e3a\u6d45\u5e73\u7b49\uff08\u53c2\u89c1\u201c\u56fe 7\u201d\uff09\u3002</p> <p> \u56fe 7\uff1a\u6d45\u5c42\u5e73\u7b49\u4e0e\u6df1\u5ea6\u5e73\u7b49 </p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u91cd\u5199<code>__eq__</code>\u65b9\u6cd5\u6765\u521b\u5efa\u6df1\u5ea6\u76f8\u7b49(deep equality)\u2014\u2014\u901a\u8fc7\u76f8\u540c\u7684\u503c\u800c\u4e0d\u662f\u76f8\u540c\u7684\u5f15\u7528\u6765\u76f8\u7b49\uff08\u53c2\u89c1\u201c\u56fe7\u201d\uff09\u3002 <code>__eq__</code> \u65b9\u6cd5\u662f\u4efb\u4f55\u7c7b\u4e2d\u53ef\u7528\u7684\u53e6\u4e00\u4e2a\u6807\u51c6\u65b9\u6cd5\u3002 <code>__eq__</code> \u65b9\u6cd5\u6bd4\u8f83\u4e24\u4e2a\u5bf9\u8c61\uff0c\u5982\u679c\u5b83\u4eec\u7684\u503c\u76f8\u540c\u5219\u8fd4\u56de\u201cTrue\u201d\uff0c\u5426\u5219\u8fd4\u56de\u201cFalse\u201d\u3002</p> <p>\u5728\u201cFraction\u201d\u7c7b\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u518d\u6b21\u5c06\u4e24\u4e2a\u5206\u6570\u653e\u5165\u5e38\u7528\u9879\u4e2d\uff0c\u7136\u540e\u6bd4\u8f83\u5206\u5b50\u6765\u5b9e\u73b0<code>__eq__</code>\u65b9\u6cd5\uff08\u53c2\u89c1\u201c\u6e05\u5355 7\u201d\uff09\u3002 \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u8fd8\u6709\u5176\u4ed6\u53ef\u4ee5\u88ab\u8986\u76d6\u7684\u5173\u7cfb\u8fd0\u7b97\u7b26\u3002 \u4f8b\u5982\uff0c<code>__le__</code> \u65b9\u6cd5\u63d0\u4f9b\u5c0f\u4e8e\u6216\u7b49\u4e8e\u529f\u80fd\u3002</p> <p>\u6e05\u5355 7</p> <pre><code>def __eq__(self, other_fraction):\n    first_num = self.num * other_fraction.den\n    second_num = other_fraction.num * self.den\n\n    return first_num == second_num\n</code></pre> <p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u5b8c\u6574\u7684\u201cFraction\u201d\u7c7b\u663e\u793a\u5728\u201cActiveCode 2\u201d\u4e2d\u3002 \u6211\u4eec\u5c06\u5269\u4e0b\u7684\u7b97\u672f\u548c\u5173\u7cfb\u65b9\u6cd5\u7559\u4f5c\u7ec3\u4e60\u3002</p> \u5206\u6570\u7c7b<pre><code>def gcd(m, n):\n    while m % n != 0:\n        m, n = n, m % n\n    return n\n\nclass Fraction:\n    def __init__(self, top, bottom):\n        self.num = top\n        self.den = bottom\n\n    def __str__(self):\n        return \"{:d}/{:d}\".format(self.num, self.den)\n\n    def __eq__(self, other_fraction):\n        first_num = self.num * other_fraction.den\n        second_num = other_fraction.num * self.den\n\n        return first_num == second_num\n\n    def __add__(self, other_fraction):\n        new_num = self.num * other_fraction.den \\\n        + self.den * other_fraction.num\n        new_den = self.den * other_fraction.den\n        cmmn = gcd(new_num, new_den)\n        return Fraction(new_num // cmmn, new_den // cmmn)\n\n    def show(self):\n        print(\"{:d}/{:d}\".format(self.num, self.den))\n\nx = Fraction(1, 2)\nx.show()\ny = Fraction(2, 3)\nprint(y)\nprint(x + y)\nprint(x == y)\n</code></pre> <p>\u81ea\u68c0</p> <p>\u4e3a\u4e86\u786e\u4fdd\u60a8\u4e86\u89e3\u5982\u4f55\u5728 Python \u7c7b\u4e2d\u5b9e\u73b0\u8fd0\u7b97\u7b26\u4ee5\u53ca\u5982\u4f55\u6b63\u786e\u7f16\u5199\u65b9\u6cd5\uff0c\u8bf7\u7f16\u5199\u4e00\u4e9b\u65b9\u6cd5\u6765\u5b9e\u73b0 <code>*, /,</code> \u548c <code>-</code> \u3002 \u8fd8\u5b9e\u73b0\u6bd4\u8f83\u8fd0\u7b97\u7b26 <code>&gt;</code> \u548c <code>&lt;</code></p> <p></p> <p>A very common example to show the details of implementing a user-defined class is to construct a class to implement the abstract data type <code>Fraction</code>. We have already seen that Python provides a number of numeric classes for our use. There are times, however, that it would be most appropriate to be able to create data objects that look like fractions to the user.</p> <p>A fraction such as \\(\\frac {3}{5}\\) consists of two parts. The top value, known as the numerator, can be any integer. The bottom value, called the denominator, can be any integer greater than 0 (negative fractions have a negative numerator). Although it is possible to create a floating point approximation for any fraction, in this case we would like to represent the fraction as an exact value.</p> <p>The operations for the <code>Fraction</code> type will allow a <code>Fraction</code> data object to behave like any other numeric value. We need to be able to add, subtract, multiply, and divide fractions. We also want to be able to show fractions using the standard \u201cslash\u201d form, for example \u2157. In addition, all fraction methods should return results in their lowest terms so that no matter what computation is performed, we always end up with the most common form.</p> <p>In Python, we define a new class by providing a name and a set of method definitions that are syntactically similar to function definitions. For this example,</p> <pre><code>    class Fraction:\n    # the methods go here\n</code></pre> <p>provides the framework for us to define the methods. The first method that all classes should provide is the constructor. The constructor defines the way in which data objects are created. To create a <code>Fraction</code> object, we will need to provide two pieces of data, the numerator and the denominator. In Python, the constructor method is always called init (two underscores before and after <code>init</code>), as shown in <code>Listing 2</code>.</p> <p>.. _lst_pyconstructor:</p> <p>Listing 2</p> <pre><code>    class Fraction:\n        \"\"\"Class Fraction\"\"\"\n        def __init__(self, top, bottom):\n            \"\"\"Constructor definition\"\"\"\n            self.num = top\n            self.den = bottom\n</code></pre> <p>Notice that the formal parameter list contains three items (<code>self</code>, <code>top</code>, <code>bottom</code>). <code>self</code> is a special parameter that will always be used as a reference back to the object itself. It must always be the first formal parameter; however, it will never be given an actual parameter value upon invocation. As described earlier, fractions require two pieces of state data, the numerator and the denominator. The notation <code>self.num</code> in the constructor defines the <code>Fraction</code> object to have an internal data object called <code>num</code> as part of its state. Likewise, <code>self.den</code> creates the denominator. The values of the two formal parameters are initially assigned to the state, allowing the new <code>Fraction</code> object to know its starting value.</p> <p>To create an instance of the <code>Fraction</code> class, we must invoke the constructor. This happens by using the name of the class and passing actual values for the necessary state (note that we never directly <code>invoke __init__</code>). For example,</p> <pre><code>    my_fraction = Fraction(3, 5)\n</code></pre> <p>creates an object called <code>my_fraction</code> representing the fraction $<code>\\frac {3}{5}$ (three-fifths).</code>Figure 5` shows this object as it is now implemented.</p> <p> Figure 5: An Instance of the <code>Fraction</code> Class </p> <p>The next thing we need to do is implement the behavior that the abstract data type requires. To begin, consider what happens when we try to print a <code>Fraction</code> object.</p> <pre><code>&gt;&gt;&gt; my_fraction = Fraction(3, 5)\n&gt;&gt;&gt; print(my_fraction)\n&lt;__main__.Fraction object at 0x103203eb8&gt;\n</code></pre> <p>The <code>Fraction</code> object, <code>my_fraction</code>, does not know how to respond to this request to print. The <code>print</code> function requires that the object convert itself into a string so that the string can be written to the output. The only choice <code>my_fraction</code> has is to show the actual reference that is stored in the variable (the address itself). This is not what we want.</p> <p>There are two ways we can solve this problem. One is to define a method called <code>show</code> that will allow the <code>Fraction</code> object to print itself as a string. We can implement this method as shown in <code>Listing 3</code>. If we create a <code>Fraction</code> object as before we can ask it to show itself (in other words, print itself  in the proper format). Unfortunately, this does not work in general. In order to make printing work properly, we need to tell the <code>Fraction</code> class how to convert itself into a string. This is what the <code>print</code> function needs in order to do its job.</p> <p>Listing 3</p> <pre><code>    def show(self):\n            print(f\"{self.num}/{self.den}\")\n</code></pre> <pre><code>    &gt;&gt;&gt; my_fraction = Fraction(3, 5)\n    &gt;&gt;&gt; my_fraction.show()\n    3/5\n    &gt;&gt;&gt; print(my_fraction)\n    &lt;__main__.Fraction object at 0x40bce9ac&gt;\n</code></pre> <p>In Python, all classes have a set of standard methods that are provided but may not work properly. One of these, <code>__str__</code>, is the method to convert an object into a string. The default implementation for this method is to return the instance address string as we have already seen. What we need to do is provide a better implementation for this method. We will say that this implementation overrides the previous one, or that it redefines the method\u2019s behavior.</p> <p>To do this, we simply define a method with the name <code>__str__</code> and give it a new implementation as shown in <code>Listing 4</code>. This definition does not need any other information except the special parameter <code>self</code>. In turn, the method will build a string representation by converting each piece of internal state data to a string and then placing a <code>/</code> character in between the strings using string concatenation. The resulting string will be returned any time a <code>Fraction</code> object is asked to convert itself to a string. Notice the various ways that this function is used.</p> <p>Listing 4</p> <pre><code>    def __str__(self):\n        return f\"{self.num}/{self.den}\"\n</code></pre> <pre><code>&gt;&gt;&gt; my_fraction = Fraction(3, 5)\n&gt;&gt;&gt; print(my_fraction)\n3/5\n&gt;&gt;&gt; print(f\"I ate {my_fraction} of pizza\")\nI ate 3/5 of pizza\n&gt;&gt;&gt; my_fraction.__str__()\n'3/5'\n&gt;&gt;&gt; str(my_fraction)\n'3/5'\n</code></pre> <p>We can override many other methods for our new <code>Fraction</code> class. Some of the most important of these are the basic arithmetic operations. We would like to be able to create two <code>Fraction</code> objects and then add them together using the standard <code>+</code> notation. At this point, if we try to add two fractions, we get the following:</p> <pre><code>    &gt;&gt;&gt; f1 = Fraction(1, 4)\n    &gt;&gt;&gt; f2 = Fraction(1, 2)\n    &gt;&gt;&gt; f1 + f2\n    Traceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n    TypeError: unsupported operand type(s) for +: 'Fraction' and 'Fraction'\n</code></pre> <p>If you look closely at the error, you see that the problem is that the <code>+</code> operator does not understand the <code>Fraction</code> operands. We can fix this by providing the <code>Fraction</code> class with a method that overrides the addition method. In Python, this method is called <code>__add__</code> and it requires two parameters. The first, <code>self</code>, is always needed, and the second represents the other operand in the expression. For example,</p> <pre><code>    f1.__add__(f2)\n</code></pre> <p>would ask the <code>Fraction</code> object <code>f1</code> to add the <code>Fraction</code> object <code>f2</code> to itself. This can be written in the standard notation, <code>f1 + f2</code>.</p> <p>Two fractions must have the same denominator to be added. The easiest way to make sure they have the same denominator is to simply use the product of the two denominators as a common denominator so that \\(\\frac {a}{b} + \\frac {c}{d} = \\frac {ad}{bd} + \\frac {cb}{bd} = \\frac{ad+cb}{bd}\\). The implementation is shown in <code>Listing 5</code>. The addition function returns a new <code>Fraction</code> object with the numerator and denominator of the sum. We can use this method by writing a standard arithmetic expression involving fractions, assigning the result of the addition, and then printing our result.</p> <p>.. _lst_addmethod:</p> <p>Listing 5</p> <pre><code>def __add__(self, other_fraction):\n    new_num = self.num *other_fraction.den + \\\n                self.den* other_fraction.num\n    new_den = self.den * other_fraction.den\n\n    return Fraction(new_num, new_den)\n</code></pre> <pre><code>    &gt;&gt;&gt; f1 = Fraction(1, 4)\n    &gt;&gt;&gt; f2 = Fraction(1, 2)\n    &gt;&gt;&gt; print(f1 + f2)\n    6/8\n</code></pre> <p>The addition method works as we desire, but one thing could be better. Note that \\(6/8\\) is the correct result (\\(\\frac {1}{4} + \\frac {1}{2}\\)) but that it is not in the \u201clowest terms\u201d representation. The best representation would be \\(3/4\\). In order to be sure that our results are always in the lowest terms, we need a helper function that knows how to reduce fractions. This function will need to look for the greatest common divisor, or GCD. We can then divide the numerator and the denominator by the GCD and the result will be reduced to lowest terms.</p> <p>The best-known algorithm for finding the greatest common divisor is Euclid\u2019s algorithm, which will be discussed in detail in Chapter 8. It states that the greatest common divisor of two integers \\(m\\) and \\(n\\) is \\(n\\) if \\(n\\) divides \\(m\\) evenly. However, if \\(n\\) does not divide \\(m\\) evenly, then the answer is the greatest common divisor of \\(n\\) and the remainder of \\(m\\) divided by \\(n\\). We will simply provide an iterative implementation here (see <code>ActiveCode 1</code>). Note that this implementation of the GCD algorithm works only when the denominator is positive. This is acceptable for our fraction class because we have said that a negative fraction will be represented by a negative numerator.</p> The Greatest Common Divisor Function<pre><code>    def gcd(m, n):\n        while m % n != 0:\n            m, n = n, m % n\n        return n\n\n    print(gcd(20, 10))\n</code></pre> <p>Now we can use this function to help reduce any fraction. To put a fraction in lowest terms, we will divide the numerator and the denominator by their greatest common divisor. So, for the fraction \\(6/8\\), the greatest common divisor is 2. Dividing the top and the bottom by 2 creates a new fraction, \\(3/4\\) (see <code>Listing 6</code>).</p> <p>Listing 6</p> <pre><code>def __add__(self, other_fraction):\n    new_num = self.num * other_fraction.den + \\\n                    self.den * other_fraction.num\n    new_den = self.den * other_fraction.den\n    common = gcd(new_num, new_den)\n    return Fraction(new_num // common, new_den // common)\n</code></pre> <p>Our <code>Fraction</code> object now has two very useful methods as depicted in <code>Figure 6</code>.</p> <p> Figure 6: An Instance of the <code>Fraction</code> Class with Two Methods </p> <pre><code>&gt;&gt;&gt; f1 = Fraction(1, 4)\n&gt;&gt;&gt; f2 = Fraction(1, 2)\n&gt;&gt;&gt; print(f1 + f2)\n3/4\n</code></pre> <p>An additional group of methods that we need to include in our example <code>Fraction</code> class will allow two fractions to compare themselves to one another. Assume we have two <code>Fraction</code> objects, <code>f1</code> and <code>f2</code>. <code>f1==f2</code> will only be <code>True</code> if they are references to the same object. Two different objects with the same numerators and denominators would not be equal under this implementation. This is called shallow equality (see <code>Figure 7</code>).</p> <p> Figure 7: Shallow Equality Versus Deep Equality </p> <p>We can create deep equality\u2013equality by the same value, not the same reference\u2013by overriding the <code>__eq__</code> method (see <code>Figure 7</code>). The <code>__eq__</code> method is another standard method available in any class. The <code>__eq__</code> method compares two objects and returns <code>True</code> if their values are the same, <code>False</code> otherwise.</p> <p>In the <code>Fraction</code> class, we can implement the <code>__eq__</code> method by again putting the two fractions in common terms and then comparing the numerators (see <code>Listing 7</code>). It is important to note that there are other relational operators that can be overridden. For example, the <code>__le__</code> method provides the less than or equal functionality.</p> <p>Listing 7</p> <pre><code>def __eq__(self, other_fraction):\n    first_num = self.num * other_fraction.den\n    second_num = other_fraction.num * self.den\n\n    return first_num == second_num\n</code></pre> <p>The complete <code>Fraction</code> class, up to this point, is shown in <code>ActiveCode 2</code>. We leave the remaining arithmetic and relational methods as exercises.</p> The Fraction Class<pre><code>def gcd(m, n):\n    while m % n != 0:\n        m, n = n, m % n\n    return n\n\nclass Fraction:\n    def __init__(self, top, bottom):\n        self.num = top\n        self.den = bottom\n\n    def __str__(self):\n        return \"{:d}/{:d}\".format(self.num, self.den)\n\n    def __eq__(self, other_fraction):\n        first_num = self.num * other_fraction.den\n        second_num = other_fraction.num * self.den\n\n        return first_num == second_num\n\n    def __add__(self, other_fraction):\n        new_num = self.num * other_fraction.den \\\n        + self.den * other_fraction.num\n        new_den = self.den * other_fraction.den\n        cmmn = gcd(new_num, new_den)\n        return Fraction(new_num // cmmn, new_den // cmmn)\n\n    def show(self):\n        print(\"{:d}/{:d}\".format(self.num, self.den))\n\nx = Fraction(1, 2)\nx.show()\ny = Fraction(2, 3)\nprint(y)\nprint(x + y)\nprint(x == y)\n</code></pre> <p>Self  Check</p> <p>To make sure you understand how operators are implemented in Python classes, and how to properly write methods, write some methods to implement <code>*, /,</code> and <code>-</code> .  Also implement comparison operators &gt; and &lt;</p> <p></p>"},{"location":"c1/s13/#1132-\u7ee7\u627f\u903b\u8f91\u95e8\u548c\u7535\u8def","title":"1.13.2. \u7ee7\u627f\uff1a\u903b\u8f91\u95e8\u548c\u7535\u8def","text":"<p>1.13.2. Inheritance: Logic Gates and Circuits</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u7684\u6700\u540e\u4e00\u8282\u5c06\u4ecb\u7ecd\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u7684\u53e6\u4e00\u4e2a\u91cd\u8981\u65b9\u9762\u3002 \u7ee7\u627f\u662f\u4e00\u4e2a\u7c7b\u4e0e\u53e6\u4e00\u7c7b\u76f8\u5173\u7684\u80fd\u529b\uff0c\u5c31\u50cf\u4eba\u4eec\u5f7c\u6b64\u4e4b\u95f4\u7684\u5173\u7cfb\u4e00\u6837\u3002 \u5b69\u5b50\u7ee7\u627f\u4e86\u7236\u6bcd\u7684\u7279\u5f81\u3002 \u7c7b\u4f3c\u5730\uff0cPython \u5b50\u7c7b\u53ef\u4ee5\u4ece\u7236\u7c7b\u7ee7\u627f\u7279\u5f81\u6570\u636e\u548c\u884c\u4e3a\u3002 \u8fd9\u4e9b\u7c7b\u901a\u5e38\u79f0\u4e3a\u5b50\u7c7b\u548c\u8d85\u7c7b\u3002</p> <p>\u201c\u56fe 8\u201d\u663e\u793a\u4e86\u5185\u7f6e\u7684 Python \u96c6\u5408\u4ee5\u53ca\u5b83\u4eec\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u6211\u4eec\u5c06\u8fd9\u6837\u7684\u5173\u7cfb\u7ed3\u6784\u79f0\u4e3a\u7ee7\u627f\u5c42\u6b21\u7ed3\u6784\u3002 \u4f8b\u5982\uff0c\u5217\u8868\u662f\u987a\u5e8f\u96c6\u5408\u7684\u5b50\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u5217\u8868\u79f0\u4e3a\u5b50\u7ea7\uff0c\u5c06\u5e8f\u5217\u79f0\u4e3a\u7236\u7ea7\uff08\u6216\u5b50\u7c7b\u5217\u8868\u548c\u8d85\u7c7b\u5e8f\u5217\uff09\u3002 \u8fd9\u901a\u5e38\u88ab\u79f0\u4e3a Is-a \u5173\u7cfb(Is-a realtionship)\uff08\u5217\u8868 Is-a \u987a\u5e8f\u96c6\u5408\uff09\u3002 \u8fd9\u610f\u5473\u7740\u5217\u8868\u7ee7\u627f\u4e86\u5e8f\u5217\u7684\u91cd\u8981\u7279\u5f81\uff0c\u5373\u57fa\u7840\u6570\u636e\u7684\u6392\u5e8f\u548c\u8fde\u63a5\u3001\u91cd\u590d\u548c\u7d22\u5f15\u7b49\u64cd\u4f5c\u3002</p> <p> \u56fe 8\uff1aPython \u96c6\u5408\u7684\u7ee7\u627f\u5c42\u6b21\u7ed3\u6784 </p> <p>\u5217\u8868\u3001\u5143\u7ec4\u548c\u5b57\u7b26\u4e32\u90fd\u662f\u987a\u5e8f\u96c6\u5408\u7684\u793a\u4f8b\u3002 \u5b83\u4eec\u90fd\u7ee7\u627f\u4e86\u901a\u7528\u7684\u6570\u636e\u7ec4\u7ec7\u548c\u64cd\u4f5c\u3002 \u7136\u800c\uff0c\u6839\u636e\u6570\u636e\u662f\u5426\u540c\u8d28\u4ee5\u53ca\u96c6\u5408\u662f\u5426\u4e0d\u53ef\u53d8\uff0c\u5b83\u4eec\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u662f\u4e0d\u540c\u7684\u3002 \u5b69\u5b50\u4eec\u90fd\u4ece\u7236\u6bcd\u90a3\u91cc\u83b7\u76ca\uff0c\u4f46\u901a\u8fc7\u589e\u52a0\u989d\u5916\u7684\u7279\u5f81\u6765\u533a\u5206\u81ea\u5df1\u3002</p> <p>\u901a\u8fc7\u4ee5\u8fd9\u79cd\u5206\u5c42\u65b9\u5f0f\u7ec4\u7ec7\u7c7b\uff0c\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u5141\u8bb8\u6269\u5c55\u4ee5\u524d\u7f16\u5199\u7684\u4ee3\u7801\u4ee5\u6ee1\u8db3\u65b0\u60c5\u51b5\u7684\u9700\u8981\u3002 \u6b64\u5916\uff0c\u901a\u8fc7\u4ee5\u8fd9\u79cd\u5206\u5c42\u65b9\u5f0f\u7ec4\u7ec7\u6570\u636e\uff0c\u6211\u4eec\u53ef\u4ee5\u66f4\u597d\u5730\u7406\u89e3\u5b58\u5728\u7684\u5173\u7cfb\u3002 \u6211\u4eec\u53ef\u4ee5\u66f4\u6709\u6548\u5730\u6784\u5efa\u62bd\u8c61\u8868\u793a\u3002</p> <p>\u4e3a\u4e86\u8fdb\u4e00\u6b65\u63a2\u7d22\u8fd9\u4e2a\u60f3\u6cd5\uff0c\u6211\u4eec\u5c06\u6784\u5efa\u4e00\u4e2a\u6a21\u62df\uff0c\u4e00\u4e2a\u6a21\u62df\u6570\u5b57\u7535\u8def\u7684\u5e94\u7528\u7a0b\u5e8f\u3002 \u8be5\u6a21\u62df\u7684\u57fa\u672c\u6784\u5efa\u6a21\u5757\u662f\u903b\u8f91\u95e8\u3002 \u8fd9\u4e9b\u7535\u5b50\u5f00\u5173\u4ee3\u8868\u5176\u8f93\u5165\u548c\u8f93\u51fa\u4e4b\u95f4\u7684\u5e03\u5c14\u4ee3\u6570\u5173\u7cfb\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u95e8\u6709\u4e00\u6761\u8f93\u51fa\u7ebf\u3002 \u8f93\u51fa\u503c\u53d6\u51b3\u4e8e\u8f93\u5165\u884c\u4e0a\u7ed9\u51fa\u7684\u503c\u3002</p> <p>AND \u95e8\u6709\u4e24\u6761\u8f93\u5165\u7ebf\uff0c\u6bcf\u6761\u8f93\u5165\u7ebf\u53ef\u4ee5\u662f 0 \u6216 1\uff08\u5206\u522b\u4ee3\u8868<code>False</code>\u6216<code>True</code>\uff09\u3002 \u5982\u679c\u4e24\u6761\u8f93\u5165\u7ebf\u7684\u503c\u4e3a 1\uff0c\u5219\u7ed3\u679c\u8f93\u51fa\u4e3a 1\u3002\u4f46\u662f\uff0c\u5982\u679c\u4e00\u6761\u6216\u4e24\u6761\u8f93\u5165\u7ebf\u5747\u4e3a 0\uff0c\u5219\u7ed3\u679c\u4e3a 0\u3002\u6216\u95e8\u4e5f\u6709\u4e24\u6761\u8f93\u5165\u7ebf\uff0c\u5982\u679c\u4e00\u6761\u6216\u4e24\u6761\u8f93\u5165\u7ebf\u90fd\u4e3a 1\uff0c\u5219\u7ed3\u679c\u4e3a 1 \u8f93\u5165\u503c\u7684\u5176\u4e2d\u4e4b\u4e00\u662f 1\u3002\u5982\u679c\u4e24\u6761\u8f93\u5165\u7ebf\u5747\u4e3a 0\uff0c\u5219\u7ed3\u679c\u4e3a 0\u3002</p> <p>NOT \u95e8\u4e0e\u5176\u4ed6\u4e24\u4e2a\u95e8\u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5b83\u4eec\u53ea\u6709\u4e00\u6761\u8f93\u5165\u7ebf\u3002 \u8f93\u51fa\u503c\u4e0e\u8f93\u5165\u503c\u6b63\u597d\u76f8\u53cd\u3002 \u5982\u679c\u8f93\u5165\u4e0a\u51fa\u73b0 0\uff0c\u5219\u8f93\u51fa\u4e0a\u4f1a\u4ea7\u751f 1\u3002 \u7c7b\u4f3c\u5730\uff0c1 \u4ea7\u751f 0\u3002\u201c\u56fe 9\u201d\u663e\u793a\u4e86\u6bcf\u4e2a\u95e8\u7684\u5178\u578b\u8868\u793a\u65b9\u5f0f\u3002 \u6bcf\u4e2a\u95e8\u8fd8\u6709\u4e00\u4e2a\u503c\u7684\u771f\u503c\u8868\uff0c\u663e\u793a\u95e8\u6267\u884c\u7684\u8f93\u5165\u5230\u8f93\u51fa\u6620\u5c04\u3002</p> <p> \u56fe 9\uff1a\u4e09\u79cd\u7c7b\u578b\u7684\u903b\u8f91\u95e8 </p> <p>\u901a\u8fc7\u4ee5\u5404\u79cd\u6a21\u5f0f\u7ec4\u5408\u8fd9\u4e9b\u95e8\uff0c\u7136\u540e\u5e94\u7528\u4e00\u7ec4\u8f93\u5165\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u5177\u6709\u903b\u8f91\u529f\u80fd\u7684\u7535\u8def\u3002 \u201c\u56fe 10\u201d\u663e\u793a\u4e86\u4e00\u4e2a\u7531\u4e24\u4e2a\u4e0e\u95e8\u3001\u4e00\u4e2a\u6216\u95e8\u548c\u4e00\u4e2a\u975e\u95e8\u7ec4\u6210\u7684\u7535\u8def\u3002 \u4e24\u4e2a\u201c\u4e0e\u201d\u95e8\u7684\u8f93\u51fa\u7ebf\u76f4\u63a5\u9988\u5165\u201c\u6216\u201d\u95e8\uff0c\u201c\u6216\u201d\u95e8\u7684\u8f93\u51fa\u7ed3\u679c\u63d0\u4f9b\u7ed9\u201c\u975e\u201d\u95e8\u3002 \u5982\u679c\u6211\u4eec\u5c06\u4e00\u7ec4\u8f93\u5165\u503c\u5e94\u7528\u4e8e\u56db\u4e2a\u8f93\u5165\u7ebf\uff08\u6bcf\u4e2a\u4e0e\u95e8\u4e24\u4e2a\u8f93\u5165\u7ebf\uff09\uff0c\u8fd9\u4e9b\u503c\u5c06\u88ab\u5904\u7406\uff0c\u5e76\u4e14\u7ed3\u679c\u5c06\u51fa\u73b0\u5728\u975e\u95e8\u7684\u8f93\u51fa\u5904\u3002 \u201c\u56fe 10\u201d\u8fd8\u663e\u793a\u4e86\u4e00\u4e2a\u5e26\u6709\u503c\u7684\u793a\u4f8b\u3002</p> <p> \u56fe 10\uff1a\u7535\u8def </p> <p>\u4e3a\u4e86\u5b9e\u73b0\u7535\u8def\uff0c\u6211\u4eec\u9996\u5148\u6784\u5efa\u903b\u8f91\u95e8\u7684\u8868\u793a\u3002 \u903b\u8f91\u95e8\u5f88\u5bb9\u6613\u7ec4\u7ec7\u6210\u7c7b\u7ee7\u627f\u5c42\u6b21\u7ed3\u6784\uff0c\u5982\u56fe 11 \u6240\u793a\u3002 \u5728\u5c42\u6b21\u7ed3\u6784\u7684\u9876\u90e8\uff0c\u201cLogicGate\u201d\u7c7b\u4ee3\u8868\u903b\u8f91\u95e8\u7684\u6700\u4e00\u822c\u7279\u5f81\uff1a\u5373\u95e8\u7684\u6807\u7b7e\u548c\u8f93\u51fa\u7ebf\u3002 \u4e0b\u4e00\u7ea7\u5b50\u7c7b\u5c06\u903b\u8f91\u95e8\u5206\u4e3a\u4e24\u4e2a\u7cfb\u5217\uff0c\u4e00\u7ec4\u6709\u4e00\u6761\u8f93\u5165\u7ebf\uff0c\u53e6\u4e00\u7ec4\u6709\u4e24\u6761\u8f93\u5165\u7ebf\u3002 \u4e0b\u9762\uff0c\u51fa\u73b0\u4e86\u6bcf\u4e2a\u7684\u5177\u4f53\u903b\u8f91\u529f\u80fd\u3002</p> <p> \u56fe 11\uff1a\u903b\u8f91\u95e8\u7684\u7ee7\u627f\u5c42\u6b21\u7ed3\u6784 </p> <p>\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u4ece\u6700\u901a\u7528\u7684\u201cLogicGate\u201d\u5f00\u59cb\u5f00\u59cb\u5b9e\u73b0\u8fd9\u4e9b\u7c7b\u3002 \u5982\u524d\u6240\u8ff0\uff0c\u6bcf\u4e2a\u95e8\u90fd\u6709\u4e00\u4e2a\u7528\u4e8e\u8bc6\u522b\u7684\u6807\u7b7e\u548c\u4e00\u6761\u8f93\u51fa\u7ebf\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u9700\u8981\u5141\u8bb8\u95e8\u7684\u7528\u6237\u5411\u95e8\u8be2\u95ee\u5176\u6807\u7b7e\u7684\u65b9\u6cd5\u3002</p> <p>\u6bcf\u4e2a\u903b\u8f91\u95e8\u9700\u8981\u7684\u53e6\u4e00\u4e2a\u884c\u4e3a\u662f\u4e86\u89e3\u5176\u8f93\u51fa\u503c\u7684\u80fd\u529b\u3002 \u8fd9\u5c06\u8981\u6c42\u95e8\u6839\u636e\u5f53\u524d\u8f93\u5165\u6267\u884c\u9002\u5f53\u7684\u903b\u8f91\u3002 \u4e3a\u4e86\u4ea7\u751f\u8f93\u51fa\uff0c\u95e8\u9700\u8981\u5177\u4f53\u77e5\u9053\u8be5\u903b\u8f91\u662f\u4ec0\u4e48\u3002 \u8fd9\u610f\u5473\u7740\u8c03\u7528\u4e00\u4e2a\u65b9\u6cd5\u6765\u6267\u884c\u903b\u8f91\u8ba1\u7b97\u3002 \u5b8c\u6574\u7684\u7c7b\u5982\u201c\u6e05\u5355 8\u201d\u6240\u793a\u3002</p> <p>\u6e05\u5355 8</p> <pre><code>class LogicGate:\n    def __init__(self, lbl):\n        self.label = lbl\n        self.output = None\n\n    def get_label(self):\n        return self.label\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n</code></pre> <p>\u6b64\u65f6\uff0c\u6211\u4eec\u4e0d\u4f1a\u5b9e\u73b0\u201cperform_gate_logic\u201d\u51fd\u6570\u3002 \u539f\u56e0\u662f\u6211\u4eec\u4e0d\u77e5\u9053\u6bcf\u4e2a\u95e8\u5c06\u5982\u4f55\u6267\u884c\u81ea\u5df1\u7684\u903b\u8f91\u8fd0\u7b97\u3002 \u8fd9\u4e9b\u8be6\u7ec6\u4fe1\u606f\u5c06\u5305\u542b\u5728\u6dfb\u52a0\u5230\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u6bcf\u4e2a\u5355\u72ec\u7684\u95e8\u4e2d\u3002 \u8fd9\u662f\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u4e2d\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u601d\u60f3\u3002 \u6211\u4eec\u6b63\u5728\u7f16\u5199\u4e00\u4e2a\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u5c06\u4f7f\u7528\u5c1a\u4e0d\u5b58\u5728\u7684\u4ee3\u7801\u3002 \u53c2\u6570\u201cself\u201d\u662f\u5bf9\u8c03\u7528\u8be5\u65b9\u6cd5\u7684\u5b9e\u9645\u95e8\u5bf9\u8c61\u7684\u5f15\u7528\u3002 \u6dfb\u52a0\u5230\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u4efb\u4f55\u65b0\u903b\u8f91\u95e8\u53ea\u9700\u8981\u5b9e\u73b0\u201cperform_gate_logic\u201d\u51fd\u6570\uff0c\u5e76\u4e14\u5b83\u5c06\u5728\u9002\u5f53\u7684\u65f6\u95f4\u4f7f\u7528\u3002 \u4e00\u65e6\u5b8c\u6210\uff0c\u95e8\u5c31\u53ef\u4ee5\u63d0\u4f9b\u5176\u8f93\u51fa\u503c\u3002 \u8fd9\u79cd\u6269\u5c55\u5f53\u524d\u5b58\u5728\u7684\u5c42\u6b21\u7ed3\u6784\u5e76\u63d0\u4f9b\u5c42\u6b21\u7ed3\u6784\u4f7f\u7528\u65b0\u7c7b\u6240\u9700\u7684\u7279\u5b9a\u529f\u80fd\u7684\u80fd\u529b\u5bf9\u4e8e\u91cd\u7528\u73b0\u6709\u4ee3\u7801\u6781\u5176\u91cd\u8981\u3002</p> <p>\u6211\u4eec\u6839\u636e\u8f93\u5165\u7ebf\u7684\u6570\u91cf\u5bf9\u903b\u8f91\u95e8\u8fdb\u884c\u5206\u7c7b\uff0c\u5982\u56fe11\u6240\u793a\uff1a\u4e0e\u95e8\u548c\u6216\u95e8\u90fd\u6709\u4e24\u6761\u8f93\u5165\u7ebf\uff0c\u800c\u975e\u95e8\u53ea\u6709\u4e00\u6761\u8f93\u5165\u7ebf\u3002 <code>LogicGate</code> \u6709\u4e24\u4e2a\u5b50\u7c7b\uff1a<code>BinaryGate</code>\uff0c\u5b83\u5c06\u6dfb\u52a0\u4e24\u4e2a\u8f93\u5165\u884c\uff0c\u4ee5\u53ca<code>UnaryGate</code>\uff0c\u5b83\u5c06\u53ea\u6709\u4e00\u4e2a\u8f93\u5165\u884c\u3002</p> <p>\u5728\u8ba1\u7b97\u673a\u7535\u8def\u8bbe\u8ba1\u4e2d\uff0c\u8fd9\u4e9b\u7ebf\u8def\u6709\u65f6\u79f0\u4e3a\u201c\u5f15\u811a\u201d\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u5728\u5b9e\u73b0\u4e2d\u4f7f\u7528\u8be5\u672f\u8bed\u3002</p> <p>\u201c\u6e05\u5355 9\u201d\u548c\u201c\u6e05\u5355 10\u201d\u5b9e\u73b0\u4e86\u8fd9\u4e24\u4e2a\u7c7b\u3002 \u8fd9\u4e24\u4e2a\u7c7b\u4e2d\u7684\u6784\u9020\u51fd\u6570\u90fd\u4ee5\u4f7f\u7528\u7236\u7c7b\u7684 <code>__init__</code> \u65b9\u6cd5\u663e\u5f0f\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\u5f00\u59cb\u3002 \u5f53\u521b\u5efa\u201cBinaryGate\u201d\u7c7b\u7684\u5b9e\u4f8b\u65f6\uff0c\u6211\u4eec\u9996\u5148\u8981\u521d\u59cb\u5316\u4ece\u201cLogicGate\u201d\u7ee7\u627f\u7684\u6240\u6709\u6570\u636e\u9879\u3002 \u5728\u672c\u4f8b\u4e2d\uff0c\u8fd9\u610f\u5473\u7740\u95e8\u7684\u6807\u7b7e\u3002 \u7136\u540e\u6784\u9020\u51fd\u6570\u7ee7\u7eed\u6dfb\u52a0\u4e24\u4e2a\u8f93\u5165\u884c\uff08\u201cpin_a\u201d\u548c\u201cpin_b\u201d\uff09\u3002 \u8fd9\u662f\u4e00\u79cd\u975e\u5e38\u5e38\u89c1\u7684\u6a21\u5f0f\uff0c\u5728\u6784\u5efa\u7c7b\u5c42\u6b21\u7ed3\u6784\u65f6\u5e94\u8be5\u59cb\u7ec8\u4f7f\u7528\u5b83\u3002 \u5b50\u7c7b\u6784\u9020\u51fd\u6570\u9700\u8981\u8c03\u7528\u7236\u7c7b\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u7ee7\u7eed\u5904\u7406\u5b83\u4eec\u81ea\u5df1\u7684\u533a\u522b\u6570\u636e\u3002</p> <p>\u6e05\u5355 9</p> <pre><code>class BinaryGate(LogicGate):\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        return int(input(f\"Enter pin A input for gate \\\n            {self.get_label()}: \"))\n\n    def get_pin_b(self):\n        return int(input(f\"Enter pin B input for gate \\\n            {self.get_label()}: \"))\n</code></pre> <p>\u6e05\u5355 10</p> <pre><code>class UnaryGate(LogicGate):\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n        self.pin = None\n\n    def get_pin(self):\n        return int(input(f\"Enter pin input for gate \\\n            {self.get_label()}: \"))\n</code></pre> <p>Python \u8fd8\u6709\u4e00\u4e2a\u540d\u4e3a\u201csuper\u201d\u7684\u51fd\u6570\uff0c\u53ef\u4ee5\u7528\u6765\u4ee3\u66ff\u663e\u5f0f\u547d\u540d\u7236\u7c7b\u3002 \u8fd9\u662f\u4e00\u79cd\u66f4\u901a\u7528\u7684\u673a\u5236\u5e76\u4e14\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u7279\u522b\u662f\u5f53\u4e00\u4e2a\u7c7b\u6709\u591a\u4e2a\u7236\u7c7b\u65f6\u3002 \u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c<code>LogicGate.__init__(self, lbl)</code> \u53ef\u4ee5\u66ff\u6362\u4e3a<code>super().__init__(lbl)</code>,<code>super(UnaryGate, self).__init__(lbl)</code>, \u6216<code>super().__init__(\"UnaryGate\", lbl)</code>\u3002 \u5177\u4f53\u7ec6\u8282\u8d85\u51fa\u4e86\u672c\u6587\u7684\u8303\u56f4\u3002</p> <p><code>BinaryGate</code> \u7c7b\u6dfb\u52a0\u7684\u552f\u4e00\u884c\u4e3a\u662f\u80fd\u591f\u4ece\u4e24\u4e2a\u8f93\u5165\u884c\u83b7\u53d6\u503c\u3002 \u7531\u4e8e\u8fd9\u4e9b\u503c\u6765\u81ea\u67d0\u4e2a\u5916\u90e8\u4f4d\u7f6e\uff0c\u6211\u4eec\u5c06\u7b80\u5355\u5730\u8981\u6c42\u7528\u6237\u901a\u8fc7\u8f93\u5165\u8bed\u53e5\u63d0\u4f9b\u5b83\u4eec\u3002 <code>UnaryGate</code> \u7c7b\u4e5f\u6709\u76f8\u540c\u7684\u5b9e\u73b0\uff0c\u53ea\u662f\u53ea\u6709\u4e00\u4e2a\u8f93\u5165\u884c\u3002</p> <p>\u73b0\u5728\u6211\u4eec\u6709\u4e86\u6839\u636e\u8f93\u5165\u7ebf\u6570\u91cf\u7684\u95e8\u7684\u901a\u7528\u7c7b\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u5efa\u5177\u6709\u72ec\u7279\u884c\u4e3a\u7684\u7279\u5b9a\u95e8\u3002 \u4f8b\u5982\uff0c<code>AndGate</code>\u7c7b\u5c06\u662f<code>BinaryGate</code>\u7684\u5b50\u7c7b\uff0c\u56e0\u4e3a\u201c\u4e0e\u201d\u95e8\u6709\u4e24\u4e2a\u8f93\u5165\u7ebf\u3002 \u548c\u4ee5\u524d\u4e00\u6837\uff0c\u6784\u9020\u51fd\u6570\u7684\u7b2c\u4e00\u884c\u8c03\u7528\u7236\u7c7b\u6784\u9020\u51fd\u6570\uff08\u201cBinaryGate\u201d\uff09\uff0c\u800c\u7236\u7c7b\u6784\u9020\u51fd\u6570\u53c8\u8c03\u7528\u5176\u7236\u7c7b\u6784\u9020\u51fd\u6570\uff08<code>LogicGate</code>\uff09\u3002 \u8bf7\u6ce8\u610f\uff0c<code>AndGate</code>\u7c7b\u4e0d\u63d0\u4f9b\u4efb\u4f55\u65b0\u6570\u636e\uff0c\u56e0\u4e3a\u5b83\u7ee7\u627f\u4e86\u4e24\u4e2a\u8f93\u5165\u884c\u3001\u4e00\u4e2a\u8f93\u51fa\u884c\u548c\u4e00\u4e2a\u6807\u7b7e\u3002</p> <p>\u201cAndGate\u201d \u552f\u4e00\u9700\u8981\u6dfb\u52a0\u7684\u662f\u6267\u884c\u524d\u9762\u63cf\u8ff0\u7684\u5e03\u5c14\u8fd0\u7b97\u7684\u7279\u5b9a\u884c\u4e3a\u3002 \u8fd9\u662f\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u201cperform_gate_logic\u201d\u65b9\u6cd5\u7684\u5730\u65b9\u3002 \u5bf9\u4e8e AND \u95e8\uff0c\u6b64\u65b9\u6cd5\u9996\u5148\u5fc5\u987b\u83b7\u53d6\u4e24\u4e2a\u8f93\u5165\u503c\uff0c\u7136\u540e\u4ec5\u5728\u4e24\u4e2a\u8f93\u5165\u503c\u5747\u4e3a 1 \u65f6\u624d\u8fd4\u56de 1\u3002\u5b8c\u6574\u7684\u7c7b\u5982\u201c\u6e05\u5355 11\u201d\u6240\u793a\u3002</p> <p>Listing 11</p> <pre><code>class AndGate(BinaryGate):\n    def __init__(self, lbl):\n        super().__init__(lbl)\n\n    def perform_gate_logic(self):\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 and b == 1:\n            return 1\n        else:\n            return 0\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\u5e76\u8981\u6c42\u5b83\u8ba1\u7b97\u5176\u8f93\u51fa\u6765\u5c55\u793a\u6b63\u5728\u8fd0\u884c\u7684\u201cAndGate\u201d\u7c7b\u3002 \u4ee5\u4e0b\u4f1a\u8bdd\u663e\u793a\u4e86\u4e00\u4e2a\u201cAndGate\u201d\u5bf9\u8c61\u201cg1\u201d\uff0c\u5b83\u6709\u4e00\u4e2a\u5185\u90e8\u6807\u7b7e\u201c\u201cG1\u201d\u201d\u3002 \u5f53\u6211\u4eec\u8c03\u7528\u201cget_output\u201d\u65b9\u6cd5\u65f6\uff0c\u8be5\u5bf9\u8c61\u5fc5\u987b\u9996\u5148\u8c03\u7528\u5176\u201cperform_gate_logic\u201d\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u4f9d\u6b21\u67e5\u8be2\u4e24\u4e2a\u8f93\u5165\u884c\u3002 \u63d0\u4f9b\u503c\u540e\uff0c\u5c31\u4f1a\u663e\u793a\u6b63\u786e\u7684\u8f93\u51fa\u3002</p> <pre><code>&gt;&gt;&gt; g1 = AndGate(\"G1\")\n&gt;&gt;&gt; g1.get_output()\nEnter pin A input for gate G1: 1\nEnter pin B input for gate G1: 0\n0\n</code></pre> <p>\u53ef\u4ee5\u5bf9\u201c\u6216\u201d\u95e8\u548c\u201c\u975e\u201d\u95e8\u8fdb\u884c\u76f8\u540c\u7684\u5f00\u53d1\u3002 \u201cOrGate\u201d\u7c7b\u4e5f\u5c06\u662f\u201cBinaryGate\u201d\u7684\u5b50\u7c7b\uff0c\u201cNotGate\u201d\u7c7b\u5c06\u6269\u5c55\u201cUnaryGate\u201d\u7c7b\u3002 \u8fd9\u4e24\u4e2a\u7c7b\u90fd\u9700\u8981\u63d0\u4f9b\u81ea\u5df1\u7684\u201cperform_gate_logic\u201d\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662f\u5b83\u4eec\u7684\u7279\u5b9a\u884c\u4e3a\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u9996\u5148\u6784\u9020\u5176\u4e2d\u4e00\u4e2a\u95e8\u7c7b\u7684\u5b9e\u4f8b\uff0c\u7136\u540e\u5411\u95e8\u8be2\u95ee\u5176\u8f93\u51fa\uff08\u8fd9\u53c8\u9700\u8981\u63d0\u4f9b\u8f93\u5165\uff09\u6765\u4f7f\u7528\u5355\u4e2a\u95e8\u3002 \u4f8b\u5982\uff1a</p> <pre><code>&gt;&gt;&gt; g2 = OrGate(\"G2\")\n&gt;&gt;&gt; g2.get_output()\nEnter pin A input for gate G2: 1\nEnter pin B input for gate G2: 1\n1\n&gt;&gt;&gt; g2.get_output()\nEnter pin A input for gate G2: 0\nEnter pin B input for gate G2: 0\n0\n&gt;&gt;&gt; g3 = NotGate(\"G3\")\n&gt;&gt;&gt; g3.get_output()\nEnter pin input for gate G3: 0\n1\n</code></pre> <p>\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u57fa\u672c\u7684\u95e8\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6ce8\u610f\u529b\u8f6c\u5411\u6784\u5efa\u7535\u8def\u3002 \u4e3a\u4e86\u521b\u5efa\u4e00\u4e2a\u7535\u8def\uff0c\u6211\u4eec\u9700\u8981\u5c06\u95e8\u8fde\u63a5\u5728\u4e00\u8d77\uff0c\u4e00\u4e2a\u95e8\u7684\u8f93\u51fa\u6d41\u5165\u53e6\u4e00\u4e2a\u95e8\u7684\u8f93\u5165\u3002 \u4e3a\u6b64\uff0c\u6211\u4eec\u5c06\u5b9e\u73b0\u4e00\u4e2a\u540d\u4e3a\u201cConnector\u201d\u7684\u65b0\u7c7b\u3002</p> <p>\u201cConnector\u201d\u7c7b\u4e0d\u4f1a\u9a7b\u7559\u5728\u95e8\u5c42\u6b21\u7ed3\u6784\u4e2d\u3002 \u7136\u800c\uff0c\u5b83\u5c06\u4f7f\u7528\u95e8\u5c42\u6b21\u7ed3\u6784\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u8fde\u63a5\u5668\u90fd\u6709\u4e24\u4e2a\u95e8\uff0c\u4e24\u7aef\u5404\u4e00\u4e2a\uff08\u53c2\u89c1\u201c\u56fe 12\u201d\uff09\u3002 \u8fd9\u79cd\u5173\u7cfb\u5728\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\u4e2d\u975e\u5e38\u91cd\u8981\u3002 \u5b83\u88ab\u79f0\u4e3a\u6709\u5173\u7cfb\u3002 \u56de\u60f3\u4e00\u4e0b\u4e4b\u524d\u6211\u4eec\u4f7f\u7528\u77ed\u8bed Is-a \u5173\u7cfb \u6765\u8868\u793a\u5b50\u7c7b\u4e0e\u7236\u7c7b\u76f8\u5173\uff0c\u4f8b\u5982 <code>UnaryGate</code> Is-a <code>LogicGate</code>\u3002</p> <p> \u56fe 12\uff1a\u8fde\u63a5\u5668\u5c06\u4e00\u4e2a\u95e8\u7684\u8f93\u51fa\u8fde\u63a5\u5230\u53e6\u4e00\u4e2a\u95e8\u7684\u8f93\u5165 </p> <p>\u73b0\u5728\uff0c\u5bf9\u4e8e\u201cConnector\u201d\u7c7b\uff0c\u6211\u4eec\u8bf4\u201cConnector\u201d\u5177\u6709\u201cLogicGate\u201d\uff0c\u8fd9\u610f\u5473\u7740\u8fde\u63a5\u5668\u5c06\u5728\u5176\u4e2d\u5305\u542b\u201cLogicGate\u201d\u7c7b\u7684\u5b9e\u4f8b\uff0c\u4f46\u4e0d\u662f \u5c42\u6b21\u7ed3\u6784\u3002 \u5728\u8bbe\u8ba1\u7c7b\u65f6\uff0c\u533a\u5206\u5177\u6709 Is-a \u5173\u7cfb\uff08\u9700\u8981\u7ee7\u627f\uff09\u548c\u5177\u6709 Has-a \u5173\u7cfb\uff08\u4e0d\u9700\u8981\u7ee7\u627f\uff09\u7684\u7c7b\u975e\u5e38\u91cd\u8981\u3002</p> <p>\u201c\u6e05\u5355 12\u201d\u663e\u793a\u4e86\u201cConnector\u201d\u7c7b\u3002 \u6bcf\u4e2a\u8fde\u63a5\u5668\u5bf9\u8c61\u5185\u7684\u4e24\u4e2a\u95e8\u5b9e\u4f8b\u5c06\u88ab\u79f0\u4e3a\u201cfrom_gate\u201d\u548c\u201cto_gate\u201d\uff0c\u8ba4\u8bc6\u5230\u6570\u636e\u503c\u5c06\u4ece\u4e00\u4e2a\u95e8\u7684\u8f93\u51fa\u6d41\u5230\u4e0b\u4e00\u4e2a\u95e8\u7684\u8f93\u5165\u7ebf\u3002 \u5bf9\u201cset_next_pin\u201d\u7684\u8c03\u7528\u5bf9\u4e8e\u5efa\u7acb\u8fde\u63a5\u975e\u5e38\u91cd\u8981\uff08\u53c2\u89c1\u201c\u6e05\u5355 13\u201d\uff09\u3002 \u6211\u4eec\u9700\u8981\u5c06\u6b64\u65b9\u6cd5\u6dfb\u52a0\u5230\u6211\u4eec\u7684\u95e8\u7c7b\u4e2d\uff0c\u4ee5\u4fbf\u6bcf\u4e2a\u201cto_gate\u201d\u53ef\u4ee5\u4e3a\u8fde\u63a5\u9009\u62e9\u6b63\u786e\u7684\u8f93\u5165\u7ebf\u3002</p> <p>\u6e05\u5355 12</p> <pre><code>class Connector:\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n</code></pre> <p>\u6e05\u5355 13</p> <pre><code>def set_next_pin(self, source):\n    if self.pin_a == None:\n        self.pin_a = source\n    else:\n        if self.pin_b == None:\n            self.pin_b = source\n        else:\n            raise RuntimeError(\"Error: NO EMPTY PINS\")\n</code></pre> <p>\u5728\u201cBinaryGate\u201d\u7c7b\u4e2d\uff0c\u5bf9\u4e8e\u5177\u6709\u4e24\u6761\u53ef\u80fd\u7684\u8f93\u5165\u7ebf\u7684\u95e8\uff0c\u8fde\u63a5\u5668\u5fc5\u987b\u4ec5\u8fde\u63a5\u5230\u4e00\u6839\u7ebf\u3002 \u5982\u679c\u4e24\u8005\u90fd\u53ef\u7528\uff0c\u6211\u4eec\u5c06\u9ed8\u8ba4\u9009\u62e9\u201cpin_a\u201d\u3002 \u5982\u679c\u201cpin_a\u201d\u5df2\u7ecf\u8fde\u63a5\uff0c\u90a3\u4e48\u6211\u4eec\u5c06\u9009\u62e9\u201cpin_b\u201d\u3002 \u65e0\u6cd5\u8fde\u63a5\u5230\u6ca1\u6709\u53ef\u7528\u8f93\u5165\u7ebf\u7684\u95e8\u3002</p> <p>\u73b0\u5728\u53ef\u4ee5\u4ece\u4e24\u4e2a\u5730\u65b9\u83b7\u5f97\u8f93\u5165\uff1a\u50cf\u4ee5\u524d\u4e00\u6837\u4ece\u5916\u90e8\u83b7\u5f97\u8f93\u5165\uff0c\u4ee5\u53ca\u4ece\u8fde\u63a5\u5230\u8be5\u8f93\u5165\u7ebf\u7684\u95e8\u7684\u8f93\u51fa\u83b7\u5f97\u8f93\u5165\u3002 \u8fd9\u9700\u8981\u66f4\u6539\u201cget_pin_a\u201d\u548c\u201cget_pin_b\u201d\u65b9\u6cd5\uff08\u53c2\u89c1\u201c\u6e05\u5355 14\u201d\uff09\u3002 \u5982\u679c\u8f93\u5165\u7ebf\u6ca1\u6709\u8fde\u63a5\u5230\u4efb\u4f55\u4e1c\u897f\uff08<code>None</code>\uff09\uff0c\u5219\u50cf\u4ee5\u524d\u4e00\u6837\u4ece\u5916\u90e8\u8be2\u95ee\u7528\u6237\u3002 \u4f46\u662f\uff0c\u5982\u679c\u5b58\u5728\u8fde\u63a5\uff0c\u5219\u4f1a\u8bbf\u95ee\u8be5\u8fde\u63a5\u5e76\u68c0\u7d22\u201cfrom_gate\u201d\u7684\u8f93\u51fa\u503c\u3002 \u8fd9\u53cd\u8fc7\u6765\u53c8\u5bfc\u81f4\u8be5\u95e8\u5904\u7406\u5176\u903b\u8f91\u3002 \u8fd9\u5c06\u6301\u7eed\u4e0b\u53bb\uff0c\u76f4\u5230\u6240\u6709\u8f93\u5165\u90fd\u53ef\u7528\u5e76\u4e14\u6700\u7ec8\u8f93\u51fa\u503c\u6210\u4e3a\u76f8\u5173\u95e8\u6240\u9700\u7684\u8f93\u5165\u3002 \u4ece\u67d0\u79cd\u610f\u4e49\u4e0a\u8bf4\uff0c\u7535\u8def\u5411\u540e\u5de5\u4f5c\u4ee5\u627e\u5230\u6700\u7ec8\u4ea7\u751f\u8f93\u51fa\u6240\u9700\u7684\u8f93\u5165\u3002</p> <p>\u6e05\u5355 14</p> <pre><code>def get_pin_a(self):\n    if self.pin_a == None:\n        return input(\n            f\"Enter pin A input for gate \\\n            {self.get_label()}: \"\n        )\n    else:\n        return self.pin_a.get_from().get_output()\n</code></pre> <p>\u4ee5\u4e0b\u7247\u6bb5\u6784\u5efa\u4e86\u672c\u8282\u524d\u9762\u6240\u793a\u7684\u7535\u8def\uff1a</p> <pre><code>&gt;&gt;&gt; g1 = AndGate(\"G1\")\n&gt;&gt;&gt; g2 = AndGate(\"G2\")\n&gt;&gt;&gt; g3 = OrGate(\"G3\")\n&gt;&gt;&gt; g4 = NotGate(\"G4\")\n&gt;&gt;&gt; c1 = Connector(g1, g3)\n&gt;&gt;&gt; c2 = Connector(g2, g3)\n&gt;&gt;&gt; c3 = Connector(g3, g4)\n</code></pre> <p>\u4e24\u4e2a\u4e0e\u95e8\uff08\u201cg1\u201d\u548c\u201cg2\u201d\uff09\u7684\u8f93\u51fa\u8fde\u63a5\u5230\u201c\u6216\u201d\u95e8\uff08\u201cg3\u201d\uff09\uff0c\u8be5\u8f93\u51fa\u8fde\u63a5\u5230\u201c\u975e\u201d\u95e8\uff08\u201cg4\u201d\uff09\u3002 \u975e\u95e8\u7684\u8f93\u51fa\u5c31\u662f\u6574\u4e2a\u7535\u8def\u7684\u8f93\u51fa\u3002 \u4f8b\u5982\uff1a</p> <pre><code>&gt;&gt;&gt; g4.get_output()\nEnter pin A input for gate G1: 0\nEnter pin B input for gate G1: 1\nEnter pin A input for gate G2: 1\nEnter pin B input for gate G2: 1\n0\n</code></pre> <p>\u4f7f\u7528 ActiveCode 4 \u4eb2\u81ea\u5c1d\u8bd5\u4e00\u4e0b\u3002</p> \u5b8c\u6574\u7684\u7535\u8def\u7a0b\u5e8f\u3002<pre><code>class LogicGate:\n\n    def __init__(self, lbl):\n        self.name = lbl\n        self.output = None\n\n    def get_label(self):\n        return self.name\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n\n\nclass BinaryGate(LogicGate):\n\n    def __init__(self, lbl):\n        super(BinaryGate, self).__init__(lbl)\n\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        if self.pin_a == None:\n            return int(input(\"Enter pin A input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin_a.get_from().get_output()\n\n    def get_pin_b(self):\n        if self.pin_b == None:\n            return int(input(\"Enter pin B input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin_b.get_from().get_output()\n\n    def set_next_pin(self, source):\n        if self.pin_a == None:\n            self.pin_a = source\n        else:\n            if self.pin_b == None:\n                self.pin_b = source\n            else:\n                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass AndGate(BinaryGate):\n\n    def __init__(self, lbl):\n        BinaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 and b == 1:\n            return 1\n        else:\n            return 0\n\nclass OrGate(BinaryGate):\n\n    def __init__(self, lbl):\n        BinaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 or b == 1:\n            return 1\n        else:\n            return 0\n\nclass UnaryGate(LogicGate):\n\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n\n        self.pin = None\n\n    def get_pin(self):\n        if self.pin == None:\n            return int(input(\"Enter pin input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin.get_from().get_output()\n\n    def set_next_pin(self, source):\n        if self.pin == None:\n            self.pin = source\n        else:\n            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass NotGate(UnaryGate):\n\n    def __init__(self, lbl):\n        UnaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n        if self.get_pin():\n            return 0\n        else:\n            return 1\n\n\nclass Connector:\n\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n\n\ndef main():\n    g1 = AndGate(\"G1\")\n    g2 = AndGate(\"G2\")\n    g3 = OrGate(\"G3\")\n    g4 = NotGate(\"G4\")\n    c1 = Connector(g1, g3)\n    c2 = Connector(g2, g3)\n    c3 = Connector(g3, g4)\n    print(g4.get_output())\n\nmain()\n</code></pre> <p>\u81ea\u68c0</p> <p>\u521b\u5efa\u4e24\u4e2a\u65b0\u7684\u95e8\u7c7b\uff0c\u4e00\u4e2a\u79f0\u4e3a NorGate\uff0c\u53e6\u4e00\u4e2a\u79f0\u4e3a NandGate\u3002 NandGates \u7684\u5de5\u4f5c\u65b9\u5f0f\u4e0e AndGates \u7c7b\u4f3c\uff0c\u4f46\u8f93\u51fa\u672a\u9644\u52a0\u3002 NorGates \u5de5\u4f5c\u4e8e OrGates \u6e56\uff0c\u5176\u8f93\u51fa\u672a\u9644\u52a0\u3002</p> <p>\u521b\u5efa\u4e00\u7cfb\u5217\u95e8\u6765\u8bc1\u660e\u4ee5\u4e0b\u7b49\u5f0f <code>NOT (( A and B) or (C and D))</code> \u4e0e <code>NOT( A and B )</code> \u548c <code>NOT (C and D)</code> \u76f8\u540c\u3002 \u786e\u4fdd\u5728\u6a21\u62df\u4e2d\u4f7f\u7528\u4e00\u4e9b\u65b0\u7684\u95e8\u3002</p> self_check_5<pre><code>class LogicGate:\n\n    def __init__(self,n):\n        self.name = n\n        self.output = None\n\n    def get_label(self):\n        return self.name\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n\n\nclass BinaryGate(LogicGate):\n\n    def __init__(self,n):\n        LogicGate.__init__(self,n)\n\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        if self.pin_a == None:\n            return int(input(\"Enter Pin A input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin_a.get_from().get_output()\n\n    def get_pin_b(self):\n        if self.pin_b == None:\n            return int(input(\"Enter Pin B input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin_b.get_from().get_output()\n\n    def set_next_pin(self,source):\n        if self.pin_a == None:\n            self.pin_a = source\n        else:\n            if self.pin_b == None:\n                self.pin_b = source\n            else:\n                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass AndGate(BinaryGate):\n\n    def __init__(self,n):\n        BinaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a==1 and b==1:\n            return 1\n        else:\n            return 0\n\nclass OrGate(BinaryGate):\n\n    def __init__(self,n):\n        BinaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a ==1 or b==1:\n            return 1\n        else:\n            return 0\n\nclass UnaryGate(LogicGate):\n\n    def __init__(self,n):\n        LogicGate.__init__(self,n)\n\n        self.pin = None\n\n    def get_pin(self):\n        if self.pin == None:\n            return int(input(\"Enter Pin input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin.get_from().get_output()\n\n    def set_next_pin(self,source):\n        if self.pin == None:\n            self.pin = source\n        else:\n            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass NotGate(UnaryGate):\n\n    def __init__(self,n):\n        UnaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n        if self.get_pin():\n            return 0\n        else:\n            return 1\n\n\nclass Connector:\n\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n\ndef main():\n    g1 = AndGate(\"G1\")\n\n    print(g1.get_output())\n\nmain()\n</code></pre> <p></p> <p>\u81ea\u68c0\u6311\u6218</p> <p>\u8ba1\u7b97\u673a\u7684\u57fa\u672c\u6784\u5efa\u6a21\u5757\u4e4b\u4e00\u662f\u89e6\u53d1\u5668\u3002 \u5b83\u4e0d\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u6388\u7a7f\u5728\u811a\u4e0a\u7684\u4e1c\u897f\uff0c\u800c\u662f\u4e00\u79cd\u7a33\u5b9a\u7684\u7535\u8def\uff0c\u53ef\u4ee5\u5b58\u50a8\u6700\u540e\u7684\u6570\u636e\u3002 \u4e00\u4e2a\u7b80\u5355\u7684\u89e6\u53d1\u5668\u53ef\u4ee5\u7531\u8fde\u63a5\u5728\u4e00\u8d77\u7684\u4e24\u4e2a\u6216\u975e\u95e8\u7ec4\u6210\uff0c\u5982\u4e0b\u56fe\u6240\u793a\u3002</p> <p></p> <p>\u8fd9\u662f\u4e00\u4e2a\u5177\u6709\u6311\u6218\u6027\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6574\u4f53\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u5982\u679c Reset \u548c Set \u7684\u521d\u59cb\u8f93\u5165\u5747\u4e3a 0\uff0c\u5219\u89e6\u53d1\u5668\u7684\u8f93\u51fa\u4e3a 0\u3002\u4f46\u662f\uff0c\u5982\u679c Set \u8f93\u5165\u5207\u6362\u4e3a 1\uff0c\u5219\u8f93\u51fa\u53d8\u4e3a 1\u3002\u6700\u68d2\u7684\u662f\uff0c\u5f53 set \u8f93\u5165\u53d8\u4e3a 0 \u65f6 \u8f93\u51fa\u4fdd\u6301\u4e3a 1\uff0c\u76f4\u5230\u590d\u4f4d\u8f93\u5165\u5207\u6362\u4e3a 1\uff0c\u4ece\u800c\u5c06\u7535\u8def\u7684\u8f93\u51fa\u590d\u4f4d\u4e3a\u96f6\u3002</p> <p>Our final section will introduce another important aspect of object-oriented programming. Inheritance is the ability of one class to be related to another class in much the same way that people can be related to one another. Children inherit characteristics from their parents. Similarly, Python child classes can inherit characteristic data and behavior from a parent class. These classes are often referred to as subclasses and superclasses.</p> <p><code>Figure 8</code> shows the built-in Python collections and their relationships to one another. We call a relationship structure such as this an inheritance hierarchy. For example, the list is a child of the sequential collection. In this case, we call the list the child and the sequence the parent (or subclass list and superclass sequence). This is often referred to as an Is-a relationship (the list Is-a sequential collection). This implies that lists inherit important characteristics from sequences, namely the ordering of the underlying data and operations such as concatenation, repetition, and indexing.</p> <p> Figure 8: An Inheritance Hierarchy for Python Collections </p> <p>Lists, tuples, and strings are all examples of sequential collections. They all inherit common data organization and operations. However, each of them is distinct based on whether the data is homogeneous and whether the collection is immutable. The children all gain from their parents but distinguish themselves by adding additional characteristics.</p> <p>By organizing classes in this hierarchical fashion, object-oriented programming languages allow previously written code to be extended to meet the needs of a new situation. In addition, by organizing data in this hierarchical manner, we can better understand the relationships that exist. We can be more efficient in building our abstract representations.</p> <p>To explore this idea further, we will construct a simulation, an application to simulate digital circuits. The basic building block for this simulation will be the logic gate. These electronic switches represent Boolean algebra relationships between their input and their output. In general, gates have a single output line. The value of the output is dependent on the values given on the input lines.</p> <p>AND gates have two input lines, each of which can be either 0 or 1 (representing <code>False</code> or <code>True</code>, respectively). If both of the input lines have the value 1, the resulting output is 1. However, if either or both of the input lines is 0, the result is 0. OR gates also have two input lines and produce a 1 if one or both of the input values is a 1. In the case where both input lines are 0, the result is 0.</p> <p>NOT gates differ from the other two gates in that they have only a single input line. The output value is simply the opposite of the input value. If 0 appears on the input, 1 is produced on the output. Similarly, 1 produces 0. <code>Figure 9</code> shows how each of these gates is typically represented. Each gate also has a truth table of values showing the input-to-output mapping that is performed by the gate.</p> <p> Figure 9: Three Types of Logic Gates </p> <p>By combining these gates in various patterns and then applying a set of  input values, we can build circuits that have logical functions. <code>Figure 10</code> shows a circuit consisting of two AND gates, one OR gate, and a single NOT gate. The output lines from the two AND gates feed directly into the OR gate, and the resulting output from the OR gate is given to the NOT gate. If we apply a set of input values to the four input lines (two for each AND gate), the values are processed and a result appears at the output of the NOT gate. <code>Figure 10</code> also shows an example with values.</p> <p> Figure 10: A Circuit </p> <p>In order to implement a circuit, we will first build a representation for logic gates. Logic gates are easily organized into a class inheritance hierarchy as shown in <code>Figure 11</code>. At the top of the hierarchy, the <code>LogicGate</code> class represents the most general characteristics of logic gates: namely, a label for the gate and an output line. The next level of subclasses breaks the logic gates into two families, those that have one input line and those that have two. Below that, the specific logic functions of each appear.</p> <p> Figure 11: An Inheritance Hierarchy for Logic Gates </p> <p>We can now start to implement the classes by starting with the most general, <code>LogicGate</code>. As noted earlier, each gate has a label for identification and a single output line. In addition, we need methods to allow a user of a gate to ask the gate for its label.</p> <p>The other behavior that every logic gate needs is the ability to know its output value. This will require that the gate perform the appropriate logic based on the current input. In order to produce output, the gate needs to know specifically what that logic is. This means calling a method to perform the logic computation. The complete class is shown in <code>Listing 8</code>.</p> <p>Listing 8</p> <pre><code>class LogicGate:\n    def __init__(self, lbl):\n        self.label = lbl\n        self.output = None\n\n    def get_label(self):\n        return self.label\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n</code></pre> <p>At this point, we will not implement the <code>perform_gate_logic</code> function. The reason for this is that we do not know how each gate will perform its own logic operation. Those details will be included by each individual gate that is added to the hierarchy. This is a very powerful idea in object-oriented programming. We are writing a method that will use code that does not exist yet. The parameter <code>self</code> is a reference to the actual gate object invoking the method. Any new logic gate that gets added to the hierarchy will simply need to implement the <code>perform_gate_logic</code> function and it will be used at the appropriate time. Once done, the gate can provide its output value. This ability to extend a hierarchy that currently exists and provide the specific functions that the hierarchy needs to use the new class is extremely important for reusing existing code.</p> <p>We categorized the logic gates based on the number of input lines, as shown in <code>Figure 11</code>: the AND gate and OR gate both have two input lines, whereas the NOT gate has only one. <code>LogicGate</code> has two subclasses: <code>BinaryGate</code>, which will add two input lines, and <code>UnaryGate</code>, which will have only a single input line.</p> <p>In computer circuit design, these lines are sometimes called pins, so we will use that terminology in our implementation.</p> <p><code>Listing 9</code> and <code>Listing 10</code> implement these two classes. The constructors in both of these classes start with an explicit call to the constructor of the parent class using the parent's <code>__init__</code> method. When creating an instance of the <code>BinaryGate</code> class, we first want to initialize any data items that are inherited from <code>LogicGate</code>. In this case, that means the label for the gate. The constructor then goes on to add the two input lines (<code>pin_a</code> and <code>pin_b</code>). This is a very common pattern that you should always use when building class hierarchies. Child class constructors need to call parent class constructors and then move on to their own distinguishing data.</p> <p>Listing 9</p> <pre><code>class BinaryGate(LogicGate):\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        return int(input(f\"Enter pin A input for gate \\\n            {self.get_label()}: \"))\n\n    def get_pin_b(self):\n        return int(input(f\"Enter pin B input for gate \\\n            {self.get_label()}: \"))\n</code></pre> <p>Listing 10</p> <pre><code>class UnaryGate(LogicGate):\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n        self.pin = None\n\n    def get_pin(self):\n        return int(input(f\"Enter pin input for gate \\\n            {self.get_label()}: \"))\n</code></pre> <p>Python also has a function called <code>super</code> which can be used in place of explicitly naming the parent class.  This is a more general mechanism and is widely used, especially when a class has more than one parent. In our example above, <code>LogicGate.__init__(self, lbl)</code> could be replaced with <code>super().__init__(lbl)</code>, <code>super(UnaryGate, self).__init__(lbl)</code>, or <code>super().__init__(\"UnaryGate\", lbl)</code>. The specific details are beyond the scope of this text.</p> <p>The only behavior that the <code>BinaryGate</code> class adds is the ability to get the values from the two input lines. Since these values come from some external place, we will simply ask the user to provide them via an input statement. The same implementation occurs for the <code>UnaryGate</code> class except that there is only one input line.</p> <p>Now that we have a general class for gates depending on the number of input lines, we can build specific gates that have unique behavior. For example, the <code>AndGate</code> class will be a subclass of <code>BinaryGate</code> since AND gates have two input lines. As before, the first line of the constructor calls upon the parent class constructor (<code>BinaryGate</code>), which in turn calls its parent class constructor (<code>LogicGate</code>). Note that the <code>AndGate</code> class does not provide any new data since it inherits two input lines, one output line, and a label.</p> <p>The only thing <code>AndGate</code> needs to add is the specific behavior that performs the Boolean operation that was described earlier. This is the place where we can provide the <code>perform_gate_logic</code> method. For an AND gate, this method first must get the two input values and then only return 1 if both input values are 1. The complete class is shown in <code>Listing 11</code>.</p> <p>Listing 11</p> <pre><code>class AndGate(BinaryGate):\n    def __init__(self, lbl):\n        super().__init__(lbl)\n\n    def perform_gate_logic(self):\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 and b == 1:\n            return 1\n        else:\n            return 0\n</code></pre> <p>We can show the <code>AndGate</code> class in action by creating an instance and asking it to compute its output. The following session shows an <code>AndGate</code> object, <code>g1</code>, that has an internal label <code>\"G1\"</code>. When we invoke the <code>get_output</code> method, the object must first call its <code>perform_gate_logic</code> method which in turn queries the two input lines. Once the values are provided, the correct output is shown.</p> <pre><code>&gt;&gt;&gt; g1 = AndGate(\"G1\")\n&gt;&gt;&gt; g1.get_output()\nEnter pin A input for gate G1: 1\nEnter pin B input for gate G1: 0\n0\n</code></pre> <p>The same development can be done for OR gates and NOT gates. The <code>OrGate</code> class will also be a subclass of <code>BinaryGate</code> and the <code>NotGate</code> class will extend the <code>UnaryGate</code> class. Both of these classes will need to provide their own <code>perform_gate_logic</code> functions, as this is their specific behavior.</p> <p>We can use a single gate by first constructing an instance of one of the gate classes and then asking the gate for its output (which will in turn need inputs to be provided). For example:</p> <pre><code>&gt;&gt;&gt; g2 = OrGate(\"G2\")\n&gt;&gt;&gt; g2.get_output()\nEnter pin A input for gate G2: 1\nEnter pin B input for gate G2: 1\n1\n&gt;&gt;&gt; g2.get_output()\nEnter pin A input for gate G2: 0\nEnter pin B input for gate G2: 0\n0\n&gt;&gt;&gt; g3 = NotGate(\"G3\")\n&gt;&gt;&gt; g3.get_output()\nEnter pin input for gate G3: 0\n1\n</code></pre> <p>Now that we have the basic gates working, we can turn our attention to building circuits. In order to create a circuit, we need to connect gates together, the output of one flowing into the input of another. To do this, we will implement a new class called <code>Connector</code>.</p> <p>The <code>Connector</code> class will not reside in the gate hierarchy. It will, however, use the gate hierarchy in that each connector will have two gates, one on either end (see <code>Figure 12</code>). This relationship is very important in object-oriented programming. It is called the Has-a relationship. Recall earlier that we used the phrase Is-a relationship to say that a child class is related to a parent class, for example <code>UnaryGate</code> Is-a <code>LogicGate</code>.</p> <p> Figure 12: A Connector Connects the Output of One Gate to the Input of Another </p> <p>Now, with the <code>Connector</code> class, we say that a <code>Connector</code> Has-a <code>LogicGate</code>, meaning that connectors will have instances of the <code>LogicGate</code> class within them but are not part of the hierarchy. When designing classes, it is very important to distinguish between those that have the Is-a relationship (which requires inheritance) and those that have Has-a relationships (with no inheritance).</p> <p><code>Listing 12</code> shows the <code>Connector</code> class. The two gate instances within each connector object will be referred to as the <code>from_gate</code> and the <code>to_gate</code>, recognizing that data values will flow from the output of one gate into an input line of the next. The call to <code>set_next_pin</code> is very important for making connections (see <code>Listing 13</code>). We need to add this method to our gate classes so that each <code>to_gate</code> can choose the proper input line for the connection.</p> <p>Listing 12</p> <pre><code>class Connector:\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n</code></pre> <p>Listing 13</p> <pre><code>def set_next_pin(self, source):\n    if self.pin_a == None:\n        self.pin_a = source\n    else:\n        if self.pin_b == None:\n            self.pin_b = source\n        else:\n            raise RuntimeError(\"Error: NO EMPTY PINS\")\n</code></pre> <p>In the <code>BinaryGate</code> class, for gates with two possible input lines, the connector must be connected to only one line. If both of them are available, we will choose <code>pin_a</code> by default. If <code>pin_a</code> is already connected, then we will choose <code>pin_b</code>. It is not possible to connect to a gate with no available input lines.</p> <p>Now it is possible to get input from two places: externally, as before, and from the output of a gate that is connected to that input line. This requires a change to the <code>get_pin_a</code> and <code>get_pin_b</code> methods (see <code>Listing 14</code>). If the input line is not connected to anything (<code>None</code>), then ask the user externally as before. However, if there is a connection, the connection is accessed and <code>from_gate</code>\u2019s output value is retrieved. This in turn causes that gate to process its logic. This continues until all input is available and the final output value becomes the required input for the gate in question. In a sense, the circuit works backwards to find the input necessary to finally produce output.</p> <p>Listing 14</p> <pre><code>def get_pin_a(self):\n    if self.pin_a == None:\n        return input(\n            f\"Enter pin A input for gate \\\n            {self.get_label()}: \"\n        )\n    else:\n        return self.pin_a.get_from().get_output()\n</code></pre> <p>The following fragment constructs the circuit shown earlier in the section:</p> <pre><code>&gt;&gt;&gt; g1 = AndGate(\"G1\")\n&gt;&gt;&gt; g2 = AndGate(\"G2\")\n&gt;&gt;&gt; g3 = OrGate(\"G3\")\n&gt;&gt;&gt; g4 = NotGate(\"G4\")\n&gt;&gt;&gt; c1 = Connector(g1, g3)\n&gt;&gt;&gt; c2 = Connector(g2, g3)\n&gt;&gt;&gt; c3 = Connector(g3, g4)\n</code></pre> <p>The outputs from the two AND gates (<code>g1</code> and <code>g2</code>) are connected to the OR gate (<code>g3</code>) and that output is connected to the NOT gate (<code>g4</code>). The output from the NOT gate is the output of the entire circuit. For example:</p> <pre><code>&gt;&gt;&gt; g4.get_output()\nEnter pin A input for gate G1: 0\nEnter pin B input for gate G1: 1\nEnter pin A input for gate G2: 1\nEnter pin B input for gate G2: 1\n0\n</code></pre> <p>Try it yourself using ActiveCode 4.</p> The Complete Circuit Program.<pre><code>class LogicGate:\n\n    def __init__(self, lbl):\n        self.name = lbl\n        self.output = None\n\n    def get_label(self):\n        return self.name\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n\n\nclass BinaryGate(LogicGate):\n\n    def __init__(self, lbl):\n        super(BinaryGate, self).__init__(lbl)\n\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        if self.pin_a == None:\n            return int(input(\"Enter pin A input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin_a.get_from().get_output()\n\n    def get_pin_b(self):\n        if self.pin_b == None:\n            return int(input(\"Enter pin B input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin_b.get_from().get_output()\n\n    def set_next_pin(self, source):\n        if self.pin_a == None:\n            self.pin_a = source\n        else:\n            if self.pin_b == None:\n                self.pin_b = source\n            else:\n                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass AndGate(BinaryGate):\n\n    def __init__(self, lbl):\n        BinaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 and b == 1:\n            return 1\n        else:\n            return 0\n\nclass OrGate(BinaryGate):\n\n    def __init__(self, lbl):\n        BinaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a == 1 or b == 1:\n            return 1\n        else:\n            return 0\n\nclass UnaryGate(LogicGate):\n\n    def __init__(self, lbl):\n        LogicGate.__init__(self, lbl)\n\n        self.pin = None\n\n    def get_pin(self):\n        if self.pin == None:\n            return int(input(\"Enter pin input for gate \" + self.get_label() + \": \"))\n        else:\n            return self.pin.get_from().get_output()\n\n    def set_next_pin(self, source):\n        if self.pin == None:\n            self.pin = source\n        else:\n            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass NotGate(UnaryGate):\n\n    def __init__(self, lbl):\n        UnaryGate.__init__(self, lbl)\n\n    def perform_gate_logic(self):\n        if self.get_pin():\n            return 0\n        else:\n            return 1\n\n\nclass Connector:\n\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n\n\ndef main():\n    g1 = AndGate(\"G1\")\n    g2 = AndGate(\"G2\")\n    g3 = OrGate(\"G3\")\n    g4 = NotGate(\"G4\")\n    c1 = Connector(g1, g3)\n    c2 = Connector(g2, g3)\n    c3 = Connector(g3, g4)\n    print(g4.get_output())\n\nmain()\n</code></pre> <p>Self Check</p> <p>Create a two new gate classes,  one called NorGate the other called NandGate.  NandGates work like AndGates that have a Not attached to the output.  NorGates work lake OrGates that have a Not attached to the output.</p> <p>Create a series of gates that prove the following equality NOT (( A and B) or (C and D)) is that same as NOT( A and B ) and NOT (C and D).  Make sure to use some of your new gates in the simulation.</p> self_check_5<pre><code>class LogicGate:\n\n    def __init__(self,n):\n        self.name = n\n        self.output = None\n\n    def get_label(self):\n        return self.name\n\n    def get_output(self):\n        self.output = self.perform_gate_logic()\n        return self.output\n\n\nclass BinaryGate(LogicGate):\n\n    def __init__(self,n):\n        LogicGate.__init__(self,n)\n\n        self.pin_a = None\n        self.pin_b = None\n\n    def get_pin_a(self):\n        if self.pin_a == None:\n            return int(input(\"Enter Pin A input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin_a.get_from().get_output()\n\n    def get_pin_b(self):\n        if self.pin_b == None:\n            return int(input(\"Enter Pin B input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin_b.get_from().get_output()\n\n    def set_next_pin(self,source):\n        if self.pin_a == None:\n            self.pin_a = source\n        else:\n            if self.pin_b == None:\n                self.pin_b = source\n            else:\n                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass AndGate(BinaryGate):\n\n    def __init__(self,n):\n        BinaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a==1 and b==1:\n            return 1\n        else:\n            return 0\n\nclass OrGate(BinaryGate):\n\n    def __init__(self,n):\n        BinaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n\n        a = self.get_pin_a()\n        b = self.get_pin_b()\n        if a ==1 or b==1:\n            return 1\n        else:\n            return 0\n\nclass UnaryGate(LogicGate):\n\n    def __init__(self,n):\n        LogicGate.__init__(self,n)\n\n        self.pin = None\n\n    def get_pin(self):\n        if self.pin == None:\n            return int(input(\"Enter Pin input for gate \"+self.get_label()+\"--&gt;\"))\n        else:\n            return self.pin.get_from().get_output()\n\n    def set_next_pin(self,source):\n        if self.pin == None:\n            self.pin = source\n        else:\n            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n\n\nclass NotGate(UnaryGate):\n\n    def __init__(self,n):\n        UnaryGate.__init__(self,n)\n\n    def perform_gate_logic(self):\n        if self.get_pin():\n            return 0\n        else:\n            return 1\n\n\nclass Connector:\n\n    def __init__(self, fgate, tgate):\n        self.from_gate = fgate\n        self.to_gate = tgate\n\n        tgate.set_next_pin(self)\n\n    def get_from(self):\n        return self.from_gate\n\n    def get_to(self):\n        return self.to_gate\n\n\n\ndef main():\n    g1 = AndGate(\"G1\")\n\n    print(g1.get_output())\n\nmain()\n</code></pre> <p></p> <p>Self  Check Challenge</p> <p>One of the fundamental building blocks of a computer is something called a flip flop.  It's not something that computer science professors wear on their feet, but rather a kind of circuit that is stable and stores the last piece of data that was put on it.  A simple flip-flop can be made from two NOR gates that are tied together as in the following diagram.</p> <p></p> <p>This is a challenge problem because the entire Note if the initial inputs to Reset and Set are both 0 then the output of the flip-flop is 0.  But if the Set input is toggled to 1 then the output becomes 1.  The great thing is that when the set input goes to 0 the output stays 1, until the reset input is toggled to 1 which resets the output of the circuit back to zero.</p>"},{"location":"c1/s14/","title":"1.14. \u603b\u7ed3","text":"<p>1.14. Summary</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u89e3\u51b3\u95ee\u9898\u7684\u7814\u7a76\u3002</li> <li>\u8ba1\u7b97\u673a\u79d1\u5b66\u4f7f\u7528\u62bd\u8c61\u4f5c\u4e3a\u8868\u793a\u8fc7\u7a0b\u548c\u6570\u636e\u7684\u5de5\u5177\u3002</li> <li>\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u5141\u8bb8\u7a0b\u5e8f\u5458\u901a\u8fc7\u9690\u85cf\u6570\u636e\u7684\u7ec6\u8282\u6765\u7ba1\u7406\u95ee\u9898\u57df\u7684\u590d\u6742\u6027\u3002</li> <li>Python \u662f\u4e00\u79cd\u529f\u80fd\u5f3a\u5927\u4e14\u6613\u4e8e\u4f7f\u7528\u7684\u9762\u5411\u5bf9\u8c61\u8bed\u8a00\u3002</li> <li>\u5217\u8868\u3001\u5143\u7ec4\u548c\u5b57\u7b26\u4e32\u662f\u5728 Python \u987a\u5e8f\u96c6\u5408\u4e2d\u6784\u5efa\u7684\u3002</li> <li>\u5b57\u5178\u548c\u96c6\u5408\u662f\u975e\u987a\u5e8f\u7684\u6570\u636e\u96c6\u5408\u3002</li> <li>\u7c7b\u5141\u8bb8\u7a0b\u5e8f\u5458\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u3002</li> <li>\u7a0b\u5e8f\u5458\u53ef\u4ee5\u91cd\u5199\u6807\u51c6\u65b9\u6cd5\u4ee5\u53ca\u521b\u5efa\u65b0\u65b9\u6cd5\u3002</li> <li>\u7c7b\u53ef\u4ee5\u7ec4\u7ec7\u6210\u5c42\u6b21\u7ed3\u6784\u3002</li> <li>\u7c7b\u6784\u9020\u51fd\u6570\u5e94\u59cb\u7ec8\u8c03\u7528\u5176\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u518d\u7ee7\u7eed\u5904\u7406\u81ea\u5df1\u7684\u6570\u636e\u548c\u884c\u4e3a\u3002</li> </ul> <ul> <li>Computer science is the study of problem solving.</li> <li>Computer science uses abstraction as a tool for representing both processes and data.</li> <li>Abstract data types allow programmers to manage the complexity of a problem domain by hiding the details of the data.</li> <li>Python is a powerful, yet easy-to-use, object-oriented language.</li> <li>Lists, tuples, and strings are built in Python sequential collections.</li> <li>Dictionaries and sets are nonsequential collections of data.</li> <li>Classes allow programmers to implement abstract data types.</li> <li>Programmers can override standard methods as well as create new methods.</li> <li>Classes can be organized into hierarchies.</li> <li>A class constructor should always invoke the constructor of its parent before continuing on with its own data and behavior. </li> </ul>"},{"location":"c1/s15/","title":"1.15. \u5173\u952e\u672f\u8bed","text":"<p>1.15. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - abstract data type (ADT) formatted strings override abstraction Has-a relationship procedural abstraction algorithm implementation-independent programming class information hiding prompt computable inheritance <code>self</code> data abstraction inheritance hierarchy set data structure interface shallow equality data type Is-a relationship simulation deep equality list string dictionary list comprehension subclass encapsulation method superclass exception mutability truth table f-string object tuple format operator - - - abstract data type (ADT) formatted strings override abstraction Has-a relationship procedural abstraction algorithm implementation-independent programming class information hiding prompt computable inheritance <code>self</code> data abstraction inheritance hierarchy set data structure interface shallow equality data type Is-a relationship simulation deep equality list string dictionary list comprehension subclass encapsulation method superclass exception mutability truth table f-string object tuple format operator"},{"location":"c1/s16/","title":"1.16. \u7ec3\u4e60","text":"<p>1.16. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li>\u4e3a\u5927\u5b66\u6821\u56ed\u91cc\u7684\u4eba\u4eec\u6784\u5efa\u4e00\u4e2a\u9636\u7ea7\u5c42\u6b21\u7ed3\u6784\u3002 \u5305\u62ec\u6559\u5e08\u3001\u804c\u5458\u548c\u5b66\u751f\u3002 \u4ed6\u4eec\u6709\u4ec0\u4e48\u5171\u540c\u70b9\uff1f \u5b83\u4eec\u6709\u4f55\u4e0d\u540c\uff1f</li> <li>\u6784\u5efa\u94f6\u884c\u5e10\u6237\u7684\u7c7b\u5c42\u6b21\u7ed3\u6784\u3002</li> <li>\u4e3a\u4e0d\u540c\u7c7b\u578b\u7684\u8ba1\u7b97\u673a\u6784\u5efa\u7c7b\u5c42\u6b21\u7ed3\u6784\u3002</li> <li>\u4f7f\u7528\u672c\u7ae0\u4e2d\u63d0\u4f9b\u7684\u7c7b\uff0c\u4ea4\u4e92\u5f0f\u5730\u6784\u5efa\u7535\u8def\u5e76\u5bf9\u5176\u8fdb\u884c\u6d4b\u8bd5\u3002</li> <li>\u5b9e\u73b0\u7b80\u5355\u7684\u65b9\u6cd5\u201cget_num\u201d\u548c\u201cget_den\u201d\uff0c\u5b83\u4eec\u5c06\u8fd4\u56de\u5206\u6570\u7684\u5206\u5b50\u548c\u5206\u6bcd\u3002</li> <li>\u4ece\u5f88\u591a\u65b9\u9762\u6765\u8bf4\uff0c\u5982\u679c\u6240\u6709\u5206\u6570\u4ece\u4e00\u5f00\u59cb\u5c31\u4fdd\u6301\u6700\u4f4e\u7684\u6c34\u5e73\u4f1a\u66f4\u597d\u3002 \u4fee\u6539\u201cFraction\u201d\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u4ee5\u4fbf\u4f7f\u7528\u201cGCD\u201d\u7acb\u5373\u51cf\u5c11\u5206\u6570\u3002 \u8bf7\u6ce8\u610f\uff0c\u8fd9\u610f\u5473\u7740 <code>__add__</code> \u51fd\u6570\u4e0d\u518d\u9700\u8981\u5f52\u7ea6\u3002 \u8fdb\u884c\u5fc5\u8981\u7684\u4fee\u6539\u3002</li> <li>\u5b9e\u73b0\u5269\u4f59\u7684\u7b80\u5355\u7b97\u672f\u8fd0\u7b97\u7b26\uff08<code>__sub__</code>\u3001<code>__mul__</code> \u548c<code>__truediv__</code>\uff09\u3002</li> <li>\u5b9e\u73b0\u5269\u4f59\u7684\u5173\u7cfb\u8fd0\u7b97\u7b26\uff08<code>__gt__</code>\u3001<code>__ge__</code>\u3001<code>__lt__</code>\u3001<code>__le__</code> \u548c <code>__ne__</code>\uff09\u3002</li> <li>\u4fee\u6539\u5206\u6570\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u4ee5\u4fbf\u5b83\u68c0\u67e5\u4ee5\u786e\u4fdd\u5206\u5b50\u548c\u5206\u6bcd\u90fd\u662f\u6574\u6570\u3002 \u5982\u679c\u5176\u4e2d\u4e00\u4e2a\u4e0d\u662f\u6574\u6570\uff0c\u6784\u9020\u51fd\u6570\u5e94\u8be5\u5f15\u53d1\u5f02\u5e38\u3002</li> <li>\u5728\u5206\u6570\u7684\u5b9a\u4e49\u4e2d\uff0c\u6211\u4eec\u5047\u8bbe\u8d1f\u5206\u6570\u5177\u6709\u8d1f\u5206\u5b50\u548c\u6b63\u5206\u6bcd\u3002 \u4f7f\u7528\u8d1f\u5206\u6bcd\u4f1a\u5bfc\u81f4\u67d0\u4e9b\u5173\u7cfb\u8fd0\u7b97\u7b26\u7ed9\u51fa\u4e0d\u6b63\u786e\u7684\u7ed3\u679c\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u8fd9\u662f\u4e00\u4e2a\u4e0d\u5fc5\u8981\u7684\u9650\u5236\u3002 \u4fee\u6539\u6784\u9020\u51fd\u6570\u4ee5\u5141\u8bb8\u7528\u6237\u4f20\u9012\u8d1f\u5206\u6bcd\uff0c\u4ee5\u4fbf\u6240\u6709\u8fd0\u7b97\u7b26\u7ee7\u7eed\u6b63\u5e38\u5de5\u4f5c\u3002</li> <li>\u7814\u7a76<code>__radd__</code>\u65b9\u6cd5\u3002 \u5b83\u4e0e <code>__add__</code> \u6709\u4f55\u4e0d\u540c\uff1f \u4ec0\u4e48\u65f6\u5019\u4f7f\u7528\uff1f \u5b9e\u73b0<code>__radd__</code>\u3002</li> <li>\u91cd\u590d\u4e0a\u4e00\u4e2a\u95ee\u9898\uff0c\u4f46\u8fd9\u6b21\u8003\u8651<code>__iadd__</code>\u65b9\u6cd5\u3002</li> <li>\u7814\u7a76<code>__repr__</code>\u65b9\u6cd5\u3002 \u5b83\u4e0e <code>__str__</code> \u6709\u4f55\u4e0d\u540c\uff1f \u4ec0\u4e48\u65f6\u5019\u4f7f\u7528\uff1f \u5b9e\u73b0<code>__repr__</code>\u3002</li> <li>\u7814\u7a76\u73b0\u6709\u7684\u5176\u4ed6\u7c7b\u578b\u7684\u95e8\uff08\u4f8b\u5982 NAND\u3001NOR \u548c XOR\uff09\u3002 \u5c06\u5b83\u4eec\u6dfb\u52a0\u5230\u7535\u8def\u5c42\u6b21\u7ed3\u6784\u4e2d\u3002 \u60a8\u9700\u8981\u505a\u591a\u5c11\u989d\u5916\u7684\u7f16\u7801\uff1f</li> <li>\u6700\u7b80\u5355\u7684\u7b97\u672f\u7535\u8def\u79f0\u4e3a\u534a\u52a0\u5668\u3002 \u7814\u7a76\u7b80\u5355\u7684\u534a\u52a0\u5668\u7535\u8def\u3002 \u5b9e\u73b0\u8be5\u7535\u8def\u3002</li> <li>\u73b0\u5728\u6269\u5c55\u8be5\u7535\u8def\u5e76\u5b9e\u73b0\u4e00\u4e2a 8 \u4f4d\u5168\u52a0\u5668\u3002</li> <li>\u672c\u7ae0\u6240\u793a\u7684\u7535\u8def\u4eff\u771f\u662f\u53cd\u5411\u5de5\u4f5c\u7684\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u7535\u8def\uff0c\u8f93\u51fa\u662f\u901a\u8fc7\u8f93\u5165\u503c\u8fdb\u884c\u53cd\u5411\u5904\u7406\u800c\u4ea7\u751f\u7684\uff0c\u8fd9\u53cd\u8fc7\u6765\u53c8\u5bfc\u81f4\u5176\u4ed6\u8f93\u51fa\u88ab\u67e5\u8be2\u3002 \u8fd9\u4e00\u76f4\u6301\u7eed\u5230\u627e\u5230\u5916\u90e8\u8f93\u5165\u7ebf\u4e3a\u6b62\uff0c\u6b64\u65f6\u7cfb\u7edf\u4f1a\u8981\u6c42\u7528\u6237\u8f93\u5165\u503c\u3002 \u4fee\u6539\u5b9e\u73b0\uff0c\u4f7f\u52a8\u4f5c\u671d\u7740\u6b63\u5411\u65b9\u5411\u8fdb\u884c\uff1b \u63a5\u6536\u8f93\u5165\u540e\uff0c\u7535\u8def\u4ea7\u751f\u8f93\u51fa\u3002</li> <li>\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u6765\u4ee3\u8868\u4e00\u5f20\u6251\u514b\u724c\uff0c\u53e6\u4e00\u4e2a\u7c7b\u6765\u4ee3\u8868\u4e00\u526f\u7eb8\u724c\u3002 \u4f7f\u7528\u8fd9\u4e24\u4e2a\u7c7b\uff0c\u5b9e\u73b0\u60a8\u6700\u559c\u6b22\u7684\u7eb8\u724c\u6e38\u620f\u3002</li> <li>\u5728\u7ebf\u6216\u5728\u5f53\u5730\u62a5\u7eb8\u4e0a\u67e5\u627e\u6570\u72ec\u8c1c\u9898\u3002 \u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u89e3\u51b3\u8fd9\u4e2a\u96be\u9898\u3002</li> </ol> <ol> <li>Construct a class hierarchy for people on a college campus. Include faculty, staff, and students. What do they have in common? What distinguishes them from one another?</li> <li>Construct a class hierarchy for bank accounts.</li> <li>Construct a class hierarchy for different types of computers.</li> <li>Using the classes provided in the chapter, interactively construct a circuit and test it.</li> <li>Implement the simple methods <code>get_num</code> and <code>get_den</code> that will return the numerator and denominator of a fraction.</li> <li>In many ways it would be better if all fractions were maintained in lowest terms right from the start. Modify the constructor for the <code>Fraction</code> class so that <code>GCD</code> is used to reduce fractions immediately. Notice that this means the <code>__add__</code> function no longer needs to reduce. Make the necessary modifications.</li> <li>Implement the remaining simple arithmetic operators (<code>__sub__</code>, <code>__mul__</code>, and <code>__truediv__</code>).</li> <li>Implement the remaining relational operators (<code>__gt__</code>, <code>__ge__</code>, <code>__lt__</code>, <code>__le__</code>, and <code>__ne__</code>).</li> <li>Modify the constructor for the fraction class so that it checks to make sure that the numerator and denominator are both integers. If either is not an integer, the constructor should raise an exception.</li> <li>In the definition of fractions we assumed that negative fractions have a negative numerator and a positive denominator. Using a negative denominator would cause some of the relational operators to give incorrect results. In general, this is an unnecessary constraint. Modify the constructor to allow the user to pass a negative denominator so that all of the operators continue to work properly.</li> <li>Research the <code>__radd__</code> method. How does it differ from <code>__add__</code>? When is it used? Implement <code>__radd__</code>.</li> <li>Repeat the last question but this time consider the <code>__iadd__</code> method.</li> <li>Research the <code>__repr__</code> method. How does it differ from <code>__str__</code>? When is it used? Implement <code>__repr__</code>.</li> <li>Research other types of gates that exist (such as NAND, NOR, and XOR). Add them to the circuit hierarchy. How much additional coding did you need to do?</li> <li>The most simple arithmetic circuit is known as the half adder. Research the simple half-adder circuit. Implement this circuit.</li> <li>Now extend that circuit and implement an 8-bit full adder.</li> <li>The circuit simulation shown in this chapter works in a backward direction. In other words, given a circuit, the output is produced by working back through the input values, which in turn cause other outputs to be queried. This continues until external input lines are found, at which point the user is asked for values. Modify the implementation so that the action is in the forward direction; upon receiving inputs the circuit produces an output.</li> <li>Design a class to represent a playing card and another one to represent a deck of cards. Using these two classes, implement your favorite card game.</li> <li>Find a Sudoku puzzle online or in the local newspaper. Write a program to solve the puzzle.</li> </ol>"},{"location":"c1/s2/","title":"1.2. \u5165\u95e8","text":"<p>1.2. Getting Started</p> \u4e2d\u6587\u82f1\u6587 <p>\u81ea\u4ece\u7b2c\u4e00\u53f0\u7535\u5b50\u8ba1\u7b97\u673a\u9700\u8981\u8df3\u7ebf\u548c\u5f00\u5173\u6765\u5c06\u6307\u4ee4\u4ece\u4eba\u4f20\u9012\u5230\u673a\u5668\u4ee5\u6765\uff0c\u591a\u5e74\u6765\u6211\u4eec\u5bf9\u7f16\u7a0b\u7684\u601d\u8003\u65b9\u5f0f\u5df2\u7ecf\u53d1\u751f\u4e86\u8bb8\u591a\u53d8\u5316\u3002 \u4e0e\u793e\u4f1a\u8bb8\u591a\u65b9\u9762\u7684\u60c5\u51b5\u4e00\u6837\uff0c\u8ba1\u7b97\u6280\u672f\u7684\u53d8\u5316\u4e3a\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u63d0\u4f9b\u4e86\u8d8a\u6765\u8d8a\u591a\u7684\u5de5\u5177\u548c\u5e73\u53f0\u6765\u5b9e\u8df5\u4ed6\u4eec\u7684\u6280\u80fd\u3002 \u66f4\u5feb\u7684\u5904\u7406\u5668\u3001\u9ad8\u901f\u7f51\u7edc\u548c\u5927\u5bb9\u91cf\u5185\u5b58\u7b49\u8fdb\u6b65\u5df2\u7ecf\u9020\u6210\u4e86\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u5fc5\u987b\u5e94\u5bf9\u7684\u590d\u6742\u6027\u87ba\u65cb\u5f0f\u4e0a\u5347\u3002 \u5728\u6240\u6709\u8fd9\u4e9b\u5feb\u901f\u53d1\u5c55\u8fc7\u7a0b\u4e2d\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4e00\u4e2a\u57fa\u672c\u539f\u7406\u59cb\u7ec8\u4fdd\u6301\u4e0d\u53d8\uff1a\u5b83\u5173\u6ce8\u7684\u662f\u4f7f\u7528\u8ba1\u7b97\u673a\u6765\u89e3\u51b3\u95ee\u9898\u3002</p> <p>\u6beb\u65e0\u7591\u95ee\uff0c\u60a8\u82b1\u8d39\u4e86\u5927\u91cf\u65f6\u95f4\u5b66\u4e60\u89e3\u51b3\u95ee\u9898\u7684\u57fa\u7840\u77e5\u8bc6\uff0c\u5e76\u5e0c\u671b\u5bf9\u81ea\u5df1\u63d0\u51fa\u95ee\u9898\u5e76\u5236\u5b9a\u89e3\u51b3\u65b9\u6848\u7684\u80fd\u529b\u5145\u6ee1\u4fe1\u5fc3\u3002 \u60a8\u8fd8\u4e86\u89e3\u5230\uff0c\u7f16\u5199\u8ba1\u7b97\u673a\u7a0b\u5e8f\u901a\u5e38\u5f88\u56f0\u96be\u3002 \u5927\u95ee\u9898\u7684\u590d\u6742\u6027\u4ee5\u53ca\u76f8\u5e94\u7684\u89e3\u51b3\u65b9\u6848\u7684\u590d\u6742\u6027\u5f80\u5f80\u4f1a\u63a9\u76d6\u4e0e\u95ee\u9898\u89e3\u51b3\u8fc7\u7a0b\u76f8\u5173\u7684\u57fa\u672c\u601d\u60f3\u3002</p> <p>\u672c\u7ae0\u5f3a\u8c03\u4e86\u6587\u672c\u5176\u4f59\u90e8\u5206\u7684\u4e24\u4e2a\u91cd\u8981\u9886\u57df\u3002 \u9996\u5148\uff0c\u6211\u4eec\u5c06\u56de\u987e\u8ba1\u7b97\u673a\u79d1\u5b66\u4ee5\u53ca\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784\u7814\u7a76\u5fc5\u987b\u9002\u5e94\u7684\u6846\u67b6\u3002 \u7279\u522b\u662f\uff0c\u6211\u4eec\u5c06\u63a2\u8ba8\u6211\u4eec\u9700\u8981\u7814\u7a76\u8fd9\u4e9b\u4e3b\u9898\u7684\u539f\u56e0\u4ee5\u53ca\u7406\u89e3\u8fd9\u4e9b\u4e3b\u9898\u5982\u4f55\u5e2e\u52a9\u6211\u4eec\u6210\u4e3a\u66f4\u597d\u7684\u95ee\u9898\u89e3\u51b3\u8005\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u5c06\u56de\u987e\u4e00\u4e0b Python \u7f16\u7a0b\u8bed\u8a00\u3002 \u5c3d\u7ba1\u6211\u4eec\u65e0\u6cd5\u63d0\u4f9b\u8be6\u7ec6\u3001\u8be6\u5c3d\u7684\u53c2\u8003\uff0c\u4f46\u6211\u4eec\u5c06\u4e3a\u5176\u4f59\u7ae0\u8282\u4e2d\u51fa\u73b0\u7684\u57fa\u672c\u7ed3\u6784\u548c\u60f3\u6cd5\u63d0\u4f9b\u793a\u4f8b\u548c\u89e3\u91ca\u3002</p> <p>The way we think about programming has undergone many changes in the years since the first electronic computers required patch cables and switches to convey instructions from human to machine. As is the case with many aspects of society, changes in computing technology provide computer scientists with a growing number of tools and platforms on which to practice their craft. Advances such as faster processors, high-speed networks, and large memory capacities have created a spiral of complexity through which computer scientists must navigate. Throughout all of this rapid evolution, a basic principle of computer science has remained constant: it is concerned with using computers to solve problems.</p> <p>You have no doubt spent considerable time learning the basics of problem-solving and hopefully feel confident in your ability to take a problem statement and develop a solution. You have also learned that writing computer programs is often hard. The complexity of large problems and the corresponding complexity of the solutions can tend to overshadow the fundamental ideas related to the problem-solving process.</p> <p>This chapter emphasizes two important areas for the rest of the text. First, we\u2019ll review the framework within which computer science and the study of algorithms and data structures must fit. In particular, we\u2019ll look at the reasons why we need to study these topics and how understanding these topics helps us to become better problem solvers. Second, we\u2019ll review the Python programming language. Although we cannot provide a detailed, exhaustive reference, we will give examples and explanations for the basic constructs and ideas that will occur throughout the remaining chapters.</p>"},{"location":"c1/s3/","title":"1.3. \u4ec0\u4e48\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\uff1f","text":"<p>1.3. What Is Computer Science?</p> \u4e2d\u6587\u82f1\u6587 <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u5f88\u96be\u5b9a\u4e49\u3002 \u8fd9\u53ef\u80fd\u662f\u7531\u4e8e\u540d\u79f0\u4e2d\u4e0d\u5e78\u4f7f\u7528\u4e86\u201c\u8ba1\u7b97\u673a\u201d\u4e00\u8bcd\u3002 \u6b63\u5982\u60a8\u53ef\u80fd\u77e5\u9053\u7684\u90a3\u6837\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0d\u4ec5\u4ec5\u662f\u5bf9\u8ba1\u7b97\u673a\u7684\u7814\u7a76\u3002 \u5c3d\u7ba1\u8ba1\u7b97\u673a\u4f5c\u4e3a\u5de5\u5177\u5728\u8be5\u5b66\u79d1\u4e2d\u53d1\u6325\u7740\u91cd\u8981\u7684\u652f\u6301\u4f5c\u7528\uff0c\u4f46\u5b83\u4eec\u53ea\u662f -- \u5de5\u5177\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u5bf9\u95ee\u9898\u3001\u95ee\u9898\u89e3\u51b3\u4ee5\u53ca\u95ee\u9898\u89e3\u51b3\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u7684\u89e3\u51b3\u65b9\u6848\u7684\u7814\u7a76\u3002 \u7ed9\u5b9a\u4e00\u4e2a\u95ee\u9898\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u7684\u76ee\u6807\u662f\u5f00\u53d1\u4e00\u79cd\u7b97\u6cd5\uff0c\u8fd9\u662f\u89e3\u51b3\u53ef\u80fd\u51fa\u73b0\u7684\u4efb\u4f55\u95ee\u9898\u5b9e\u4f8b\u7684\u9010\u6b65\u8bf4\u660e\u5217\u8868\u3002 \u7b97\u6cd5\u662f\u6709\u9650\u7684\u8fc7\u7a0b\uff0c\u5982\u679c\u9075\u5faa\u5b83\u5c31\u80fd\u89e3\u51b3\u95ee\u9898\u3002 \u7b97\u6cd5\u5c31\u662f\u89e3\u51b3\u65b9\u6848\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u53ef\u4ee5\u88ab\u8ba4\u4e3a\u662f\u7b97\u6cd5\u7684\u7814\u7a76\u3002 \u7136\u800c\uff0c\u6211\u4eec\u5fc5\u987b\u5c0f\u5fc3\u5730\u627f\u8ba4\uff0c\u6709\u4e9b\u95ee\u9898\u53ef\u80fd\u6ca1\u6709\u89e3\u51b3\u65b9\u6848\u3002 \u867d\u7136\u8bc1\u660e\u8fd9\u4e00\u8bf4\u6cd5\u8d85\u51fa\u4e86\u672c\u6587\u7684\u8303\u56f4\uff0c\u4f46\u6709\u4e9b\u95ee\u9898\u65e0\u6cd5\u89e3\u51b3\u8fd9\u4e00\u4e8b\u5b9e\u5bf9\u4e8e\u7814\u7a76\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u4eba\u6765\u8bf4\u5f88\u91cd\u8981\u3002 \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5305\u62ec\u8fd9\u4e24\u79cd\u7c7b\u578b\u7684\u95ee\u9898\u6765\u5b8c\u6574\u5730\u5b9a\u4e49\u8ba1\u7b97\u673a\u79d1\u5b66\uff0c\u5e76\u6307\u51fa\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u5bf9\u95ee\u9898\u89e3\u51b3\u65b9\u6848\u7684\u7814\u7a76\u4ee5\u53ca\u5bf9\u65e0\u89e3\u51b3\u65b9\u6848\u7684\u95ee\u9898\u7684\u7814\u7a76\u3002</p> <p>\u5728\u63cf\u8ff0\u95ee\u9898\u548c\u89e3\u51b3\u65b9\u6848\u65f6\uff0c\u5305\u542b \u53ef\u8ba1\u7b97 \u4e00\u8bcd\u4e5f\u5f88\u5e38\u89c1\u3002 \u5982\u679c\u5b58\u5728\u89e3\u51b3\u95ee\u9898\u7684\u7b97\u6cd5\uff0c\u6211\u4eec\u5c31\u8bf4\u95ee\u9898\u662f\u53ef\u8ba1\u7b97\u7684\u3002 \u90a3\u4e48\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u53e6\u4e00\u79cd\u5b9a\u4e49\u662f\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u5bf9\u53ef\u8ba1\u7b97\u548c\u4e0d\u53ef\u8ba1\u7b97\u95ee\u9898\u7684\u7814\u7a76\uff0c\u662f\u5bf9\u7b97\u6cd5\u5b58\u5728\u548c\u4e0d\u5b58\u5728\u7684\u7814\u7a76\u3002 \u65e0\u8bba\u5982\u4f55\uff0c\u60a8\u4f1a\u6ce8\u610f\u5230 \u8ba1\u7b97\u673a \u8fd9\u4e2a\u8bcd\u6839\u672c\u6ca1\u6709\u51fa\u73b0\u3002 \u89e3\u51b3\u65b9\u6848\u88ab\u8ba4\u4e3a\u72ec\u7acb\u4e8e\u673a\u5668\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\uff0c\u56e0\u4e3a\u5b83\u6d89\u53ca\u95ee\u9898\u89e3\u51b3\u8fc7\u7a0b\u672c\u8eab\uff0c\u6240\u4ee5\u4e5f\u662f\u62bd\u8c61\u7684\u7814\u7a76\u3002 \u62bd\u8c61\u4f7f\u6211\u4eec\u80fd\u591f\u4ee5\u5206\u79bb\u6240\u8c13\u7684\u903b\u8f91\u548c\u7269\u7406\u89c6\u89d2\u7684\u65b9\u5f0f\u6765\u770b\u5f85\u95ee\u9898\u548c\u89e3\u51b3\u65b9\u6848\u3002 \u6211\u4eec\u5728\u4e00\u4e2a\u5e38\u89c1\u7684\u4f8b\u5b50\u4e2d\u719f\u6089\u5176\u57fa\u672c\u601d\u60f3\u3002</p> <p>\u8003\u8651\u4e00\u4e0b\u60a8\u4eca\u5929\u53ef\u80fd\u5f00\u7740\u7684\u8f66\u53bb\u5b66\u6821\u6216\u4e0a\u73ed\u3002 \u4f5c\u4e3a\u9a7e\u9a76\u5458\u3001\u8f66\u8f86\u7684\u7528\u6237\uff0c\u60a8\u9700\u8981\u8fdb\u884c\u67d0\u4e9b\u4ea4\u4e92\u624d\u80fd\u5c06\u6c7d\u8f66\u7528\u4e8e\u5176\u9884\u671f\u7528\u9014\u3002 \u60a8\u4e0a\u8f66\uff0c\u63d2\u5165\u94a5\u5319\uff0c\u542f\u52a8\u53d1\u52a8\u673a\uff0c\u6362\u6863\uff0c\u5236\u52a8\uff0c\u52a0\u901f\u548c\u8f6c\u5411\u4ee5\u8fdb\u884c\u9a7e\u9a76\u3002 \u4ece\u62bd\u8c61\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u6211\u4eec\u53ef\u4ee5\u8bf4\u4f60\u770b\u5230\u7684\u662f\u6c7d\u8f66\u7684\u903b\u8f91\u89c6\u89d2\u3002 \u60a8\u6b63\u5728\u4f7f\u7528\u8f66\u8f86\u8bbe\u8ba1\u8005\u63d0\u4f9b\u7684\u529f\u80fd\u6765\u5c06\u60a8\u4ece\u4e00\u4e2a\u5730\u70b9\u8fd0\u9001\u5230\u53e6\u4e00\u4e2a\u5730\u70b9\u3002 \u8fd9\u4e9b\u51fd\u6570\u6709\u65f6\u4e5f\u79f0\u4e3a\u63a5\u53e3\u3002</p> <p>\u53e6\u4e00\u65b9\u9762\uff0c\u5fc5\u987b\u4fee\u7406\u4f60\u7684\u6c7d\u8f66\u7684\u673a\u68b0\u5e08\u5219\u6301\u622a\u7136\u4e0d\u540c\u7684\u89c2\u70b9\u3002 \u4ed6\u4eec\u4e0d\u4ec5\u77e5\u9053\u5982\u4f55\u9a7e\u9a76\uff0c\u8fd8\u5fc5\u987b\u4e86\u89e3\u6267\u884c\u6211\u4eec\u8ba4\u4e3a\u7406\u6240\u5f53\u7136\u7684\u6240\u6709\u529f\u80fd\u6240\u9700\u7684\u6240\u6709\u7ec6\u8282\u3002 \u4ed6\u4eec\u9700\u8981\u4e86\u89e3\u53d1\u52a8\u673a\u5982\u4f55\u5de5\u4f5c\u3001\u53d8\u901f\u5668\u5982\u4f55\u6362\u6863\u3001\u5982\u4f55\u63a7\u5236\u6e29\u5ea6\u7b49\u7b49\u3002 \u8fd9\u88ab\u79f0\u4e3a\u7269\u7406\u89c6\u89d2\uff0c\u5373 \u201c\u5e55\u540e\u201d \u53d1\u751f\u7684\u7ec6\u8282\u3002</p> <p>\u5f53\u6211\u4eec\u4f7f\u7528\u7535\u8111\u65f6\u4e5f\u4f1a\u53d1\u751f\u540c\u6837\u7684\u4e8b\u60c5\u3002 \u5927\u591a\u6570\u4eba\u4f7f\u7528\u8ba1\u7b97\u673a\u7f16\u5199\u6587\u6863\u3001\u53d1\u9001\u548c\u63a5\u6536\u7535\u5b50\u90ae\u4ef6\u3001\u4e0a\u7f51\u3001\u64ad\u653e\u97f3\u4e50\u3001\u5b58\u50a8\u56fe\u50cf\u548c\u73a9\u6e38\u620f\uff0c\u4f46\u4e0d\u4e86\u89e3\u8fd9\u4e9b\u7c7b\u578b\u7684\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u4ed6\u4eec\u4ece\u903b\u8f91\u6216\u7528\u6237\u7684\u89d2\u5ea6\u770b\u5f85\u8ba1\u7b97\u673a\u3002 \u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u3001\u7a0b\u5e8f\u5458\u3001\u6280\u672f\u652f\u6301\u4eba\u5458\u548c\u7cfb\u7edf\u7ba1\u7406\u5458\u5bf9\u8ba1\u7b97\u673a\u7684\u770b\u6cd5\u622a\u7136\u4e0d\u540c\u3002 \u4ed6\u4eec\u5fc5\u987b\u4e86\u89e3\u64cd\u4f5c\u7cfb\u7edf\u5982\u4f55\u5de5\u4f5c\u3001\u7f51\u7edc\u534f\u8bae\u5982\u4f55\u914d\u7f6e\u4ee5\u53ca\u5982\u4f55\u7f16\u5199\u63a7\u5236\u8ba1\u7b97\u673a\u529f\u80fd\u7684\u5404\u79cd\u811a\u672c\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u4ed6\u4eec\u5fc5\u987b\u80fd\u591f\u63a7\u5236\u7528\u6237\u7b80\u5355\u5047\u8bbe\u7684\u4f4e\u7ea7\u7ec6\u8282\u3002</p> <p>\u8fd9\u4e24\u4e2a\u793a\u4f8b\u7684\u5171\u540c\u70b9\u662f\uff0c\u62bd\u8c61\u7684\u7528\u6237\uff08\u6709\u65f6\u4e5f\u79f0\u4e3a\u5ba2\u6237\u7aef\uff09\u4e0d\u9700\u8981\u4e86\u89e3\u7ec6\u8282\uff0c\u53ea\u8981\u7528\u6237\u77e5\u9053\u754c\u9762\u7684\u5de5\u4f5c\u65b9\u5f0f\u5373\u53ef\u3002 \u8fd9\u4e2a\u63a5\u53e3\u662f\u6211\u4eec\u4f5c\u4e3a\u7528\u6237\u4e0e\u5b9e\u73b0\u7684\u5e95\u5c42\u590d\u6742\u6027\u8fdb\u884c\u901a\u4fe1\u7684\u65b9\u5f0f\u3002</p> <p>\u4f5c\u4e3a\u62bd\u8c61\u7684\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8003\u8651\u4e00\u4e0b Python \u7684 <code>math</code> \u6a21\u5757\u3002 \u4e00\u65e6\u6211\u4eec\u5bfc\u5165\u6a21\u5757\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u6267\u884c\u8ba1\u7b97\uff0c\u4f8b\u5982</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(16)\n4.0\n</code></pre> <p>\u8fd9\u662f \u7a0b\u5e8f\u62bd\u8c61 \u7684\u4e00\u4e2a\u4f8b\u5b50\u3002 \u6211\u4eec\u4e0d\u4e00\u5b9a\u77e5\u9053\u5e73\u65b9\u6839\u662f\u5982\u4f55\u8ba1\u7b97\u7684\uff0c\u4f46\u6211\u4eec\u77e5\u9053\u8be5\u51fd\u6570\u7684\u540d\u79f0\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528\u5b83\u3002 \u5982\u679c\u6211\u4eec\u6b63\u786e\u6267\u884c\u5bfc\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe\u8be5\u51fd\u6570\u5c06\u4e3a\u6211\u4eec\u63d0\u4f9b\u6b63\u786e\u7684\u7ed3\u679c\u3002 \u6211\u4eec\u77e5\u9053\u6709\u4eba\u5b9e\u73b0\u4e86\u5e73\u65b9\u6839\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u4f46\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u5982\u4f55\u4f7f\u7528\u5b83\u3002 \u8fd9\u6709\u65f6\u88ab\u79f0\u4e3a\u6d41\u7a0b\u7684 \u9ed1\u5323\u5b50 \u89c6\u56fe\u3002 \u6211\u4eec\u7b80\u5355\u5730\u63cf\u8ff0\u63a5\u53e3\uff1a\u51fd\u6570\u7684\u540d\u79f0\u3001\u9700\u8981\u4ec0\u4e48\uff08\u53c2\u6570\uff09\u4ee5\u53ca\u5c06\u8fd4\u56de\u4ec0\u4e48\u3002 \u7ec6\u8282\u9690\u85cf\u5728\u91cc\u9762\uff08\u53c2\u89c1\u201c\u56fe1\u201d\uff09\u3002</p> <p> \u56fe 1: \u7a0b\u5e8f\u62bd\u8c61 </p> <p>Computer science is difficult to define. This is probably due to the unfortunate use of the word computer in the name. As you are perhaps aware, computer science is not simply the study of computers. Although computers play an important supporting role as a tool in the discipline, they are just that\u2013\u2013tools.</p> <p>Computer science is the study of problems, problem-solving, and the solutions that come out of the problem-solving process. Given a problem, a computer scientist\u2019s goal is to develop an algorithm, a step-by-step list of instructions for solving any instance of the problem that might arise. Algorithms are finite processes that if followed will solve the problem. Algorithms are solutions.</p> <p>Computer science can be thought of as the study of algorithms. However, we must be careful to include the fact that some problems may not have a solution. Although proving this statement is beyond the scope of this text, the fact that some problems cannot be solved is important for those who study computer science. We can fully define computer science, then, by including both types of problems and stating that computer science is the study of solutions to problems as well as the study of problems with no solutions.</p> <p>It is also very common to include the word computable when describing problems and solutions. We say that a problem is computable if an algorithm exists for solving it. An alternative definition for computer science, then, is to say that computer science is the study of problems that are and that are not computable, the study of the existence and the nonexistence of algorithms. In any case, you will note that the word computer did not come up at all. Solutions are considered independent from the machine.</p> <p>Computer science, as it pertains to the problem-solving process itself, is also the study of abstraction. Abstraction allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives. The basic idea is familiar to us in a common example.</p> <p>Consider the car that you may have driven to school or work today. As a driver, a user of the vehicle, you have certain interactions that take place in order to use the car for its intended purpose. You get in, insert the key, start the engine, shift, brake, accelerate, and steer in order to drive. From an abstraction point of view, we can say that you are seeing the logical perspective of the car. You are using the functions provided by the vehicle designers for the purpose of transporting you from one location to another. These functions are sometimes also referred to as the interface.</p> <p>On the other hand, the mechanic who must repair your car takes a very different point of view. They not only know how to drive but must know all of the details necessary to carry out all the functions that we take for granted. They need to understand how the engine works, how the transmission shifts gears, how temperature is controlled, and so on. This is known as the physical perspective, the details that take place \u201cunder the hood.\u201d</p> <p>The same thing happens when we use computers. Most people use computers to write documents, send and receive email, surf the web, play music, store images, and play games without any knowledge of the details that take place to allow those types of applications to work. They view computers from a logical or user perspective. Computer scientists, programmers, technology support staff, and system administrators take a very different view of the computer. They must know the details of how operating systems work, how network protocols are configured, and how to code various scripts that control computer functionality. They must be able to control the low-level details that a user simply assumes.</p> <p>The common point for both of these examples is that the user of the abstraction, sometimes also called the client, does not need to know the details as long as the user is aware of the way the interface works. This interface is the way we as users communicate with the underlying complexities of the implementation.</p> <p>As another example of abstraction, consider the Python <code>math</code> module. Once we import the module, we can perform computations such as</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(16)\n4.0\n</code></pre> <p>This is an example of procedural abstraction. We do not necessarily know how the square root is being calculated, but we know what the function is called and how to use it. If we perform the import correctly, we can assume that the function will provide us with the correct results. We know that someone implemented a solution to the square root problem, but we only need to know how to use it. This is sometimes referred to as a black box view of a process. We simply describe the interface: the name of the function, what is needed (the parameters), and what will be returned. The details are hidden inside (see Figure 1).</p> <p> Figure 1: Procedural Abstraction </p>"},{"location":"c1/s4/","title":"1.4. \u4ec0\u4e48\u662f\u7f16\u7a0b\uff1f","text":"<p>1.4. What Is Programming?</p> \u4e2d\u6587\u82f1\u6587 <p>\u7f16\u7a0b(Programming)\u662f\u91c7\u7528\u7b97\u6cd5\u5e76\u5c06\u5176\u7f16\u7801\u4e3a\u7b26\u53f7\uff08\u4e00\u79cd\u7f16\u7a0b\u8bed\u8a00\uff09\u4ee5\u4fbf\u8ba1\u7b97\u673a\u53ef\u4ee5\u6267\u884c\u7684\u8fc7\u7a0b\u3002 \u5c3d\u7ba1\u5b58\u5728\u8bb8\u591a\u7f16\u7a0b\u8bed\u8a00\u548c\u8bb8\u591a\u4e0d\u540c\u7c7b\u578b\u7684\u8ba1\u7b97\u673a\uff0c\u4f46\u91cd\u8981\u7684\u7b2c\u4e00\u6b65\u662f\u9700\u8981\u6709\u89e3\u51b3\u65b9\u6848\u3002 \u6ca1\u6709\u7b97\u6cd5\u5c31\u4e0d\u53ef\u80fd\u6709\u7a0b\u5e8f\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0d\u662f\u7f16\u7a0b\u7684\u7814\u7a76\u3002 \u7136\u800c\uff0c\u7f16\u7a0b\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u5de5\u4f5c\u7684\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u3002 \u7f16\u7a0b\u901a\u5e38\u662f\u6211\u4eec\u4e3a\u89e3\u51b3\u65b9\u6848\u521b\u5efa\u8868\u793a\u7684\u65b9\u5f0f\u3002 \u56e0\u6b64\uff0c\u8fd9\u79cd\u8bed\u8a00\u8868\u793a\u53ca\u5176\u521b\u5efa\u8fc7\u7a0b\u6210\u4e3a\u8be5\u5b66\u79d1\u7684\u57fa\u672c\u7ec4\u6210\u90e8\u5206\u3002</p> <p>\u7b97\u6cd5\u6839\u636e\u8868\u793a\u95ee\u9898\u5b9e\u4f8b\u6240\u9700\u7684\u6570\u636e\u4ee5\u53ca\u4ea7\u751f\u9884\u671f\u7ed3\u679c\u6240\u9700\u7684\u6b65\u9aa4\u96c6\u6765\u63cf\u8ff0\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u3002 \u7f16\u7a0b\u8bed\u8a00\u5fc5\u987b\u63d0\u4f9b\u4e00\u79cd\u8868\u793a\u8fc7\u7a0b\u548c\u6570\u636e\u7684\u7b26\u53f7\u65b9\u5f0f\u3002 \u4e3a\u6b64\uff0c\u8bed\u8a00\u63d0\u4f9b\u4e86\u63a7\u5236\u7ed3\u6784(control constructs)\u548c\u6570\u636e\u7c7b\u578b(data types)\u3002</p> <p>\u63a7\u5236\u7ed3\u6784\u5141\u8bb8\u4ee5\u65b9\u4fbf\u800c\u660e\u786e\u7684\u65b9\u5f0f\u8868\u793a\u7b97\u6cd5\u6b65\u9aa4\u3002 \u81f3\u5c11\uff0c\u7b97\u6cd5\u9700\u8981\u6267\u884c\u987a\u5e8f\u5904\u7406\u3001\u51b3\u7b56\u9009\u62e9\u548c\u91cd\u590d\u63a7\u5236\u8fed\u4ee3\u7684\u7ed3\u6784\u3002 \u53ea\u8981\u8bed\u8a00\u63d0\u4f9b\u4e86\u8fd9\u4e9b\u57fa\u672c\u8bed\u53e5\uff0c\u5c31\u53ef\u4ee5\u7528\u4e8e\u7b97\u6cd5\u8868\u793a\u3002</p> <p>\u8ba1\u7b97\u673a\u4e2d\u7684\u6240\u6709\u6570\u636e\u9879\u90fd\u8868\u793a\u4e3a\u4e8c\u8fdb\u5236\u6570\u5b57\u4e32\u3002 \u4e3a\u4e86\u8d4b\u4e88\u8fd9\u4e9b\u5b57\u7b26\u4e32\u542b\u4e49\uff0c\u6211\u4eec\u9700\u8981\u6570\u636e\u7c7b\u578b(data types)\u3002 \u6570\u636e\u7c7b\u578b\u63d0\u4f9b\u4e86\u5bf9\u8fd9\u79cd\u4e8c\u8fdb\u5236\u6570\u636e\u7684\u89e3\u91ca\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u7528\u5bf9\u8981\u89e3\u51b3\u7684\u95ee\u9898\u6709\u610f\u4e49\u7684\u672f\u8bed\u6765\u601d\u8003\u6570\u636e\u3002 \u8fd9\u4e9b\u4f4e\u7ea7\u5185\u7f6e\u6570\u636e\u7c7b\u578b\uff08\u6709\u65f6\u79f0\u4e3a \u539f\u59cb(primitive) \u6570\u636e\u7c7b\u578b\uff09\u4e3a\u7b97\u6cd5\u5f00\u53d1\u63d0\u4f9b\u4e86\u6784\u5efa\u5757\u3002</p> <p>\u4f8b\u5982\uff0c\u5927\u591a\u6570\u7f16\u7a0b\u8bed\u8a00\u90fd\u63d0\u4f9b\u6574\u6570\u6570\u636e\u7c7b\u578b\u3002 \u8ba1\u7b97\u673a\u5185\u5b58\u4e2d\u7684\u4e8c\u8fdb\u5236\u6570\u5b57\u4e32\u53ef\u4ee5\u89e3\u91ca\u4e3a\u6574\u6570\uff0c\u5e76\u5177\u6709\u6211\u4eec\u901a\u5e38\u4e0e\u6574\u6570\u76f8\u5173\u7684\u5178\u578b\u542b\u4e49\uff08\u4f8b\u5982 23\u3001654 \u548c -19\uff09\u3002 \u6b64\u5916\uff0c\u6570\u636e\u7c7b\u578b\u8fd8\u63d0\u4f9b\u4e86\u6570\u636e\u9879\u53ef\u4ee5\u53c2\u4e0e\u7684\u8fd0\u7b97\u7684\u63cf\u8ff0\u3002\u5bf9\u4e8e\u6574\u6570\uff0c\u52a0\u6cd5\u3001\u51cf\u6cd5\u548c\u4e58\u6cd5\u7b49\u8fd0\u7b97\u5f88\u5e38\u89c1\u3002 \u6211\u4eec\u671f\u671b\u6570\u5b57\u7c7b\u578b\u7684\u6570\u636e\u53ef\u4ee5\u53c2\u4e0e\u8fd9\u4e9b\u7b97\u672f\u8fd0\u7b97\u3002</p> <p>\u6211\u4eec\u7ecf\u5e38\u9047\u5230\u7684\u56f0\u96be\u662f\u95ee\u9898\u53ca\u5176\u89e3\u51b3\u65b9\u6848\u975e\u5e38\u590d\u6742\u3002 \u8fd9\u4e9b\u7b80\u5355\u7684\u3001\u8bed\u8a00\u63d0\u4f9b\u7684\u7ed3\u6784\u548c\u6570\u636e\u7c7b\u578b\u867d\u7136\u8db3\u4ee5\u8868\u793a\u590d\u6742\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u4f46\u5728\u6211\u4eec\u89e3\u51b3\u95ee\u9898\u7684\u8fc7\u7a0b\u4e2d\u901a\u5e38\u5904\u4e8e\u52a3\u52bf\u3002 \u6211\u4eec\u9700\u8981\u4e00\u4e9b\u65b9\u6cd5\u6765\u63a7\u5236\u8fd9\u79cd\u590d\u6742\u6027\u5e76\u534f\u52a9\u521b\u5efa\u89e3\u51b3\u65b9\u6848\u3002</p> <p>Programming is the process of taking an algorithm and encoding it into a notation, a programming language, so that it can be executed by a computer. Although many programming languages and many different types of computers exist, the important first step is the need to have the solution. Without an algorithm there can be no program.</p> <p>Computer science is not the study of programming. Programming, however, is an important part of what a computer scientist does. Programming is often the way that we create a representation for our solutions. Therefore, this language representation and the process of creating it becomes a fundamental part of the discipline.</p> <p>Algorithms describe the solution to a problem in terms of the data needed to represent the problem instance and the set of steps necessary to produce the intended result. Programming languages must provide a notational way to represent both the process and the data. To this end, languages provide control constructs and data types.</p> <p>Control constructs allow algorithmic steps to be represented in a convenient yet unambiguous way. At a minimum, algorithms require constructs that perform sequential processing, selection for decision-making, and iteration for repetitive control. As long as the language provides these basic statements, it can be used for algorithm representation.</p> <p>All data items in the computer are represented as strings of binary digits. In order to give these strings meaning, we need to have data types. Data types provide an interpretation for this binary data so that we can think about the data in terms that make sense with respect to the problem being solved. These low-level, built-in data types (sometimes called the primitive data types) provide the building blocks for algorithm development.</p> <p>For example, most programming languages provide a data type for integers. Strings of binary digits in the computer\u2019s memory can be interpreted as integers and given the typical meanings that we commonly associate with integers (e.g. 23, 654, and -19). In addition, a data type also provides a description of the operations that the data items can participate in. With integers, operations such as addition, subtraction, and multiplication are common. We have come to expect that numeric types of data can participate in these arithmetic operations.</p> <p>The difficulty that often arises for us is the fact that problems and their solutions are very complex. These simple, language-provided constructs and data types, although certainly sufficient to represent complex solutions, are typically at a disadvantage as we work through the problem-solving process. We need ways to control this complexity and assist with the creation of solutions.</p>"},{"location":"c1/s5/","title":"1.5. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u6570\u636e\u7ed3\u6784\u548c\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff1f","text":"<p>1.5. Why Study Data Structures and Abstract Data Types?</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e3a\u4e86\u7ba1\u7406\u95ee\u9898\u7684\u590d\u6742\u6027\u548c\u89e3\u51b3\u95ee\u9898\u7684\u8fc7\u7a0b\uff0c\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u4f7f\u7528\u62bd\u8c61\u6765\u8ba9\u4ed6\u4eec\u4e13\u6ce8\u4e8e\u201c\u5927\u5c40\uff08big picture\uff09\u201d\uff0c\u800c\u4e0d\u4f1a\u8ff7\u5931\u5728\u7ec6\u8282\u4e2d\u3002 \u901a\u8fc7\u521b\u5efa\u95ee\u9898\u57df\u7684\u6a21\u578b\uff0c\u6211\u4eec\u80fd\u591f\u5229\u7528\u66f4\u597d\u3001\u66f4\u9ad8\u6548\u7684\u95ee\u9898\u89e3\u51b3\u8fc7\u7a0b\u3002 \u8fd9\u4e9b\u6a21\u578b\u4f7f\u6211\u4eec\u80fd\u591f\u63cf\u8ff0\u6211\u4eec\u7684\u7b97\u6cd5\u5c06\u4ee5\u4e0e\u95ee\u9898\u672c\u8eab\u66f4\u52a0\u4e00\u81f4\u7684\u65b9\u5f0f\u64cd\u4f5c\u7684\u6570\u636e\u3002</p> <p>\u65e9\u4e9b\u65f6\u5019\uff0c\u6211\u4eec\u5c06\u8fc7\u7a0b\u62bd\u8c61\u79f0\u4e3a\u9690\u85cf\u7279\u5b9a\u51fd\u6570\u7684\u7ec6\u8282\u4ee5\u5141\u8bb8\u7528\u6237\u6216\u5ba2\u6237\u7aef\u5728\u975e\u5e38\u9ad8\u7684\u7ea7\u522b\u4e0a\u67e5\u770b\u5b83\u7684\u8fc7\u7a0b\u3002 \u73b0\u5728\u6211\u4eec\u5c06\u6ce8\u610f\u529b\u8f6c\u5411\u4e00\u4e2a\u7c7b\u4f3c\u7684\u60f3\u6cd5\uff0c\u5373\u6570\u636e\u62bd\u8c61\u3002 \u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff0c\u6709\u65f6\u7f29\u5199\u4e3aADT\uff0c\u662f\u6211\u4eec\u5982\u4f55\u67e5\u770b\u6570\u636e\u548c\u5141\u8bb8\u7684\u64cd\u4f5c\u7684\u903b\u8f91\u63cf\u8ff0\uff0c\u800c\u4e0d\u8003\u8651\u5b83\u4eec\u5c06\u5982\u4f55\u5b9e\u73b0\u3002 \u8fd9\u610f\u5473\u7740\u6211\u4eec\u53ea\u5173\u5fc3\u6570\u636e\u4ee3\u8868\u4ec0\u4e48\uff0c\u800c\u4e0d\u5173\u5fc3\u5b83\u6700\u7ec8\u5c06\u5982\u4f55\u6784\u5efa\u3002 \u901a\u8fc7\u63d0\u4f9b\u8fd9\u79cd\u62bd\u8c61\u7ea7\u522b\uff0c\u6211\u4eec\u6b63\u5728\u56f4\u7ed5\u6570\u636e\u521b\u5efa\u5c01\u88c5\u3002 \u6211\u4eec\u7684\u60f3\u6cd5\u662f\uff0c\u901a\u8fc7\u5c01\u88c5\u5b9e\u73b0\u7684\u7ec6\u8282\uff0c\u6211\u4eec\u5c06\u5b83\u4eec\u9690\u85cf\u5728\u7528\u6237\u7684\u89c6\u91ce\u4e4b\u5916\u3002 \u8fd9\u79f0\u4e3a\u4fe1\u606f\u9690\u85cf\u3002</p> <p>\u201c\u56fe 2\u201d\u663e\u793a\u4e86\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u662f\u4ec0\u4e48\u53ca\u5176\u64cd\u4f5c\u65b9\u5f0f\u7684\u56fe\u7247\u3002 \u7528\u6237\u4f7f\u7528\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u6307\u5b9a\u7684\u64cd\u4f5c\u4e0e\u754c\u9762\u4ea4\u4e92\u3002 \u62bd\u8c61\u6570\u636e\u7c7b\u578b\u662f\u7528\u6237\u4ea4\u4e92\u7684\u5916\u58f3\u3002 \u8be5\u5b9e\u73b0\u9690\u85cf\u5f97\u66f4\u6df1\u4e00\u5c42\u3002 \u7528\u6237\u4e0d\u5173\u5fc3\u5b9e\u73b0\u7684\u7ec6\u8282\u3002</p> <p> \u56fe 2: \u62bd\u8c61\u6570\u636e\u7c7b\u578b </p> <p>\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff08\u901a\u5e38\u79f0\u4e3a\u6570\u636e\u7ed3\u6784\uff09\u7684\u5b9e\u73b0\u5c06\u8981\u6c42\u6211\u4eec\u4f7f\u7528\u4e00\u4e9b\u7f16\u7a0b\u7ed3\u6784\u548c\u539f\u59cb\u6570\u636e\u7c7b\u578b\u7684\u96c6\u5408\u6765\u63d0\u4f9b\u6570\u636e\u7684\u7269\u7406\u89c6\u56fe\u3002 \u6b63\u5982\u6211\u4eec\u4e4b\u524d\u8ba8\u8bba\u7684\uff0c\u8fd9\u4e24\u4e2a\u89c6\u89d2\u7684\u5206\u79bb\u5c06\u4f7f\u6211\u4eec\u80fd\u591f\u4e3a\u6211\u4eec\u7684\u95ee\u9898\u5b9a\u4e49\u590d\u6742\u7684\u6570\u636e\u6a21\u578b\uff0c\u800c\u65e0\u9700\u7ed9\u51fa\u4efb\u4f55\u6709\u5173\u5982\u4f55\u5b9e\u9645\u6784\u5efa\u6a21\u578b\u7684\u7ec6\u8282\u7684\u6307\u793a\u3002 \u8fd9\u63d0\u4f9b\u4e86\u6570\u636e\u7684\u72ec\u7acb\u4e8e\u5b9e\u73b0\u7684\u89c6\u56fe\u3002 \u7531\u4e8e\u901a\u5e38\u6709\u8bb8\u591a\u4e0d\u540c\u7684\u65b9\u6cd5\u6765\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff0c\u56e0\u6b64\u8fd9\u79cd\u5b9e\u73b0\u72ec\u7acb\u6027\u5141\u8bb8\u7a0b\u5e8f\u5458\u5207\u6362\u5b9e\u73b0\u7684\u7ec6\u8282\uff0c\u800c\u65e0\u9700\u66f4\u6539\u6570\u636e\u7528\u6237\u4e0e\u5176\u4ea4\u4e92\u7684\u65b9\u5f0f\u3002 \u7528\u6237\u53ef\u4ee5\u7ee7\u7eed\u4e13\u6ce8\u4e8e\u89e3\u51b3\u95ee\u9898\u7684\u8fc7\u7a0b\u3002</p> <p>To manage the complexity of problems and the problem-solving process, computer scientists use abstractions to allow them to focus on the \u201cbig picture\u201d without getting lost in the details. By creating models of the problem domain, we are able to utilize a better and more efficient problem-solving process. These models allow us to describe the data that our algorithms will manipulate in a much more consistent way with respect to the problem itself.</p> <p>Earlier, we referred to procedural abstraction as a process that hides the details of a particular function to allow the user or client to view it at a very high level. We now turn our attention to a similar idea, that of data abstraction. An abstract data type, sometimes abbreviated ADT, is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented. This means that we are concerned only with what the data is representing and not with how it will eventually be constructed. By providing this level of abstraction, we are creating an encapsulation around the data. The idea is that by encapsulating the details of the implementation, we are hiding them from the user\u2019s view. This is called information hiding.</p> <p>Figure 2 shows a picture of what an abstract data type is and how it operates. The user interacts with the interface, using the operations that have been specified by the abstract data type. The abstract data type is the shell that the user interacts with. The implementation is hidden one level deeper. The user is not concerned with the details of the implementation.</p> <p> Figure 2: Abstract Data Type </p> <p>The implementation of an abstract data type, often referred to as a data structure, will require that we provide a physical view of the data using some collection of programming constructs and primitive data types. As we discussed earlier, the separation of these two perspectives will allow us to define the complex data models for our problems without giving any indication as to the details of how the model will actually be built. This provides an implementation-independent view of the data. Since there will usually be many different ways to implement an abstract data type, this implementation independence allows the programmer to switch the details of the implementation without changing the way the user of the data interacts with it. The user can remain focused on the problem-solving process.</p>"},{"location":"c1/s6/","title":"1.6. \u4e3a\u4ec0\u4e48\u5b66\u4e60\u7b97\u6cd5\uff1f","text":"<p>1.6. Why Study Algorithms?</p> \u4e2d\u6587\u82f1\u6587 <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u901a\u8fc7\u7ecf\u9a8c\u5b66\u4e60\u3002 \u6211\u4eec\u901a\u8fc7\u770b\u5230\u522b\u4eba\u89e3\u51b3\u95ee\u9898\u548c\u81ea\u5df1\u89e3\u51b3\u95ee\u9898\u6765\u5b66\u4e60\u3002 \u63a5\u89e6\u4e0d\u540c\u7684\u95ee\u9898\u89e3\u51b3\u6280\u672f\u5e76\u4e86\u89e3\u4e0d\u540c\u7b97\u6cd5\u7684\u8bbe\u8ba1\u65b9\u5f0f\u6709\u52a9\u4e8e\u6211\u4eec\u5e94\u5bf9\u4e0b\u4e00\u4e2a\u5177\u6709\u6311\u6218\u6027\u7684\u95ee\u9898\u3002 \u901a\u8fc7\u8003\u8651\u591a\u79cd\u4e0d\u540c\u7684\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u5f00\u53d1\u6a21\u5f0f\u8bc6\u522b\uff0c\u4ee5\u4fbf\u4e0b\u6b21\u51fa\u73b0\u7c7b\u4f3c\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u80fd\u591f\u66f4\u597d\u5730\u89e3\u51b3\u5b83\u3002</p> <p>\u7b97\u6cd5\u4e4b\u95f4\u5f80\u5f80\u5b58\u5728\u5f88\u5927\u5dee\u5f02\u3002 \u8003\u8651\u524d\u9762\u770b\u5230\u7684 sqrt \u793a\u4f8b\uff08\u89c1\u56fe 1.1\uff09\u3002 \u5b8c\u5168\u6709\u53ef\u80fd\u6709\u8bb8\u591a\u4e0d\u540c\u7684\u65b9\u6cd5\u6765\u5b9e\u73b0\u8ba1\u7b97\u5e73\u65b9\u6839\u51fd\u6570\u7684\u7ec6\u8282\u3002 \u4e00\u79cd\u7b97\u6cd5\u4f7f\u7528\u7684\u8d44\u6e90\u53ef\u80fd\u6bd4\u53e6\u4e00\u79cd\u7b97\u6cd5\u5c11\u5f97\u591a\u3002 \u4e00\u79cd\u7b97\u6cd5\u8fd4\u56de\u7ed3\u679c\u7684\u65f6\u95f4\u53ef\u80fd\u662f\u53e6\u4e00\u79cd\u7b97\u6cd5\u7684 10 \u500d\u3002 \u6211\u4eec\u5e0c\u671b\u6709\u67d0\u79cd\u65b9\u6cd5\u6765\u6bd4\u8f83\u8fd9\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\u3002 \u5c3d\u7ba1\u5b83\u4eec\u90fd\u6709\u6548\uff0c\u4f46\u5176\u4e2d\u4e00\u79cd\u53ef\u80fd\u6bd4\u53e6\u4e00\u79cd\u201c\u66f4\u597d\u201d\u3002\u6211\u4eec\u53ef\u80fd\u4f1a\u5efa\u8bae\u5176\u4e2d\u4e00\u79cd\u6548\u7387\u66f4\u9ad8\uff0c\u6216\u8005\u53ea\u662f\u5de5\u4f5c\u901f\u5ea6\u66f4\u5feb\u6216\u4f7f\u7528\u66f4\u5c11\u7684\u5185\u5b58\u3002\u5f53\u6211\u4eec\u7814\u7a76\u7b97\u6cd5\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5b66\u4e60\u5206\u6790\u6280\u672f\uff0c\u8fd9\u4e9b\u6280\u672f\u4f7f\u6211\u4eec\u80fd\u591f\u4ec5\u6839\u636e\u89e3\u51b3\u65b9\u6848\u81ea\u8eab\u7684\u7279\u5f81\uff0c\u800c\u4e0d\u662f\u7528\u4e8e\u5b9e\u73b0\u5b83\u4eec\u7684\u7a0b\u5e8f\u6216\u8ba1\u7b97\u673a\u7684\u7279\u5f81\u6765\u6bd4\u8f83\u548c\u5bf9\u6bd4\u89e3\u51b3\u65b9\u6848\u3002</p> <p>\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u9047\u5230\u4e00\u4e2a\u68d8\u624b\u7684\u95ee\u9898\uff0c\u8fd9\u610f\u5473\u7740\u6ca1\u6709\u7b97\u6cd5\u53ef\u4ee5\u5728\u73b0\u5b9e\u7684\u65f6\u95f4\u5185\u89e3\u51b3\u95ee\u9898\u3002 \u91cd\u8981\u7684\u662f\u80fd\u591f\u533a\u5206\u54ea\u4e9b\u6709\u89e3\u51b3\u65b9\u6848\u7684\u95ee\u9898\u3001\u54ea\u4e9b\u6ca1\u6709\u89e3\u51b3\u65b9\u6848\u7684\u95ee\u9898\u4ee5\u53ca\u54ea\u4e9b\u5b58\u5728\u89e3\u51b3\u65b9\u6848\u4f46\u9700\u8981\u592a\u591a\u65f6\u95f4\u6216\u5176\u4ed6\u8d44\u6e90\u624d\u80fd\u5408\u7406\u5de5\u4f5c\u7684\u95ee\u9898\u3002</p> <p>\u6211\u4eec\u7ecf\u5e38\u9700\u8981\u786e\u5b9a\u5e76\u505a\u51fa\u6743\u8861\u3002 \u4f5c\u4e3a\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\uff0c\u9664\u4e86\u89e3\u51b3\u95ee\u9898\u7684\u80fd\u529b\u4e4b\u5916\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u4e86\u89e3\u548c\u7406\u89e3\u89e3\u51b3\u65b9\u6848\u8bc4\u4f30\u6280\u672f\u3002 \u6700\u540e\uff0c\u89e3\u51b3\u4e00\u4e2a\u95ee\u9898\u5f80\u5f80\u6709\u5f88\u591a\u79cd\u65b9\u6cd5\u3002 \u627e\u5230\u4e00\u4e2a\u89e3\u51b3\u65b9\u6848\uff0c\u7136\u540e\u51b3\u5b9a\u5b83\u662f\u5426\u662f\u4e00\u4e2a\u597d\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u662f\u6211\u4eec\u4f1a\u4e00\u904d\u53c8\u4e00\u904d\u5730\u505a\u7684\u4efb\u52a1\u3002</p> <p>Computer scientists learn by experience. We learn by seeing others solve problems and by solving problems by ourselves. Being exposed to different problem-solving techniques and seeing how different algorithms are designed helps us to take on the next challenging problem that we are given. By considering a number of different algorithms, we can begin to develop pattern recognition so that the next time a similar problem arises, we are better able to solve it.</p> <p>Algorithms are often quite different from one another. Consider the example of <code>sqrt</code> seen earlier (see Figure 1.1). It is entirely possible that there are many different ways to implement the details to compute the square root function. One algorithm may use many fewer resources than another. One algorithm might take 10 times as long to return the result as the other. We would like to have some way to compare these two solutions. Even though they both work, one is perhaps \u201cbetter\u201d than the other. We might suggest that one is more efficient or that one simply works faster or uses less memory. As we study algorithms, we can learn analysis techniques that allow us to compare and contrast solutions based solely on their own characteristics, not the characteristics of the program or computer used to implement them.</p> <p>In the worst-case scenario, we may have a problem that is intractable, meaning that there is no algorithm that can solve the problem in a realistic amount of time. It is important to be able to distinguish between those problems that have solutions, those that do not, and those where solutions exist but require too much time or other resources to work reasonably.</p> <p>There will often be trade-offs that we will need to identify and decide upon. As computer scientists, in addition to our ability to solve problems, we will also need to know and understand solution evaluation techniques. In the end, there are often many ways to solve a problem. Finding a solution and then deciding whether it is a good one are tasks that we will do over and over again.</p>"},{"location":"c1/s7/","title":"1.7. Python\u57fa\u7840\u56de\u987e","text":"<p>1.7. Review of Basic Python</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u56de\u987e\u7f16\u7a0b\u8bed\u8a00 Python\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b\u66f4\u8be6\u7ec6\u7684\u793a\u4f8b\u6765\u4f53\u73b0\u4e0a\u4e00\u8282\u4e2d\u7684\u60f3\u6cd5\u3002 \u5982\u679c\u60a8\u662f Python \u65b0\u624b\u6216\u53d1\u73b0\u9700\u8981\u6709\u5173\u6240\u63d0\u4f9b\u7684\u4efb\u4f55\u4e3b\u9898\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\u67e5\u9605\u8d44\u6e90\uff0c\u4f8b\u5982 \u201cPython \u8bed\u8a00\u53c2\u8003\u201d\u3001\u201cPython \u6559\u7a0b\u201d \u6216 https://docs.python.org/ \u4e2d\u63d0\u4f9b\u7684\u5176\u4ed6\u6587\u6863\u3002 \u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9\u60a8\u91cd\u65b0\u719f\u6089\u8be5\u8bed\u8a00\uff0c\u5e76\u5f3a\u5316\u4e00\u4e9b\u5c06\u6210\u4e3a\u540e\u7eed\u7ae0\u8282\u6838\u5fc3\u7684\u6982\u5ff5\u3002</p> <p>Python \u662f\u4e00\u79cd\u73b0\u4ee3\u3001\u6613\u4e8e\u5b66\u4e60\u3001\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u3002 \u5b83\u5177\u6709\u4e00\u7ec4\u5f3a\u5927\u7684\u5185\u7f6e\u6570\u636e\u7c7b\u578b\u548c\u6613\u4e8e\u4f7f\u7528\u7684\u63a7\u5236\u7ed3\u6784\u3002 \u7531\u4e8e Python \u662f\u4e00\u79cd\u89e3\u91ca\u6027\u8bed\u8a00\uff0c\u56e0\u6b64\u901a\u8fc7\u7b80\u5355\u5730\u67e5\u770b\u548c\u63cf\u8ff0\u4ea4\u4e92\u5f0f\u4f1a\u8bdd\u6765\u6700\u5bb9\u6613\u5bf9\u5176\u8fdb\u884c\u5ba1\u67e5\u3002 \u60a8\u5e94\u8be5\u8bb0\u5f97\uff0c\u89e3\u91ca\u5668\u663e\u793a\u719f\u6089\u7684<code>&gt;&gt;&gt;</code>\u63d0\u793a\u7b26\uff0c\u7136\u540e\u8bc4\u4f30\u60a8\u63d0\u4f9b\u7684 Python \u6784\u9020\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; print(\"Algorithms and Data Structures\")\nAlgorithms and Data Structures\n</code></pre> <p>\u663e\u793a\u63d0\u793a\u3001<code>print</code>\u51fd\u6570\u3001\u7ed3\u679c\u548c\u4e0b\u4e00\u4e2a\u63d0\u793a\u3002</p> <p>In this section, we will review the programming language Python and also provide some more detailed examples of the ideas from the previous section. If you are new to Python or find that you need more information about any of the topics presented, we recommend that you consult a resource such as \u201cThe Python Language Reference\u201d, \u201cThe Python Tutorial\u201d, or other documents available at https://docs.python.org/. Our goal here is to reacquaint you with the language and also reinforce some of the concepts that will be central to later chapters.</p> <p>Python is a modern, easy-to-learn, object-oriented programming language. It has a powerful set of built-in data types and easy-to-use control constructs. Since Python is an interpreted language, it is most easily reviewed by simply looking at and describing interactive sessions. You should recall that the interpreter displays the familiar <code>&gt;&gt;&gt;</code> prompt and then evaluates the Python construct that you provide. For example,</p> <pre><code>&gt;&gt;&gt; print(\"Algorithms and Data Structures\")\nAlgorithms and Data Structures\n</code></pre> <p>shows the prompt, the <code>print</code> function, the result, and the next prompt.</p>"},{"location":"c1/s8/","title":"1.8. \u6570\u636e\u5165\u95e8","text":"<p>1.8. Getting Started with Data</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e0a\u9762\u6211\u4eec\u8bf4\u8fc7Python\u652f\u6301\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8303\u5f0f\u3002 \u8fd9\u610f\u5473\u7740 Python \u5c06\u6570\u636e\u89c6\u4e3a\u89e3\u51b3\u95ee\u9898\u8fc7\u7a0b\u7684\u7126\u70b9\u3002 \u5728Python\u4ee5\u53ca\u4efb\u4f55\u5176\u4ed6\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u7c7b(class)\u6765\u63cf\u8ff0\u6570\u636e\u7684\u6837\u5b50\uff08\u72b6\u6001\uff09\u4ee5\u53ca\u6570\u636e\u53ef\u4ee5\u505a\u4ec0\u4e48\uff08\u884c\u4e3a\uff09\u3002 \u7c7b\u7c7b\u4f3c\u4e8e\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff0c\u56e0\u4e3a\u7c7b\u7684\u7528\u6237\u53ea\u80fd\u770b\u5230\u6570\u636e\u9879\u7684\u72b6\u6001\u548c\u884c\u4e3a\u3002 \u5728\u9762\u5411\u5bf9\u8c61\u7684\u8303\u5f0f\u4e2d\uff0c\u6570\u636e\u9879\u88ab\u79f0\u4e3a\u5bf9\u8c61(objects)\u3002 \u5bf9\u8c61\u662f\u7c7b\u7684\u5b9e\u4f8b\u3002</p> <p>We stated above that Python supports the object-oriented programming paradigm. This means that Python considers data to be the focal point of the problem-solving process. In Python, as well as in any other object-oriented programming language, we define a class to be a description of what the data look like (the state) and what the data can do (the behavior). Classes are analogous to abstract data types because a user of a class only sees the state and behavior of a data item. Data items are called objects in the object-oriented paradigm. An object is an instance of a class.</p>"},{"location":"c1/s8/#181-\u5185\u5efa\u7684\u539f\u5b50\u6570\u636e\u7c7b\u578b","title":"1.8.1. \u5185\u5efa\u7684\u539f\u5b50\u6570\u636e\u7c7b\u578b","text":"<p>1.8.1. Built-in Atomic Data Types</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5c06\u901a\u8fc7\u8003\u8651\u539f\u5b50\u6570\u636e\u7c7b\u578b\u6765\u5f00\u59cb\u6211\u4eec\u7684\u5ba1\u67e5\u3002 Python \u6709\u4e24\u4e2a\u4e3b\u8981\u7684\u5185\u7f6e\u6570\u5b57\u7c7b\uff0c\u5b83\u4eec\u5b9e\u73b0\u6574\u6570\u548c\u6d6e\u70b9\u6570\u636e\u7c7b\u578b\u3002 \u8fd9\u4e9b Python \u7c7b\u79f0\u4e3a <code>int</code> \u548c\u201cfloat\u201d\u3002 \u6807\u51c6\u7b97\u672f\u8fd0\u7b97\u7b26 +\u3001-\u3001*\u3001/ \u548c **\uff08\u6c42\u5e42\uff09\u53ef\u4ee5\u4e0e\u62ec\u53f7\u4e00\u8d77\u4f7f\u7528\uff0c\u5f3a\u5236\u64cd\u4f5c\u987a\u5e8f\u504f\u79bb\u6b63\u5e38\u8fd0\u7b97\u7b26\u4f18\u5148\u7ea7\u3002 \u5176\u4ed6\u975e\u5e38\u6709\u7528\u7684\u8fd0\u7b97\u7b26\u662f\u4f59\u6570\uff08\u6a21\uff09\u8fd0\u7b97\u7b26 (%) \u548c\u6574\u6570\u9664\u6cd5 (//)\u3002 \u8bf7\u6ce8\u610f\uff0c\u5f53\u4e24\u4e2a\u6574\u6570\u76f8\u9664\u65f6\uff0c\u7ed3\u679c\u662f\u6d6e\u70b9\u6570\u3002 \u6574\u6570\u9664\u6cd5\u8fd0\u7b97\u7b26\u901a\u8fc7\u622a\u65ad\u4efb\u4f55\u5c0f\u6570\u90e8\u5206\u6765\u8fd4\u56de\u5546\u7684\u6574\u6570\u90e8\u5206\u3002</p> Activity: 1.8.1.1 Basic Arithmetic Operators<pre><code>print(2 + 3 * 4)\nprint((2 + 3) * 4)\nprint(2 ** 10)\nprint(6 / 3)\nprint(7 / 3)\nprint(7 // 3)\nprint(7 % 3)\nprint(3 / 6)\nprint(3 // 6)\nprint(3 % 6)\nprint(2 ** 100)\n</code></pre> <p>\u5e03\u5c14\u6570\u636e\u7c7b\u578b\uff0c\u4f5c\u4e3aPython <code>bool</code> \u7c7b\u5b9e\u73b0\uff0c\u5bf9\u4e8e\u8868\u793a\u771f\u503c\u975e\u5e38\u6709\u7528\u3002 \u5e03\u5c14\u5bf9\u8c61\u7684\u53ef\u80fd\u72b6\u6001\u503c\u662f<code>True</code>\u548c<code>False</code>\uff0c\u4ee5\u53ca\u6807\u51c6\u5e03\u5c14\u8fd0\u7b97\u7b26<code>and</code>\u3001<code>or</code>\u548c<code>not</code>\u3002</p> <pre><code>&gt;&gt;&gt; True\nTrue\n&gt;&gt;&gt; False\nFalse\n&gt;&gt;&gt; False or True\nTrue\n&gt;&gt;&gt; not (False or True)\nFalse\n&gt;&gt;&gt; True and True\nTrue\n</code></pre> <p>\u5e03\u5c14\u6570\u636e\u5bf9\u8c61\u8fd8\u7528\u4f5c\u6bd4\u8f83\u8fd0\u7b97\u7b26\u7684\u7ed3\u679c\uff0c\u4f8b\u5982\u7b49\u4e8e (==) \u548c\u5927\u4e8e (\\(&gt;\\))\u3002 \u6b64\u5916\uff0c\u5173\u7cfb\u8fd0\u7b97\u7b26\u548c\u903b\u8f91\u8fd0\u7b97\u7b26\u53ef\u4ee5\u7ec4\u5408\u5728\u4e00\u8d77\u5f62\u6210\u590d\u6742\u7684\u903b\u8f91\u95ee\u9898\u3002 \u201c\u8868 1\u201d\u663e\u793a\u4e86\u5173\u7cfb\u8fd0\u7b97\u7b26\u548c\u903b\u8f91\u8fd0\u7b97\u7b26\uff0c\u5e76\u5728\u968f\u540e\u7684\u4f1a\u8bdd\u4e2d\u663e\u793a\u4e86\u793a\u4f8b\u3002</p> <p>\u8868 1: \u5173\u7cfb\u8fd0\u7b97\u7b26\u548c\u903b\u8f91\u8fd0\u7b97\u7b26</p> \u8fd0\u7b97\u7b26\u540d\u79f0 \u8fd0\u7b97\u7b26 \u89e3\u91ca \u5c0f\u4e8e \\(&lt;\\) \u5c0f\u4e8e\u8fd0\u7b97\u7b26 \u5927\u4e8e \\(&gt;\\) \u5927\u4e8e\u8fd0\u7b97\u7b26 \u5c0f\u4e8e\u6216\u7b49\u4e8e \\(&lt;=\\) \u5c0f\u4e8e\u6216\u7b49\u4e8e\u8fd0\u7b97\u7b26 \u5927\u4e8e\u6216\u7b49\u4e8e \\(&gt;=\\) \u5927\u4e8e\u6216\u7b49\u4e8e\u8fd0\u7b97\u7b26 \u7b49\u4e8e \\(==\\) \u7b49\u4e8e\u8fd0\u7b97\u7b26 \u4e0d\u7b49\u4e8e \\(!=\\) \u4e0d\u7b49\u4e8e\u8fd0\u7b97\u7b26 \u903b\u8f91\u548c \\(and\\) \u4e24\u4e2a\u64cd\u4f5c\u6570\u90fd\u4e3a True \u65f6\u7ed3\u679c\u4e3a True \u903b\u8f91\u6216 \\(or\\) \u4e00\u4e2a\u6216\u53e6\u4e00\u4e2a\u64cd\u4f5c\u6570\u4e3a True \u5219\u7ed3\u679c\u4e3a True \u903b\u8f91\u975e \\(not\\) \u5426\u5b9a\u771f\u503c\uff0cFalse \u53d8\u4e3a True\uff0cTrue \u53d8\u4e3a False Activity: 1.8.1.2 \u57fa\u672c\u5173\u7cfb\u548c\u903b\u8f91\u8fd0\u7b97\u7b26<pre><code>&gt;&gt;&gt; print(5 == 10)\nFalse\n&gt;&gt;&gt; print(10 &gt; 5)\nTrue\n&gt;&gt;&gt; print((5 &gt;= 1) and (5 &lt;= 10))\nTrue\n&gt;&gt;&gt; print((1 &lt; 5) or (10 &lt; 1))\nTrue\n&gt;&gt;&gt; print(1 &lt; 5 &lt; 10)\nTrue\n</code></pre> <p>\u6807\u8bc6\u7b26\u5728\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7528\u4f5c\u540d\u79f0\u3002 \u5728 Python \u4e2d\uff0c\u6807\u8bc6\u7b26\u4ee5\u5b57\u6bcd\u6216\u4e0b\u5212\u7ebf (_) \u5f00\u5934\uff0c\u533a\u5206\u5927\u5c0f\u5199\uff0c\u5e76\u4e14\u53ef\u4ee5\u662f\u4efb\u610f\u957f\u5ea6\u3002 \u8bf7\u8bb0\u4f4f\uff0c\u4f7f\u7528\u4f20\u8fbe\u542b\u4e49\u7684\u540d\u79f0\u59cb\u7ec8\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\uff0c\u4ee5\u4fbf\u60a8\u7684\u7a0b\u5e8f\u4ee3\u7801\u66f4\u6613\u4e8e\u9605\u8bfb\u548c\u7406\u89e3\u3002</p> <p>\u5f53\u7b2c\u4e00\u6b21\u5728\u8d4b\u503c\u8bed\u53e5\u7684\u5de6\u4fa7\u4f7f\u7528\u540d\u79f0\u65f6\uff0c\u5c31\u4f1a\u521b\u5efa Python \u53d8\u91cf\u3002 \u8d4b\u503c\u8bed\u53e5\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06\u540d\u79f0\u4e0e\u503c\u5173\u8054\u8d77\u6765\u7684\u65b9\u6cd5\u3002 \u8be5\u53d8\u91cf\u5c06\u4fdd\u5b58\u5bf9\u4e00\u6bb5\u6570\u636e\u7684\u5f15\u7528\uff0c\u4f46\u4e0d\u4fdd\u5b58\u6570\u636e\u672c\u8eab\u3002 \u8003\u8651\u4ee5\u4e0b\u4f1a\u8bdd\uff1a</p> <pre><code>&gt;&gt;&gt; the_sum = 0\n&gt;&gt;&gt; the_sum\n0\n&gt;&gt;&gt; the_sum = the_sum + 1\n&gt;&gt;&gt; the_sum\n1\n&gt;&gt;&gt; the_sum = True\n&gt;&gt;&gt; the_sum\nTrue\n</code></pre> <p>\u8d4b\u503c\u8bed\u53e5<code>the_sum = 0</code>\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a<code>the_sum</code>\u7684\u53d8\u91cf\uff0c\u5e76\u8ba9\u5b83\u4fdd\u5b58\u5bf9\u6570\u636e\u5bf9\u8c61<code>0</code>\u7684\u5f15\u7528\uff08\u53c2\u89c1\u201c\u56fe3\u201d\uff09\u3002 \u901a\u5e38\uff0c\u5bf9\u8d4b\u503c\u8bed\u53e5\u7684\u53f3\u4fa7\u8fdb\u884c\u6c42\u503c\uff0c\u5e76\u5bf9\u7ed3\u679c\u6570\u636e\u5bf9\u8c61\u7684\u5f15\u7528\u5206\u914d\u7ed9\u5de6\u4fa7\u7684\u540d\u79f0\u3002 \u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\uff0c\u6b64\u65f6\u53d8\u91cf\u7684\u7c7b\u578b\u662f\u6574\u6570\uff0c\u56e0\u4e3a\u8fd9\u662f<code>the_sum</code>\u5f53\u524d\u5f15\u7528\u7684\u6570\u636e\u7684\u7c7b\u578b\u3002 \u5982\u679c\u6570\u636e\u7c7b\u578b\u53d1\u751f\u53d8\u5316\uff08\u53c2\u89c1\u201c\u56fe 4\u201d\uff09\uff0c\u5982\u4e0a\u9762\u5e03\u5c14\u503c<code>True</code>\u6240\u793a\uff0c\u53d8\u91cf\u7684\u7c7b\u578b\u4e5f\u4f1a\u53d1\u751f\u53d8\u5316\uff08<code>the_sum</code>\u73b0\u5728\u662f\u5e03\u5c14\u7c7b\u578b\uff09\u3002 \u8d4b\u503c\u8bed\u53e5\u66f4\u6539\u53d8\u91cf\u6240\u6301\u6709\u7684\u5f15\u7528\u3002 \u8fd9\u662fPython\u7684\u52a8\u6001\u7279\u6027\u3002 \u540c\u4e00\u53d8\u91cf\u53ef\u4ee5\u5f15\u7528\u8bb8\u591a\u4e0d\u540c\u7c7b\u578b\u7684\u6570\u636e\u3002</p> <p> \u56fe 3: \u53d8\u91cf\u4fdd\u5b58\u5bf9\u6570\u636e\u5bf9\u8c61\u7684\u5f15\u7528 </p> <p> \u56fe 4: \u8d4b\u503c\u6539\u53d8\u5f15\u7528 </p> <p>We will begin our review by considering the atomic data types. Python has two main built-in numeric classes that implement the integer and floating-point data types. These Python classes are called <code>int</code> and <code>float</code>. The standard arithmetic operators, +, -, *, /, and ** (exponentiation), can be used with parentheses forcing the order of operations away from normal operator precedence. Other very useful operators are the remainder (modulo) operator (%) and integer division (//). Note that when two integers are divided, the result is a floating point. The integer division operator returns the integer portion of the quotient by truncating any fractional part.</p> Activity: 1.8.1.1 Basic Arithmetic Operators<pre><code>print(2 + 3 * 4)\nprint((2 + 3) * 4)\nprint(2 ** 10)\nprint(6 / 3)\nprint(7 / 3)\nprint(7 // 3)\nprint(7 % 3)\nprint(3 / 6)\nprint(3 // 6)\nprint(3 % 6)\nprint(2 ** 100)\n</code></pre> <p>The Boolean data type, implemented as the Python <code>bool</code> class, will be quite useful for representing truth values. The possible state values for a Boolean object are <code>True</code> and <code>False</code> with the standard Boolean operators, <code>and</code>, <code>or</code>, and <code>not</code>.</p> <pre><code>&gt;&gt;&gt; True\nTrue\n&gt;&gt;&gt; False\nFalse\n&gt;&gt;&gt; False or True\nTrue\n&gt;&gt;&gt; not (False or True)\nFalse\n&gt;&gt;&gt; True and True\nTrue\n</code></pre> <p>Boolean data objects are also used as results for comparison operators such as equality (==) and greater than ( &gt; ). In addition, relational operators and logical operators can be combined together to form complex logical questions. Table 1 shows the relational and logical operators with examples shown in the session that follows.</p> <p>Table 1: Relational and Logical Operators</p> Operation Name Operator Explanation less than \\(&lt;\\) Less than operator greater than \\(&gt;\\) Greater than operator less than or equal \\(&lt;=\\) Less than or equal to operator greater than or equal \\(&gt;=\\) Greater than or equal to operator equal \\(==\\) Equality operator not equal \\(!=\\) Not equal operator logical and \\(and\\) Both operands True for result to be True logical or \\(or\\) One or the other operand is True for the result to be True logical not \\(not\\) Negates the truth value, False becomes True, True becomes False Activity: 1.8.1.2 Basic Relational and Logical Operators<pre><code>&gt;&gt;&gt; print(5 == 10)\nFalse\n&gt;&gt;&gt; print(10 &gt; 5)\nTrue\n&gt;&gt;&gt; print((5 &gt;= 1) and (5 &lt;= 10))\nTrue\n&gt;&gt;&gt; print((1 &lt; 5) or (10 &lt; 1))\nTrue\n&gt;&gt;&gt; print(1 &lt; 5 &lt; 10)\nTrue\n</code></pre> <p>Identifiers are used in programming languages as names. In Python, identifiers start with a letter or an underscore (_), are case sensitive, and can be of any length. Remember that it is always a good idea to use names that convey meaning so that your program code is easier to read and understand.</p> <p>A Python variable is created when a name is used for the first time on the left-hand side of an assignment statement. Assignment statements provide a way to associate a name with a value. The variable will hold a reference to a piece of data but not the data itself. Consider the following session:</p> <pre><code>&gt;&gt;&gt; the_sum = 0\n&gt;&gt;&gt; the_sum\n0\n&gt;&gt;&gt; the_sum = the_sum + 1\n&gt;&gt;&gt; the_sum\n1\n&gt;&gt;&gt; the_sum = True\n&gt;&gt;&gt; the_sum\nTrue\n</code></pre> <p>The assignment statement <code>the_sum = 0</code> creates a variable called <code>the_sum</code> and lets it hold the reference to the data object <code>0</code> (see Figure 3). In general, the right-hand side of the assignment statement is evaluated and a reference to the resulting data object is assigned to the name on the left-hand side. At this point in our example, the type of the variable is integer as that is the type of the data currently being referred to by <code>the_sum</code>. If the type of the data changes (see Figure 4), as shown above with the Boolean value <code>True</code>, so does the type of the variable (<code>the_sum</code> is now of the type Boolean). The assignment statement changes the reference being held by the variable. This is a dynamic characteristic of Python. The same variable can refer to many different types of data.</p> <p> Figure 3: Variables Hold References to Data Objects </p> <p> Figure 4: Assignment Changes the Reference </p>"},{"location":"c1/s8/#182-\u5185\u5efa\u7684\u96c6\u5408\u6570\u636e\u7c7b\u578b","title":"1.8.2. \u5185\u5efa\u7684\u96c6\u5408\u6570\u636e\u7c7b\u578b","text":"<p>1.8.2. Built-in Collection Data Types</p> \u4e2d\u6587\u82f1\u6587 <p>\u9664\u4e86\u6570\u5b57\u7c7b\u548c\u5e03\u5c14\u7c7b\u4e4b\u5916\uff0cPython \u8fd8\u6709\u8bb8\u591a\u975e\u5e38\u5f3a\u5927\u7684\u5185\u7f6e\u96c6\u5408\u7c7b\u3002 \u5217\u8868\u3001\u5b57\u7b26\u4e32\u548c\u5143\u7ec4\u662f\u6709\u5e8f\u96c6\u5408\uff0c\u5b83\u4eec\u5728\u4e00\u822c\u7ed3\u6784\u4e0a\u975e\u5e38\u76f8\u4f3c\uff0c\u4f46\u5177\u6709\u7279\u5b9a\u7684\u5dee\u5f02\uff0c\u5fc5\u987b\u7406\u89e3\u8fd9\u4e9b\u5dee\u5f02\u624d\u80fd\u6b63\u786e\u4f7f\u7528\u5b83\u4eec\u3002 \u96c6\u5408\u548c\u5b57\u5178\u662f\u65e0\u5e8f\u96c6\u5408\u3002</p> <p>In addition to the numeric and Boolean classes, Python has a number of very powerful built-in collection classes. Lists, strings, and tuples are ordered collections that are very similar in general structure but have specific differences that must be understood for them to be used properly. Sets and dictionaries are unordered collections.</p>"},{"location":"c1/s8/#list","title":"list","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5217\u8868(list)\u662f\u96f6\u4e2a\u6216\u591a\u4e2a\u5bf9 Python \u6570\u636e\u5bf9\u8c61\u7684\u5f15\u7528\u7684\u6709\u5e8f\u96c6\u5408\u3002 \u5217\u8868\u88ab\u5199\u4e3a\u62ec\u5728\u65b9\u62ec\u53f7\u4e2d\u7684\u9017\u53f7\u5206\u9694\u503c\u3002 \u7a7a\u5217\u8868\u5c31\u662f<code>[ ]</code>\u3002 \u5217\u8868\u662f\u5f02\u6784\u7684\uff0c\u8fd9\u610f\u5473\u7740\u6570\u636e\u5bf9\u8c61\u4e0d\u5fc5\u5168\u90e8\u6765\u81ea\u540c\u4e00\u7c7b\uff0c\u5e76\u4e14\u53ef\u4ee5\u5c06\u96c6\u5408\u5206\u914d\u7ed9\u53d8\u91cf\uff0c\u5982\u4e0b\u6240\u793a\u3002 \u4ee5\u4e0b\u7247\u6bb5\u663e\u793a\u4e86\u5217\u8868\u4e2d\u7684\u5404\u79cd Python \u6570\u636e\u5bf9\u8c61\u3002</p> <pre><code>&gt;&gt;&gt; [1, 3, True, 6.5]\n[1, 3, True, 6.5]\n&gt;&gt;&gt; my_list = [1, 3, True, 6.5]\n&gt;&gt;&gt; my_list\n[1, 3, True, 6.5]\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5f53 Python \u8ba1\u7b97(evaluates)\u5217\u8868\u65f6\uff0c\u4f1a\u8fd4\u56de\u5217\u8868\u672c\u8eab\u3002 \u4f46\u662f\uff0c\u4e3a\u4e86\u8bb0\u4f4f\u8be5\u5217\u8868\u4ee5\u4f9b\u4ee5\u540e\u5904\u7406\uff0c\u9700\u8981\u5c06\u5176\u5f15\u7528\u5206\u914d\u7ed9\u4e00\u4e2a\u53d8\u91cf\u3002</p> <p>\u7531\u4e8e\u5217\u8868\u88ab\u8ba4\u4e3a\u662f\u6309\u987a\u5e8f\u6392\u5e8f\u7684\uff0c\u56e0\u6b64\u5b83\u4eec\u652f\u6301\u8bb8\u591a\u53ef\u5e94\u7528\u4e8e\u4efb\u4f55 Python \u5e8f\u5217\u7684\u64cd\u4f5c\u3002 \u201c\u8868 2\u201d\u56de\u987e\u4e86\u8fd9\u4e9b\u64cd\u4f5c\uff0c\u4e0b\u9762\u7684\u8bfe\u7a0b\u7ed9\u51fa\u4e86\u5b83\u4eec\u7684\u4f7f\u7528\u793a\u4f8b\u3002</p> <p>\u8868 2\uff1aPython \u4e2d\u4efb\u610f\u5e8f\u5217\u7684\u64cd\u4f5c</p> \u8fd0\u7b97\u7b26\u540d\u79f0 \u8fd0\u7b97\u7b26 \u89e3\u91ca \u7d22\u5f15 [ ] \u8bbf\u95ee\u5e8f\u5217\u7684\u5143\u7d20 \u4e32\u8054 + \u5c06\u5e8f\u5217\u7ec4\u5408\u5728\u4e00\u8d77 \u91cd\u590d * \u8fde\u63a5\u91cd\u590d\u6b21\u6570 \u4f1a\u5458 <code>in</code> \u8be2\u95ee\u67d0\u4e2a\u9879\u76ee\u662f\u5426\u5728\u5e8f\u5217\u4e2d \u957f\u5ea6 <code>len</code> \u8be2\u95ee\u5e8f\u5217\u4e2d\u7684\u9879\u76ee\u6570 \u5207\u7247 [ : ] \u63d0\u53d6\u5e8f\u5217\u7684\u4e00\u90e8\u5206 <p>\u8bf7\u6ce8\u610f\uff0c\u5217\u8868\uff08\u5e8f\u5217\uff09\u7684\u7d22\u5f15\u4ece 0 \u5f00\u59cb\u8ba1\u6570\u3002\u5207\u7247\u64cd\u4f5c <code>my_list[1:3]</code> \u8fd4\u56de\u4e00\u4e2a\u9879\u76ee\u5217\u8868\uff0c\u8be5\u5217\u8868\u4ee5\u7d22\u5f15\u4e3a <code>1</code> \u7684\u9879\u76ee\u5f00\u59cb\uff0c\u76f4\u5230\uff08\u4f46\u4e0d\u5305\u62ec\uff09\u7d22\u5f15\u4e3a\u7684\u9879\u76ee <code>3</code>.</p> <p>\u6709\u65f6\u60a8\u4f1a\u60f3\u8981\u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\u3002 \u8fd9\u53ef\u4ee5\u901a\u8fc7\u91cd\u590d\u6765\u5feb\u901f\u5b8c\u6210\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; my_list = [0] * 6\n&gt;&gt;&gt; my_list\n[0, 0, 0, 0, 0, 0]\n</code></pre> <p>\u4e0e\u91cd\u590d\u8fd0\u7b97\u7b26\u76f8\u5173\u7684\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u95ee\u9898\u662f\uff0c\u7ed3\u679c\u662f\u91cd\u590d\u5bf9\u5e8f\u5217\u4e2d\u7684\u6570\u636e\u5bf9\u8c61\u7684\u5f15\u7528\u3002 \u901a\u8fc7\u8003\u8651\u4ee5\u4e0b\u4f1a\u8bae\u53ef\u4ee5\u6700\u597d\u5730\u770b\u51fa\u8fd9\u4e00\u70b9\uff1a</p> \u53c2\u8003\u6587\u732e\u7684\u91cd\u590d<pre><code>my_list = [1, 2, 3, 4]\nbig_list = [my_list] * 3\nprint(big_list)\nmy_list[2] = 45\nprint(big_list)\n</code></pre> <p>\u53d8\u91cf<code>big_list</code>\u4fdd\u5b58\u5bf9\u539f\u59cb\u5217\u8868<code>my_list</code>\u7684\u4e09\u4e2a\u5f15\u7528\u7684\u96c6\u5408\u3002 \u8bf7\u6ce8\u610f\uff0c\u5bf9 <code>my_list</code> \u7684\u4e00\u4e2a\u5143\u7d20\u7684\u66f4\u6539\u4f1a\u51fa\u73b0\u5728 <code>big_list</code> \u4e2d\u7684\u6240\u6709\u4e09\u4e2a\u4e8b\u4ef6\u4e2d\u3002</p> <p>\u5217\u8868\u652f\u6301\u8bb8\u591a\u7528\u4e8e\u6784\u5efa\u6570\u636e\u7ed3\u6784\u7684\u65b9\u6cd5\u3002 \u201c\u8868 3\u201d\u63d0\u4f9b\u4e86\u6458\u8981\u3002 \u5b83\u4eec\u7684\u4f7f\u7528\u793a\u4f8b\u5982\u4e0b\u3002</p> <p>\u8868 3\uff1aPython \u4e2d\u5217\u8868\u63d0\u4f9b\u7684\u65b9\u6cd5</p> \u65b9\u6cd5\u540d\u79f0 \u7528\u6cd5 \u89e3\u91ca <code>append</code> <code>a_list.append(item)</code> \u5c06\u65b0\u9879\u76ee\u6dfb\u52a0\u5230\u5217\u8868\u672b\u5c3e <code>insert</code> <code>a_list.insert(i,item)</code> \u5728\u5217\u8868\u4e2d\u7684\u7b2c i \u4e2a\u4f4d\u7f6e\u63d2\u5165\u4e00\u4e2a\u9879\u76ee <code>pop</code> <code>a_list.pop()</code> \u5220\u9664\u5e76\u8fd4\u56de\u5217\u8868\u4e2d\u7684\u6700\u540e\u4e00\u9879 <code>pop</code> <code>a_list.pop(i)</code> \u5220\u9664\u5e76\u8fd4\u56de\u5217\u8868\u4e2d\u7684\u7b2c i \u4e2a\u9879\u76ee <code>sort</code> <code>a_list.sort()</code> \u5bf9\u5217\u8868\u8fdb\u884c\u9002\u5f53\u6392\u5e8f <code>reverse</code> <code>a_list.reverse()</code> \u5c06\u5217\u8868\u4fee\u6539\u4e3a\u5012\u5e8f <code>del</code> <code>del a_list[i]</code> \u5220\u9664\u7b2c i \u4e2a\u4f4d\u7f6e\u7684\u9879\u76ee <code>index</code> <code>a_list.index(item)</code> \u8fd4\u56de\u7b2c\u4e00\u6b21\u51fa\u73b0<code>item</code>\u7684\u7d22\u5f15 <code>count</code> <code>a_list.count(item)</code> \u8fd4\u56de<code>item</code>\u51fa\u73b0\u7684\u6b21\u6570 <code>remove</code> <code>a_list.remove(item)</code> \u5220\u9664\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684<code>item</code> \u5217\u8868\u65b9\u6cd5\u7684\u793a\u4f8b<pre><code>my_list = [1024, 3, True, 6.5]\nmy_list.append(False)\nprint(my_list)\nmy_list.insert(2,4.5)\nprint(my_list)\nprint(my_list.pop())\nprint(my_list)\nprint(my_list.pop(1))\nprint(my_list)\nmy_list.pop(2)\nprint(my_list)\nmy_list.sort()\nprint(my_list)\nmy_list.reverse()\nprint(my_list)\nprint(my_list.count(6.5))\nprint(my_list.index(4.5))\nmy_list.remove(6.5)\nprint(my_list)\ndel my_list[0]\nprint(my_list)\n</code></pre> <p>\u60a8\u53ef\u4ee5\u770b\u5230\u67d0\u4e9b\u65b9\u6cd5\uff0c\u4f8b\u5982<code>pop</code>\uff0c\u8fd4\u56de\u4e00\u4e2a\u503c\u5e76\u4fee\u6539\u5217\u8868\u3002 \u5176\u4ed6\u7684\uff0c\u4f8b\u5982<code>reverse</code>\uff0c\u53ea\u662f\u7b80\u5355\u5730\u4fee\u6539\u5217\u8868\uff0c\u6ca1\u6709\u8fd4\u56de\u503c\u3002 <code>pop</code> \u5c06\u9ed8\u8ba4\u4f4d\u4e8e\u5217\u8868\u672b\u5c3e\uff0c\u4f46\u4e5f\u53ef\u4ee5\u5220\u9664\u5e76\u8fd4\u56de\u7279\u5b9a\u9879\u76ee\u3002 \u8fd9\u4e9b\u65b9\u6cd5\u518d\u6b21\u4f7f\u7528\u4ece 0 \u5f00\u59cb\u7684\u7d22\u5f15\u8303\u56f4\u3002 \u60a8\u8fd8\u5e94\u8be5\u6ce8\u610f\u5230\u719f\u6089\u7684\u201c\u70b9(.)\u201d\u8868\u793a\u6cd5\uff0c\u7528\u4e8e\u8981\u6c42\u5bf9\u8c61\u8c03\u7528\u65b9\u6cd5\u3002 <code>my_list.append(False)</code> \u53ef\u4ee5\u7406\u89e3\u4e3a\u201c\u8981\u6c42\u5bf9\u8c61 <code>my_list</code> \u6267\u884c\u5176 <code>append</code> \u65b9\u6cd5\u5e76\u5411\u5176\u53d1\u9001\u503c <code>False</code>\u3002 \u5373\u4f7f\u662f\u7b80\u5355\u7684\u6570\u636e\u5bf9\u8c61\uff08\u4f8b\u5982\u6574\u6570\uff09\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u8c03\u7528\u65b9\u6cd5\u3002</p> <pre><code>&gt;&gt;&gt; (54).__add__(21)\n75\n</code></pre> <p>\u5728\u8fd9\u4e2a\u7247\u6bb5\u4e2d\uff0c\u6211\u4eec\u8981\u6c42\u6574\u6570\u5bf9\u8c61<code>54</code>\u6267\u884c\u5176<code>add</code>\u65b9\u6cd5\uff08\u5728Python\u4e2d\u79f0\u4e3a<code>__add__</code>\uff09\u5e76\u5c06\u5176\u4f20\u9012<code>21</code>\u4f5c\u4e3a\u8981\u6dfb\u52a0\u7684\u503c\u3002 \u7ed3\u679c\u662f\u603b\u548c<code>75</code>\u3002 \u5f53\u7136\uff0c\u6211\u4eec\u901a\u5e38\u5199\u6210<code>54+21</code>\u3002 \u6211\u4eec\u5c06\u5728\u672c\u8282\u540e\u9762\u8be6\u7ec6\u4ecb\u7ecd\u8fd9\u4e9b\u65b9\u6cd5\u3002</p> <p>\u7ecf\u5e38\u4e0e\u5217\u8868\u4e00\u8d77\u8ba8\u8bba\u7684\u4e00\u79cd\u5e38\u89c1 Python \u51fd\u6570\u662f<code>range</code>\u51fd\u6570\u3002 <code>range</code> \u751f\u6210\u4e00\u4e2a\u8868\u793a\u503c\u5e8f\u5217\u7684\u8303\u56f4\u5bf9\u8c61\u3002 \u901a\u8fc7\u4f7f\u7528<code>list</code>\u51fd\u6570\uff0c\u53ef\u4ee5\u5c06\u8303\u56f4\u5bf9\u8c61\u7684\u503c\u89c6\u4e3a\u5217\u8868\u3002 \u5982\u4e0b\u56fe\u6240\u793a\u3002</p> <pre><code>&gt;&gt;&gt; range(10)\nrange(0, 10)\n&gt;&gt;&gt; list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; range(5, 10)\nrange(5, 10)\n&gt;&gt;&gt; list(range(5, 10))\n[5, 6, 7, 8, 9]\n&gt;&gt;&gt; list(range(5, 10, 2))\n[5, 7, 9]\n&gt;&gt;&gt; list(range(10, 1, -1))\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n</code></pre> <p>range \u5bf9\u8c61\u8868\u793a\u4e00\u4e2a\u6574\u6570\u5e8f\u5217\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b83\u5c06\u4ece 0 \u5f00\u59cb\u3002\u5982\u679c\u60a8\u63d0\u4f9b\u66f4\u591a\u53c2\u6570\uff0c\u5b83\u5c06\u5728\u7279\u5b9a\u70b9\u5f00\u59cb\u548c\u7ed3\u675f\uff0c\u751a\u81f3\u53ef\u4ee5\u8df3\u8fc7\u9879\u76ee\u3002 \u5728\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a\u793a\u4f8b\u4e2d\uff0c<code>range(10)</code>\uff0c\u5e8f\u5217\u4ece 0 \u5f00\u59cb\uff0c\u4e00\u76f4\u4e0a\u5347\u5230\u4f46\u4e0d\u5305\u62ec 10\u3002\u5728\u6211\u4eec\u7684\u7b2c\u4e8c\u4e2a\u793a\u4f8b\u4e2d\uff0c<code>range(5, 10)</code>\u4ece 5 \u5f00\u59cb\uff0c\u4e00\u76f4\u4e0a\u5347 \u5230\u4f46\u4e0d\u5305\u62ec 10\u3002<code>range(5, 10, 2)</code> \u6267\u884c\u7c7b\u4f3c\uff0c\u4f46\u8df3\u8fc7\u4e24\u4e2a\uff08\u540c\u6837\uff0c\u4e0d\u5305\u62ec 10\uff09\u3002</p> <p>A <code>list</code> is an ordered collection of zero or more references to Python data objects. Lists are written as comma-delimited values enclosed in square brackets. The empty list is simply <code>[ ]</code>. Lists are heterogeneous, meaning that the data objects need not all be from the same class and the collection can be assigned to a variable as below. The following fragment shows a variety of Python data objects in a list.</p> <pre><code>&gt;&gt;&gt; [1, 3, True, 6.5]\n[1, 3, True, 6.5]\n&gt;&gt;&gt; my_list = [1, 3, True, 6.5]\n&gt;&gt;&gt; my_list\n[1, 3, True, 6.5]\n</code></pre> <p>Note that when Python evaluates a list, the list itself is returned. However, in order to remember the list for later processing, its reference needs to be assigned to a variable.</p> <p>Since lists are considered to be sequentially ordered, they support a number of operations that can be applied to any Python sequence. Table 2 reviews these operations and the following session gives examples of their use.</p> <p>Table 2: Operations on Any Sequence in Python</p> Operation Name Operator Explanation indexing [ ] Access an element of a sequence concatenation + Combine sequences together repetition * Concatenate a repeated number of times membership in Ask whether an item is in a sequence length len Ask the number of items in the sequence slicing [ : ] Extract a part of a sequence <p>Note that the indices for lists (sequences) start counting with 0. The slice operation my_list[1:3] returns a list of items starting with the item indexed by 1 up to---but not including---the item indexed by 3.</p> <p>Sometimes you will want to initialize a list. This can quickly be accomplished by using repetition. For example,</p> <pre><code>&gt;&gt;&gt; my_list = [0] * 6\n&gt;&gt;&gt; my_list\n[0, 0, 0, 0, 0, 0]\n</code></pre> <p>One very important aside relating to the repetition operator is that the result is a repetition of references to the data objects in the sequence. This can best be seen by considering the following session:</p> Activity: 1.8.2.1 Repetition of References<pre><code>my_list = [1, 2, 3, 4]\nbig_list = [my_list] * 3\nprint(big_list)\nmy_list[2] = 45\nprint(big_list)\n</code></pre> <p>The variable <code>big_list</code> holds a collection of three references to the original list called <code>my_list</code>. Note that a change to one element of <code>my_list</code> shows up in all three occurrences in <code>big_list</code>.</p> <p>Lists support a number of methods that will be used to build data structures. <code>Table\u00a03</code> provides a summary. Examples of their use follow.</p> <p>Table 3: Methods Provided by Lists in Python</p> Method Name Use Explanation <code>append</code> <code>a_list.append(item)</code> Adds a new item to the end of a list <code>insert</code> <code>a_list.insert(i,item)</code> Inserts an item at the ith position in a list <code>pop</code> <code>a_list.pop()</code> Removes and returns the last item in a list <code>pop</code> <code>a_list.pop(i)</code> Removes and returns the ith item in a list <code>sort</code> <code>a_list.sort()</code> Sorts a list in place <code>reverse</code> <code>a_list.reverse()</code> Modifies a list to be in reverse order <code>del</code> <code>del a_list[i]</code> Deletes the item in the ith position <code>index</code> <code>a_list.index(item)</code> Returns the index of the first occurrence of <code>item</code> <code>count</code> <code>a_list.count(item)</code> Returns the number of occurrences of <code>item</code> <code>remove</code> <code>a_list.remove(item)</code> Removes the first occurrence of <code>item</code> Activity: 1.8.2.2 Examples of List Methods<pre><code>my_list = [1024, 3, True, 6.5]\nmy_list.append(False)\nprint(my_list)\nmy_list.insert(2,4.5)\nprint(my_list)\nprint(my_list.pop())\nprint(my_list)\nprint(my_list.pop(1))\nprint(my_list)\nmy_list.pop(2)\nprint(my_list)\nmy_list.sort()\nprint(my_list)\nmy_list.reverse()\nprint(my_list)\nprint(my_list.count(6.5))\nprint(my_list.index(4.5))\nmy_list.remove(6.5)\nprint(my_list)\ndel my_list[0]\nprint(my_list)\n</code></pre> <p>You can see that some of the methods, such as <code>pop</code>, return a value and also modify the list. Others, such as <code>reverse</code>, simply modify the list with no return value. <code>pop</code> will default to the end of the list but can also remove and return a specific item. The index range starting from 0 is again used for these methods. You should also notice the familiar \u201cdot\u201d notation for asking an object to invoke a method. <code>my_list.append(False)</code> can be read as \u201cask the object <code>my_list</code> to perform its <code>append</code> method and send it the value <code>False</code>.\u201d Even simple data objects such as integers can invoke methods in this way.</p> <pre><code>&gt;&gt;&gt; (54).__add__(21)\n75\n</code></pre> <p>In this fragment we are asking the integer object <code>54</code> to execute its <code>add</code> method (called <code>__add__</code> in Python) and passing it <code>21</code> as the value to add. The result is the sum, <code>75</code>. Of course, we usually write this as <code>54+21</code>. We will say much more about these methods later in this section.</p> <p>One common Python function that is often discussed in conjunction with lists is the <code>range</code> function. <code>range</code> produces a range object that represents a sequence of values. By using the <code>list</code> function, it is possible to see the value of the range object as a list. This is illustrated below.</p> <pre><code>&gt;&gt;&gt; range(10)\nrange(0, 10)\n&gt;&gt;&gt; list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; range(5, 10)\nrange(5, 10)\n&gt;&gt;&gt; list(range(5, 10))\n[5, 6, 7, 8, 9]\n&gt;&gt;&gt; list(range(5, 10, 2))\n[5, 7, 9]\n&gt;&gt;&gt; list(range(10, 1, -1))\n[10, 9, 8, 7, 6, 5, 4, 3, 2]\n</code></pre> <p>The range object represents a sequence of integers. By default, it will start with 0. If you provide more parameters, it will start and end at particular points and can even skip items. In our first example, <code>range(10)</code>, the sequence starts with 0 and goes up to but does not include 10. In our second example, <code>range(5, 10)</code> starts at 5 and goes up to but does not include 10. <code>range(5, 10, 2)</code> performs similarly but skips by twos (again, 10 is not included).</p>"},{"location":"c1/s8/#strings","title":"Strings","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5b57\u7b26\u4e32(Strings)\u662f\u96f6\u4e2a\u6216\u591a\u4e2a\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u5176\u4ed6\u7b26\u53f7\u7684\u8fde\u7eed\u96c6\u5408\u3002 \u6211\u4eec\u5c06\u8fd9\u4e9b\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u5176\u4ed6\u7b26\u53f7\u79f0\u4e3a\u5b57\u7b26\u3002 \u6587\u5b57\u5b57\u7b26\u4e32\u503c\u901a\u8fc7\u4f7f\u7528\u5f15\u53f7\uff08\u5355\u5f15\u53f7\u6216\u53cc\u5f15\u53f7\uff09\u4e0e\u6807\u8bc6\u7b26\u533a\u5206\u5f00\u6765\u3002</p> <pre><code>&gt;&gt;&gt; \"David\"\n'David'\n&gt;&gt;&gt; my_name = \"David\"\n&gt;&gt;&gt; my_name[3]\n'i'\n&gt;&gt;&gt; my_name * 2\n'DavidDavid'\n&gt;&gt;&gt; len(my_name)\n5\n</code></pre> <p>\u7531\u4e8e\u5b57\u7b26\u4e32\u662f\u5e8f\u5217\uff0c\u56e0\u6b64\u4e0a\u8ff0\u6240\u6709\u5e8f\u5217\u64cd\u4f5c\u90fd\u6309\u60a8\u7684\u9884\u671f\u5de5\u4f5c\u3002 \u6b64\u5916\uff0c\u5b57\u7b26\u4e32\u8fd8\u6709\u8bb8\u591a\u65b9\u6cd5\uff0c\u5176\u4e2d\u4e00\u4e9b\u65b9\u6cd5\u5982\u201c\u8868 4\u201d\u6240\u793a\u3002</p> <p>\u8868 4\uff1aPython \u4e2d\u5b57\u7b26\u4e32\u63d0\u4f9b\u7684\u65b9\u6cd5</p> \u65b9\u6cd5\u540d\u79f0 \u7528\u6cd5 \u89e3\u91ca <code>center</code> <code>a_string.center(w)</code> \u8fd4\u56de\u4ee5\u5927\u5c0f\u4e3a<code>w</code>\u7684\u5b57\u6bb5\u4e3a\u4e2d\u5fc3\u7684\u5b57\u7b26\u4e32 <code>count</code> <code>a_string.count(item)</code> \u8fd4\u56de\u5b57\u7b26\u4e32\u4e2d<code>item</code>\u51fa\u73b0\u7684\u6b21\u6570 <code>ljust</code> <code>a_string.ljust(w)</code> \u8fd4\u56de\u5728\u5927\u5c0f\u4e3a<code>w</code>\u7684\u5b57\u6bb5\u4e2d\u5de6\u5bf9\u9f50\u7684\u5b57\u7b26\u4e32 <code>lower</code> <code>a_string.lower()</code> \u8fd4\u56de\u5168\u5c0f\u5199\u7684\u5b57\u7b26\u4e32 <code>rjust</code> <code>a_string.rjust(w)</code> \u8fd4\u56de\u5728\u5927\u5c0f\u4e3a<code>w</code>\u7684\u5b57\u6bb5\u4e2d\u53f3\u5bf9\u9f50\u7684\u5b57\u7b26\u4e32 <code>find</code> <code>a_string.find(item)</code> \u8fd4\u56de\u7b2c\u4e00\u6b21\u51fa\u73b0<code>item</code>\u7684\u7d22\u5f15 <code>split</code> <code>a_string.split(s_char)</code> \u5c06\u5b57\u7b26\u4e32\u62c6\u5206\u4e3a <code>s_char</code> \u5904\u7684\u5b50\u5b57\u7b26\u4e32 <p>\u5176\u4e2d\uff0c<code>split</code>\u5bf9\u4e8e\u5904\u7406\u6570\u636e\u975e\u5e38\u6709\u7528\u3002 <code>split</code> \u5c06\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u5e76\u4f7f\u7528\u5206\u5272\u5b57\u7b26\u4f5c\u4e3a\u5206\u5272\u70b9\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u5217\u8868\u3002 \u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>v</code>\u662f\u5212\u5206\u70b9\u3002 \u5982\u679c\u672a\u6307\u5b9a\u9664\u6cd5\uff0c\u5219 <code>split</code> \u65b9\u6cd5\u5c06\u67e5\u627e\u7a7a\u767d\u5b57\u7b26\uff0c\u4f8b\u5982\u5236\u8868\u7b26\u3001\u6362\u884c\u7b26\u548c\u7a7a\u683c\u3002</p> <pre><code>&gt;&gt;&gt; my_name\n'David'\n&gt;&gt;&gt; my_name.upper()\n'DAVID'\n&gt;&gt;&gt; my_name.center(10)\n'  David   '\n&gt;&gt;&gt; my_name.find(\"v\")\n2\n&gt;&gt;&gt; my_name.split(\"v\")\n['Da', 'id']\n</code></pre> <p>\u5217\u8868\u548c\u5b57\u7b26\u4e32\u4e4b\u95f4\u7684\u4e3b\u8981\u533a\u522b\u662f\u5217\u8868\u53ef\u4ee5\u4fee\u6539\uff0c\u800c\u5b57\u7b26\u4e32\u5219\u4e0d\u80fd\u3002 \u8fd9\u79f0\u4e3a\u53ef\u53d8\u6027\u3002 \u5217\u8868\u662f\u53ef\u53d8\u7684\uff1b \u5b57\u7b26\u4e32\u662f\u4e0d\u53ef\u53d8\u7684\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u7d22\u5f15\u548c\u5206\u914d\u6765\u66f4\u6539\u5217\u8868\u4e2d\u7684\u9879\u76ee\u3002 \u5bf9\u4e8e\u4e0d\u5141\u8bb8\u66f4\u6539\u7684\u5b57\u7b26\u4e32\uff0c\u5982\u4e0b\u6240\u793a\u3002</p> <pre><code>&gt;&gt;&gt; my_list\n[1, 3, True, 6.5]\n&gt;&gt;&gt; my_list[0] = 2 ** 10\n&gt;&gt;&gt; my_list\n[1024, 3, True, 6.5]\n&gt;&gt;&gt;\n&gt;&gt;&gt; my_name\n'David'\n&gt;&gt;&gt; my_name[0] = \"X\"\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\n</code></pre> <p>Strings are sequential collections of zero or more letters, numbers, and other symbols. We call these letters, numbers, and other symbols characters. Literal string values are differentiated from identifiers by using quotation marks (either single or double).</p> <pre><code>&gt;&gt;&gt; \"David\"\n'David'\n&gt;&gt;&gt; my_name = \"David\"\n&gt;&gt;&gt; my_name[3]\n'i'\n&gt;&gt;&gt; my_name * 2\n'DavidDavid'\n&gt;&gt;&gt; len(my_name)\n5\n</code></pre> <p>Since strings are sequences, all of the sequence operations described above work as you would expect. In addition, strings have a number of methods, some of which are shown in <code>Table\u00a04</code>.</p> <p>Table 4: Methods Provided by Strings in Python</p> Method Name Use Explanation <code>center</code> <code>a_string.center(w)</code> Returns a string centered in a field of size <code>w</code> <code>count</code> <code>a_string.count(item)</code> Returns the number of occurrences of <code>item</code> in the string <code>ljust</code> <code>a_string.ljust(w)</code> Returns a string left-justified in a field of size <code>w</code> <code>lower</code> <code>a_string.lower()</code> Returns a string in all lowercase <code>rjust</code> <code>a_string.rjust(w)</code> Returns a string right-justified in a field of size <code>w</code> <code>find</code> <code>a_string.find(item)</code> Returns the index of the first occurrence of <code>item</code> <code>split</code> <code>a_string.split(s_char)</code> Splits a string into substrings at <code>s_char</code> <p>Of these, <code>split</code> will be very useful for processing data. <code>split</code> will take a string and return a list of strings using the split character as a division point. In the example below, \u201cv\u201d is the division point. If no division is specified, the split method looks for whitespace characters such as tab, newline, and space.</p> <pre><code>&gt;&gt;&gt; my_name\n'David'\n&gt;&gt;&gt; my_name.upper()\n'DAVID'\n&gt;&gt;&gt; my_name.center(10)\n'  David   '\n&gt;&gt;&gt; my_name.find(\"v\")\n2\n&gt;&gt;&gt; my_name.split(\"v\")\n['Da', 'id']\n</code></pre> <p>A major difference between lists and strings is that lists can be modified while strings cannot. This is referred to as mutability. Lists are mutable; strings are immutable. For example, you can change an item in a list by using indexing and assignment. With a string that change is not allowed, as shown below.</p> <pre><code>&gt;&gt;&gt; my_list\n[1, 3, True, 6.5]\n&gt;&gt;&gt; my_list[0] = 2 ** 10\n&gt;&gt;&gt; my_list\n[1024, 3, True, 6.5]\n&gt;&gt;&gt;\n&gt;&gt;&gt; my_name\n'David'\n&gt;&gt;&gt; my_name[0] = \"X\"\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\n</code></pre>"},{"location":"c1/s8/#tuples","title":"Tuples","text":"\u4e2d\u6587\u82f1\u6587 <p>\u5143\u7ec4(Tuples)\u4e0e\u5217\u8868\u975e\u5e38\u76f8\u4f3c\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u5f02\u6784\u6570\u636e\u5e8f\u5217\u3002 \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5143\u7ec4\u662f\u4e0d\u53ef\u53d8\u7684\uff0c\u5c31\u50cf\u5b57\u7b26\u4e32\u4e00\u6837\u3002 \u5143\u7ec4\u65e0\u6cd5\u66f4\u6539\u3002 \u5143\u7ec4\u88ab\u5199\u4e3a\u62ec\u5728\u62ec\u53f7\u4e2d\u7684\u9017\u53f7\u5206\u9694\u503c\u3002 \u4f5c\u4e3a\u5e8f\u5217\uff0c\u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u4efb\u4f55\u64cd\u4f5c\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; my_tuple = (2, True, 4.96)\n&gt;&gt;&gt; my_tuple\n(2, True, 4.96)\n&gt;&gt;&gt; len(my_tuple)\n3\n&gt;&gt;&gt; my_tuple[0]\n2\n&gt;&gt;&gt; my_tuple * 3\n(2, True, 4.96, 2, True, 4.96, 2, True, 4.96)\n&gt;&gt;&gt; my_tuple[0:2]\n(2, True)\n</code></pre> <p>\u4f46\u662f\uff0c\u5982\u679c\u60a8\u5c1d\u8bd5\u66f4\u6539\u5143\u7ec4\u4e2d\u7684\u9879\u76ee\uff0c\u5219\u4f1a\u6536\u5230\u9519\u8bef\u3002 \u8bf7\u6ce8\u610f\uff0c\u9519\u8bef\u6d88\u606f\u63d0\u4f9b\u4e86\u95ee\u9898\u7684\u4f4d\u7f6e\u548c\u539f\u56e0\u3002</p> <pre><code>&gt;&gt;&gt; my_tuple[1] = False\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code></pre> <p>Tuples are very similar to lists in that they are heterogeneous sequences of data. The difference is that a tuple is immutable, like a string. A tuple cannot be changed. Tuples are written as comma-delimited values enclosed in parentheses. As sequences, they can use any operation described above. For example,</p> <pre><code>&gt;&gt;&gt; my_tuple = (2, True, 4.96)\n&gt;&gt;&gt; my_tuple\n(2, True, 4.96)\n&gt;&gt;&gt; len(my_tuple)\n3\n&gt;&gt;&gt; my_tuple[0]\n2\n&gt;&gt;&gt; my_tuple * 3\n(2, True, 4.96, 2, True, 4.96, 2, True, 4.96)\n&gt;&gt;&gt; my_tuple[0:2]\n(2, True)\n</code></pre> <p>However, if you try to change an item in a tuple, you will get an error. Note that the error message provides the location and reason for the problem.</p> <pre><code>&gt;&gt;&gt; my_tuple[1] = False\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code></pre>"},{"location":"c1/s8/#set","title":"set","text":"\u4e2d\u6587\u82f1\u6587 <p>\u96c6\u5408(set) \u662f\u96f6\u4e2a\u6216\u591a\u4e2a\u4e0d\u53ef\u53d8 Python \u6570\u636e\u5bf9\u8c61\u7684\u65e0\u5e8f\u96c6\u5408\u3002 \u96c6\u5408\u4e0d\u5141\u8bb8\u91cd\u590d\uff0c\u5e76\u4e14\u88ab\u5199\u4e3a\u7528\u5927\u62ec\u53f7\u62ec\u8d77\u6765\u7684\u9017\u53f7\u5206\u9694\u503c\u3002 \u7a7a\u96c6\u7531<code>set()</code>\u8868\u793a\u3002 \u96c6\u5408\u662f\u5f02\u6784\u7684\uff0c\u96c6\u5408\u53ef\u4ee5\u5206\u914d\u7ed9\u53d8\u91cf\uff0c\u5982\u4e0b\u6240\u793a\u3002</p> <pre><code>&gt;&gt;&gt; {3, 6, \"cat\", 4.5, False}\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; my_set = {3, 6, \"cat\", 4.5, False}\n&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n</code></pre> <p>\u5c3d\u7ba1\u96c6\u5408\u4e0d\u88ab\u8ba4\u4e3a\u662f\u8fde\u7eed\u7684\uff0c\u4f46\u5b83\u4eec\u786e\u5b9e\u652f\u6301\u524d\u9762\u4ecb\u7ecd\u7684\u4e00\u4e9b\u719f\u6089\u7684\u64cd\u4f5c\u3002 <code>\u8868 5</code> \u56de\u987e\u4e86\u8fd9\u4e9b\u64cd\u4f5c\uff0c\u4e0b\u9762\u7684\u4f1a\u8bae\u7ed9\u51fa\u4e86\u5b83\u4eec\u7684\u4f7f\u7528\u793a\u4f8b\u3002</p> <p>\u8868 5\uff1aPython \u4e2d\u96c6\u5408\u7684\u64cd\u4f5c</p> \u8fd0\u7b97\u7b26\u540d\u79f0 \u8fd0\u7b97\u7b26 \u89e3\u91ca \u9879 <code>in</code> \u65f6\u5019\u4e3a\u96c6\u5408\u4e2d\u7684\u9879 \u957f\u5ea6 <code>len</code> \u8fd4\u56de\u96c6\u5408\u7684\u957f\u5ea6 <code>|</code> <code>a_set                                                          | other_set</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u5305\u542b\u4e24\u4e2a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 <code>&amp;</code> <code>a_set &amp; other_set</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u4ec5\u5305\u542b\u4e24\u4e2a\u96c6\u5408\u5171\u6709\u7684\u5143\u7d20 <code>-</code> <code>a_set - other_set</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u5305\u542b\u7b2c\u4e00\u4e2a\u96c6\u5408\u4e2d\u4e0d\u5c5e\u4e8e\u7b2c\u4e8c\u4e2a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u9879\u76ee <code>&lt;=</code> <code>a_set &lt;= other_set</code> \u8be2\u95ee\u7b2c\u4e00\u4e2a\u96c6\u5408\u7684\u6240\u6709\u5143\u7d20\u662f\u5426\u90fd\u5728\u7b2c\u4e8c\u4e2a\u96c6\u5408\u4e2d <pre><code>&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; len(my_set)\n5\n&gt;&gt;&gt; False in my_set\nTrue\n&gt;&gt;&gt; \"dog\" in my_set\nFalse\n</code></pre> <p>\u96c6\u5408\u652f\u6301\u8bb8\u591a\u65b9\u6cd5\uff0c\u90a3\u4e9b\u5728\u6570\u5b66\u73af\u5883\u4e2d\u4f7f\u7528\u8fc7\u96c6\u5408\u7684\u4eba\u5e94\u8be5\u719f\u6089\u8fd9\u4e9b\u65b9\u6cd5\u3002 \u8868 6 \u63d0\u4f9b\u4e86\u6458\u8981\u3002 \u5b83\u4eec\u7684\u4f7f\u7528\u793a\u4f8b\u5982\u4e0b\u3002 \u8bf7\u6ce8\u610f\uff0c<code>union</code>\u3001<code>intersection</code>\u3001<code>issubset</code>\u548c<code>difference</code>\u90fd\u5177\u6709\u53ef\u4ee5\u4f7f\u7528\u7684\u8fd0\u7b97\u7b26\u3002</p> <p>\u8868 6\uff1aPython \u4e2d\u96c6\u5408\u63d0\u4f9b\u7684\u65b9\u6cd5</p> \u65b9\u6cd5\u540d\u79f0 \u7528\u6cd5 \u89e3\u91ca <code>union</code> <code>a_set.union(other_set)</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u5305\u542b\u4e24\u4e2a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20 <code>intersection</code> <code>a_set.intersection(other_set)</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u4ec5\u5305\u542b\u4e24\u4e2a\u96c6\u5408\u5171\u6709\u7684\u5143\u7d20 <code>difference</code> <code>a_set.difference(other_set)</code> \u8fd4\u56de\u4e00\u4e2a\u65b0\u96c6\u5408\uff0c\u5176\u4e2d\u5305\u542b\u7b2c\u4e00\u4e2a\u96c6\u5408\u4e2d\u4e0d\u5c5e\u4e8e\u7b2c\u4e8c\u4e2a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u9879\u76ee <code>issubset</code> <code>a_set.issubset(othe_rset)</code> \u8be2\u95ee\u4e00\u4e2a\u96c6\u5408\u7684\u6240\u6709\u5143\u7d20\u662f\u5426\u90fd\u5728\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d <code>add</code> <code>a_set.add(item)</code> \u5c06\u9879\u76ee\u6dfb\u52a0\u5230\u96c6\u5408\u4e2d <code>remove</code> <code>a_set.remove(item)</code> \u4ece\u96c6\u5408\u4e2d\u5220\u9664\u9879\u76ee <code>pop</code> <code>a_set.pop()</code> \u4ece\u96c6\u5408\u4e2d\u5220\u9664\u4efb\u610f\u5143\u7d20 <code>clear</code> <code>a_set.clear()</code> \u4ece\u96c6\u5408\u4e2d\u5220\u9664\u6240\u6709\u5143\u7d20 <pre><code>&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; your_set = {99, 3, 100}\n&gt;&gt;&gt; my_set.union(your_set)\n{False, 3, 4.5, 'cat', 6, 99, 100}\n&gt;&gt;&gt; my_set | your_set\n{False, 3, 4.5, 'cat', 6, 99, 100}\n&gt;&gt;&gt; my_set.intersection(your_set)\n{3}\n&gt;&gt;&gt; my_set &amp; your_set\n{3}\n&gt;&gt;&gt; my_set.difference(your_set)\n{False, 'cat', 4.5, 6}\n&gt;&gt;&gt; my_set - your_set\n{False, 'cat', 4.5, 6}\n&gt;&gt;&gt; {3, 100}.issubset(your_set)\nTrue\n&gt;&gt;&gt; {3, 100} &lt;= your_set\nTrue\n&gt;&gt;&gt; my_set.add(\"house\")\n&gt;&gt;&gt; my_set\n{False, 'house', 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; my_set.remove(4.5)\n&gt;&gt;&gt; my_set\n{False, 'house', 3, 6, 'cat'}\n&gt;&gt;&gt; my_set.pop()\nFalse\n&gt;&gt;&gt; my_set\n{'house', 3, 6, 'cat'}\n&gt;&gt;&gt; my_set.clear()\n&gt;&gt;&gt; my_set\nset()\n</code></pre> <p>\u6211\u4eec\u6700\u7ec8\u7684 Python \u96c6\u5408\u662f\u4e00\u4e2a\u65e0\u5e8f\u7ed3\u6784\uff0c\u79f0\u4e3a \u5b57\u5178\u3002 \u5b57\u5178\u662f\u76f8\u5173\u9879\u76ee\u5bf9\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u6bcf\u5bf9\u90fd\u5305\u542b\u4e00\u4e2a\u952e\u548c\u4e00\u4e2a\u503c\u3002 \u8be5\u952e\u503c\u5bf9\u901a\u5e38\u5199\u4e3a\u952e\uff1a\u503c\u3002 \u5b57\u5178\u4ee5\u9017\u53f7\u5206\u9694\u7684\u952e\uff1a\u503c\u5bf9\u5f62\u5f0f\u7f16\u5199\uff0c\u5e76\u62ec\u5728\u5927\u62ec\u53f7\u4e2d\u3002 \u4f8b\u5982\uff0c</p> <pre><code>&gt;&gt;&gt; capitals = {\"Iowa\": \"Des Moines\", \"Wisconsin\": \"Madison\"}\n&gt;&gt;&gt; capitals\n{'Iowa': 'Des Moines', 'Wisconsin': 'Madison'}\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u952e\u8bbf\u95ee\u503c\u6216\u6dfb\u52a0\u53e6\u4e00\u4e2a\u952e\u503c\u5bf9\u6765\u64cd\u4f5c\u5b57\u5178\u3002 \u8bbf\u95ee\u7684\u8bed\u6cd5\u770b\u8d77\u6765\u5f88\u50cf\u5e8f\u5217\u8bbf\u95ee\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u4e0d\u4f7f\u7528\u9879\u76ee\u7684\u7d22\u5f15\uff0c\u800c\u662f\u4f7f\u7528\u952e\u503c\u3002 \u6dfb\u52a0\u65b0\u503c\u4e5f\u662f\u7c7b\u4f3c\u7684\u3002</p> Using a Dictionary<pre><code>capitals = {\"Iowa\": \"Des Moines\", \"Wisconsin\": \"Madison\"}\nprint(capitals[\"Iowa\"])\ncapitals[\"Utah\"] = \"Salt Lake City\"\nprint(capitals)\ncapitals[\"California\"] = \"Sacramento\"\nprint(len(capitals))\nfor k in capitals:\n    print(capitals[k],\"is the capital of\", k)\n</code></pre> <p>\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5728 Python 3.6 \u4e4b\u524d\uff0c\u5b57\u5178\u7684\u7ef4\u62a4\u987a\u5e8f\u4e0e\u952e\u6ca1\u6709\u7279\u5b9a\u7684\u987a\u5e8f\u3002 \u6dfb\u52a0\u7684\u7b2c\u4e00\u5bf9 (<code>\"Utah\":</code> <code>\"Salt Lake City\"</code>) \u5c06\u653e\u5728\u5b57\u5178\u4e2d\u7684\u7b2c\u4e00\u4f4d\uff0c\u6dfb\u52a0\u7684\u7b2c\u4e8c\u5bf9 (<code>\"California\":</code> <code>\"Sacramento\"</code>) \u5c06\u653e\u5728\u6700\u540e\u3002 \u952e\u7684\u653e\u7f6e\u53d6\u51b3\u4e8e \u6563\u5217 \u7684\u601d\u60f3\uff0c\u8fd9\u5c06\u5728\u7b2c 5 \u7ae0\u4e2d\u66f4\u8be6\u7ec6\u5730\u89e3\u91ca\u3002\u81ea Python 3.6 \u4ee5\u6765\uff0c\u5b57\u5178\u786e\u5b9e\u4fdd\u6301\u987a\u5e8f\uff0c\u56e0\u6b64\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u5bf9\u6309\u7167\u5b83\u4eec\u5728\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u987a\u5e8f\u51fa\u73b0\u3002 \u6dfb\u52a0\u3002 \u6211\u4eec\u8fd8\u5c55\u793a\u4e86\u957f\u5ea6\u51fd\u6570\uff0c\u5176\u4f5c\u7528\u4e0e\u5176\u4ed6\u96c6\u5408\u76f8\u540c\u3002</p> <p>\u5b57\u5178\u65e2\u6709\u65b9\u6cd5\u53c8\u6709\u8fd0\u7b97\u7b26\u3002 \u201c\u8868 7\u201d\u548c\u201c\u8868 8\u201d\u5bf9\u5b83\u4eec\u8fdb\u884c\u4e86\u63cf\u8ff0\uff0c\u4f1a\u8bae\u5c55\u793a\u4e86\u5b83\u4eec\u7684\u5b9e\u9645\u5e94\u7528\u3002 <code>keys</code>\u3001<code>values</code>\u548c<code>items</code>\u65b9\u6cd5\u90fd\u8fd4\u56de\u5305\u542b\u611f\u5174\u8da3\u503c\u7684\u5bf9\u8c61\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528<code>list</code>\u51fd\u6570\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u5217\u8868\u3002 \u60a8\u8fd8\u5c06\u770b\u5230<code>get</code>\u65b9\u6cd5\u6709\u4e24\u79cd\u53d8\u4f53\u3002 \u5982\u679c\u5b57\u5178\u4e2d\u4e0d\u5b58\u5728\u8be5\u952e\uff0c<code>get</code>\u5c06\u8fd4\u56de<code>None</code>\u3002 \u4f46\u662f\uff0c\u7b2c\u4e8c\u4e2a\u53ef\u9009\u53c2\u6570\u53ef\u4ee5\u6307\u5b9a\u8fd4\u56de\u503c\u3002</p> <p>\u8868 7\uff1aPython \u4e2d\u5b57\u5178\u63d0\u4f9b\u7684\u8fd0\u7b97\u7b26</p> \u8fd0\u7b97\u7b26 \u7528\u6cd5 \u89e3\u91ca <code>[]</code> <code>a_dict[k]</code> \u8fd4\u56de\u4e0e<code>k</code>\u5173\u8054\u7684\u503c\uff0c\u5426\u5219\u9519\u8bef <code>in</code> <code>key in a_dict</code> \u5982\u679c\u952e\u5728\u5b57\u5178\u4e2d\u5219\u8fd4\u56de<code>True</code>\uff0c\u5426\u5219\u8fd4\u56de<code>False</code> <code>del</code> del <code>a_dict[key]</code> \u4ece\u5b57\u5178\u4e2d\u5220\u9664\u6761\u76ee <p>\u8868 8\uff1aPython \u4e2d\u5b57\u5178\u63d0\u4f9b\u7684\u65b9\u6cd5</p> \u65b9\u6cd5\u540d\u79f0 \u7528\u6cd5 \u89e3\u91ca <code>keys</code> <code>a_dict.keys()</code> \u8fd4\u56de dict_keys \u5bf9\u8c61\u4e2d\u5b57\u5178\u7684\u952e <code>values</code> <code>a_dict.values()</code> \u8fd4\u56de dict_values \u5bf9\u8c61\u4e2d\u5b57\u5178\u7684\u503c <code>items</code> <code>a_dict.items()</code> \u8fd4\u56de dict_items \u5bf9\u8c61\u4e2d\u7684\u952e\u503c\u5bf9 <code>get</code> <code>a_dict.get(k)</code> \u8fd4\u56de\u4e0e<code>k</code>\u76f8\u5173\u7684\u503c\uff0c\u5426\u5219\u8fd4\u56de<code>None</code> <code>get</code> <code>a_dict.get(k, alt)</code> \u5426\u5219\u8fd4\u56de\u4e0e<code>k</code>\u3001<code>alt</code>\u5173\u8054\u7684\u503c <pre><code>&gt;&gt;&gt; phone_ext={\"david\": 1410, \"brad\": 1137, \"roman\": 1171}\n&gt;&gt;&gt; phone_ext\n{'david': 1410, 'brad': 1137, 'roman': 1171}\n&gt;&gt;&gt; phone_ext.keys()\ndict_keys(['david', 'brad', 'roman'])\n&gt;&gt;&gt; list(phone_ext.keys())\n['david', 'brad', 'roman']\n&gt;&gt;&gt; phone_ext.values()\ndict_values([1410, 1137, 1171])\n&gt;&gt;&gt; list(phone_ext.values())\n[1410, 1137, 1171]\n&gt;&gt;&gt; phone_ext.items()\ndict_items([('david', 1410), ('brad', 1137), ('roman', 1171)])\n&gt;&gt;&gt; list(phone_ext.items())\n[('david', 1410), ('brad', 1137), ('roman', 1171)]\n&gt;&gt;&gt; phone_ext.get(\"kent\")\n&gt;&gt;&gt; phone_ext.get(\"kent\", \"NO ENTRY\")\n'NO ENTRY'\n</code></pre> <p>A set is an unordered collection of zero or more immutable Python data objects. Sets do not allow duplicates and are written as comma-delimited values enclosed in curly braces. The empty set is represented by <code>set()</code>. Sets are heterogeneous, and the collection can be assigned to a variable as below.</p> <pre><code>&gt;&gt;&gt; {3, 6, \"cat\", 4.5, False}\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; my_set = {3, 6, \"cat\", 4.5, False}\n&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n</code></pre> <p>Even though sets are not considered to be sequential, they do support a few of the familiar operations presented earlier. <code>Table\u00a05</code> reviews these operations and the following session gives examples of their use.</p> <p>Table 5: Operations on a Set in Python</p> Operation Name Operator Explanation membership <code>in</code> Set membership length <code>len</code> Returns the cardinality of the set <code>|</code> <code>a_set                                                                | other_set</code> Returns a new set with all elements from both sets <code>&amp;</code> <code>a_set &amp; other_set</code> Returns a new set with only those elements common to both sets <code>-</code> <code>a_set - other_set</code> Returns a new set with all items from the first set not in the second <code>&lt;=</code> <code>a_set &lt;= other_set</code> Asks whether all elements of  the first set are in the second <pre><code>&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; len(my_set)\n5\n&gt;&gt;&gt; False in my_set\nTrue\n&gt;&gt;&gt; \"dog\" in my_set\nFalse\n</code></pre> <p>Sets support a number of methods that should be familiar to those who have worked with them in a mathematics setting. <code>Table\u00a06</code> provides a summary. Examples of their use follow. Note that <code>union</code>, <code>intersection</code>, <code>issubset</code>, and <code>difference</code> all have operators that can be used as well.</p> <p>Table 6: Methods Provided by Sets in Python</p> Method Name Use Explanation <code>union</code> <code>a_set.union(other_set)</code> Returns a new set with all elements from both sets <code>intersection</code> <code>a_set.intersection(other_set)</code> Returns a new set with only those elements common to both sets <code>difference</code> <code>a_set.difference(other_set)</code> Returns a new set with all items from the first set not in the second <code>issubset</code> <code>a_set.issubset(othe_rset)</code> Asks whether all elements of one set are in the other <code>add</code> <code>a_set.add(item)</code> Adds item to the set <code>remove</code> <code>a_set.remove(item)</code> Removes item from the set <code>pop</code> <code>a_set.pop()</code> Removes an arbitrary element from the set <code>clear</code> <code>a_set.clear()</code> Removes all elements from the set <pre><code>&gt;&gt;&gt; my_set\n{False, 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; your_set = {99, 3, 100}\n&gt;&gt;&gt; my_set.union(your_set)\n{False, 3, 4.5, 'cat', 6, 99, 100}\n&gt;&gt;&gt; my_set | your_set\n{False, 3, 4.5, 'cat', 6, 99, 100}\n&gt;&gt;&gt; my_set.intersection(your_set)\n{3}\n&gt;&gt;&gt; my_set &amp; your_set\n{3}\n&gt;&gt;&gt; my_set.difference(your_set)\n{False, 'cat', 4.5, 6}\n&gt;&gt;&gt; my_set - your_set\n{False, 'cat', 4.5, 6}\n&gt;&gt;&gt; {3, 100}.issubset(your_set)\nTrue\n&gt;&gt;&gt; {3, 100} &lt;= your_set\nTrue\n&gt;&gt;&gt; my_set.add(\"house\")\n&gt;&gt;&gt; my_set\n{False, 'house', 3, 4.5, 6, 'cat'}\n&gt;&gt;&gt; my_set.remove(4.5)\n&gt;&gt;&gt; my_set\n{False, 'house', 3, 6, 'cat'}\n&gt;&gt;&gt; my_set.pop()\nFalse\n&gt;&gt;&gt; my_set\n{'house', 3, 6, 'cat'}\n&gt;&gt;&gt; my_set.clear()\n&gt;&gt;&gt; my_set\nset()\n</code></pre> <p>Our final Python collection is an unordered structure called a dictionary. Dictionaries are collections of associated pairs of items where each pair consists of a key and a value. This key-value pair is typically written as key:value. Dictionaries are written as comma-delimited key:value pairs enclosed in curly braces. For example,</p> <pre><code>&gt;&gt;&gt; capitals = {\"Iowa\": \"Des Moines\", \"Wisconsin\": \"Madison\"}\n&gt;&gt;&gt; capitals\n{'Iowa': 'Des Moines', 'Wisconsin': 'Madison'}\n</code></pre> <p>We can manipulate a dictionary by accessing a value via its key or by adding another key-value pair. The syntax for access looks much like a sequence access except that instead of using the index of the item, we use the key value. To add a new value is similar.</p> Using a Dictionary<pre><code>capitals = {\"Iowa\": \"Des Moines\", \"Wisconsin\": \"Madison\"}\nprint(capitals[\"Iowa\"])\ncapitals[\"Utah\"] = \"Salt Lake City\"\nprint(capitals)\ncapitals[\"California\"] = \"Sacramento\"\nprint(len(capitals))\nfor k in capitals:\n    print(capitals[k],\"is the capital of\", k)\n</code></pre> <p>It is important to note that prior to Python 3.6 dictionaries were maintained in no particular order with respect to the keys. The first pair added (<code>\"Utah\":</code> <code>\"Salt Lake City\"</code>) would be placed first in the dictionary and the second pair added (<code>\"California\":</code> <code>\"Sacramento\"</code>) would be placed last. The placement of a key is dependent on the idea of hashing, which will be explained in more detail in Chapter 5. Dictionaries do maintain the order since Python 3.6, so in the example above the pairs appear in the dictionary in the order they were added. We also show the length function performing the same role as with other collections.</p> <p>Dictionaries have both methods and operators. <code>Table\u00a07</code> and <code>Table 8</code> describe them, and the session shows them in action. The <code>keys</code>, <code>values</code>, and <code>items</code> methods all return objects that contain the values of interest. You can use the <code>list</code> function to convert them to lists. You will also see that there are two variations on the <code>get</code> method. If the key is not present in the dictionary, <code>get</code> will return <code>None</code>. However, a second, optional parameter can specify a return value instead.</p> <p>Table 7: Operators Provided by Dictionaries in Python</p> Operator Use Explanation <code>[]</code> <code>a_dict[k]</code> Returns the value associated with <code>k</code>, otherwise its an error <code>in</code> <code>key in a_dict</code> Returns <code>True</code> if key is in the   dictionary, <code>False</code> otherwise <code>del</code> del <code>a_dict[key]</code> Removes the entry from the dictionary <p>Table 8: Methods Provided by Dictionaries in Python</p> Method Name Use Explanation <code>keys</code> <code>a_dict.keys()</code> Returns the keys of the dictionary in a dict_keys object <code>values</code> <code>a_dict.values()</code> Returns the values of the dictionary in a dict_values object <code>items</code> <code>a_dict.items()</code> Returns the key-value pairs in a dict_items object <code>get</code> <code>a_dict.get(k)</code> Returns the value associated with <code>k</code>, <code>None</code> otherwise <code>get</code> <code>a_dict.get(k, alt)</code> Returns the value associated with <code>k</code>, <code>alt</code> otherwise <pre><code>&gt;&gt;&gt; phone_ext={\"david\": 1410, \"brad\": 1137, \"roman\": 1171}\n&gt;&gt;&gt; phone_ext\n{'david': 1410, 'brad': 1137, 'roman': 1171}\n&gt;&gt;&gt; phone_ext.keys()\ndict_keys(['david', 'brad', 'roman'])\n&gt;&gt;&gt; list(phone_ext.keys())\n['david', 'brad', 'roman']\n&gt;&gt;&gt; phone_ext.values()\ndict_values([1410, 1137, 1171])\n&gt;&gt;&gt; list(phone_ext.values())\n[1410, 1137, 1171]\n&gt;&gt;&gt; phone_ext.items()\ndict_items([('david', 1410), ('brad', 1137), ('roman', 1171)])\n&gt;&gt;&gt; list(phone_ext.items())\n[('david', 1410), ('brad', 1137), ('roman', 1171)]\n&gt;&gt;&gt; phone_ext.get(\"kent\")\n&gt;&gt;&gt; phone_ext.get(\"kent\", \"NO ENTRY\")\n'NO ENTRY'\n</code></pre>"},{"location":"c1/s9/","title":"1.9. \u8f93\u5165\u548c\u8f93\u51fa","text":"<p>1.9. Input and Output</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u7ecf\u5e38\u9700\u8981\u4e0e\u7528\u6237\u4ea4\u4e92\uff0c\u8981\u4e48\u83b7\u53d6\u6570\u636e\uff0c\u8981\u4e48\u63d0\u4f9b\u67d0\u79cd\u7ed3\u679c\u3002 \u5982\u4eca\uff0c\u5927\u591a\u6570\u7a0b\u5e8f\u90fd\u4f7f\u7528\u5bf9\u8bdd\u6846\u6765\u8981\u6c42\u7528\u6237\u63d0\u4f9b\u67d0\u79cd\u7c7b\u578b\u7684\u8f93\u5165\u3002 \u867d\u7136 Python \u786e\u5b9e\u6709\u4e00\u79cd\u521b\u5efa\u5bf9\u8bdd\u6846\u7684\u65b9\u6cd5\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u66f4\u7b80\u5355\u7684\u51fd\u6570\u3002 Python \u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570\uff0c\u5141\u8bb8\u6211\u4eec\u8981\u6c42\u7528\u6237\u8f93\u5165\u4e00\u4e9b\u6570\u636e\u5e76\u4ee5\u5b57\u7b26\u4e32\u7684\u5f62\u5f0f\u8fd4\u56de\u5bf9\u6570\u636e\u7684\u5f15\u7528\u3002 \u8be5\u51fd\u6570\u79f0\u4e3a<code>input</code>\u3002</p> <p>Python \u7684\u51fd\u6570<code>input</code>\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u53c2\u6570\u3002 \u8be5\u5b57\u7b26\u4e32\u901a\u5e38\u79f0\u4e3a \u63d0\u793a(prompt)\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u4e00\u4e9b\u6709\u7528\u7684\u6587\u672c\uff0c\u63d0\u793a\u7528\u6237\u8f93\u5165\u67d0\u4e9b\u5185\u5bb9\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u6309\u5982\u4e0b\u65b9\u5f0f\u8c03\u7528\u8f93\u5165\uff1a</p> <pre><code>a_name = input(\"Please enter your name: \")\n</code></pre> <p>\u73b0\u5728\uff0c\u65e0\u8bba\u7528\u6237\u5728\u63d0\u793a\u540e\u8f93\u5165\u4ec0\u4e48\u5185\u5bb9\uff0c\u90fd\u5c06\u5b58\u50a8\u5728<code>a_name</code>\u53d8\u91cf\u4e2d\u3002 \u4f7f\u7528<code>input</code>\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u8f7b\u677e\u7f16\u5199\u6307\u4ee4\uff0c\u63d0\u793a\u7528\u6237\u8f93\u5165\u6570\u636e\uff0c\u7136\u540e\u5c06\u8be5\u6570\u636e\u5408\u5e76\u5230\u8fdb\u4e00\u6b65\u5904\u7406\u4e2d\u3002 \u4f8b\u5982\uff0c\u5728\u4ee5\u4e0b\u4e24\u4e2a\u8bed\u53e5\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u8bed\u53e5\u8be2\u95ee\u7528\u6237\u7684\u59d3\u540d\uff0c\u7b2c\u4e8c\u4e2a\u8bed\u53e5\u6839\u636e\u63d0\u4f9b\u7684\u5b57\u7b26\u4e32\u6253\u5370\u4e00\u4e9b\u7b80\u5355\u5904\u7406\u7684\u7ed3\u679c\u3002</p> The input Function Returns a String<pre><code>a_name = input(\"Please enter your name: \")\nprint(\"Your name in all capitals is\", a_name.upper(),\n        \"and has length\", len(a_name))\n</code></pre> <p>\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u4ece<code>input</code>\u51fd\u6570\u8fd4\u56de\u7684\u503c\u5c06\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u5728\u63d0\u793a\u540e\u8f93\u5165\u7684\u786e\u5207\u5b57\u7b26\u3002 \u5982\u679c\u60a8\u5e0c\u671b\u5c06\u6b64\u5b57\u7b26\u4e32\u89e3\u91ca\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u5219\u5fc5\u987b\u663e\u5f0f\u63d0\u4f9b\u7c7b\u578b\u8f6c\u6362\u3002 \u5728\u4e0b\u9762\u7684\u8bed\u53e5\u4e2d\uff0c\u7528\u6237\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u88ab\u8f6c\u6362\u4e3a\u6d6e\u70b9\u6570\uff0c\u4ee5\u4fbf\u53ef\u4ee5\u7528\u4e8e\u8fdb\u4e00\u6b65\u7684\u7b97\u672f\u5904\u7406\u3002</p> <pre><code>&gt;&gt;&gt; s_radius = input(\"Please enter the radius of the circle \")\nPlease enter the radius of the circle 10\n&gt;&gt;&gt; s_radius\n'10'\n&gt;&gt;&gt; radius = float(s_radius)\n&gt;&gt;&gt; radius\n10.0\n&gt;&gt;&gt; diameter = 2 * radius\n&gt;&gt;&gt; diameter\n20.0\n</code></pre> <p>We often have a need to interact with users, either to get data or to provide some sort of result. Most programs today use a dialog box as a way of asking the user to provide some type of input. While Python does have a way to create dialog boxes, there is a much simpler function that we can use. Python provides us with a function that allows us to ask a user to enter some data and returns a reference to the data in the form of a string. The function is called <code>input</code>.</p> <p>Python\u2019s function <code>input</code> takes a single parameter that is a string. This string is often called the prompt because it contains some helpful text prompting the user to enter something. For example, you might call input as follows:</p> <pre><code>a_name = input(\"Please enter your name: \")\n</code></pre> <p>Now whatever the user types after the prompt will be stored in the <code>a_name</code> variable. Using the <code>input</code> function, we can easily write instructions that will prompt the user to enter data and then incorporate that data into further processing. For example, in the following two statements, the first asks the user for their name and the second prints the result of some simple processing based on the string that is provided.</p> The input Function Returns a String<pre><code>a_name = input(\"Please enter your name: \")\nprint(\"Your name in all capitals is\", a_name.upper(),\n        \"and has length\", len(a_name))\n</code></pre> <p>It is important to note that the value returned from the <code>input</code> function will be a string representing the exact characters that were entered after the prompt. If you want this string interpreted as another type, you must provide the type conversion explicitly. In the statements below, the string that is entered by the user is converted to a float so that it can be used in further arithmetic processing.</p> <pre><code>&gt;&gt;&gt; s_radius = input(\"Please enter the radius of the circle \")\nPlease enter the radius of the circle 10\n&gt;&gt;&gt; s_radius\n'10'\n&gt;&gt;&gt; radius = float(s_radius)\n&gt;&gt;&gt; radius\n10.0\n&gt;&gt;&gt; diameter = 2 * radius\n&gt;&gt;&gt; diameter\n20.0\n</code></pre>"},{"location":"c1/s9/#191-\u5b57\u7b26\u4e32\u683c\u5f0f\u5316","title":"1.9.1. \u5b57\u7b26\u4e32\u683c\u5f0f\u5316","text":"<p>1.9.1. String Formatting</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5df2\u7ecf\u770b\u5230\uff0c<code>print</code>\u51fd\u6570\u63d0\u4f9b\u4e86\u4e00\u79cd\u975e\u5e38\u7b80\u5355\u7684\u65b9\u6cd5\u6765\u4ece Python \u7a0b\u5e8f\u8f93\u51fa\u503c\u3002 <code>print</code> \u63a5\u53d7\u96f6\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\uff0c\u5e76\u4f7f\u7528\u5355\u4e2a\u7a7a\u683c\u4f5c\u4e3a\u9ed8\u8ba4\u5206\u9694\u7b26\u6765\u663e\u793a\u5b83\u4eec\u3002 \u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e<code>sep</code>\u53c2\u6570\u6765\u66f4\u6539\u5206\u9694\u7b26\u3002 \u6b64\u5916\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6bcf\u6b21\u6253\u5370\u90fd\u4f1a\u4ee5\u6362\u884c\u7b26\u7ed3\u5c3e\u3002 \u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e <code>end</code> \u53c2\u6570\u6765\u66f4\u6539\u6b64\u884c\u4e3a\u3002 \u8fd9\u4e9b\u53d8\u5316\u663e\u793a\u5728\u4ee5\u4e0b\u4f1a\u8bdd\u4e2d\uff1a</p> <pre><code>&gt;&gt;&gt; print(\"Hello\")\nHello\n&gt;&gt;&gt; print(\"Hello\", \"World\")\nHello World\n&gt;&gt;&gt; print(\"Hello\", \"World\", sep=\"***\")\nHello***World\n&gt;&gt;&gt; print(\"Hello\", \"World\", end=\"***\")\nHello World***&gt;&gt;&gt;\n</code></pre> <p>\u5bf9\u8f93\u51fa\u7684\u5916\u89c2\u8fdb\u884c\u66f4\u591a\u63a7\u5236\u901a\u5e38\u5f88\u6709\u7528\u3002 \u5e78\u8fd0\u7684\u662f\uff0cPython \u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u79cd\u66ff\u4ee3\u65b9\u6848\uff0c\u79f0\u4e3a \u683c\u5f0f\u5316\u5b57\u7b26\u4e32(formatted strings)\u3002 \u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u662f\u4e00\u4e2a\u6a21\u677f\uff0c\u5176\u4e2d\u4fdd\u6301\u4e0d\u53d8\u7684\u5355\u8bcd\u6216\u7a7a\u683c\u4e0e\u5c06\u63d2\u5165\u5230\u5b57\u7b26\u4e32\u4e2d\u7684\u53d8\u91cf\u7684\u5360\u4f4d\u7b26\u7ec4\u5408\u5728\u4e00\u8d77\u3002 \u4f8b\u5982\uff0c\u58f0\u660e</p> <pre><code>&gt;&gt;&gt; print(a_name, \"is\", age, \"years old.\")\n</code></pre> <p>\u5305\u542b\u5355\u8bcd<code>is</code>\u548c<code>years old</code>\uff0c\u4f46\u662f\u540d\u5b57\u548c\u5e74\u9f84\u4f1a\u6839\u636e\u6267\u884c\u65f6\u7684\u53d8\u91cf\u503c\u800c\u6539\u53d8\u3002 \u4f7f\u7528\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0c\u6211\u4eec\u5c06\u524d\u9762\u7684\u8bed\u53e5\u5199\u4e3a</p> <pre><code>&gt;&gt;&gt; print(\"%s is %d years old.\" % (a_name, age))\n</code></pre> <p>\u8fd9\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\u8bf4\u660e\u4e86\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26\u4e32\u8868\u8fbe\u5f0f\u3002 <code>%</code> \u8fd0\u7b97\u7b26\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u8fd0\u7b97\u7b26\uff0c\u79f0\u4e3a \u683c\u5f0f\u8fd0\u7b97\u7b26(format operator)\u3002 \u8868\u8fbe\u5f0f\u7684\u5de6\u4fa7\u4fdd\u5b58\u6a21\u677f\u6216\u683c\u5f0f\u5b57\u7b26\u4e32\uff0c\u53f3\u4fa7\u4fdd\u5b58\u5c06\u66ff\u6362\u5230\u683c\u5f0f\u5b57\u7b26\u4e32\u4e2d\u7684\u503c\u7684\u96c6\u5408\u3002 \u8bf7\u6ce8\u610f\uff0c\u53f3\u4fa7\u96c6\u5408\u4e2d\u503c\u7684\u6570\u91cf\u4e0e\u683c\u5f0f\u5b57\u7b26\u4e32\u4e2d<code>%</code>\u5b57\u7b26\u7684\u6570\u91cf\u76f8\u5bf9\u5e94\u3002 \u4ece\u96c6\u5408\u4e2d\u6309\u987a\u5e8f\u4ece\u5de6\u5230\u53f3\u83b7\u53d6\u503c\u5e76\u5c06\u5176\u63d2\u5165\u5230\u683c\u5f0f\u5b57\u7b26\u4e32\u4e2d\u3002</p> <p>\u8ba9\u6211\u4eec\u66f4\u8be6\u7ec6\u5730\u770b\u770b\u8fd9\u4e2a\u683c\u5f0f\u5316\u8868\u8fbe\u5f0f\u7684\u4e24\u8fb9\u3002 \u683c\u5f0f\u5b57\u7b26\u4e32\u53ef\u4ee5\u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2a\u8f6c\u6362\u89c4\u8303\u3002 \u8f6c\u6362\u5b57\u7b26\u544a\u8bc9\u683c\u5f0f\u8fd0\u7b97\u7b26\u4ec0\u4e48\u7c7b\u578b\u7684\u503c\u5c06\u88ab\u63d2\u5165\u5230\u5b57\u7b26\u4e32\u4e2d\u7684\u8be5\u4f4d\u7f6e\u3002 \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>%s</code>\u6307\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u800c<code>%d</code>\u6307\u5b9a\u4e00\u4e2a\u6574\u6570\u3002 \u5176\u4ed6\u53ef\u80fd\u7684\u7c7b\u578b\u89c4\u8303\u5305\u62ec<code>i</code>\u3001<code>u</code>\u3001<code>f</code>\u3001<code>e</code>\u3001<code>g</code>\u3001<code>c</code>\u6216<code>%</code>\u3002 \u201c\u8868 9\u201d\u603b\u7ed3\u4e86\u6240\u6709\u5404\u79cd\u7c7b\u578b\u7684\u89c4\u683c\u3002</p> <p>\u8868 9\uff1a\u5b57\u7b26\u4e32\u683c\u5f0f\u8f6c\u6362\u5b57\u7b26</p> \u8f6c\u6362\u5b57\u7b26 \u8f93\u51fa\u683c\u5f0f <code>d</code>, <code>i</code> \u6574\u6570 <code>u</code> \u65e0\u7b26\u53f7\u6574\u6570 <code>f</code> \u6d6e\u70b9\u6570\u4e3a m.ddddd <code>e</code> \u6d6e\u70b9\u6570\u4e3a m.ddddde\u00b1xx <code>E</code> \u6d6e\u70b9\u4e3a m.dddddE\u00b1xx <code>g</code> \u5bf9\u4e8e\u5c0f\u4e8e<code>-4</code>\u6216\u5927\u4e8e<code>+5</code>\u7684\u6307\u6570\u4f7f\u7528<code>%e</code>\uff0c\u5426\u5219\u4f7f\u7528<code>%f</code> <code>c</code> \u5355\u4e2a\u5b57\u7b26 <code>s</code> \u5b57\u7b26\u4e32\uff0c\u6216\u4efb\u4f55\u53ef\u4ee5\u4f7f\u7528<code>str</code>\u51fd\u6570\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u7684Python\u6570\u636e\u5bf9\u8c61 <code>%</code> \u63d2\u5165\u6587\u5b57 <code>%</code> \u5b57\u7b26 <p>\u9664\u4e86\u683c\u5f0f\u5b57\u7b26\u4e4b\u5916\uff0c\u60a8\u8fd8\u53ef\u4ee5\u5728<code>%</code>\u548c\u683c\u5f0f\u5b57\u7b26\u4e4b\u95f4\u5305\u542b\u683c\u5f0f\u4fee\u9970\u7b26\u3002 \u683c\u5f0f\u4fee\u9970\u7b26\u53ef\u7528\u4e8e\u5de6\u5bf9\u9f50\u6216\u53f3\u5bf9\u9f50\u5177\u6709\u6307\u5b9a\u5b57\u6bb5\u5bbd\u5ea6\u7684\u503c\u3002 \u4fee\u9970\u7b26\u8fd8\u53ef\u7528\u4e8e\u6307\u5b9a\u5b57\u6bb5\u5bbd\u5ea6\u4ee5\u53ca\u5c0f\u6570\u70b9\u540e\u7684\u4f4d\u6570\u3002 <code>\u8868 10</code> \u89e3\u91ca\u4e86\u8fd9\u4e9b\u683c\u5f0f\u4fee\u9970\u7b26\u3002</p> <p>\u8868 10\uff1a\u5176\u4ed6\u683c\u5f0f\u9009\u9879</p> \u4fee\u9970\u7b26 \u4f8b\u5b50 \u63cf\u8ff0 number <code>%20d</code> \u5c06\u503c\u653e\u5165\u5bbd\u5ea6\u4e3a 20 \u7684\u5b57\u6bb5\u4e2d <code>-</code> <code>%-20d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u5de6\u5bf9\u9f50 <code>+</code> <code>%+20d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u53f3\u5bf9\u9f50 <code>0</code> <code>%020d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u5e76\u7528\u524d\u5bfc\u96f6\u586b\u5145 <code>.</code> <code>%20.2f</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u3001\u5c0f\u6570\u70b9\u53f3\u4fa7 2 \u4e2a\u5b57\u7b26\u7684\u5b57\u6bb5\u4e2d <code>(name)</code> <code>%(name)d</code> \u4f7f\u7528<code>name</code>\u4f5c\u4e3a\u952e\u4ece\u63d0\u4f9b\u7684\u5b57\u5178\u4e2d\u83b7\u53d6\u503c <p>\u5982\u524d\u6240\u8ff0\uff0c\u683c\u5f0f\u8fd0\u7b97\u7b26\u7684\u53f3\u4fa7\u662f\u5c06\u63d2\u5165\u5230\u683c\u5f0f\u5b57\u7b26\u4e32\u4e2d\u7684\u503c\u7684\u96c6\u5408\u3002 \u8be5\u96c6\u5408\u53ef\u4ee5\u662f\u5143\u7ec4\u6216\u5b57\u5178\u3002 \u5982\u679c\u96c6\u5408\u662f\u5143\u7ec4\uff0c\u5219\u6309\u4f4d\u7f6e\u987a\u5e8f\u63d2\u5165\u503c\u3002 \u4e5f\u5c31\u662f\u8bf4\uff0c\u5143\u7ec4\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5bf9\u5e94\u4e8e\u683c\u5f0f\u5b57\u7b26\u4e32\u4e2d\u7684\u7b2c\u4e00\u4e2a\u683c\u5f0f\u5b57\u7b26\u3002 \u5982\u679c\u96c6\u5408\u662f\u5b57\u5178\uff0c\u5219\u6839\u636e\u952e\u63d2\u5165\u503c\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u683c\u5f0f\u5b57\u7b26\u5fc5\u987b\u4f7f\u7528<code>(name)</code>\u4fee\u9970\u7b26\u6765\u6307\u5b9a\u952e\u7684\u540d\u79f0\u3002</p> <pre><code>&gt;&gt;&gt; price = 24\n&gt;&gt;&gt; item = \"banana\"\n&gt;&gt;&gt; print(\"The %s costs %d cents\" % (item, price))\nThe banana costs 24 cents\n&gt;&gt;&gt; print(\"The %+10s costs %5.2f cents\" % (item, price))\nThe     banana costs 24.00 cents\n&gt;&gt;&gt; print(\"The %+10s costs %10.2f cents\" % (item, price))\nThe     banana costs      24.00 cents\n&gt;&gt;&gt; itemdict = {\"item\": \"banana\", \"cost\": 24}\n&gt;&gt;&gt; print(\"The %(item)s costs %(cost)7.1f cents\" % itemdict)\nThe banana costs    24.0 cents\n</code></pre> <p>\u9664\u4e86\u4f7f\u7528\u683c\u5f0f\u5b57\u7b26\u548c\u683c\u5f0f\u4fee\u9970\u7b26\u7684\u683c\u5f0f\u5b57\u7b26\u4e32\u4e4b\u5916\uff0cPython \u5b57\u7b26\u4e32\u8fd8\u5305\u542b\u4e00\u4e2a<code>format</code>\u65b9\u6cd5\uff0c\u53ef\u4ee5\u4e0e\u65b0\u7684<code>Formatter</code>\u7c7b\u7ed3\u5408\u4f7f\u7528\u6765\u5b9e\u73b0\u590d\u6742\u7684\u5b57\u7b26\u4e32\u683c\u5f0f\u5316\u3002 \u6709\u5173\u8fd9\u4e9b\u529f\u80fd\u7684\u66f4\u591a\u4fe1\u606f\u53ef\u4ee5\u5728 Python \u5e93\u53c2\u8003\u624b\u518c\u4e2d\u627e\u5230\u3002</p> <pre><code>&gt;&gt;&gt; print(\"The {} costs {} cents\".format(item, price))\nThe banana costs 24 cents\n&gt;&gt;&gt; print(\"The {:s} costs {:d} cents\".format(item, price))\nThe banana costs 24 cents\n</code></pre> <p>Python 3.6 \u5f15\u5165\u4e86 f-strings\uff0c\u8fd9\u662f\u4e00\u79cd\u4f7f\u7528\u6b63\u786e\u7684\u53d8\u91cf\u540d\u79f0\u800c\u4e0d\u662f\u5360\u4f4d\u7b26\u7684\u65b9\u6cd5\u3002 \u683c\u5f0f\u5316\u8f6c\u6362\u7b26\u53f7\u4ecd\u7136\u53ef\u4ee5\u5728 f \u5b57\u7b26\u4e32\u5185\u4f7f\u7528\uff0c\u4f46\u5bf9\u9f50\u7b26\u53f7\u4e0e\u5360\u4f4d\u7b26\u4e2d\u4f7f\u7528\u7684\u5bf9\u9f50\u7b26\u53f7\u4e0d\u540c\uff08\u8bf7\u53c2\u9605\u201c\u8868 11\u201d\uff09\u3002 \u6211\u4eec\u5c06\u5bf9\u6587\u672c\u7684\u5176\u4f59\u90e8\u5206\u4f7f\u7528\u8fd9\u79cd\u683c\u5f0f\u8bbe\u7f6e\u65b9\u6cd5\u3002</p> <p>\u8868 11\uff1af-string\u683c\u5f0f\u9009\u9879</p> \u4fee\u9970\u7b26 \u4f8b\u5b50 \u63cf\u8ff0 number <code>:20d</code> \u5c06\u503c\u653e\u5165\u5bbd\u5ea6\u4e3a 20 \u7684\u5b57\u6bb5\u4e2d <code>&lt;</code> <code>:&lt;20d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u5de6\u5bf9\u9f50 <code>&gt;</code> <code>:&gt;20d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u53f3\u5bf9\u9f50 <code>^</code> <code>:^20d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u3001\u5c45\u4e2d\u5bf9\u9f50\u7684\u5b57\u6bb5\u4e2d <code>0</code> <code>:020d</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u7684\u5b57\u6bb5\u4e2d\uff0c\u5e76\u7528\u524d\u5bfc\u96f6\u586b\u5145\u3002 <code>.</code> <code>:20.2f</code> \u5c06\u503c\u653e\u5165 20 \u4e2a\u5b57\u7b26\u5bbd\u3001\u5c0f\u6570\u70b9\u53f3\u4fa7 2 \u4e2a\u5b57\u7b26\u7684\u5b57\u6bb5\u4e2d\u3002 <pre><code>&gt;&gt;&gt; print(f\"The {item:10} costs {price:10.2f} cents\")\nThe banana     costs      24.00 cents\n&gt;&gt;&gt; print(f\"The {item:&lt;10} costs {price:&lt;10.2f} cents\")\nThe banana     costs 24.00      cents\n&gt;&gt;&gt; print(f\"The {item:^10} costs {price:^10.2f} cents\")\nThe   banana   costs   24.00    cents\n&gt;&gt;&gt; print(f\"The {item:&gt;10} costs {price:&gt;10.2f} cents\")\nThe     banana costs      24.00 cents\n&gt;&gt;&gt; print(f\"The {item:&gt;10} costs {price:&gt;010.2f} cents\")\nThe     banana costs 0000024.00 cents\n&gt;&gt;&gt; itemdict = {\"item\": \"banana\", \"price\": 24}\n&gt;&gt;&gt; print(f\"Item:{itemdict['item']:.&gt;10}\\n\" +\n... f\"Price:{'$':.&gt;4}{itemdict['price']:5.2f}\")\nItem:....banana\nPrice:...$24.00\n</code></pre> <p>\u6709\u5173\u8fd9\u4e9b\u529f\u80fd\u7684\u66f4\u591a\u4fe1\u606f\u53ef\u4ee5\u5728 Python \u5e93\u53c2\u8003\u624b\u518c\u4e2d\u627e\u5230\u3002</p> <p>We have already seen that the <code>print</code> function provides a very simple way to output values from a Python program. <code>print</code> takes zero or more parameters and displays them using a single blank as the default separator. It is possible to change the separator character by setting the <code>sep</code> argument. In addition, each print ends with a newline character by default. This behavior can be changed by setting the <code>end</code> argument. These variations are shown in the following session:</p> <pre><code>&gt;&gt;&gt; print(\"Hello\")\nHello\n&gt;&gt;&gt; print(\"Hello\", \"World\")\nHello World\n&gt;&gt;&gt; print(\"Hello\", \"World\", sep=\"***\")\nHello***World\n&gt;&gt;&gt; print(\"Hello\", \"World\", end=\"***\")\nHello World***&gt;&gt;&gt;\n\u2035\u2035`\n\nIt is often useful to have more control over the look of your output. Fortunately, Python provides us with an alternative called **formatted strings**. A formatted string is a template in which words or spaces that will remain constant are combined with placeholders for variables that will be inserted into the string. For example, the statement\n\n```pycon\n&gt;&gt;&gt; print(a_name, \"is\", age, \"years old.\")\n\u2035\u2035`\n\ncontains the words ``is`` and ``years old``, but the name and the age will change depending on the variable values at the time of execution. Using a formatted string, we write the previous statement as\n\n```pycon\n&gt;&gt;&gt; print(\"%s is %d years old.\" % (a_name, age))\n\u2035\u2035`\n\nThis simple example illustrates a new string expression. The ``%`` operator is a string operator called the **format operator**. The left side of the expression holds the template or format string, and the right side holds a collection of values that will be substituted into the format string. Note that the number of values in the collection on the right side corresponds with the number of ``%`` characters in the format string. Values are taken\u2014in order, left to right\u2014from the collection and inserted into the format string.\n\nLet\u2019s look at both sides of this formatting expression in more detail. The format string may contain one or more conversion specifications. A conversion character tells the format operator what type of value is going to be inserted into that position in the string. In the example above, the ``%s`` specifies a string, while the ``%d`` specifies an integer. Other possible type specifications include ``i``, ``u``, ``f``, ``e``, ``g``, ``c``, or ``%``. `Table\u00a09` summarizes all of the\nvarious type specifications.\n\n**Table 9: String Formatting Conversion Characters**\n\n| **Character** | **Output Format**                                                                                 |\n| ------------- | ------------------------------------------------------------------------------------------------- |\n| ``d``, ``i``  | Integer                                                                                           |\n| ``u``         | Unsigned integer                                                                                  |\n| ``f``         | Floating point as m.ddddd                                                                         |\n| ``e``         | Floating point as m.ddddde+/-xx                                                                   |\n| ``E``         | Floating point as m.dddddE+/-xx                                                                   |\n| ``g``         | Use ``%e`` for exponents less than :math:`-4` or greater than :math:`+5`, otherwise use ``%f``    |\n| ``c``         | Single character                                                                                  |\n| ``s``         | String, or any Python data object that can be converted to a string by using the ``str`` function |\n| ``%``         | Insert a literal ``%`` character                                                                  |\n\nIn addition to the format character, you can also include a format modifier between the ``%`` and the format character. Format modifiers may be used to left-justify or right-justify the value with a specified field width. Modifiers can also be used to specify the field width along with a number of digits after the decimal point. :ref:`Table\u00a010 &lt;tab_fmtaddsa&gt;` explains these format modifiers.\n\n**Table 10: Additional formatting options**\n\n\n| **Modifier** | **Example**  | **Description**                                                                                 |\n| ------------ | ------------ | ----------------------------------------------------------------------------------------------- |\n| number       | ``%20d``     | Put the value in a field width of 20                                                            |\n| ``-``        | ``%-20d``    | Put the value in a field 20 characters wide, left-justified                                     |\n| ``+``        | ``%+20d``    | Put the value in a field 20 characters wide, right-justified                                    |\n| ``0``        | ``%020d``    | Put the value in a field 20 characters wide, fill in with leading zeros                         |\n| ``.``        | ``%20.2f``   | Put the value in a field 20 characters wide with 2 characters to the right of the decimal point |\n| ``(name)``   | ``%(name)d`` | Get the value from the supplied dictionary using ``name`` as the key                            |\n\nAs mentioned, the right side of the format operator is a collection of values that will be inserted into the format string. The collection will be either a tuple or a dictionary. If the collection is a tuple, the values are inserted in order of position. That is, the first element in the tuple corresponds to the first format character in the format string. If the collection is a dictionary, the values are inserted according to their keys. In this case all format characters must use the ``(name)`` modifier to specify the name of the key.\n\n```pycon\n&gt;&gt;&gt; price = 24\n&gt;&gt;&gt; item = \"banana\"\n&gt;&gt;&gt; print(\"The %s costs %d cents\" % (item, price))\nThe banana costs 24 cents\n&gt;&gt;&gt; print(\"The %+10s costs %5.2f cents\" % (item, price))\nThe     banana costs 24.00 cents\n&gt;&gt;&gt; print(\"The %+10s costs %10.2f cents\" % (item, price))\nThe     banana costs      24.00 cents\n&gt;&gt;&gt; itemdict = {\"item\": \"banana\", \"cost\": 24}\n&gt;&gt;&gt; print(\"The %(item)s costs %(cost)7.1f cents\" % itemdict)\nThe banana costs    24.0 cents\n</code></pre> <p>In addition to format strings that use format characters and format modifiers, Python strings also include a <code>format</code> method that can be used in conjunction with a new <code>Formatter</code> class to implement complex string formatting. More about these features can be found in the Python library reference manual.</p> <pre><code>&gt;&gt;&gt; print(\"The {} costs {} cents\".format(item, price))\nThe banana costs 24 cents\n&gt;&gt;&gt; print(\"The {:s} costs {:d} cents\".format(item, price))\nThe banana costs 24 cents\n</code></pre> <p>Python 3.6 introduced f-strings, a way to use proper variable names instead of placeholders. Formatting conversion symbols can still be used inside an f-string, but the alignment symbols are different from those used with placeholders (see <code>Table\u00a011</code>). We are going to use this formatting method for the rest of the text.</p> <p>Table 11: f-string Formatting Options</p> Modifier Example Description number <code>:20d</code> Put the value in a field width of 20 <code>&lt;</code> <code>:&lt;20d</code> Put the value in a field 20 characters wide, left-aligned <code>&gt;</code> <code>:&gt;20d</code> Put the value in a field 20 characters wide, right-aligned <code>^</code> <code>:^20d</code> Put the value in a field 20 characters wide, center-aligned <code>0</code> <code>:020d</code> Put the value in a field 20 characters wide, fill in with leading zeros. <code>.</code> <code>:20.2f</code> Put the value in a field 20 characters wide with 2 characters to the right of the decimal point. <pre><code>&gt;&gt;&gt; print(f\"The {item:10} costs {price:10.2f} cents\")\nThe banana     costs      24.00 cents\n&gt;&gt;&gt; print(f\"The {item:&lt;10} costs {price:&lt;10.2f} cents\")\nThe banana     costs 24.00      cents\n&gt;&gt;&gt; print(f\"The {item:^10} costs {price:^10.2f} cents\")\nThe   banana   costs   24.00    cents\n&gt;&gt;&gt; print(f\"The {item:&gt;10} costs {price:&gt;10.2f} cents\")\nThe     banana costs      24.00 cents\n&gt;&gt;&gt; print(f\"The {item:&gt;10} costs {price:&gt;010.2f} cents\")\nThe     banana costs 0000024.00 cents\n&gt;&gt;&gt; itemdict = {\"item\": \"banana\", \"price\": 24}\n&gt;&gt;&gt; print(f\"Item:{itemdict['item']:.&gt;10}\\n\" +\n... f\"Price:{'$':.&gt;4}{itemdict['price']:5.2f}\")\nItem:....banana\nPrice:...$24.00\n</code></pre> <p>More about these features can be found in the Python library reference manual.</p>"},{"location":"c2/","title":"2. \u7b97\u6cd5\u5206\u6790","text":"<p>2. Algorithm Analysis</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>2.1. \u76ee\u6807 </li> <li>2.2. \u4ec0\u4e48\u662f\u7b97\u6cd5\u5206\u6790\uff1f </li> <li>2.3. \u5927O\u7b26\u53f7 </li> <li>2.4. \u4e00\u4e2a\u5b57\u8c1c\u68c0\u6d4b\u4f8b\u5b50 <ul> <li>2.4.1. \u89e3\u51b3\u65b9\u68481\uff1a\u5b57\u8c1c\u68c0\u6d4b\u9010\u4e00\u68c0\u67e5 </li> <li>2.4.2. \u89e3\u51b3\u65b9\u68482\uff1a\u6392\u5e8f\u548c\u6bd4\u8f83 </li> <li>2.4.3. \u89e3\u51b3\u65b9\u68483\uff1a\u66b4\u529b\u7834\u89e3 </li> <li>2.4.4. \u89e3\u51b3\u65b9\u68484\uff1a\u8ba1\u6570\u548c\u6bd4\u8f83 </li> </ul> </li> <li>2.5. Python\u6570\u636e\u7ed3\u6784\u7684\u6027\u80fd </li> <li>2.6. \u5217\u8868 </li> <li>2.7. \u5b57\u5178 </li> <li>2.8. \u603b\u7ed3 </li> <li>2.9. \u5173\u952e\u672f\u8bed </li> <li>2.10. \u7ec3\u4e60</li> </ul> <ul> <li>2.1. Objectives</li> <li>2.2. What Is Algorithm Analysis?</li> <li>2.3. Big O Notation</li> <li>2.4. An Anagram Detection Example<ul> <li>2.4.1. Solution 1: Anagram Detection Checking Off</li> <li>2.4.2. Anagram Detection Solution 2: Sort and Compare</li> <li>2.4.3. Anagram Detection Solution 3: Brute Force</li> <li>2.4.4. Anagram Detection Solution 4: Count and Compare</li> </ul> </li> <li>2.5. Performance of Python Data Structures</li> <li>2.6. Lists</li> <li>2.7. Dictionaries</li> <li>2.8. Summary</li> <li>2.9. Key Terms</li> <li>2.10. Exercises</li> </ul>"},{"location":"c2/s1/","title":"2.1. \u76ee\u6807","text":"<p>2.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>\u7406\u89e3\u4e3a\u4f55\u7b97\u6cd5\u5206\u6790\u5982\u6b64\u91cd\u8981\u3002</li> <li>\u80fd\u591f\u4f7f\u7528\u5927O\u6765\u63cf\u8ff0\u6267\u884c\u65f6\u95f4\u3002</li> <li>\u4e86\u89e3Python\u5217\u8868\u548c\u8bcd\u5178\u4e0a\u5e38\u89c1\u64cd\u4f5c\u7684\u5927\u91cfO\u6267\u884c\u65f6\u95f4\u3002</li> <li>\u4e86\u89e3 Python \u5173\u4e8e\u6570\u636e\u7684\u5b9e\u73b0\u5982\u4f55\u5f71\u54cd\u7b97\u6cd5\u5206\u6790\u3002</li> <li>\u4e86\u89e3\u5982\u4f55\u5bf9\u7b80\u5355\u7684 Python \u7a0b\u5e8f\u8fdb\u884c\u57fa\u51c6\u6d4b\u8bd5\u3002</li> </ul> <ul> <li>To understand why algorithm analysis is important.</li> <li>To be able to use Big O to describe execution time.</li> <li>To understand the Big O execution time of common operations on Python lists and dictionaries.</li> <li>To understand how the implementation of Python data impacts algorithm analysis.</li> <li>To understand how to benchmark simple Python programs.</li> </ul>"},{"location":"c2/s10/","title":"2.10. \u7ec3\u4e60","text":"<p>2.10. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u7684 Big O \u6027\u80fd\u662f\u591a\u5c11\uff1f</p> <pre><code>for i in range(n):\n    for j in range(n):\n        k = 2 + 2\n</code></pre> <p>Big O \u6027\u80fd\uff1a \\(O(n^2)\\)</p> <p>\u89e3\u91ca\uff1a \u6709\u4e24\u4e2a\u5d4c\u5957\u7684\u5faa\u73af\uff0c\u6bcf\u4e2a\u5faa\u73af\u8fd0\u884c \\(n\\) \u6b21\uff0c\u56e0\u6b64\u603b\u64cd\u4f5c\u6b21\u6570\u4e3a \\(n \\times n = n^2\\)\u3002</p> </li> <li> <p>\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u7684 Big O \u6027\u80fd\u662f\u591a\u5c11\uff1f</p> <pre><code>    for i in range(n):\n            k = 2 + 2\n</code></pre> <p>Big O \u6027\u80fd\uff1a \\(O(n)\\)</p> <p>\u89e3\u91ca\uff1a \u6709\u4e00\u4e2a\u5faa\u73af\u8fd0\u884c \\(n\\) \u6b21\uff0c\u56e0\u6b64\u64cd\u4f5c\u6b21\u6570\u4e0e \\(n\\) \u6210\u7ebf\u6027\u5173\u7cfb\u3002</p> </li> <li> <p>\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u7684 Big O \u6027\u80fd\u662f\u591a\u5c11\uff1f</p> <pre><code>    i = n\n    while i &gt; 0:\n        k = 2 + 2\n        i = i // 2\n</code></pre> <p>Big O \u6027\u80fd\uff1a \\(O(\\log n)\\)</p> <p>\u89e3\u91ca\uff1a \u6bcf\u6b21\u8fed\u4ee3\u65f6 \\(i\\) \u7684\u503c\u88ab\u51cf\u534a\uff0c\u56e0\u6b64\u8fed\u4ee3\u6b21\u6570\u4e0e \\(n\\) \u53ef\u4ee5\u88ab 2 \u9664\u7684\u6b21\u6570\u6210\u6b63\u6bd4\uff0c\u5373 \\(\\log n\\)\u3002</p> </li> <li> <p>\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u7684 Big O \u6027\u80fd\u662f\u591a\u5c11\uff1f</p> <pre><code>    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                k = 2 + 2\n</code></pre> <p>Big O \u6027\u80fd\uff1a \\(O(n^3)\\)</p> <p>\u89e3\u91ca\uff1a \u6709\u4e09\u4e2a\u5d4c\u5957\u7684\u5faa\u73af\uff0c\u6bcf\u4e2a\u5faa\u73af\u8fd0\u884c \\(n\\) \u6b21\uff0c\u603b\u64cd\u4f5c\u6b21\u6570\u4e3a \\(n \\times n \\times n = n^3\\)\u3002</p> </li> <li> <p>\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\u7684 Big O \u6027\u80fd\u662f\u591a\u5c11\uff1f</p> <pre><code>    for i in range(n):\n        k = 2 + 2\n    for j in range(n):\n        k = 2 + 2\n    for k in range(n):\n        k = 2 + 2\n</code></pre> <p>Big O \u6027\u80fd\uff1a \\(O(n)\\)</p> <p>\u89e3\u91ca\uff1a \u867d\u7136\u6709\u4e09\u4e2a\u5206\u5f00\u7684\u5faa\u73af\uff0c\u4f46\u5b83\u4eec\u662f\u987a\u5e8f\u6267\u884c\u7684\u800c\u4e0d\u662f\u5d4c\u5957\u7684\u3002\u6bcf\u4e2a\u5faa\u73af\u8fd0\u884c \\(n\\) \u6b21\uff0c\u56e0\u6b64\u603b\u64cd\u4f5c\u6b21\u6570\u4e3a \\(3n\\)\uff0c\u5728 Big O \u8bb0\u6cd5\u4e2d\u5e38\u6570\u7cfb\u6570\u88ab\u7701\u7565\uff0c\u6240\u4ee5\u4e3a \\(O(n)\\)\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u4e00\u4e2a\u5b9e\u9a8c\u6765\u9a8c\u8bc1 <code>list index</code> \u64cd\u4f5c\u7b26\u7684\u6027\u80fd\u662f \\(O(1)\\)\uff1a</p> <p>\u5b9e\u9a8c\uff1a \u6d4b\u91cf\u8bbf\u95ee\u5217\u8868\u4e2d\u67d0\u4e2a\u7279\u5b9a\u7d22\u5f15\u7684\u65f6\u95f4\uff0c\u5e76\u5bf9\u4e0d\u540c\u5927\u5c0f\u7684\u5217\u8868\u8fdb\u884c\u6d4b\u8bd5\u3002</p> <p>\u5b9e\u73b0\uff1a</p> <pre><code>import timeit\n\ndef index_test(n):\n    l = list(range(n))\n    for _ in range(1000):  # \u91cd\u590d\u4ee5\u83b7\u5f97\u7a33\u5b9a\u7684\u6d4b\u91cf\u7ed3\u679c\n        _ = l[n // 2]  # \u8bbf\u95ee\u4e2d\u95f4\u5143\u7d20\n\nfor size in [10, 100, 1000, 10000]:\n    time_taken = timeit.timeit(lambda: index_test(size), number=1)\n    print(f\"\u5217\u8868\u5927\u5c0f: {size}, \u8017\u65f6: {time_taken:.6f} \u79d2\")\n</code></pre> <p>\u9884\u671f\u7ed3\u679c\uff1a \u65e0\u8bba\u5217\u8868\u5927\u5c0f\u5982\u4f55\uff0c\u65f6\u95f4\u5e94\u8be5\u4fdd\u6301\u4e0d\u53d8\uff0c\u4ece\u800c\u9a8c\u8bc1 \\(O(1)\\) \u6027\u80fd\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u4e00\u4e2a\u5b9e\u9a8c\u6765\u9a8c\u8bc1 <code>get item</code> \u548c <code>set item</code> \u64cd\u4f5c\u5728\u5b57\u5178\u4e2d\u7684\u6027\u80fd\u662f \\(O(1)\\)\uff1a</p> <p>\u5b9e\u9a8c\uff1a \u6d4b\u91cf\u4ece\u5b57\u5178\u4e2d\u83b7\u53d6\u548c\u8bbe\u7f6e\u9879\u7684\u65f6\u95f4\uff0c\u5e76\u5bf9\u4e0d\u540c\u5927\u5c0f\u7684\u5b57\u5178\u8fdb\u884c\u6d4b\u8bd5\u3002</p> <p>\u5b9e\u73b0\uff1a</p> <pre><code>import timeit\n\ndef dict_get_set_test(n):\n    d = {i: i for i in range(n)}\n    for _ in range(1000):  # \u91cd\u590d\u4ee5\u83b7\u5f97\u7a33\u5b9a\u7684\u6d4b\u91cf\u7ed3\u679c\n        _ = d[n // 2]  # \u83b7\u53d6\u9879\n        d[n // 2] = n // 2  # \u8bbe\u7f6e\u9879\n\nfor size in [10, 100, 1000, 10000]:\n    time_taken = timeit.timeit(lambda: dict_get_set_test(size), number=1)\n    print(f\"\u5b57\u5178\u5927\u5c0f: {size}, \u8017\u65f6: {time_taken:.6f} \u79d2\")\n</code></pre> <p>\u9884\u671f\u7ed3\u679c\uff1a \u65e0\u8bba\u5b57\u5178\u5927\u5c0f\u5982\u4f55\uff0c\u65f6\u95f4\u5e94\u8be5\u4fdd\u6301\u4e0d\u53d8\uff0c\u4ece\u800c\u9a8c\u8bc1 \\(O(1)\\) \u6027\u80fd\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u4e00\u4e2a\u5b9e\u9a8c\u6765\u6bd4\u8f83 <code>del</code> \u64cd\u4f5c\u7b26\u5728\u5217\u8868\u548c\u5b57\u5178\u4e2d\u7684\u6027\u80fd\uff1a</p> <p>\u5b9e\u9a8c\uff1a \u6d4b\u91cf\u4ece\u5217\u8868\u548c\u5b57\u5178\u4e2d\u5220\u9664\u9879\u7684\u65f6\u95f4\uff0c\u5e76\u5bf9\u4e0d\u540c\u5927\u5c0f\u7684\u5217\u8868\u548c\u5b57\u5178\u8fdb\u884c\u6d4b\u8bd5\u3002</p> <p>\u5b9e\u73b0\uff1a</p> <pre><code>import timeit\n\ndef list_del_test(n):\n    l = list(range(n))\n    for _ in range(1000):  # \u91cd\u590d\u4ee5\u83b7\u5f97\u7a33\u5b9a\u7684\u6d4b\u91cf\u7ed3\u679c\n        l.pop()  # \u4ece\u672b\u5c3e\u5220\u9664\n\ndef dict_del_test(n):\n    d = {i: i for i in range(n)}\n    for _ in range(1000):  # \u91cd\u590d\u4ee5\u83b7\u5f97\u7a33\u5b9a\u7684\u6d4b\u91cf\u7ed3\u679c\n        del d[n // 2]  # \u5220\u9664\u7279\u5b9a\u952e\n\nfor size in [10, 100, 1000, 10000]:\n    list_time = timeit.timeit(lambda: list_del_test(size), number=1)\n    dict_time = timeit.timeit(lambda: dict_del_test(size), number=1)\n    print(f\"\u5927\u5c0f: {size}, \u5217\u8868\u5220\u9664\u65f6\u95f4: {list_time:.6f} \u79d2, \u5b57\u5178\u5220\u9664\u65f6\u95f4: {dict_time:.6f} \u79d2\")\n</code></pre> <p>\u9884\u671f\u7ed3\u679c\uff1a \u5220\u9664\u5b57\u5178\u4e2d\u7684\u9879\u65f6\u95f4\u5e94\u8be5\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c\u4ece\u5217\u8868\u4e2d\u5220\u9664\u9879\u7684\u65f6\u95f4\u4f1a\u968f\u7740\u5217\u8868\u5927\u5c0f\u7684\u589e\u52a0\u800c\u7ebf\u6027\u589e\u957f\u3002</p> </li> <li> <p>\u7ed9\u5b9a\u4e00\u4e2a\u968f\u673a\u987a\u5e8f\u7684\u6570\u5b57\u5217\u8868\uff0c\u7f16\u5199\u4e00\u4e2a \\(O(n \\log n)\\) \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\u6765\u627e\u5230\u5217\u8868\u4e2d\u7684\u7b2c \\(k\\) \u5c0f\u7684\u6570\u5b57\uff1a</p> <p>\u7b97\u6cd5\uff1a \u5bf9\u5217\u8868\u8fdb\u884c\u6392\u5e8f\uff0c\u7136\u540e\u8bbf\u95ee\u7b2c \\(k\\) \u5c0f\u7684\u5143\u7d20\u3002</p> <p>\u5b9e\u73b0\uff1a</p> <pre><code>def kth_smallest(arr, k):\n    sorted_arr = sorted(arr)  # O(n log n) \u6392\u5e8f\n    return sorted_arr[k - 1]  # \u8bbf\u95ee\u7b2c k \u5c0f\u7684\u5143\u7d20\n\n# \u793a\u4f8b\u7528\u6cd5\uff1a\nimport random\nnums = random.sample(range(1, 10000), 5000)  # \u751f\u6210\u968f\u673a\u6570\u5217\u8868\nprint(kth_smallest(nums, 10))\n</code></pre> </li> <li> <p>\u80fd\u5426\u5c06\u4e0a\u4e00\u4e2a\u95ee\u9898\u4e2d\u7684\u7b97\u6cd5\u6539\u8fdb\u4e3a\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\uff1f\u89e3\u91ca\uff1a</p> <p>\u7b97\u6cd5\uff1a \u4f7f\u7528 Quickselect \u7b97\u6cd5\uff0c\u8fd9\u53ef\u4ee5\u5728\u671f\u671b\u7684 \\(O(n)\\) \u65f6\u95f4\u590d\u6742\u5ea6\u5185\u627e\u5230\u7b2c \\(k\\) \u5c0f\u7684\u5143\u7d20\u3002</p> <p>\u89e3\u91ca\uff1a Quickselect \u662f\u4e00\u4e2a\u9009\u62e9\u7b97\u6cd5\uff0c\u7528\u4e8e\u5728\u65e0\u5e8f\u5217\u8868\u4e2d\u627e\u5230\u7b2c \\(k\\) \u5c0f\u7684\u5143\u7d20\u3002\u5b83\u4e0e\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u76f8\u5173\uff0c\u4f46\u4ec5\u5bf9\u5217\u8868\u8fdb\u884c\u90e8\u5206\u6392\u5e8f\u3002\u5176\u5e73\u5747\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(n)\\)\uff0c\u5c3d\u7ba1\u6700\u574f\u60c5\u51b5\u4e0b\u7684\u590d\u6742\u5ea6\u4e3a \\(O(n^2)\\)\uff0c\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u968f\u673a\u5316\u6216\u4e2d\u4f4d\u6570\u7684\u4e2d\u4f4d\u6570\u6280\u672f\u6765\u7f13\u89e3\u3002</p> <p>\u5b9e\u73b0\uff1a</p> <pre><code>import random\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] &lt;= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef quickselect(arr, low, high, k):\n    if low == high:\n        return arr[low]\n    pivot_index = random.randint(low, high)\n    pivot_index = partition(arr, low, high)\n    if k == pivot_index:\n        return arr[k]\n    elif k &lt; pivot_index:\n        return quickselect(arr, low, pivot_index - 1, k)\n    else:\n        return quickselect(arr, pivot_index + 1, high, k)\n\ndef find_kth_smallest(arr, k):\n    return quickselect(arr, 0, len(arr) - 1, k - 1)\n\n# \u793a\u4f8b\u7528\u6cd5\uff1a\nnums = random.sample(range(1, 10000), 5000)\nprint(find_kth_smallest(nums, 10))\n</code></pre> <p>\u89e3\u91ca\uff1a Quickselect \u7b97\u6cd5\u65e8\u5728\u4ee5\u5e73\u5747 \\(O(n)\\) \u65f6\u95f4\u590d\u6742\u5ea6\u627e\u5230\u7b2c \\(k\\) \u5c0f\u7684\u5143\u7d20\uff0c\u4f7f\u5176\u6bd4\u6392\u5e8f\u66f4\u9ad8\u6548\uff0c\u53ea\u9700\u627e\u5230\u4e00\u4e2a\u5143\u7d20\u3002</p> </li> </ol> <ol> <li> <p>Give the Big O performance of the following code fragment:</p> <pre><code>for i in range(n):\n    for j in range(n):\n        k = 2 + 2\n</code></pre> </li> <li> <p>Give the Big O performance of the following code fragment:</p> <pre><code>    for i in range(n):\n            k = 2 + 2\n</code></pre> </li> <li> <p>Give the Big O performance of the following code fragment:</p> <pre><code>    i = n\n    while i &gt; 0:\n        k = 2 + 2\n        i = i // 2\n</code></pre> </li> <li> <p>Give the Big O performance of the following code fragment:</p> <pre><code>    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                k = 2 + 2\n</code></pre> </li> <li> <p>Give the Big O performance of the following code fragment:</p> <pre><code>    for i in range(n):\n        k = 2 + 2\n    for j in range(n):\n        k = 2 + 2\n    for k in range(n):\n        k = 2 + 2\n</code></pre> </li> <li> <p>Devise an experiment to verify that the <code>list index</code> operator is \\(O(1)\\).</p> </li> <li> <p>Devise an experiment to verify that <code>get item</code> and <code>set item</code> are \\(O(1)\\) for dictionaries.</p> </li> <li> <p>Devise an experiment that compares the performance of the <code>del</code> operator on lists and dictionaries.</p> </li> <li> <p>Given a list of numbers in random order, write an algorithm that works in \\(O(n\\log(n))\\) to find the \\(k\\) th smallest number in the list.</p> </li> <li> <p>Can you improve the algorithm from the previous problem to be linear? Explain.</p> </li> </ol>"},{"location":"c2/s2/","title":"2.2. \u4ec0\u4e48\u662f\u7b97\u6cd5\u5206\u6790\uff1f","text":"<p>2.2. What Is Algorithm Analysis?</p> \u4e2d\u6587\u82f1\u6587 <p>\u5bf9\u4e8e\u521a\u5f00\u59cb\u8ba1\u7b97\u673a\u79d1\u5b66\u4e13\u4e1a\u7684\u5b66\u751f\u6765\u8bf4\uff0c\u76f8\u4e92\u6bd4\u8f83\u4ed6\u4eec\u7684\u7a0b\u5e8f\u662f\u5f88\u5e38\u89c1\u7684\u3002 \u60a8\u53ef\u80fd\u8fd8\u6ce8\u610f\u5230\uff0c\u8ba1\u7b97\u673a\u7a0b\u5e8f\u770b\u8d77\u6765\u975e\u5e38\u76f8\u4f3c\u662f\u5f88\u5e38\u89c1\u7684\uff0c\u5c24\u5176\u662f\u7b80\u5355\u7684\u7a0b\u5e8f\u3002 \u7ecf\u5e38\u4f1a\u51fa\u73b0\u4e00\u4e2a\u6709\u8da3\u7684\u95ee\u9898\u3002 \u5f53\u4e24\u4e2a\u7a0b\u5e8f\u89e3\u51b3\u76f8\u540c\u7684\u95ee\u9898\u4f46\u770b\u8d77\u6765\u4e0d\u540c\u65f6\uff0c\u4e00\u4e2a\u7a0b\u5e8f\u6bd4\u53e6\u4e00\u4e2a\u66f4\u597d\u5417\uff1f</p> <p>\u4e3a\u4e86\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u4f4f\u7a0b\u5e8f\u548c\u7a0b\u5e8f\u6240\u4ee3\u8868\u7684\u5e95\u5c42\u7b97\u6cd5\u4e4b\u95f4\u5b58\u5728\u91cd\u8981\u533a\u522b\u3002 \u6b63\u5982\u6211\u4eec\u5728\u7b2c\u4e00\u7ae0\u4e2d\u6240\u8ff0\uff0c\u7b97\u6cd5\u662f\u7528\u4e8e\u89e3\u51b3\u95ee\u9898\u7684\u901a\u7528\u7684\u3001\u9010\u6b65\u7684\u6307\u4ee4\u5217\u8868\u3002 \u5b83\u662f\u4e00\u79cd\u89e3\u51b3\u95ee\u9898\u7684\u4efb\u4f55\u5b9e\u4f8b\u7684\u65b9\u6cd5\uff0c\u4ee5\u4fbf\u7ed9\u5b9a\u7279\u5b9a\u8f93\u5165\uff0c\u7b97\u6cd5\u4ea7\u751f\u6240\u9700\u7684\u7ed3\u679c\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u7a0b\u5e8f\u662f\u4e00\u79cd\u5df2\u7f16\u7801\u4e3a\u67d0\u79cd\u7f16\u7a0b\u8bed\u8a00\u7684\u7b97\u6cd5\u3002 \u540c\u4e00\u7b97\u6cd5\u53ef\u80fd\u6709\u8bb8\u591a\u7a0b\u5e8f\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u7a0b\u5e8f\u5458\u548c\u6240\u4f7f\u7528\u7684\u7f16\u7a0b\u8bed\u8a00\u3002</p> <p>\u4e3a\u4e86\u8fdb\u4e00\u6b65\u63a2\u7d22\u8fd9\u79cd\u5dee\u5f02\uff0c\u8bf7\u8003\u8651\u201cActiveCode 1\u201d\u4e2d\u663e\u793a\u7684\u51fd\u6570\u3002 \u8be5\u51fd\u6570\u89e3\u51b3\u4e86\u4e00\u4e2a\u719f\u6089\u7684\u95ee\u9898\uff0c\u8ba1\u7b97\u524d n \u4e2a\u6574\u6570\u7684\u603b\u548c\u3002 \u8be5\u7b97\u6cd5\u4f7f\u7528\u521d\u59cb\u5316\u4e3a 0 \u7684\u7d2f\u52a0\u5668\u53d8\u91cf\u7684\u601d\u60f3\u3002\u7136\u540e\uff0c\u8be5\u89e3\u51b3\u65b9\u6848\u8fed\u4ee3 n \u4e2a\u6574\u6570\uff0c\u5c06\u6bcf\u4e2a\u6574\u6570\u6dfb\u52a0\u5230\u7d2f\u52a0\u5668\u4e2d\u3002</p> \u524d n \u4e2a\u6574\u6570\u7684\u6c42\u548c<pre><code>def sum_of_n(n):\n    the_sum = 0\n    for i in range(1, n + 1):\n        the_sum = the_sum + i\n\n    return the_sum\n\nprint(sum_of_n(10))\n</code></pre> <p>\u73b0\u5728\u770b\u770b\u201cActiveCode 2\u201d\u4e2d\u7684\u51fd\u6570\u3002 \u4e4d\u4e00\u770b\uff0c\u5b83\u53ef\u80fd\u770b\u8d77\u6765\u5f88\u5947\u602a\uff0c\u4f46\u7ecf\u8fc7\u8fdb\u4e00\u6b65\u68c0\u67e5\uff0c\u60a8\u4f1a\u53d1\u73b0\u8be5\u51fd\u6570\u672c\u8d28\u4e0a\u4e0e\u524d\u4e00\u4e2a\u51fd\u6570\u6267\u884c\u76f8\u540c\u7684\u64cd\u4f5c\u3002 \u8fd9\u4e0d\u660e\u663e\u7684\u539f\u56e0\u662f\u7f16\u7801\u4e0d\u4f73\u3002 \u6211\u4eec\u6ca1\u6709\u4f7f\u7528\u597d\u7684\u6807\u8bc6\u7b26\u540d\u79f0\u6765\u63d0\u9ad8\u53ef\u8bfb\u6027\uff0c\u5e76\u4e14\u6211\u4eec\u4f7f\u7528\u4e86\u5728\u7d2f\u79ef\u6b65\u9aa4\u4e2d\u5e76\u4e0d\u662f\u771f\u6b63\u5fc5\u8981\u7684\u989d\u5916\u8d4b\u503c\u8bed\u53e5\u3002</p> \u524d n \u4e2a\u6574\u6570\u7684\u53e6\u4e00\u4e2a\u6c42\u548c<pre><code>def foo(tom):\n    fred = 0\n    for bill in range(1, tom + 1):\n        barney = bill\n        fred = fred + barney\n\n    return fred\n\nprint(foo(10))\n</code></pre> <p>\u6211\u4eec\u4e4b\u524d\u63d0\u51fa\u7684\u95ee\u9898\u662f\u4e00\u4e2a\u51fd\u6570\u662f\u5426\u6bd4\u53e6\u4e00\u4e2a\u51fd\u6570\u66f4\u597d\u3002 \u7b54\u6848\u53d6\u51b3\u4e8e\u60a8\u7684\u6807\u51c6\u3002 \u5982\u679c\u60a8\u5173\u5fc3\u53ef\u8bfb\u6027\uff0c\u51fd\u6570\u201csum_of_n\u201d\u80af\u5b9a\u6bd4\u51fd\u6570\u201cfoo\u201d\u66f4\u597d\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u60a8\u53ef\u80fd\u5728\u5165\u95e8\u7f16\u7a0b\u8bfe\u7a0b\u4e2d\u770b\u5230\u8fc7\u8bb8\u591a\u8fd9\u6837\u7684\u793a\u4f8b\uff0c\u56e0\u4e3a\u5176\u4e2d\u7684\u76ee\u6807\u4e4b\u4e00\u662f\u5e2e\u52a9\u60a8\u7f16\u5199\u6613\u4e8e\u9605\u8bfb\u548c\u7406\u89e3\u7684\u7a0b\u5e8f\u3002 \u7136\u800c\uff0c\u5728\u672c\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4e5f\u5bf9\u7b97\u6cd5\u672c\u8eab\u7684\u7279\u5f81\u611f\u5174\u8da3\u3002 \uff08\u6211\u4eec\u5f53\u7136\u5e0c\u671b\u60a8\u7ee7\u7eed\u52aa\u529b\u7f16\u5199\u53ef\u8bfb\u3001\u53ef\u7406\u89e3\u7684\u4ee3\u7801\u3002\uff09</p> <p>\u7b97\u6cd5\u5206\u6790\u6d89\u53ca\u6839\u636e\u6bcf\u79cd\u7b97\u6cd5\u4f7f\u7528\u7684\u8ba1\u7b97\u8d44\u6e90\u91cf\u6765\u6bd4\u8f83\u7b97\u6cd5\u3002 \u6211\u4eec\u5e0c\u671b\u80fd\u591f\u8003\u8651\u4e24\u79cd\u7b97\u6cd5\uff0c\u5e76\u8bf4\u5176\u4e2d\u4e00\u79cd\u6bd4\u53e6\u4e00\u79cd\u66f4\u597d\uff0c\u56e0\u4e3a\u5b83\u5728\u4f7f\u7528\u8fd9\u4e9b\u8d44\u6e90\u65b9\u9762\u66f4\u6709\u6548\uff0c\u6216\u8005\u53ef\u80fd\u53ea\u662f\u56e0\u4e3a\u5b83\u4f7f\u7528\u7684\u8d44\u6e90\u66f4\u5c11\u3002 \u4ece\u8fd9\u4e2a\u89d2\u5ea6\u6765\u770b\uff0c\u4e0a\u9762\u4e24\u4e2a\u51fd\u6570\u770b\u8d77\u6765\u975e\u5e38\u76f8\u4f3c\u3002 \u5b83\u4eec\u672c\u8d28\u4e0a\u90fd\u4f7f\u7528\u76f8\u540c\u7684\u7b97\u6cd5\u6765\u89e3\u51b3\u6c42\u548c\u95ee\u9898\u3002</p> <p>\u6b64\u65f6\uff0c\u91cd\u8981\u7684\u662f\u8981\u66f4\u591a\u5730\u601d\u8003\u8ba1\u7b97\u8d44\u6e90\u7684\u771f\u6b63\u542b\u4e49\u3002 \u6709\u4e24\u79cd\u4e0d\u540c\u7684\u65b9\u5f0f\u6765\u770b\u5f85\u8fd9\u4e2a\u95ee\u9898\u3002 \u4e00\u79cd\u65b9\u6cd5\u662f\u8003\u8651\u7b97\u6cd5\u89e3\u51b3\u95ee\u9898\u6240\u9700\u7684\u7a7a\u95f4\u6216\u5185\u5b58\u91cf\u3002 \u95ee\u9898\u89e3\u51b3\u65b9\u6848\u6240\u9700\u7684\u7a7a\u95f4\u91cf\u901a\u5e38\u7531\u95ee\u9898\u5b9e\u4f8b\u672c\u8eab\u51b3\u5b9a\u3002 \u7136\u800c\uff0c\u65f6\u5e38\u6709\u4e00\u4e9b\u7b97\u6cd5\u6709\u975e\u5e38\u5177\u4f53\u7684\u7a7a\u95f4\u8981\u6c42\uff0c\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4f1a\u975e\u5e38\u5c0f\u5fc3\u5730\u89e3\u91ca\u8fd9\u4e9b\u53d8\u5316\u3002</p> <p>\u4f5c\u4e3a\u7a7a\u95f4\u8981\u6c42\u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u7b97\u6cd5\u6240\u9700\u7684\u6267\u884c\u65f6\u95f4\u6765\u5206\u6790\u548c\u6bd4\u8f83\u7b97\u6cd5\u3002 \u6b64\u5ea6\u91cf\u6709\u65f6\u79f0\u4e3a\u7b97\u6cd5\u7684\u201c\u6267\u884c\u65f6\u95f4(execution time)\u201d\u6216\u201c\u8fd0\u884c\u65f6\u95f4(running time)\u201d\u3002 \u6211\u4eec\u6d4b\u91cf\u51fd\u6570<code>sum_of_n</code>\u6267\u884c\u65f6\u95f4\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u8fdb\u884c\u57fa\u51c6\u5206\u6790(benchmark analysis)\u3002 \u8fd9\u610f\u5473\u7740\u6211\u4eec\u5c06\u8ddf\u8e2a\u7a0b\u5e8f\u8ba1\u7b97\u5176\u7ed3\u679c\u6240\u9700\u7684\u5b9e\u9645\u65f6\u95f4\u3002 \u5728Python\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8bb0\u5f55\u6211\u4eec\u6b63\u5728\u4f7f\u7528\u7684\u7cfb\u7edf\u5185\u7684\u5f00\u59cb\u65f6\u95f4\u548c\u7ed3\u675f\u65f6\u95f4\u6765\u5bf9\u51fd\u6570\u8fdb\u884c\u57fa\u51c6\u6d4b\u8bd5\u3002 \u5728<code>time</code>\u6a21\u5757\u4e2d\uff0c\u6709\u4e00\u4e2a\u540d\u4e3a<code>time</code>\u7684\u51fd\u6570\uff0c\u5b83\u5c06\u8fd4\u56de\u81ea\u67d0\u4e2a\u4efb\u610f\u8d77\u70b9\u4ee5\u6765\u7684\u5f53\u524d\u7cfb\u7edf\u65f6\u949f\u65f6\u95f4\uff08\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff09\u3002 \u901a\u8fc7\u5728\u5f00\u59cb\u548c\u7ed3\u675f\u65f6\u8c03\u7528\u8be5\u51fd\u6570\u4e24\u6b21\uff0c\u7136\u540e\u8ba1\u7b97\u5dee\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u5f97\u6267\u884c\u7684\u7cbe\u786e\u79d2\u6570\uff08\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u662f\u5206\u6570\uff09\u3002</p> <pre><code>import time\n\ndef sum_of_n_2(n):\n    start = time.time()\n\n    the_sum = 0\n    for i in range(1, n + 1):\n        the_sum = the_sum + i\n\n    end = time.time()\n\n    return the_sum, end - start\n</code></pre> <p>\u201c\u6e05\u5355 1\u201d\u663e\u793a\u4e86\u539f\u59cb\u7684<code>sum_of_n</code>\u51fd\u6570\uff0c\u5176\u4e2d\u5728\u6c42\u548c\u4e4b\u524d\u548c\u4e4b\u540e\u5d4c\u5165\u4e86\u5b9a\u65f6\u8c03\u7528\u3002 \u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u7531\u7ed3\u679c\u548c\u8ba1\u7b97\u6240\u9700\u7684\u65f6\u95f4\uff08\u4ee5\u79d2\u4e3a\u5355\u4f4d\uff09\u7ec4\u6210\u7684\u5143\u7ec4\u3002 \u5982\u679c\u6211\u4eec\u5bf9\u8be5\u51fd\u6570\u6267\u884c\u4e94\u6b21\u8c03\u7528\uff0c\u6bcf\u6b21\u8c03\u7528\u8ba1\u7b97\u524d 10,000 \u4e2a\u6574\u6570\u7684\u603b\u548c\uff0c\u6211\u4eec\u5c06\u5f97\u5230\u4ee5\u4e0b\u7ed3\u679c\uff1a</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(10000))\n... \nSum is 50005000 required  0.0018950 seconds\nSum is 50005000 required  0.0018620 seconds\nSum is 50005000 required  0.0019171 seconds\nSum is 50005000 required  0.0019162 seconds\nSum is 50005000 required  0.0019360 seconds\n&gt;&gt;&gt;\n</code></pre> <p>\u6211\u4eec\u53d1\u73b0\u65f6\u95f4\u76f8\u5f53\u4e00\u81f4\uff0c\u6267\u884c\u8be5\u4ee3\u7801\u5e73\u5747\u9700\u8981\u5927\u7ea6 0.0019 \u79d2\u3002 \u5982\u679c\u6211\u4eec\u8fd0\u884c\u6dfb\u52a0\u524d 100,000 \u4e2a\u6574\u6570\u7684\u51fd\u6570\u4f1a\u600e\u6837\uff1f</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(100000))\n... \nSum is 5000050000 required  0.0199420 seconds\nSum is 5000050000 required  0.0180972 seconds\nSum is 5000050000 required  0.0194821 seconds\nSum is 5000050000 required  0.0178988 seconds\nSum is 5000050000 required  0.0188949 seconds\n&gt;&gt;&gt;\n</code></pre> <p>\u540c\u6837\uff0c\u6bcf\u6b21\u8fd0\u884c\u6240\u9700\u7684\u65f6\u95f4\u867d\u7136\u8f83\u957f\uff0c\u4f46\u975e\u5e38\u4e00\u81f4\uff0c\u5e73\u5747\u5927\u7ea6\u591a\u51fa 10 \u500d\u79d2\u3002 \u5f53\u201cn\u201d\u7b49\u4e8e 1,000,000 \u65f6\uff0c\u6211\u4eec\u5f97\u5230\uff1a</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(1000000))\n...\nSum is 500000500000 required  0.1948988 seconds\nSum is 500000500000 required  0.1850290 seconds\nSum is 500000500000 required  0.1809771 seconds\nSum is 500000500000 required  0.1729250 seconds\nSum is 500000500000 required  0.1646299 seconds\n&gt;&gt;&gt;\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5e73\u5747\u503c\u518d\u6b21\u7ea6\u4e3a\u4e4b\u524d\u5b9e\u9a8c\u7684 10 \u500d\u3002</p> <p>\u73b0\u5728\u8003\u8651\u201cActiveCode 3\u201d\uff0c\u5b83\u5c55\u793a\u4e86\u89e3\u51b3\u6c42\u548c\u95ee\u9898\u7684\u4e0d\u540c\u65b9\u6cd5\u3002 \u6b64\u51fd\u6570\u201csum_of_n_3\u201d\u5229\u7528\u95ed\u65b9\u7a0b \\(\\sum_{i=1}^{n} i = \\frac {(n)(n+1)}{2}\\) \u6765\u8ba1\u7b97\u603b\u548c\u524d\u201cn\u201d\u4e2a\u6574\u6570\uff0c\u65e0\u9700\u8fed\u4ee3\u3002</p> \u4e0d\u8fed\u4ee3\u6c42\u548c<pre><code>def sum_of_n_3(n):\n    return (n * (n + 1)) / 2\n\n\nprint(sum_of_n_3(10))\n</code></pre> <p>\u5982\u679c\u6211\u4eec\u5bf9\u201csum_of_n_3\u201d\u8fdb\u884c\u76f8\u540c\u7684\u57fa\u51c6\u6d4b\u91cf\uff0c\u4f7f\u7528\u4e94\u4e2a\u4e0d\u540c\u7684\u201cn\u201d\u503c\uff0810,000\u3001100,000\u30011,000,000\u300110,000,000 \u548c 100,000,000\uff09\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u4ee5\u4e0b\u7ed3\u679c\uff1a</p> <pre><code>Sum is 50005000 required 0.00000095 seconds\nSum is 5000050000 required 0.00000191 seconds\nSum is 500000500000 required 0.00000095 seconds\nSum is 50000005000000 required 0.00000095 seconds\nSum is 5000000050000000 required 0.00000119 seconds\n</code></pre> <p>\u5173\u4e8e\u6b64\u8f93\u51fa\uff0c\u6709\u4e24\u4ef6\u91cd\u8981\u7684\u4e8b\u60c5\u9700\u8981\u6ce8\u610f\u3002 \u9996\u5148\uff0c\u4e0a\u9762\u8bb0\u5f55\u7684\u65f6\u95f4\u6bd4\u524d\u9762\u7684\u4efb\u4f55\u4f8b\u5b50\u90fd\u77ed\u3002 \u5176\u6b21\uff0c\u65e0\u8bba\u201cn\u201d\u7684\u503c\u662f\u591a\u5c11\uff0c\u5b83\u4eec\u90fd\u975e\u5e38\u4e00\u81f4\u3002 \u770b\u6765\u201csum_of_n_3\u201d\u51e0\u4e4e\u4e0d\u53d7\u6dfb\u52a0\u7684\u6574\u6570\u6570\u91cf\u7684\u5f71\u54cd\u3002</p> <p>\u4f46\u8fd9\u4e2a\u57fa\u51c6\u6d4b\u8bd5\u771f\u6b63\u544a\u8bc9\u6211\u4eec\u4ec0\u4e48\uff1f \u76f4\u89c2\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u8fed\u4ee3\u89e3\u51b3\u65b9\u6848\u4f3c\u4e4e\u505a\u4e86\u66f4\u591a\u7684\u5de5\u4f5c\uff0c\u56e0\u4e3a\u67d0\u4e9b\u7a0b\u5e8f\u6b65\u9aa4\u6b63\u5728\u91cd\u590d\u3002 \u8fd9\u53ef\u80fd\u662f\u9700\u8981\u66f4\u957f\u65f6\u95f4\u7684\u539f\u56e0\u3002 \u6b64\u5916\uff0c\u968f\u7740\u6211\u4eec\u589e\u52a0\u201cn\u201d\u7684\u503c\uff0c\u8fed\u4ee3\u89e3\u51b3\u65b9\u6848\u6240\u9700\u7684\u65f6\u95f4\u4f3c\u4e4e\u4e5f\u4f1a\u589e\u52a0\u3002 \u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u5728\u4e0d\u540c\u7684\u8ba1\u7b97\u673a\u4e0a\u8fd0\u884c\u76f8\u540c\u7684\u51fd\u6570\u6216\u4f7f\u7528\u4e0d\u540c\u7684\u7f16\u7a0b\u8bed\u8a00\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u5f97\u5230\u4e0d\u540c\u7684\u7ed3\u679c\u3002 \u5982\u679c\u8ba1\u7b97\u673a\u8f83\u65e7\uff0c\u5219\u6267\u884c\u201csum_of_n_3\u201d\u53ef\u80fd\u9700\u8981\u66f4\u957f\u7684\u65f6\u95f4\u3002</p> <p>\u6211\u4eec\u9700\u8981\u4e00\u79cd\u66f4\u597d\u7684\u65b9\u6cd5\u6765\u63cf\u8ff0\u8fd9\u4e9b\u7b97\u6cd5\u5728\u6267\u884c\u65f6\u95f4\u65b9\u9762\u7684\u7279\u5f81\u3002 \u57fa\u51c6\u6d4b\u8bd5\u6280\u672f\u8ba1\u7b97\u5b9e\u9645\u6267\u884c\u65f6\u95f4\u3002 \u5b83\u5e76\u6ca1\u6709\u771f\u6b63\u4e3a\u6211\u4eec\u63d0\u4f9b\u6709\u7528\u7684\u6d4b\u91cf\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4e8e\u7279\u5b9a\u7684\u673a\u5668\u3001\u7a0b\u5e8f\u3001\u4e00\u5929\u4e2d\u7684\u65f6\u95f4\u3001\u7f16\u8bd1\u5668\u548c\u7f16\u7a0b\u8bed\u8a00\u3002 \u76f8\u53cd\uff0c\u6211\u4eec\u5e0c\u671b\u62e5\u6709\u72ec\u7acb\u4e8e\u6240\u4f7f\u7528\u7684\u7a0b\u5e8f\u6216\u8ba1\u7b97\u673a\u7684\u7279\u5f81\u3002 \u8fd9\u79cd\u6d4b\u91cf\u5bf9\u4e8e\u5355\u72ec\u5224\u65ad\u7b97\u6cd5\u5f88\u6709\u7528\uff0c\u5e76\u4e14\u53ef\u4ee5\u7528\u4e8e\u6bd4\u8f83\u8de8\u5b9e\u73b0\u7684\u7b97\u6cd5\u3002</p> <p>What Is Algorithm Analysis?</p> <p>It is very common for beginning computer science students to compare their programs with one another. You may also have noticed that it is common for computer programs to look very similar, especially the simple ones. An interesting question often arises. When two programs solve the same problem but look different, is one program better than the other?</p> <p>In order to answer this question, we need to remember that there is an important difference between a program and the underlying algorithm that the program is representing. As we stated in Chapter 1, an algorithm is a generic, step-by-step list of instructions for solving a problem. It is a method for solving any instance of the problem so that given a particular input, the algorithm produces the desired result. A program, on the other hand, is an algorithm that has been encoded into some programming language. There may be many programs for the same algorithm, depending on the programmer and the programming language being used.</p> <p>To explore this difference further, consider the function shown in <code>ActiveCode 1</code>. This function solves a familiar problem, computing the sum of the first n integers. The algorithm uses the idea of an accumulator variable that is initialized to 0. The solution then iterates through the n integers, adding each to the accumulator.</p> Summation of the First n Integers<pre><code>def sum_of_n(n):\n    the_sum = 0\n    for i in range(1, n + 1):\n        the_sum = the_sum + i\n\n    return the_sum\n\nprint(sum_of_n(10))\n</code></pre> <p>Now look at the function in <code>ActiveCode 2</code>. At first glance it may look strange, but upon further inspection you can see that this function is essentially doing the same thing as the previous one. The reason this is not obvious is poor coding. We did not use good identifier names to assist with readability, and we used an extra assignment statement that was not really necessary during the accumulation step.</p> Another Summation of the First n Integers<pre><code>def foo(tom):\n    fred = 0\n    for bill in range(1, tom + 1):\n        barney = bill\n        fred = fred + barney\n\n    return fred\n\nprint(foo(10))\n</code></pre> <p>The question we raised earlier asked whether one function is better than another. The answer depends on your criteria. The function <code>sum_of_n</code> is certainly better than the function <code>foo</code> if you are concerned with readability. In fact, you have probably seen many examples of this in your introductory programming course since one of the goals there is to help you write programs that are easy to read and easy to understand. In this course, however, we are also interested in characterizing the algorithm itself. (We certainly hope that you will continue to strive to write readable, understandable code.)</p> <p>Algorithm analysis is concerned with comparing algorithms based upon the amount of computing resources that each algorithm uses. We want to be able to consider two algorithms and say that one is better than the other because it is more efficient in its use of those resources or perhaps because it simply uses fewer. From this perspective, the two functions above seem very similar. They both use essentially the same algorithm to solve the summation problem.</p> <p>At this point, it is important to think more about what we really mean by computing resources. There are two different ways to look at this. One way is to consider the amount of space or memory an algorithm requires to solve the problem. The amount of space required by a problem solution is typically dictated by the problem instance itself. Every so often, however, there are algorithms that have very specific space requirements, and in those cases we will be very careful to explain the variations.</p> <p>As an alternative to space requirements, we can analyze and compare algorithms based on the amount of time they require to execute. This measure is sometimes referred to as the execution time or running time of the algorithm. One way we can measure the execution time for the function <code>sum_of_n</code> is to do a benchmark analysis. This means that we will track the actual time required for the program to compute its result. In Python, we can benchmark a function by noting the starting time and ending time within the system we are using. In the <code>time</code> module there is a function called <code>time</code> that will return the current system clock time in seconds since some arbitrary starting point. By calling this function twice, at the beginning and at the end, and then computing the difference, we can get an exact number of seconds (fractions in most cases) for execution.</p> <pre><code>import time\n\ndef sum_of_n_2(n):\n    start = time.time()\n\n    the_sum = 0\n    for i in range(1, n + 1):\n        the_sum = the_sum + i\n\n    end = time.time()\n\n    return the_sum, end - start\n</code></pre> <p><code>Listing 1</code> shows the original <code>sum_of_n</code> function with the timing calls embedded before and after the summation. The function returns a tuple consisting of the result and the amount of time (in seconds) required for the calculation. If we perform five invocations of the function, each computing the sum of the first 10,000 integers, we get the following:</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(10000))\n... \nSum is 50005000 required  0.0018950 seconds\nSum is 50005000 required  0.0018620 seconds\nSum is 50005000 required  0.0019171 seconds\nSum is 50005000 required  0.0019162 seconds\nSum is 50005000 required  0.0019360 seconds\n&gt;&gt;&gt;\n</code></pre> <p>We discover that the time is fairly consistent and it takes on average about 0.0019 seconds to execute that code. What if we run the function adding the first 100,000 integers?</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(100000))\n... \nSum is 5000050000 required  0.0199420 seconds\nSum is 5000050000 required  0.0180972 seconds\nSum is 5000050000 required  0.0194821 seconds\nSum is 5000050000 required  0.0178988 seconds\nSum is 5000050000 required  0.0188949 seconds\n&gt;&gt;&gt;\n</code></pre> <p>Again, the time required for each run, although longer, is very consistent, averaging about 10 times more seconds. For <code>n</code> equal to 1,000,000 we get:</p> <pre><code>&gt;&gt;&gt; for i in range(5):\n...     print(\"Sum is %d required %10.7f seconds\" % sum_of_n_2(1000000))\n...\nSum is 500000500000 required  0.1948988 seconds\nSum is 500000500000 required  0.1850290 seconds\nSum is 500000500000 required  0.1809771 seconds\nSum is 500000500000 required  0.1729250 seconds\nSum is 500000500000 required  0.1646299 seconds\n&gt;&gt;&gt;\n</code></pre> <p>In this case, the average again turns out to be about 10 times the previous experiment.</p> <p>Now consider <code>ActiveCode 3</code>, which shows a different means of solving the summation problem. This function, <code>sum_of_n_3</code>, takes advantage of a closed equation \\(`\\sum_{i=1}^{n} i = \\frac {(n)(n+1)}{2}\\) to compute the sum of the first <code>n</code> integers without iterating.</p> Summation Without Iteration<pre><code>def sum_of_n_3(n):\n    return (n * (n + 1)) / 2\n\n\nprint(sum_of_n_3(10))\n</code></pre> <p>If we do the same benchmark measurement for <code>sum_of_n_3</code>, using five different values for <code>n</code> (10,000, 100,000, 1,000,000, 10,000,000, and 100,000,000), we get the following results:</p> <pre><code>Sum is 50005000 required 0.00000095 seconds\nSum is 5000050000 required 0.00000191 seconds\nSum is 500000500000 required 0.00000095 seconds\nSum is 50000005000000 required 0.00000095 seconds\nSum is 5000000050000000 required 0.00000119 seconds\n</code></pre> <p>There are two important things to notice about this output. First, the times recorded above are shorter than any of the previous examples. Second, they are very consistent no matter what the value of <code>n</code>. It appears that <code>sum_of_n_3</code> is hardly impacted by the number of integers being added.</p> <p>But what does this benchmark really tell us? Intuitively, we can see that the iterative solutions seem to be doing more work since some program steps are being repeated. This is likely the reason it is taking longer. Also, the time required for the iterative solution seems to increase as we increase the value of <code>n</code>. However, if we ran the same function on a different computer or used a different programming language, we would likely get different results. It could take even longer to perform <code>sum_of_n_3</code> if the computer were older.</p> <p>We need a better way to characterize these algorithms with respect to execution time. The benchmark technique computes the actual time to execute. It does not really provide us with a useful measurement because it is dependent on a particular machine, program, time of day, compiler, and programming language. Instead, we would like to have a characterization that is independent of the program or computer being used. This measure would then be useful for judging the algorithm alone and could be used to compare algorithms across implementations.</p>"},{"location":"c2/s3/","title":"2.3. \u5927O\u8868\u793a\u6cd5","text":"<p>2.3. Big O Notation</p> \u4e2d\u6587\u82f1\u6587 <p>\u5f53\u8bd5\u56fe\u5728\u72ec\u7acb\u4e8e\u4efb\u4f55\u7279\u5b9a\u7a0b\u5e8f\u6216\u8ba1\u7b97\u673a\u7684\u6267\u884c\u65f6\u95f4\u65b9\u9762\u8868\u5f81\u7b97\u6cd5\u7684\u6548\u7387\u65f6\uff0c\u91cf\u5316\u7b97\u6cd5\u6240\u9700\u7684\u64cd\u4f5c\u6216\u6b65\u9aa4\u7684\u6570\u91cf\u975e\u5e38\u91cd\u8981\u3002 \u5982\u679c\u5c06\u8fd9\u4e9b\u6b65\u9aa4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u89c6\u4e3a\u8ba1\u7b97\u7684\u57fa\u672c\u5355\u5143\uff0c\u5219\u7b97\u6cd5\u7684\u6267\u884c\u65f6\u95f4\u53ef\u4ee5\u8868\u793a\u4e3a\u89e3\u51b3\u95ee\u9898\u6240\u9700\u7684\u6b65\u9aa4\u6570\u3002 \u51b3\u5b9a\u9002\u5f53\u7684\u57fa\u672c\u8ba1\u7b97\u5355\u4f4d\u53ef\u80fd\u662f\u4e00\u4e2a\u590d\u6742\u7684\u95ee\u9898\uff0c\u5e76\u4e14\u53d6\u51b3\u4e8e\u7b97\u6cd5\u7684\u5b9e\u73b0\u65b9\u5f0f\u3002</p> <p>\u7528\u4e8e\u6bd4\u8f83\u524d\u9762\u6240\u793a\u7684\u6c42\u548c\u7b97\u6cd5\u7684\u4e00\u4e2a\u5f88\u597d\u7684\u57fa\u672c\u8ba1\u7b97\u5355\u4f4d\u53ef\u80fd\u662f\u4e3a\u8ba1\u7b97\u603b\u548c\u800c\u6267\u884c\u7684\u8d4b\u503c\u8bed\u53e5\u7684\u6570\u91cf\u3002 \u5728\u51fd\u6570<code>sum_of_n</code>\u4e2d\uff0c\u8d4b\u503c\u8bed\u53e5\u7684\u6570\u91cf\u4e3a 1 (\\(the\\_sum = 0\\)) \u52a0\u4e0a n \u7684\u503c\uff08\u6211\u4eec\u6267\u884c\u7684\u6b21\u6570 \\(the\\_sum = the\\_sum + i\\) \uff09\u3002 \u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a\u51fd\u6570\u6765\u8868\u793a\u5b83\uff0c\u79f0\u4e4b\u4e3a\\(T\\)\uff0c\u5176\u4e2d\\(T(n) = 1 + n\\)\u3002 \u53c2\u6570 n \u901a\u5e38\u88ab\u79f0\u4e3a \u201c\u95ee\u9898\u7684\u5927\u5c0f\u201d\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u7406\u89e3\u4e3a\u201c\\(T(n)\\) \u662f\u89e3\u51b3\u5927\u5c0f\u4e3a \\(n\\) \u7684\u95ee\u9898\u6240\u9700\u7684\u65f6\u95f4\uff0c\u5373 \\(1 + n\\) \u4e2a\u6b65\u9aa4\u3002\u201d</p> <p>\u5728\u4e0a\u9762\u7ed9\u51fa\u7684\u6c42\u548c\u51fd\u6570\u4e2d\uff0c\u4f7f\u7528\u6c42\u548c\u4e2d\u7684\u9879\u6570\u6765\u8868\u793a\u95ee\u9898\u7684\u5927\u5c0f\u662f\u6709\u610f\u4e49\u7684\u3002 \u7136\u540e\u6211\u4eec\u53ef\u4ee5\u8bf4\u524d 100,000 \u4e2a\u6574\u6570\u7684\u603b\u548c\u662f\u6bd4\u524d 1,000 \u4e2a\u6574\u6570\u7684\u603b\u548c\u66f4\u5927\u7684\u6c42\u548c\u95ee\u9898\u5b9e\u4f8b\u3002 \u56e0\u6b64\uff0c\u89e3\u51b3\u8f83\u5927\u6848\u4ef6\u6240\u9700\u7684\u65f6\u95f4\u6bd4\u89e3\u51b3\u8f83\u5c0f\u6848\u4ef6\u6240\u9700\u7684\u65f6\u95f4\u66f4\u957f\u4f3c\u4e4e\u662f\u5408\u7406\u7684\u3002 \u6211\u4eec\u7684\u76ee\u6807\u662f\u5c55\u793a\u7b97\u6cd5\u7684\u6267\u884c\u65f6\u95f4\u5982\u4f55\u968f\u7740\u95ee\u9898\u7684\u5927\u5c0f\u800c\u53d8\u5316\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u66f4\u613f\u610f\u5c06\u8fd9\u79cd\u5206\u6790\u6280\u672f\u66f4\u8fdb\u4e00\u6b65\u3002 \u4e8b\u5b9e\u8bc1\u660e\uff0c\u786e\u5207\u7684\u64cd\u4f5c\u6b21\u6570\u5e76\u4e0d\u50cf\u786e\u5b9a \\(T(n)\\) \u51fd\u6570\u4e2d\u6700\u4e3b\u8981\u7684\u90e8\u5206\u90a3\u4e48\u91cd\u8981\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u968f\u7740\u95ee\u9898\u53d8\u5f97\u8d8a\u6765\u8d8a\u5927\uff0c\\(T(n)\\) \u51fd\u6570\u7684\u67d0\u4e9b\u90e8\u5206\u5f80\u5f80\u4f1a\u538b\u5012\u5176\u4f59\u90e8\u5206\u3002 \u8fd9\u4e2a\u4e3b\u5bfc\u672f\u8bed\u6700\u7ec8\u662f\u7528\u6765\u8fdb\u884c\u6bd4\u8f83\u7684\u3002 \u6570\u91cf\u7ea7 \u51fd\u6570\u63cf\u8ff0\u4e86\u968f\u7740 n \u503c\u7684\u589e\u52a0\u800c\u589e\u52a0\u6700\u5feb\u7684 \\(T(n)\\) \u90e8\u5206\u3002 \u6570\u91cf\u7ea7\u901a\u5e38\u79f0\u4e3a Big O \u8868\u793a\u6cd5\uff08\u4ee3\u8868 order\uff09\u5e76\u5199\u4e3a \\(O(f(n))\\)\u3002 \u5b83\u63d0\u4f9b\u4e86\u8ba1\u7b97\u4e2d\u5b9e\u9645\u6b65\u9aa4\u6570\u7684\u6709\u7528\u8fd1\u4f3c\u503c\u3002 \u51fd\u6570 \\(f(n)\\) \u63d0\u4f9b\u4e86\u539f\u59cb \\(T(n)\\) \u7684\u4e3b\u8981\u90e8\u5206\u7684\u7b80\u5355\u8868\u793a\u3002</p> <p>\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\\(T(n) = 1 + n\\)\u3002 \u968f\u7740 n \u53d8\u5927\uff0c\u5e38\u6570 1 \u5bf9\u6700\u7ec8\u7ed3\u679c\u7684\u91cd\u8981\u6027\u5c06\u53d8\u5f97\u8d8a\u6765\u8d8a\u5c0f\u3002 \u5982\u679c\u6211\u4eec\u6b63\u5728\u5bfb\u627e \\(T(n)\\) \u7684\u8fd1\u4f3c\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u53bb\u6389 1 \u5e76\u7b80\u5355\u5730\u8bf4\u8fd0\u884c\u65f6\u95f4\u662f \\(O(n)\\)\u3002 \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c1 \u5bf9\u4e8e \\(T(n)\\) \u6765\u8bf4\u80af\u5b9a\u5f88\u91cd\u8981\u3002 \u7136\u800c\uff0c\u968f\u7740 n \u53d8\u5927\uff0c\u6211\u4eec\u7684\u8fd1\u4f3c\u503c\u5728\u6ca1\u6709\u5b83\u7684\u60c5\u51b5\u4e0b\u4e5f\u5c06\u540c\u6837\u51c6\u786e\u3002</p> <p>\u518d\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5047\u8bbe\u5bf9\u4e8e\u67d0\u4e9b\u7b97\u6cd5\uff0c\u786e\u5207\u7684\u6b65\u9aa4\u6570\u662f \\(T(n)=5n^{2} + 27n + 1005\\)\u3002 \u5f53 n \u5f88\u5c0f\u65f6\uff0c\u4f8b\u5982 1 \u6216 2\uff0c\u5e38\u6570 1005 \u4f3c\u4e4e\u662f\u51fd\u6570\u7684\u4e3b\u8981\u90e8\u5206\u3002 \u7136\u800c\uff0c\u968f\u7740 n \u53d8\u5927\uff0c\\(n^{2}\\) \u9879\u53d8\u5f97\u6700\u91cd\u8981\u3002 \u4e8b\u5b9e\u4e0a\uff0c\u5f53 n \u975e\u5e38\u5927\u65f6\uff0c\u5176\u4ed6\u4e24\u9879\u5728\u786e\u5b9a\u6700\u7ec8\u7ed3\u679c\u4e2d\u6240\u8d77\u7684\u4f5c\u7528\u5c31\u53d8\u5f97\u5fae\u4e0d\u8db3\u9053\u4e86\u3002 \u540c\u6837\uff0c\u5f53 n \u53d8\u5927\u65f6\uff0c\u4e3a\u4e86\u8fd1\u4f3c \\(T(n)\\)\uff0c\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u5176\u4ed6\u9879\u5e76\u4e13\u6ce8\u4e8e \\(5n^{2}\\)\u3002 \u6b64\u5916\uff0c\u968f\u7740 n \u53d8\u5927\uff0c\u7cfb\u6570 \\(5\\) \u53d8\u5f97\u5fae\u4e0d\u8db3\u9053\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bf4\u51fd\u6570 \\(T(n)\\) \u7684\u6570\u91cf\u7ea7\u4e3a \\(f(n) = n^{2}\\)\uff0c\u6216\u8005\u7b80\u5355\u5730\u8bf4\u5b83\u662f \\(O(n^{2})\\)\u3002</p> <p>\u5c3d\u7ba1\u6211\u4eec\u5728\u6c42\u548c\u793a\u4f8b\u4e2d\u6ca1\u6709\u770b\u5230\u8fd9\u4e00\u70b9\uff0c\u4f46\u6709\u65f6\u7b97\u6cd5\u7684\u6027\u80fd\u53d6\u51b3\u4e8e\u6570\u636e\u7684\u7cbe\u786e\u503c\uff0c\u800c\u4e0d\u4ec5\u4ec5\u662f\u95ee\u9898\u7684\u5927\u5c0f\u3002 \u5bf9\u4e8e\u8fd9\u4e9b\u7c7b\u578b\u7684\u7b97\u6cd5\uff0c\u6211\u4eec\u9700\u8981\u6839\u636e\u6700\u4f73\u60c5\u51b5\u3001\u6700\u574f\u60c5\u51b5\u6216\u5e73\u5747\u60c5\u51b5\u6027\u80fd\u6765\u8868\u5f81\u5176\u6027\u80fd\u3002 \u6700\u574f\u60c5\u51b5\u6027\u80fd\u662f\u6307\u7b97\u6cd5\u6027\u80fd\u7279\u522b\u5dee\u7684\u7279\u5b9a\u6570\u636e\u96c6\uff0c\u800c\u5b8c\u5168\u76f8\u540c\u7b97\u6cd5\u7684\u4e0d\u540c\u6570\u636e\u96c6\u53ef\u80fd\u5177\u6709\u975e\u5e38\u597d\u7684\uff08\u6700\u4f73\u60c5\u51b5\uff09\u6027\u80fd\u3002 \u7136\u800c\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u7b97\u6cd5\u7684\u6027\u80fd\u4ecb\u4e8e\u8fd9\u4e24\u4e2a\u6781\u7aef\u4e4b\u95f4\uff08\u5e73\u5747\u60c5\u51b5\u6027\u80fd\uff09\u3002 \u5bf9\u4e8e\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u6765\u8bf4\uff0c\u7406\u89e3\u8fd9\u4e9b\u533a\u522b\u975e\u5e38\u91cd\u8981\uff0c\u8fd9\u6837\u4ed6\u4eec\u5c31\u4e0d\u4f1a\u88ab\u67d0\u4e00\u7279\u5b9a\u6848\u4f8b\u8bef\u5bfc\u3002</p> <p>\u5f53\u60a8\u7814\u7a76\u7b97\u6cd5\u65f6\uff0c\u8bb8\u591a\u975e\u5e38\u5e38\u89c1\u7684\u6570\u91cf\u7ea7\u51fd\u6570\u4f1a\u53cd\u590d\u51fa\u73b0\u3002 \u8fd9\u4e9b\u5982\u201c\u8868 1\u201d\u6240\u793a\u3002 \u4e3a\u4e86\u786e\u5b9a\u8fd9\u4e9b\u51fd\u6570\u4e2d\u7684\u54ea\u4e00\u4e2a\u662f\u4efb\u4f55 \\(T(n)\\) \u51fd\u6570\u7684\u4e3b\u5bfc\u90e8\u5206\uff0c\u6211\u4eec\u5fc5\u987b\u4e86\u89e3\u5f53 n \u53d8\u5927\u65f6\u5b83\u4eec\u5982\u4f55\u76f8\u4e92\u6bd4\u8f83\u3002</p> <p>\u8868 1: \u5927 O \u7684\u5e38\u7528\u51fd\u6570</p> f(n) \u540d\u79f0 \\(1\\) \u5e38\u91cf(Constant) \\(\\log n\\) \u5bf9\u6570(Logarithmic) \\(n\\) \u7ebf\u6027(Linear) \\(n\\log n\\) \u5bf9\u6570\u7ebf\u6027(Log linear) \\(n^{2}\\) \u4e8c\u6b21\u65b9(Quadratic) \\(n^{3}\\) \u7acb\u65b9(Cubic) \\(2^{n}\\) \u6307\u6570(Exponential) <p>\u201c\u56fe 1\u201d\u663e\u793a\u4e86\u201c\u8868 1\u201d\u4e2d\u5e38\u89c1\u529f\u80fd\u7684\u56fe\u8868\u3002 \u8bf7\u6ce8\u610f\uff0c\u5f53 n \u5f88\u5c0f\u65f6\uff0c\u51fd\u6570\u4e4b\u95f4\u7684\u5b9a\u4e49\u4e0d\u662f\u5f88\u597d\u3002 \u5f88\u96be\u8bf4\u54ea\u4e2a\u5360\u4e3b\u5bfc\u5730\u4f4d\u3002 \u7136\u800c\uff0c\u968f\u7740 n \u7684\u589e\u957f\uff0c\u5b58\u5728\u7740\u660e\u786e\u7684\u5173\u7cfb\uff0c\u5e76\u4e14\u5f88\u5bb9\u6613\u770b\u51fa\u5b83\u4eec\u5982\u4f55\u76f8\u4e92\u6bd4\u8f83\u3002</p> <p> \u56fe 1: \u5e38\u89c1\u5927 O \u51fd\u6570\u56fe </p> <p>\u4f5c\u4e3a\u6700\u540e\u4e00\u4e2a\u793a\u4f8b\uff0c\u5047\u8bbe\u6211\u4eec\u6709\u201c\u6e05\u5355 2\u201d\u4e2d\u6240\u793a\u7684 Python \u4ee3\u7801\u7247\u6bb5\u3002 \u5c3d\u7ba1\u8fd9\u4e2a\u7a0b\u5e8f\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u505a\u4efb\u4f55\u4e8b\u60c5\uff0c\u4f46\u4e86\u89e3\u6211\u4eec\u5982\u4f55\u83b7\u53d6\u5b9e\u9645\u4ee3\u7801\u5e76\u5206\u6790\u6027\u80fd\u8fd8\u662f\u5f88\u6709\u542f\u53d1\u6027\u7684\u3002</p> <p>\u6e05\u5355 2</p> <pre><code>a = 5\nb = 6\nc = 10\nfor i in range(n):\n    for j in range(n):\n        x = i * i\n        y = j * j\n        z = i * j\nfor k in range(n):\n    w = a * k + 45\n    v = b * b\nd = 33\n</code></pre> <p>\u8d4b\u503c\u8fd0\u7b97\u7684\u6b21\u6570\u662f\u56db\u9879\u4e4b\u548c\u3002 \u7b2c\u4e00\u9879\u662f\u5e38\u91cf 3\uff0c\u4ee3\u8868\u7247\u6bb5\u5f00\u5934\u7684\u4e09\u4e2a\u8d4b\u503c\u8bed\u53e5\u3002 \u7b2c\u4e8c\u9879\u662f \\(3n^{2}\\)\uff0c\u56e0\u4e3a\u7531\u4e8e\u5d4c\u5957\u8fed\u4ee3\uff0c\u8bed\u6709 3 \u4e2a\u53e5\u88ab\u6267\u884c\u4e86 \\(n^{2}\\) \u6b21\u3002 \u7b2c\u4e09\u9879\u662f \\(2n\\)\uff0c\u4e24\u6761\u8bed\u53e5\u8fed\u4ee3 n \u6b21\u3002 \u6700\u540e\uff0c\u7b2c\u56db\u9879\u662f\u5e38\u65701\uff0c\u4ee3\u8868\u6700\u7ec8\u7684\u8d4b\u503c\u8bed\u53e5\u3002 \u8fd9\u7ed9\u6211\u4eec\\(T(n) = 3 + 3n^{2} + 2n + 1 = 3n^{2} + 2n + 4\\)\u3002 \u901a\u8fc7\u67e5\u770b\u6307\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u770b\u51fa \\(n^{2}\\) \u9879\u5c06\u5360\u4e3b\u5bfc\u5730\u4f4d\uff0c\u56e0\u6b64\u8fd9\u6bb5\u4ee3\u7801\u662f \\(O(n^{2})\\)\u3002 \u8bf7\u6ce8\u610f\uff0c\u968f\u7740 n \u53d8\u5927\uff0c\u6240\u6709\u5176\u4ed6\u9879\u4ee5\u53ca\u4e3b\u9879\u7684\u7cfb\u6570\u90fd\u53ef\u4ee5\u5ffd\u7565\u3002</p> <p> \u56fe 2\uff1a\\(T(n)\\) \u4e0e\u5e38\u89c1 \u5927 O \u51fd\u6570\u7684\u6bd4\u8f83 </p> <p><code>\u56fe 2</code> \u663e\u793a\u4e86\u4e00\u4e9b\u5e38\u89c1\u7684 \u5927 O \u51fd\u6570\u4e0e\u4e0a\u9762\u8ba8\u8bba\u7684 \\(T(n)\\) \u51fd\u6570\u7684\u6bd4\u8f83\u3002 \u8bf7\u6ce8\u610f\uff0c\\(T(n)\\) \u6700\u521d\u5927\u4e8e\u4e09\u6b21\u51fd\u6570\u3002 \u7136\u800c\uff0c\u968f\u7740 n \u7684\u589e\u957f\uff0c\u4e09\u6b21\u51fd\u6570\u5f88\u5feb\u5c31\u4f1a\u8d85\u8fc7 \\(T(n)\\)\u3002 \u5f88\u5bb9\u6613\u770b\u51fa\uff0c\u968f\u7740 \\(n\\) \u7ee7\u7eed\u589e\u957f\uff0c\\(T(n)\\) \u9075\u5faa\u4e8c\u6b21\u51fd\u6570\u3002</p> <p>\u81ea\u68c0</p> <p>\u7f16\u5199\u4e24\u4e2a Python \u51fd\u6570\u6765\u67e5\u627e\u5217\u8868\u4e2d\u7684\u6700\u5c0f\u6570\u5b57\u3002 \u7b2c\u4e00\u4e2a\u51fd\u6570\u5e94\u8be5\u5c06\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5176\u4ed6\u6570\u5b57\u8fdb\u884c\u6bd4\u8f83\u3002 \\(O(n^2)\\)\u3002 \u7b2c\u4e8c\u4e2a\u51fd\u6570\u5e94\u8be5\u662f\u7ebf\u6027\u7684\\(O(n)\\)\u3002</p> <p></p> <p>Big O Notation</p> <p>When trying to characterize an algorithm\u2019s efficiency in terms of execution time, independent of any particular program or computer, it is important to quantify the number of operations or steps that the algorithm will require. If each of these steps is considered to be a basic unit of computation, then the execution time for an algorithm can be expressed as the number of steps required to solve the problem. Deciding on an appropriate basic unit of computation can be a complicated problem and will depend on how the algorithm is implemented.</p> <p>A good basic unit of computation for comparing the summation algorithms shown earlier might be the number of assignment statements performed to compute the sum. In the function <code>sum_of_n</code>, the number of assignment statements is 1 (\\(the\\_sum = 0\\)) plus the value of n (the number of times we perform \\(the\\_sum = the\\_sum + i\\)). We can denote this by a function, call it \\(T\\), where \\(T(n) = 1 + n\\). The parameter n is often referred to as the \u201csize of the problem,\u201d and we can read this as \u201c\\(T(n)\\) is the time it takes to solve a problem of size \\(n\\), namely \\(1 + n\\) steps.\u201d</p> <p>In the summation functions given above, it makes sense to use the number of terms in the summation to denote the size of the problem. We can then say that the sum of the first 100,000 integers is a bigger instance of the summation problem than the sum of the first 1,000. Because of this, it might seem reasonable that the time required to solve the larger case would be greater than for the smaller case. Our goal then is to show how the algorithm\u2019s execution time changes with respect to the size of the problem.</p> <p>Computer scientists prefer to take this analysis technique one step further. It turns out that the exact number of operations is not as important as determining the most dominant part of the \\(T(n)\\) function. In other words, as the problem gets larger, some portion of the \\(T(n)\\) function tends to overpower the rest. This dominant term is what, in the end, is used for comparison. The order of magnitude function describes the part of \\(T(n)\\) that increases the fastest as the value of n increases. Order of magnitude is often called Big O notation (for order) and written as \\(O(f(n))\\). It provides a useful approximation of the actual number of steps in the computation. The function \\(f(n)\\) provides a simple representation of the dominant part of the original \\(T(n)\\).</p> <p>In the above example, \\(T(n) = 1 + n\\). As n gets larger, the constant 1 will become less and less significant to the final result. If we are looking for an approximation for \\(T(n)\\), then we can drop the 1 and simply say that the running time is \\(O(n)\\). It is important to note that the 1 is certainly significant for \\(T(n)\\). However, as n gets large, our approximation will be just as accurate without it.</p> <p>As another example, suppose that for some algorithm, the exact number of steps is \\(T(n)=5n^{2} + 27n + 1005\\). When n is small, say 1 or 2, the constant 1005 seems to be the dominant part of the function. However, as n gets larger, the \\(n^{2}\\) term becomes the most important. In fact, when n is really large, the other two terms become insignificant in the role that they play in determining the final result. Again, to approximate \\(T(n)\\) as n gets large, we can ignore the other terms and focus on \\(5n^{2}\\). In addition, the coefficient \\(5\\) becomes insignificant as n gets large. We would say then that the function \\(T(n)\\) has an order of magnitude \\(f(n) = n^{2}\\), or simply that it is \\(O(n^{2})\\).</p> <p>Although we do not see this in the summation example, sometimes the performance of an algorithm depends on the exact values of the data rather than simply the size of the problem. For these kinds of algorithms we need to characterize their performance in terms of best-case, worst-case, or average-case performance. The worst-case performance refers to a particular data set where the algorithm performs especially poorly, whereas a different data set for the exact same algorithm might have extraordinarily good (best-case) performance. However, in most cases the algorithm performs somewhere in between these two extremes (average-case performance). It is important for a computer scientist to understand these distinctions so they are not misled by one particular case.</p> <p>A number of very common order of magnitude functions will come up over and over as you study algorithms. These are shown in <code>Table 1</code>. In order to decide which of these functions is the dominant part of any \\(T(n)\\) function, we must see how they compare with one another as n gets large.</p> <p>Table 1: Common Functions for Big O</p> f(n) Name \\(1\\) Constant \\(\\log n\\) Logarithmic \\(n\\) Linear \\(n\\log n\\) Log linear \\(n^{2}\\) Quadratic \\(n^{3}\\) Cubic \\(2^{n}\\) Exponential <p><code>Figure 1</code> shows graphs of the common functions from <code>Table 1</code>. Notice that when n is small, the functions are not very well defined with respect to one another. It is hard to tell which is dominant. However, as n grows, there is a definite relationship and it is easy to see how they compare with one another.</p> <p> Figure 1: Plot of Common Big O Functions </p> <p>As a final example, suppose that we have the fragment of Python code shown in <code>Listing 2</code>. Although this program does not really do anything, it is instructive to see how we can take actual code and analyze performance.</p> <p>Listing 2</p> <pre><code>a = 5\nb = 6\nc = 10\nfor i in range(n):\n    for j in range(n):\n        x = i * i\n        y = j * j\n        z = i * j\nfor k in range(n):\n    w = a * k + 45\n    v = b * b\nd = 33\n</code></pre> <p>The number of assignment operations is the sum of four terms. The first term is the constant 3, representing the three assignment statements at the start of the fragment. The second term is \\(3n^{2}\\), since there are three statements that are performed \\(n^{2}\\) times due to the nested iteration. The third term is \\(2n\\), two statements iterated n times. Finally, the fourth term is the constant 1, representing the final assignment statement. This gives us \\(T(n) = 3 + 3n^{2} + 2n + 1 = 3n^{2} + 2n + 4\\). By looking at the exponents, we can easily see that the \\(n^{2}\\) term will be dominant and therefore this fragment of code is \\(O(n^{2})\\). Note that all of the other terms as well as the coefficient on the dominant term can be ignored as n grows larger.</p> <p> Figure 2: Comparing \\(T(n)\\) with Common Big O Functions </p> <p><code>Figure 2 &lt;fig_graphfigure2&gt;</code> shows a few of the common Big O functions as they compare with the \\(T(n)\\) function discussed above. Note that \\(T(n)\\) is initially larger than the cubic function. However, as n grows, the cubic function quickly overtakes \\(T(n)\\). It is easy to see that \\(T(n)\\) then follows the quadratic function as \\(n\\) continues to grow.</p> <p>Self Check</p> <p>Write two Python functions to find the minimum number in a list.  The first function should compare each number to every other number on the list. \\(O(n^2)\\).  The second function should be linear \\(O(n)\\).</p> <p></p>"},{"location":"c2/s4/","title":"2.4. \u4e00\u4e2a\u5b57\u8c1c\u68c0\u6d4b\u4f8b\u5b50","text":"<p>2.4. An Anagram Detection Example</p> \u4e2d\u6587\u82f1\u6587 <p>\u5c55\u793a\u4e0d\u540c\u6570\u91cf\u7ea7\u7b97\u6cd5\u7684\u4e00\u4e2a\u5f88\u597d\u4f8b\u5b50\u662f\u7ecf\u5178\u7684\u5b57\u7b26\u4e32\u5b57\u8c1c\u68c0\u6d4b\u95ee\u9898\u3002\u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u5b57\u8c1c\uff0c\u90a3\u4e48\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u53ea\u662f\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u91cd\u65b0\u6392\u5217\u3002\u4f8b\u5982\uff0c<code>heart</code> \u548c <code>earth</code> \u662f\u5b57\u8c1c\u3002\u5b57\u7b26\u4e32 <code>python</code> \u548c <code>typhon</code> \u4e5f\u662f\u5b57\u8c1c\u3002\u4e3a\u4e86\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u76f8\u7b49\uff0c\u5e76\u4e14\u5b83\u4eec\u7531 26 \u4e2a\u5c0f\u5199\u5b57\u6bcd\u7ec4\u6210\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u7f16\u5199\u4e00\u4e2a\u5e03\u5c14\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u63a5\u53d7\u4e24\u4e2a\u5b57\u7b26\u4e32\u5e76\u8fd4\u56de\u5b83\u4eec\u662f\u5426\u662f\u5b57\u8c1c\u3002</p> <p>A good example problem for showing algorithms with different orders of magnitude is the classic anagram detection problem for strings. One string is an anagram of another if the second is simply a rearrangement of the first. For example, <code>heart</code> and <code>earth</code> are anagrams. The strings <code>python</code> and <code>typhon</code> are anagrams as well. For the sake of simplicity, we will assume that the two strings in question are of equal length and that they are made up of symbols from the set of 26 lowercase alphabetic characters. Our goal is to write a boolean function that will take two strings and return whether they are anagrams.</p>"},{"location":"c2/s4/#241-\u89e3\u51b3\u65b9\u68481\u5b57\u8c1c\u68c0\u6d4b\u9010\u4e00\u68c0\u67e5","title":"2.4.1. \u89e3\u51b3\u65b9\u68481\uff1a\u5b57\u8c1c\u68c0\u6d4b\u9010\u4e00\u68c0\u67e5","text":"<p>2.4.1. Solution 1: Anagram Detection Checking Off</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5bf9\u5b57\u8c1c\u95ee\u9898\u7684\u7b2c\u4e00\u4e2a\u89e3\u51b3\u65b9\u6848\u5c06\u68c0\u67e5\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u7136\u540e\u68c0\u67e5\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u786e\u5b9e\u51fa\u73b0\u5728\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u4e2d\u3002\u5982\u679c\u53ef\u4ee5\u52fe\u9009\u6bcf\u4e2a\u5b57\u7b26\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u5fc5\u987b\u662f\u5b57\u8c1c\u3002\u52fe\u9009\u5b57\u7b26\u5c06\u901a\u8fc7\u5c06\u5176\u66ff\u6362\u4e3a\u7279\u6b8a\u7684 Python \u503c <code>None</code> \u6765\u5b8c\u6210\u3002\u7136\u800c\uff0c\u7531\u4e8e Python \u4e2d\u7684\u5b57\u7b26\u4e32\u662f\u4e0d\u53ef\u53d8\u7684\uff0c\u56e0\u6b64\u5904\u7406\u7684\u7b2c\u4e00\u6b65\u662f\u5c06\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5217\u8868\u3002\u7136\u540e\u53ef\u4ee5\u5c06\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e0e\u5217\u8868\u4e2d\u7684\u5b57\u7b26\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u627e\u5230\uff0c\u5219\u901a\u8fc7\u66ff\u6362\u6765\u52fe\u9009\u3002<code>ActiveCode 1</code> \u663e\u793a\u4e86\u8fd9\u4e2a\u51fd\u6570\u3002</p> Activity: 2.4.1.1 Checking Off<pre><code>def anagram_solution_1(s1, s2):\n    still_ok = True\n    if len(s1) != len(s2):\n        still_ok = False\n\n    a_list = list(s2)\n    pos_1 = 0\n\n    while pos_1 &lt; len(s1) and still_ok:\n        pos_2 = 0\n        found = False\n        while pos_2 &lt; len(a_list) and not found:\n            if s1[pos_1] == a_list[pos_2]:\n                found = True\n            else:\n                pos_2 = pos_2 + 1\n        if found:\n            a_list[pos_2] = None\n        else:\n            still_ok = False\n        pos_1 = pos_1 + 1\n\n    return still_ok\n\n\nprint(anagram_solution_1(\"apple\", \"pleap\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_1(\"abcd\", \"dcba\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_1(\"abcd\", \"dcda\"))  # \u9884\u671f\u7ed3\u679c: False\n</code></pre> <p>\u8981\u5206\u6790\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u6211\u4eec\u9700\u8981\u6ce8\u610f <code>s1</code> \u4e2d\u7684\u6bcf\u4e2a n \u4e2a\u5b57\u7b26\u90fd\u4f1a\u5bfc\u81f4\u5bf9 <code>s2</code> \u5217\u8868\u4e2d\u7684\u6700\u591a n \u4e2a\u5b57\u7b26\u7684\u8fed\u4ee3\u3002\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a n \u4e2a\u4f4d\u7f6e\u5c06\u88ab\u8bbf\u95ee\u4e00\u6b21\u4ee5\u5339\u914d\u6765\u81ea <code>s1</code> \u7684\u5b57\u7b26\u3002\u8bbf\u95ee\u7684\u6b21\u6570\u5c06\u6210\u4e3a\u4ece 1 \u5230 n \u7684\u6574\u6570\u7684\u603b\u548c\u3002\u6211\u4eec\u4e4b\u524d\u63d0\u5230\uff0c\u8fd9\u53ef\u4ee5\u5199\u6210\uff1a</p> \\[\\begin{align}      \\sum_{i=1}^{n} i &amp;= \\frac {n(n+1)}{2} \\\\ &amp;= \\frac {1}{2}n^{2} + \\frac {1}{2}n \\end{align}\\] <p>\u968f\u7740 \\(n\\) \u53d8\u5927\uff0c\\(n^{2}\\) \u9879\u5c06\u5360\u4e3b\u5bfc\u5730\u4f4d\uff0c\u800c \\(n\\) \u9879\u548c \\(\\frac {1}{2}\\) \u53ef\u4ee5\u5ffd\u7565\u3002\u56e0\u6b64\uff0c\u8fd9\u4e2a\u89e3\u51b3\u65b9\u6848\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(n^{2})\\)\u3002</p> <p>Our first solution to the anagram problem will check the lengths of the strings and then check to see that each character in the first string actually occurs in the second. If it is possible to check off each character, then the two strings must be anagrams. Checking off a character will be accomplished by replacing it with the special Python value <code>None</code>. However, since strings in Python are immutable, the first step in the process will be to convert the second string to a list. Each character from the first string can be checked against the characters in the list and if found, checked off by replacement. <code>ActiveCode 1</code> shows this function.</p> Activity: 2.4.1.1 Checking Off<pre><code>def anagram_solution_1(s1, s2):\n    still_ok = True\n    if len(s1) != len(s2):\n        still_ok = False\n\n    a_list = list(s2)\n    pos_1 = 0\n\n    while pos_1 &lt; len(s1) and still_ok:\n        pos_2 = 0\n        found = False\n        while pos_2 &lt; len(a_list) and not found:\n            if s1[pos_1] == a_list[pos_2]:\n                found = True\n            else:\n                pos_2 = pos_2 + 1\n        if found:\n            a_list[pos_2] = None\n        else:\n            still_ok = False\n        pos_1 = pos_1 + 1\n\n    return still_ok\n\n\nprint(anagram_solution_1(\"apple\", \"pleap\"))  # expected: True\nprint(anagram_solution_1(\"abcd\", \"dcba\"))  # expected: True\nprint(anagram_solution_1(\"abcd\", \"dcda\"))  # expected: False\n</code></pre> <p>To analyze this algorithm, we need to note that each of the n characters in <code>s1</code> will cause an iteration through up to n characters in the list from <code>s2</code>. Each of the n positions in the list will be visited once to match a character from s1. The number of visits then becomes the sum of the integers from 1 to n. We stated earlier that this can be written as</p> \\[\\begin{align}    \\sum_{i=1}^{n} i &amp;= \\frac {n(n+1)}{2} \\\\ &amp;= \\frac {1}{2}n^{2} + \\frac {1}{2}n \\end{align}\\] <p>As \\(n\\) gets large, the \\(n^{2}\\) term will dominate the $n term and the \\(\\frac {1}{2}\\) can be ignored. Therefore, this solution is \\(O(n^{2})\\).</p>"},{"location":"c2/s4/#242-\u89e3\u51b3\u65b9\u68482\u6392\u5e8f\u548c\u6bd4\u8f83","title":"2.4.2. \u89e3\u51b3\u65b9\u68482\uff1a\u6392\u5e8f\u548c\u6bd4\u8f83","text":"<p>2.4.2. Anagram Detection Solution 2: Sort and Compare</p> \u4e2d\u6587\u82f1\u6587 <p>\u53e6\u4e00\u79cd\u89e3\u51b3\u5b57\u8c1c\u95ee\u9898\u7684\u65b9\u6848\u5229\u7528\u4e86\u8fd9\u6837\u4e00\u4e2a\u4e8b\u5b9e\uff0c\u5373\u867d\u7136 <code>s1</code> \u548c <code>s2</code> \u4e0d\u540c\uff0c\u4f46\u5b83\u4eec\u53ea\u6709\u5728\u7531\u5b8c\u5168\u76f8\u540c\u7684\u5b57\u7b26\u7ec4\u6210\u65f6\u624d\u662f\u5b57\u8c1c\u3002\u56e0\u6b64\uff0c\u5982\u679c\u6211\u4eec\u5148\u6309\u5b57\u6bcd\u987a\u5e8f\u5c06\u6bcf\u4e2a\u5b57\u7b26\u4e32\u4ece a \u6392\u5230 z\uff0c\u90a3\u4e48\u5982\u679c\u539f\u59cb\u7684\u4e24\u4e2a\u5b57\u7b26\u4e32\u662f\u5b57\u8c1c\uff0c\u6700\u7ec8\u5b83\u4eec\u4f1a\u5f97\u5230\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u3002<code>ActiveCode 2</code> \u663e\u793a\u4e86\u8fd9\u4e2a\u89e3\u51b3\u65b9\u6848\u3002\u540c\u6837\uff0c\u5728 Python \u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06\u6bcf\u4e2a\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5217\u8868\u6765\u4f7f\u7528\u5185\u7f6e\u7684 <code>sort</code> \u65b9\u6cd5\u8fdb\u884c\u6392\u5e8f\u3002</p> Activity: 2.4.2.1 Sort and Compare<pre><code>def anagram_solution_2(s1, s2):\n    a_list_1 = list(s1)\n    a_list_2 = list(s2)\n\n    a_list_1.sort()\n    a_list_2.sort()\n\n    pos = 0\n    matches = True\n\n    while pos &lt; len(s1) and matches:\n        if a_list_1[pos] == a_list_2[pos]:\n            pos = pos + 1\n        else:\n            matches = False\n\n    return matches\n\n\nprint(anagram_solution_2(\"apple\", \"pleap\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_2(\"abcd\", \"dcba\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_2(\"abcd\", \"dcda\"))  # \u9884\u671f\u7ed3\u679c: False\n</code></pre> <p>\u4e4d\u4e00\u770b\uff0c\u4f60\u53ef\u80fd\u4f1a\u8ba4\u4e3a\u8be5\u7b97\u6cd5\u662f \\(O(n)\\)\uff0c\u56e0\u4e3a\u5728\u6392\u5e8f\u8fc7\u7a0b\u4e4b\u540e\uff0c\u53ea\u9700\u8fdb\u884c\u4e00\u6b21\u7b80\u5355\u7684\u8fed\u4ee3\u6765\u6bd4\u8f83 n \u4e2a\u5b57\u7b26\u3002\u7136\u800c\uff0c\u5bf9 Python <code>sort</code> \u65b9\u6cd5\u7684\u4e24\u6b21\u8c03\u7528\u4e5f\u5e76\u975e\u6ca1\u6709\u4ee3\u4ef7\u3002\u6b63\u5982\u6211\u4eec\u5c06\u5728\u7b2c 5 \u7ae0\u770b\u5230\u7684\u90a3\u6837\uff0c\u6392\u5e8f\u901a\u5e38\u662f \\(O(n^{2})\\) \u6216 \\(O(n\\log n)\\)\uff0c\u56e0\u6b64\u6392\u5e8f\u64cd\u4f5c\u5360\u4e3b\u5bfc\u5730\u4f4d\u3002\u6700\u7ec8\uff0c\u8fd9\u4e2a\u7b97\u6cd5\u7684\u6570\u91cf\u7ea7\u4e0e\u6392\u5e8f\u8fc7\u7a0b\u76f8\u540c\u3002</p> <p>Another solution to the anagram problem will make use of the fact that even though <code>s1</code> and <code>s2</code> are different, they are anagrams only if they consist of exactly the same characters. So if we begin by sorting each string alphabetically from a to z, we will end up with the same string if the original two strings are anagrams. <code>ActiveCode 2</code> shows this solution. Again, in Python we can use the built-in <code>sort</code> method on lists by simply converting each string to a list at the start.</p> Activity: 2.4.2.1 Sort and Compare<pre><code>def anagram_solution_2(s1, s2):\n    a_list_1 = list(s1)\n    a_list_2 = list(s2)\n\n    a_list_1.sort()\n    a_list_2.sort()\n\n    pos = 0\n    matches = True\n\n    while pos &lt; len(s1) and matches:\n        if a_list_1[pos] == a_list_2[pos]:\n            pos = pos + 1\n        else:\n            matches = False\n\n    return matches\n\n\nprint(anagram_solution_2(\"apple\", \"pleap\"))  # expected: True\nprint(anagram_solution_2(\"abcd\", \"dcba\"))  # expected: True\nprint(anagram_solution_2(\"abcd\", \"dcda\"))  # expected: False\n</code></pre> <p>At first glance you may be tempted to think that this algorithm is \\(O(n)\\), since there is one simple iteration to compare the n characters after the sorting process. However, the two calls to the Python <code>sort</code> method are not without their own cost. As we will see in Chapter 5, sorting is typically either \\(O(n^{2})\\) or \\(O(n\\log n)\\), so the sorting operations dominate the iteration. In the end, this algorithm will have the same order of magnitude as that of the sorting process.</p>"},{"location":"c2/s4/#243-\u89e3\u51b3\u65b9\u68483\u66b4\u529b\u7834\u89e3","title":"2.4.3. \u89e3\u51b3\u65b9\u68483\uff1a\u66b4\u529b\u7834\u89e3","text":"<p>2.4.3. Anagram Detection Solution 3: Brute Force</p> \u4e2d\u6587\u82f1\u6587 <p>\u66b4\u529b\u6c42\u89e3\u65b9\u6cd5\u901a\u5e38\u5c1d\u8bd5\u7a77\u5c3d\u6240\u6709\u53ef\u80fd\u6027\u3002\u5bf9\u4e8e\u5b57\u8c1c\u68c0\u6d4b\u95ee\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u751f\u6210\u4f7f\u7528 s1 \u4e2d\u5b57\u7b26\u7684\u6240\u6709\u53ef\u80fd\u5b57\u7b26\u4e32\u5217\u8868\uff0c\u7136\u540e\u68c0\u67e5 s2 \u662f\u5426\u51fa\u73b0\u3002\u7136\u800c\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5b58\u5728\u95ee\u9898\u3002\u751f\u6210 s1 \u7684\u6240\u6709\u53ef\u80fd\u5b57\u7b26\u4e32\u65f6\uff0c\u7b2c\u4e00\u4f4d\u6709 n \u79cd\u53ef\u80fd\uff0c\u7b2c\u4e8c\u4f4d\u6709 \\(n - 1\\) \u79cd\u53ef\u80fd\uff0c\u7b2c\u4e09\u4f4d\u6709 \\(n - 2\\) \u79cd\u53ef\u80fd\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u5019\u9009\u5b57\u7b26\u4e32\u7684\u603b\u6570\u662f \\(n \\cdot (n - 1) \\cdot (n - 2) \\cdot ... \\cdot 3 \\cdot 2 \\cdot 1\\)\uff0c\u5373 \\(n!\\)\u3002\u867d\u7136\u67d0\u4e9b\u5b57\u7b26\u4e32\u53ef\u80fd\u662f\u91cd\u590d\u7684\uff0c\u4f46\u7a0b\u5e8f\u65e0\u6cd5\u63d0\u524d\u77e5\u9053\u8fd9\u4e00\u70b9\uff0c\u56e0\u6b64\u5b83\u4ecd\u7136\u4f1a\u751f\u6210 \\(n!\\) \u4e2a\u4e0d\u540c\u7684\u5b57\u7b26\u4e32\u3002</p> <p>\u4e8b\u5b9e\u4e0a\uff0c\u968f\u7740 n \u7684\u589e\u5927\uff0c\\(n!\\) \u7684\u589e\u957f\u901f\u5ea6\u751a\u81f3\u6bd4 \\(2^{n}\\) \u8fd8\u5feb\u3002\u5b9e\u9645\u4e0a\uff0c\u5982\u679c s1 \u6709 20 \u4e2a\u5b57\u7b26\uff0c\u90a3\u4e48\u53ef\u80fd\u7684\u5019\u9009\u5b57\u7b26\u4e32\u6570\u4e3a \\(20! = 2,432,902,008,176,640,000\\)\u3002\u5982\u679c\u6211\u4eec\u6bcf\u79d2\u5904\u7406\u4e00\u4e2a\u53ef\u80fd\u7684\u5b57\u7b26\u4e32\uff0c\u904d\u5386\u6574\u4e2a\u5217\u8868\u4ecd\u7136\u9700\u8981 77,146,816,596 \u5e74\u3002\u8fd9\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u597d\u7684\u89e3\u51b3\u65b9\u6848\u3002</p> <p>A brute force technique for solving a problem typically tries to exhaust all possibilities. For the anagram detection problem, we can simply generate a list of all possible strings using the characters from s1 and then see if s2 occurs. However, there is a problem with this approach. When generating all possible strings from s1, there are n possible first characters, \\(n - 1\\) possible characters for the second position, \\(n - 2\\) for the third, and so on. The total number of candidate strings is \\(n \\cdot (n - 1) \\cdot (n - 2) \\cdot ... \\cdot 3 \\cdot 2 \\cdot 1\\), which is \\(n!\\). Although some of the strings may be duplicates, the program cannot know this ahead of time and so it will still generate \\(n!\\) different strings.</p> <p>It turns out that \\(n!\\) grows even faster than \\(2^{n}\\) as n gets large. In fact, if s1 were 20 characters long, there would be \\(20! = 2,432,902,008,176,640,000\\) possible candidate strings. If we processed one possibility every second, it would still take us 77,146,816,596 years to go through the entire list. This is probably not going to be a good solution.</p>"},{"location":"c2/s4/#244-\u89e3\u51b3\u65b9\u68484\u8ba1\u6570\u548c\u6bd4\u8f83","title":"2.4.4. \u89e3\u51b3\u65b9\u68484\uff1a\u8ba1\u6570\u548c\u6bd4\u8f83","text":"<p>2.4.4. Anagram Detection Solution 4: Count and Compare</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5bf9\u5b57\u8c1c\u95ee\u9898\u7684\u6700\u7ec8\u89e3\u51b3\u65b9\u6848\u5229\u7528\u4e86\u8fd9\u6837\u4e00\u4e2a\u4e8b\u5b9e\uff1a\u4efb\u4f55\u4e24\u4e2a\u5b57\u8c1c\u90fd\u4f1a\u6709\u76f8\u540c\u6570\u91cf\u7684\u5b57\u6bcd a\uff0c\u76f8\u540c\u6570\u91cf\u7684\u5b57\u6bcd b\uff0c\u76f8\u540c\u6570\u91cf\u7684\u5b57\u6bcd c\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002\u4e3a\u4e86\u5224\u65ad\u4e24\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u662f\u5b57\u8c1c\uff0c\u6211\u4eec\u9996\u5148\u8981\u8ba1\u7b97\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u3002\u7531\u4e8e\u6709 26 \u4e2a\u53ef\u80fd\u7684\u5b57\u7b26\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u5305\u542b 26 \u4e2a\u8ba1\u6570\u5668\u7684\u5217\u8868\uff0c\u6bcf\u4e2a\u8ba1\u6570\u5668\u5bf9\u5e94\u4e00\u4e2a\u5b57\u7b26\u3002\u6bcf\u6b21\u770b\u5230\u4e00\u4e2a\u7279\u5b9a\u5b57\u7b26\u65f6\uff0c\u6211\u4eec\u5c06\u589e\u52a0\u8be5\u4f4d\u7f6e\u7684\u8ba1\u6570\u3002\u6700\u7ec8\uff0c\u5982\u679c\u8fd9\u4e24\u4e2a\u8ba1\u6570\u5b57\u7b26\u5217\u8868\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\u5fc5\u987b\u662f\u5b57\u8c1c\u3002<code>ActiveCode 3</code> \u663e\u793a\u4e86\u8be5\u89e3\u51b3\u65b9\u6848\u3002</p> Activity: 2.4.4.1 Count and Compare<pre><code>def anagram_solution_4(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n\n    for i in range(len(s1)):\n        pos = ord(s1[i]) - ord(\"a\")\n        c1[pos] = c1[pos] + 1\n\n    for i in range(len(s2)):\n        pos = ord(s2[i]) - ord(\"a\")\n        c2[pos] = c2[pos] + 1\n\n    j = 0\n    still_ok = True\n    while j &lt; 26 and still_ok:\n        if c1[j] == c2[j]:\n            j = j + 1\n        else:\n            still_ok = False\n\n    return still_ok\n\n\nprint(anagram_solution_4(\"apple\", \"pleap\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_4(\"abcd\", \"dcba\"))  # \u9884\u671f\u7ed3\u679c: True\nprint(anagram_solution_4(\"abcd\", \"dcda\"))  # \u9884\u671f\u7ed3\u679c: False\n</code></pre> <p>\u540c\u6837\uff0c\u8fd9\u4e2a\u89e3\u51b3\u65b9\u6848\u4e5f\u6709\u591a\u6b21\u8fed\u4ee3\u3002\u7136\u800c\uff0c\u4e0d\u540c\u4e8e\u7b2c\u4e00\u4e2a\u89e3\u51b3\u65b9\u6848\uff0c\u8fed\u4ee3\u5e76\u672a\u5d4c\u5957\u3002\u524d\u4e24\u6b21\u7528\u4e8e\u8ba1\u7b97\u5b57\u7b26\u7684\u8fed\u4ee3\u57fa\u4e8e n\u3002\u7b2c\u4e09\u6b21\u8fed\u4ee3\u7528\u4e8e\u6bd4\u8f83\u4e24\u4e2a\u8ba1\u6570\u5217\u8868\uff0c\u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u6709 26 \u4e2a\u53ef\u80fd\u7684\u5b57\u7b26\uff0c\u8fd9\u6b21\u8fed\u4ee3\u603b\u5171\u9700\u8981 26 \u6b65\u3002\u603b\u5171\u8ba1\u7b97\u5f97\u5230\u7684\u6b65\u6570\u4e3a \\(T(n)=2n+26\\)\u3002\u5373 \\(O(n)\\)\u3002\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u4e00\u4e2a\u7ebf\u6027\u6570\u91cf\u7ea7\u7684\u7b97\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002</p> <p>\u5728\u7ed3\u675f\u8fd9\u4e2a\u4f8b\u5b50\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u8ba8\u8bba\u4e00\u4e0b\u7a7a\u95f4\u9700\u6c42\u3002\u867d\u7136\u6700\u540e\u7684\u89e3\u51b3\u65b9\u6848\u80fd\u591f\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u8fd0\u884c\uff0c\u4f46\u5b83\u53ea\u80fd\u901a\u8fc7\u4f7f\u7528\u989d\u5916\u7684\u5b58\u50a8\u7a7a\u95f4\u6765\u4fdd\u5b58\u4e24\u4e2a\u5b57\u7b26\u8ba1\u6570\u5217\u8868\u6765\u5b9e\u73b0\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u4e2a\u7b97\u6cd5\u727a\u7272\u4e86\u7a7a\u95f4\u6765\u6362\u53d6\u65f6\u95f4\u3002</p> <p>\u8fd9\u79cd\u60c5\u51b5\u975e\u5e38\u5e38\u89c1\u3002\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u9700\u8981\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u7684\u6743\u8861\u4e4b\u95f4\u505a\u51fa\u51b3\u7b56\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u989d\u5916\u7684\u7a7a\u95f4\u9700\u6c42\u5e76\u4e0d\u5927\u3002\u7136\u800c\uff0c\u5982\u679c\u5e95\u5c42\u7684\u5b57\u6bcd\u8868\u5305\u542b\u6570\u767e\u4e07\u4e2a\u5b57\u7b26\uff0c\u90a3\u4e48\u8fd9\u4e2a\u95ee\u9898\u5c06\u4f1a\u66f4\u52a0\u4ee4\u4eba\u62c5\u5fe7\u3002\u4f5c\u4e3a\u4e00\u540d\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\uff0c\u5f53\u4f60\u6709\u9009\u62e9\u7b97\u6cd5\u7684\u673a\u4f1a\u65f6\uff0c\u4f60\u9700\u8981\u6839\u636e\u5177\u4f53\u95ee\u9898\u51b3\u5b9a\u5982\u4f55\u6700\u6709\u6548\u5730\u5229\u7528\u8ba1\u7b97\u8d44\u6e90\u3002</p> <p>\u81ea\u68c0</p> \u6d3b\u52a8\uff1a2.4.4.2 \u591a\u9879\u9009\u62e9\u6d3b\u52a8\uff1a2.4.4.3 \u591a\u9879\u9009\u62e9\u6d3b\u52a8\uff1a2.4.4.4 \u591a\u9879\u9009\u62e9 <p>Q-4\uff1a\u7ed9\u5b9a\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\uff0c\u5b83\u7684 Big O \u8fd0\u884c\u65f6\u95f4\u662f\u4ec0\u4e48\uff1f</p> <pre><code>test = 0\nfor i in range(n):\n    for j in range(n):\n        test = test + i * j\n</code></pre> <ul> <li> A. \\(O(n)\\)</li> <li> B. \\(O(n^2)\\)</li> <li> C. \\(O(log n)\\)</li> <li> D. \\(O(n^3)\\)</li> </ul> <p>Q-5\uff1a\u7ed9\u5b9a\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\uff0c\u5b83\u7684 Big O \u8fd0\u884c\u65f6\u95f4\u662f\u4ec0\u4e48\uff1f</p> <pre><code>test = 0\nfor i in range(n):\n    test = test + 1\n\nfor j in range(n):\n    test = test - 1\n</code></pre> <ul> <li> A. \\(O(n)\\)</li> <li> B. \\(O(n^2)\\)</li> <li> C. \\(O(log n)\\)</li> <li> D. \\(O(n^3)\\)</li> </ul> <p>Q-6\uff1a\u7ed9\u5b9a\u4ee5\u4e0b\u4ee3\u7801\u7247\u6bb5\uff0c\u5b83\u7684 Big O \u8fd0\u884c\u65f6\u95f4\u662f\u4ec0\u4e48\uff1f</p> <pre><code>i = n\nwhile i &gt; 0:\n    k = 2 + 2\n    i = i // 2\n</code></pre> <ul> <li> A. \\(O(n)\\)</li> <li> B. \\(O(n^2)\\)</li> <li> C. \\(O(log n)\\)</li> <li> D. \\(O(n^3)\\)</li> </ul> <p>Our final solution to the anagram problem takes advantage of the fact that any two anagrams will have the same number of a\u2019s, the same number of b\u2019s, the same number of c\u2019s, and so on. In order to decide whether two strings are anagrams, we will first count the number of times each character occurs. Since there are 26 possible characters, we can use a list of 26 counters, one for each possible character. Each time we see a particular character, we will increment the counter at that position. In the end, if the two lists of counters are identical, the strings must be anagrams. <code>ActiveCode 3</code> shows this solution.</p> Activity: 2.4.4.1 Count and Compare<pre><code>def anagram_solution_4(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n\n    for i in range(len(s1)):\n        pos = ord(s1[i]) - ord(\"a\")\n        c1[pos] = c1[pos] + 1\n\n    for i in range(len(s2)):\n        pos = ord(s2[i]) - ord(\"a\")\n        c2[pos] = c2[pos] + 1\n\n    j = 0\n    still_ok = True\n    while j &lt; 26 and still_ok:\n        if c1[j] == c2[j]:\n            j = j + 1\n        else:\n            still_ok = False\n\n    return still_ok\n\n\nprint(anagram_solution_4(\"apple\", \"pleap\"))  # expected: True\nprint(anagram_solution_4(\"abcd\", \"dcba\"))  # expected: True\nprint(anagram_solution_4(\"abcd\", \"dcda\"))  # expected: False\n</code></pre> <p>Again, the solution has a number of iterations. However, unlike the first solution, none of them are nested. The first two iterations used to count the characters are both based on n. The third iteration, comparing the two lists of counts, always takes 26 steps since there are 26 possible characters in the strings. Adding it all up gives us \\(T(n)=2n+26\\) steps. That is \\(O(n)\\). We have found a linear order of magnitude algorithm for solving this problem.</p> <p>Before leaving this example, we need to say something about space requirements. Although the last solution was able to run in linear time, it could only do so by using additional storage to keep the two lists of character counts. In other words, this algorithm sacrificed space in order to gain time.</p> <p>This is a common occurrence. On many occasions you will need to make decisions between time and space trade-offs. In this case, the amount of extra space is not significant. However, if the underlying alphabet had millions of characters, there would be more concern. As a computer scientist, when given a choice of algorithms, it will be up to you to determine the best use of computing resources given a particular problem.</p> <p>Self Check [Activity: 2.4.4.2 Multiple Choice]</p> <p>Q-4: Given the following code fragment, what is its Big O running time?</p> <pre><code>test = 0\nfor i in range(n):\n   for j in range(n):\n      test = test + i * j\n</code></pre> <ul> <li> A. O(n)</li> <li> B. O(n^2)</li> <li> C. O(log n)</li> <li> D. O(n^3)</li> </ul> <p>Self Check [Activity: 2.4.4.3 Multiple Choice]</p> <p>Q-5: Given the following code fragment what is its Big O running time?</p> <pre><code>test = 0\nfor i in range(n):\n   test = test + 1\n\nfor j in range(n):\n   test = test - 1\n</code></pre> <ul> <li> A. O(n)</li> <li> B. O(n^2)</li> <li> C. O(log n)</li> <li> D. O(n^3)</li> </ul> <p>Self Check [Activity: 2.4.4.4 Multiple Choice]</p> <p>Q-6: Given the following code fragment what is its Big O running time?</p> <pre><code>i = n\nwhile i &gt; 0:\n   k = 2 + 2\n   i = i // 2\n</code></pre> <ul> <li> A. O(n)</li> <li> B. O(n^2)</li> <li> C. O(log n)</li> <li> D. O(n^3)</li> </ul>"},{"location":"c2/s5/","title":"2.5. Python\u6570\u636e\u7ed3\u6784\u7684\u6027\u80fd","text":"<p>2.5. Performance of Python Data Structures</p> \u4e2d\u6587\u82f1\u6587 <p>\u73b0\u5728\u4f60\u5df2\u7ecf\u5bf9\u5927 O \u7b26\u53f7\u53ca\u4e0d\u540c\u51fd\u6570\u4e4b\u95f4\u7684\u5dee\u5f02\u6709\u4e86\u4e00\u4e2a\u5927\u81f4\u7684\u4e86\u89e3\uff0c\u6211\u4eec\u5728\u672c\u8282\u7684\u76ee\u6807\u662f\u5411\u4f60\u4ecb\u7ecd Python \u5217\u8868\u548c\u5b57\u5178\u64cd\u4f5c\u7684 Big O \u6027\u80fd\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f1a\u5c55\u793a\u4e00\u4e9b\u65f6\u95f4\u5b9e\u9a8c\uff0c\u8bf4\u660e\u5728\u4e0d\u540c\u6570\u636e\u7ed3\u6784\u4e0a\u4f7f\u7528\u67d0\u4e9b\u64cd\u4f5c\u7684\u6210\u672c\u548c\u6536\u76ca\u3002\u7406\u89e3\u8fd9\u4e9b Python \u6570\u636e\u7ed3\u6784\u7684\u6548\u7387\u5bf9\u4f60\u6765\u8bf4\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u6211\u4eec\u5728\u672c\u4e66\u4e2d\u5b9e\u73b0\u5176\u4ed6\u6570\u636e\u7ed3\u6784\u65f6\u7684\u6784\u5efa\u57fa\u7840\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4e0d\u4f1a\u89e3\u91ca\u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u6837\u7684\u6027\u80fd\u8868\u73b0\u3002\u5728\u540e\u7eed\u7ae0\u8282\u4e2d\uff0c\u4f60\u4f1a\u770b\u5230\u5217\u8868\u548c\u5b57\u5178\u7684\u67d0\u4e9b\u53ef\u80fd\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4ee5\u53ca\u6027\u80fd\u5982\u4f55\u4f9d\u8d56\u4e8e\u8fd9\u4e9b\u5b9e\u73b0\u3002</p> <p>Now that you have a general idea of Big O notation and the differences between the different functions, our goal in this section is to tell you about the Big O performance for the operations on Python lists and dictionaries. We will then show you some timing experiments that illustrate the costs and benefits of using certain operations on each data structure. It is important for you to understand the efficiency of these Python data structures because they are the building blocks we will use as we implement other data structures in the remainder of the book. In this section we are not going to explain why the performance is what it is. In later chapters you will see some possible implementations of both lists and dictionaries and how the performance depends on the implementation.</p>"},{"location":"c2/s6/","title":"2.6. \u5217\u8868","text":"<p>2.6. Lists</p> \u4e2d\u6587\u82f1\u6587 <p>Python \u7684\u8bbe\u8ba1\u8005\u5728\u5b9e\u73b0\u5217\u8868\u6570\u636e\u7ed3\u6784\u65f6\u6709\u5f88\u591a\u9009\u62e9\u3002\u6bcf\u4e2a\u9009\u62e9\u90fd\u4f1a\u5f71\u54cd\u5217\u8868\u64cd\u4f5c\u7684\u6267\u884c\u901f\u5ea6\u3002\u4e3a\u4e86\u505a\u51fa\u6b63\u786e\u7684\u9009\u62e9\uff0c\u4ed6\u4eec\u8003\u5bdf\u4e86\u4eba\u4eec\u6700\u5e38\u4f7f\u7528\u5217\u8868\u6570\u636e\u7ed3\u6784\u7684\u65b9\u5f0f\uff0c\u5e76\u4f18\u5316\u4e86\u5217\u8868\u7684\u5b9e\u73b0\uff0c\u4f7f\u6700\u5e38\u89c1\u7684\u64cd\u4f5c\u975e\u5e38\u5feb\u901f\u3002\u5f53\u7136\uff0c\u4ed6\u4eec\u4e5f\u8bd5\u56fe\u8ba9\u4e0d\u592a\u5e38\u89c1\u7684\u64cd\u4f5c\u66f4\u5feb\uff0c\u4f46\u5f53\u5fc5\u987b\u5728\u4e0d\u540c\u64cd\u4f5c\u7684\u6027\u80fd\u4e4b\u95f4\u505a\u51fa\u53d6\u820d\u65f6\uff0c\u5f80\u5f80\u4f1a\u727a\u7272\u4e0d\u5e38\u89c1\u64cd\u4f5c\u7684\u6027\u80fd\uff0c\u4f18\u5148\u4f18\u5316\u5e38\u89c1\u64cd\u4f5c\u7684\u6027\u80fd\u3002</p> <p>\u4e24\u79cd\u5e38\u89c1\u7684\u64cd\u4f5c\u662f\u7d22\u5f15\u8bbf\u95ee\u548c\u7d22\u5f15\u8d4b\u503c\u3002\u65e0\u8bba\u5217\u8868\u591a\u5927\uff0c\u8fd9\u4e24\u79cd\u64cd\u4f5c\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u90fd\u662f\u76f8\u540c\u7684\u3002\u5f53\u4e00\u4e2a\u64cd\u4f5c\u4e0e\u5217\u8868\u7684\u5927\u5c0f\u65e0\u5173\u65f6\uff0c\u5b83\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(1)\\)\u3002</p> <p>\u53e6\u4e00\u9879\u975e\u5e38\u5e38\u89c1\u7684\u7f16\u7a0b\u4efb\u52a1\u662f\u6269\u5c55\u5217\u8868\u3002\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u6765\u521b\u5efa\u4e00\u4e2a\u66f4\u957f\u7684\u5217\u8868\uff1a\u4f7f\u7528 <code>append</code> \u65b9\u6cd5\u6216\u4f7f\u7528\u8fde\u63a5\u64cd\u4f5c\u7b26\u3002<code>append</code> \u65b9\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(1)\\)\u3002\u7136\u800c\uff0c\u8fde\u63a5\u64cd\u4f5c\u7b26\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(k)\\)\uff0c\u5176\u4e2d \\(k\\) \u662f\u88ab\u8fde\u63a5\u7684\u5217\u8868\u7684\u5927\u5c0f\u3002\u4e86\u89e3\u8fd9\u4e00\u70b9\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5e2e\u52a9\u4f60\u9009\u62e9\u5408\u9002\u7684\u5de5\u5177\uff0c\u4ece\u800c\u8ba9\u7a0b\u5e8f\u66f4\u9ad8\u6548\u3002</p> <p>\u8ba9\u6211\u4eec\u6765\u770b\u770b\u751f\u6210\u4e00\u4e2a\u5305\u542b\u4ece 0 \u5f00\u59cb\u7684 <code>n</code> \u4e2a\u6570\u5b57\u7684\u5217\u8868\u7684\u56db\u79cd\u4e0d\u540c\u65b9\u5f0f\u3002\u9996\u5148\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u4f7f\u7528 <code>for</code> \u5faa\u73af\uff0c\u901a\u8fc7\u8fde\u63a5\u6765\u521b\u5efa\u5217\u8868\uff0c\u7136\u540e\u6211\u4eec\u4f7f\u7528 <code>append</code> \u65b9\u6cd5\u4ee3\u66ff\u8fde\u63a5\u64cd\u4f5c\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u5c1d\u8bd5\u4f7f\u7528\u5217\u8868\u63a8\u5bfc\u5f0f\u521b\u5efa\u5217\u8868\uff0c\u6700\u540e\uff0c\u4e5f\u8bb8\u662f\u6700\u660e\u663e\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528 <code>range</code> \u51fd\u6570\uff0c\u5e76\u901a\u8fc7 <code>list</code> \u6784\u9020\u51fd\u6570\u5c06\u5176\u5305\u88c5\u8d77\u6765\u3002<code>\u5217\u8868 3</code> \u663e\u793a\u4e86\u8fd9\u56db\u79cd\u751f\u6210\u5217\u8868\u7684\u4ee3\u7801\u3002</p> \u5217\u8868 3<pre><code>def test1():\n    l = []\n    for i in range(1000):\n        l = l + [i]\n\n\ndef test2():\n    l = []\n    for i in range(1000):\n        l.append(i)\n\n\ndef test3():\n    l = [i for i in range(1000)]\n\n\ndef test4():\n    l = list(range(1000))\n</code></pre> <p>\u4e3a\u4e86\u8bb0\u5f55\u6211\u4eec\u6bcf\u4e2a\u51fd\u6570\u7684\u6267\u884c\u65f6\u95f4\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 Python \u7684 <code>timeit</code> \u6a21\u5757\u3002<code>timeit</code> \u6a21\u5757\u65e8\u5728\u8ba9 Python \u5f00\u53d1\u8005\u5728\u8de8\u5e73\u53f0\u7684\u73af\u5883\u4e0b\u8fdb\u884c\u65f6\u95f4\u6d4b\u91cf\uff0c\u901a\u8fc7\u5728\u4e00\u81f4\u7684\u73af\u5883\u4e2d\u8fd0\u884c\u51fd\u6570\uff0c\u5e76\u4f7f\u7528\u5c3d\u53ef\u80fd\u76f8\u4f3c\u7684\u8ba1\u65f6\u673a\u5236\u6765\u8de8\u64cd\u4f5c\u7cfb\u7edf\u8fdb\u884c\u7cbe\u786e\u7684\u65f6\u95f4\u6bd4\u8f83\u3002</p> <p>\u8981\u4f7f\u7528 <code>timeit</code>\uff0c\u4f60\u9700\u8981\u521b\u5efa\u4e00\u4e2a <code>Timer</code> \u5bf9\u8c61\uff0c\u5176\u53c2\u6570\u662f\u4e24\u4e2a Python \u8bed\u53e5\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u4f60\u60f3\u8981\u8ba1\u65f6\u7684 Python \u8bed\u53e5\uff1b\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u8bbe\u7f6e\u6d4b\u8bd5\u7684\u8bed\u53e5\uff0c\u53ea\u8fd0\u884c\u4e00\u6b21\u3002\u7136\u540e\uff0c<code>timeit</code> \u6a21\u5757\u5c06\u5bf9\u8bed\u53e5\u6267\u884c\u82e5\u5e72\u6b21\u5e76\u8ba1\u65f6\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>timeit</code> \u4f1a\u5c1d\u8bd5\u6267\u884c\u8bed\u53e5\u4e00\u767e\u4e07\u6b21\u3002\u6267\u884c\u5b8c\u6210\u540e\uff0c\u5b83\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6d6e\u70b9\u6570\uff0c\u8868\u793a\u6267\u884c\u8fd9\u4e9b\u8bed\u53e5\u7684\u603b\u79d2\u6570\u3002\u7136\u800c\uff0c\u7531\u4e8e\u5b83\u6267\u884c\u4e86\u4e00\u767e\u4e07\u6b21\uff0c\u4f60\u53ef\u4ee5\u5c06\u7ed3\u679c\u7406\u89e3\u4e3a\u6267\u884c\u4e00\u6b21\u6d4b\u8bd5\u6240\u9700\u7684\u5fae\u79d2\u6570\u3002\u4f60\u8fd8\u53ef\u4ee5\u901a\u8fc7\u4f20\u9012\u4e00\u4e2a\u540d\u4e3a <code>number</code> \u7684\u53c2\u6570\u6765\u6307\u5b9a\u6d4b\u8bd5\u8bed\u53e5\u6267\u884c\u7684\u6b21\u6570\u3002\u4e0b\u9762\u7684\u4f8b\u5b50\u5c55\u793a\u4e86\u6211\u4eec\u5982\u4f55\u8bb0\u5f55\u6bcf\u4e2a\u6d4b\u8bd5\u51fd\u6570\u6267\u884c\u4e00\u5343\u6b21\u7684\u65f6\u95f4\u3002</p> <pre><code>from timeit import Timer\n\n\nt1 = Timer(\"test1()\", \"from __main__ import test1\")\nprint(f\"concatenation: {t1.timeit(number=1000):15.2f} milliseconds\")\nt2 = Timer(\"test2()\", \"from __main__ import test2\")\nprint(f\"appending: {t2.timeit(number=1000):19.2f} milliseconds\")\nt3 = Timer(\"test3()\", \"from __main__ import test3\")\nprint(f\"list comprehension: {t3.timeit(number=1000):10.2f} milliseconds\")\nt4 = Timer(\"test4()\", \"from __main__ import test4\")\nprint(f\"list range: {t4.timeit(number=1000):18.2f} milliseconds\")\n\nconcatenation:           6.54 milliseconds\nappending:               0.31 milliseconds\nlist comprehension:      0.15 milliseconds\nlist range:              0.07 milliseconds\n</code></pre> <p>\u5728\u4e0a\u9762\u7684\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u8ba1\u65f6\u7684\u8bed\u53e5\u662f\u5bf9 <code>test1()</code>, <code>test2()</code> \u7b49\u51fd\u6570\u7684\u8c03\u7528\u3002\u8bbe\u7f6e\u8bed\u53e5\u53ef\u80fd\u770b\u8d77\u6765\u6709\u70b9\u5947\u602a\uff0c\u6240\u4ee5\u6211\u4eec\u8be6\u7ec6\u89e3\u91ca\u4e00\u4e0b\u3002\u4f60\u53ef\u80fd\u5df2\u7ecf\u5f88\u719f\u6089 <code>from...import</code> \u8bed\u53e5\uff0c\u4f46\u5b83\u901a\u5e38\u5728 Python \u7a0b\u5e8f\u6587\u4ef6\u7684\u5f00\u5934\u4f7f\u7528\u3002\u5728\u8fd9\u91cc\uff0c\u8bed\u53e5 <code>from __main__ import test1</code> \u5c06\u51fd\u6570 <code>test1</code> \u4ece <code>__main__</code> \u547d\u540d\u7a7a\u95f4\u5bfc\u5165\u5230 <code>timeit</code> \u4e3a\u8ba1\u65f6\u5b9e\u9a8c\u8bbe\u7f6e\u7684\u547d\u540d\u7a7a\u95f4\u4e2d\u3002<code>timeit</code> \u6a21\u5757\u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u786e\u4fdd\u8ba1\u65f6\u6d4b\u8bd5\u5728\u4e00\u4e2a\u5e72\u51c0\u7684\u73af\u5883\u4e2d\u8fdb\u884c\uff0c\u4e0d\u53d7\u4f60\u53ef\u80fd\u521b\u5efa\u7684\u6742\u4e71\u53d8\u91cf\u7684\u5e72\u6270\uff0c\u4ece\u800c\u907f\u514d\u5b83\u4eec\u5728\u672a\u9884\u89c1\u7684\u60c5\u51b5\u4e0b\u5f71\u54cd\u51fd\u6570\u7684\u6027\u80fd\u3002</p> <p>\u4ece\u4e0a\u9762\u7684\u5b9e\u9a8c\u53ef\u4ee5\u770b\u51fa\uff0c<code>append</code> \u64cd\u4f5c\u7684\u65f6\u95f4\u4e3a 0.31 \u6beb\u79d2\uff0c\u8fdc\u8fdc\u5feb\u4e8e\u8fde\u63a5\u64cd\u4f5c\u7684 6.54 \u6beb\u79d2\u3002\u6211\u4eec\u8fd8\u5c55\u793a\u4e86\u53e6\u5916\u4e24\u79cd\u521b\u5efa\u5217\u8868\u7684\u65b9\u6cd5\uff1a\u4f7f\u7528\u5e26\u6709 <code>range</code> \u8c03\u7528\u7684\u5217\u8868\u6784\u9020\u51fd\u6570\u548c\u5217\u8868\u63a8\u5bfc\u5f0f\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5217\u8868\u63a8\u5bfc\u5f0f\u7684\u901f\u5ea6\u662f\u4f7f\u7528 <code>append</code> \u64cd\u4f5c\u7684 <code>for</code> \u5faa\u73af\u7684\u4e24\u500d\u3002</p> <p>\u5173\u4e8e\u8fd9\u4e2a\u5c0f\u5b9e\u9a8c\u7684\u6700\u540e\u4e00\u4e2a\u89c2\u5bdf\u662f\uff0c\u6240\u6709\u4f60\u770b\u5230\u7684\u65f6\u95f4\u90fd\u5305\u62ec\u4e86\u5b9e\u9645\u8c03\u7528\u6d4b\u8bd5\u51fd\u6570\u7684\u5f00\u9500\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe\u6240\u6709\u56db\u4e2a\u6d4b\u8bd5\u4e2d\u7684\u51fd\u6570\u8c03\u7528\u5f00\u9500\u662f\u76f8\u540c\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u5bf9\u64cd\u4f5c\u8fdb\u884c\u6709\u610f\u4e49\u7684\u6bd4\u8f83\u3002\u56e0\u6b64\uff0c\u51c6\u786e\u5730\u8bf4\uff0c\u8fde\u63a5\u64cd\u4f5c\u672c\u8eab\u5e76\u4e0d\u662f\u82b1\u8d39 6.54 \u6beb\u79d2\uff0c\u800c\u662f\u8fde\u63a5\u6d4b\u8bd5\u51fd\u6570\u82b1\u8d39\u4e86 6.54 \u6beb\u79d2\u3002\u4f5c\u4e3a\u4e00\u4e2a\u7ec3\u4e60\uff0c\u4f60\u53ef\u4ee5\u6d4b\u8bd5\u8c03\u7528\u7a7a\u51fd\u6570\u6240\u9700\u7684\u65f6\u95f4\uff0c\u5e76\u4ece\u4e0a\u9762\u7684\u6570\u5b57\u4e2d\u51cf\u53bb\u90a3\u4e2a\u503c\u3002</p> <p>\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u5982\u4f55\u5177\u4f53\u5730\u8861\u91cf\u6027\u80fd\uff0c\u4f60\u53ef\u4ee5\u67e5\u770b <code>\u8868 2</code>\uff0c\u4e86\u89e3\u6240\u6709\u57fa\u672c\u5217\u8868\u64cd\u4f5c\u7684 Big O \u6548\u7387\u3002\u5728\u4ed4\u7ec6\u601d\u8003 <code>\u8868 2</code> \u4e4b\u540e\uff0c\u4f60\u53ef\u80fd\u4f1a\u5bf9 <code>pop</code> \u7684\u4e24\u79cd\u4e0d\u540c\u65f6\u95f4\u611f\u5230\u597d\u5947\u3002\u5f53\u5728\u5217\u8868\u7684\u672b\u5c3e\u8c03\u7528 <code>pop</code> \u65f6\uff0c\u5b83\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(1)\\)\uff0c\u4f46\u5f53\u5728\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u6216\u4e2d\u95f4\u67d0\u5904\u8c03\u7528 <code>pop</code> \u65f6\uff0c\u5b83\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(n)\\)\u3002\u8fd9\u80cc\u540e\u7684\u539f\u56e0\u5728\u4e8e Python \u9009\u62e9\u5982\u4f55\u5b9e\u73b0\u5217\u8868\u3002\u5f53\u4ece\u5217\u8868\u7684\u5f00\u5934\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u5217\u8868\u4e2d\u7684\u6240\u6709\u5176\u4ed6\u5143\u7d20\u90fd\u4f1a\u5411\u524d\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e\u3002\u4f60\u73b0\u5728\u53ef\u80fd\u89c9\u5f97\u8fd9\u6709\u70b9\u4e0d\u5408\u7406\uff0c\u4f46\u5982\u679c\u4f60\u67e5\u770b <code>\u8868 2</code>\uff0c\u4f60\u4f1a\u53d1\u73b0\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u5141\u8bb8\u7d22\u5f15\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\(O(1)\\)\u3002\u8fd9\u662f Python \u8bbe\u8ba1\u8005\u8ba4\u4e3a\u4e0d\u9519\u7684\u4e00\u79cd\u6743\u8861\u3002</p> <p>\u8868 2\uff1aPython \u5217\u8868\u64cd\u4f5c\u7684 Big O \u6548\u7387</p> \u64cd\u4f5c Big O \u6548\u7387 <code>index []</code> O(1) <code>index \u8d4b\u503c(assignment)</code> O(1) <code>append</code> O(1) <code>pop()</code> O(1) <code>pop(i)</code> O(n) <code>insert(i, item)</code> O(n) <code>del \u64cd\u4f5c\u7b26(operator)</code> O(n) <code>\u904d\u5386(iteration)</code> O(n) <code>\u5305\u542b (in)</code> O(n) <code>\u5207\u7247\u83b7\u53d6 [x:y](get slice)</code> O(k) <code>\u5207\u7247\u5220\u9664(del slice)</code> O(n) <code>\u5207\u7247\u8d4b\u503c(set slice)</code> O(n+k) <code>\u53cd\u8f6c(reverse)</code> O(n) <code>\u8fde\u63a5(concatenate)</code> O(k) <code>\u6392\u5e8f(sort)</code> O(n log n) <code>\u4e58\u6cd5(multiply)</code> O(nk) <p>\u4e3a\u4e86\u5c55\u793a\u6027\u80fd\u7684\u5dee\u5f02\uff0c\u8ba9\u6211\u4eec\u4f7f\u7528 <code>timeit</code> \u6a21\u5757\u8fdb\u884c\u53e6\u4e00\u4e2a\u5b9e\u9a8c\u3002\u6211\u4eec\u7684\u76ee\u6807\u662f\u9a8c\u8bc1\u5728\u5df2\u77e5\u5927\u5c0f\u7684\u5217\u8868\u4e0a\u8c03\u7528 <code>pop</code> \u64cd\u4f5c\u65f6\uff0c\u4ece\u5217\u8868\u672b\u5c3e\u5f39\u51fa\u548c\u4ece\u5217\u8868\u5f00\u5934\u5f39\u51fa\u7684\u6027\u80fd\u5dee\u5f02\u3002\u6211\u4eec\u8fd8\u5e0c\u671b\u6d4b\u91cf\u4e0d\u540c\u5927\u5c0f\u7684\u5217\u8868\u7684\u65f6\u95f4\u3002\u6211\u4eec\u9884\u671f\u7684\u7ed3\u679c\u662f\uff0c\u968f\u7740\u5217\u8868\u7684\u589e\u957f\uff0c\u4ece\u5217\u8868\u672b\u5c3e\u5f39\u51fa\u7684\u65f6\u95f4\u4fdd\u6301\u4e0d\u53d8\uff0c\u800c\u4ece\u5217\u8868\u5f00\u5934\u5f39\u51fa\u7684\u65f6\u95f4\u4f1a\u968f\u7740\u5217\u8868\u7684\u589e\u957f\u800c\u589e\u52a0\u3002</p> <p><code>\u5217\u8868 4</code> \u663e\u793a\u4e86\u4e00\u79cd\u6d4b\u91cf <code>pop</code> \u4e0d\u540c\u7528\u6cd5\u6027\u80fd\u7684\u5c1d\u8bd5\u3002\u6b63\u5982\u4f60\u4ece\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\u770b\u5230\u7684\uff0c\u4ece\u672b\u5c3e\u5f39\u51fa\u9700\u8981 0.00014 \u6beb\u79d2\uff0c\u800c\u4ece\u5f00\u5934\u5f39\u51fa\u9700\u8981 2.09779 \u6beb\u79d2\u3002\u5bf9\u4e8e\u5305\u542b\u4e24\u767e\u4e07\u4e2a\u5143\u7d20\u7684\u5217\u8868\uff0c\u8fd9\u4e2a\u5dee\u5f02\u662f 15,000 \u500d\u3002</p> <p>\u5728 <code>\u5217\u8868 4</code> \u4e2d\uff0c\u6709\u51e0\u4ef6\u503c\u5f97\u6ce8\u610f\u7684\u4e8b\u60c5\u3002\u9996\u5148\u662f\u8bed\u53e5 <code>from __main__ import x</code>\u3002\u5c3d\u7ba1\u6211\u4eec\u6ca1\u6709\u5b9a\u4e49\u51fd\u6570\uff0c\u4f46\u6211\u4eec\u786e\u5b9e\u60f3\u5728\u6d4b\u8bd5\u4e2d\u4f7f\u7528\u5217\u8868\u5bf9\u8c61 x\u3002\u8fd9\u4e2a\u65b9\u6cd5\u5141\u8bb8\u6211\u4eec\u4ec5\u5bf9\u5355\u4e2a <code>pop</code> \u8bed\u53e5\u8fdb\u884c\u8ba1\u65f6\uff0c\u5e76\u83b7\u5f97\u8be5\u64cd\u4f5c\u7684\u6700\u7cbe\u786e\u65f6\u95f4\u3002\u7531\u4e8e\u8ba1\u65f6\u5668\u4f1a\u91cd\u590d\u4e00\u5343\u6b21\uff0c\u56e0\u6b64\u8fd8\u9700\u6307\u51fa\u7684\u662f\uff0c\u6bcf\u6b21\u5faa\u73af\u4e2d\u5217\u8868\u7684\u5927\u5c0f\u90fd\u4f1a\u51cf\u5c11\u4e00\u4e2a\u5143\u7d20\u3002\u4e0d\u8fc7\u7531\u4e8e\u521d\u59cb\u5217\u8868\u6709\u4e24\u767e\u4e07\u4e2a\u5143\u7d20\uff0c\u56e0\u6b64\u6574\u4f53\u5927\u5c0f\u53ea\u51cf\u5c11\u4e86 \\(0.05\\%\\)\u3002</p> \u5217\u8868 4<pre><code>pop_zero = Timer(\"x.pop(0)\", \"from __main__ import x\")\npop_end = Timer(\"x.pop()\", \"from __main__ import x\")\n\nx = list(range(2000000))\nprint(f\"pop(0): {pop_zero.timeit(number=1000):10.5f} milliseconds\")\n\nx = list(range(2000000))\nprint(f\"pop(): {pop_end.timeit(number=1000):11.5f} milliseconds\")\n\npop(0):    2.09779 milliseconds\npop():     0.00014 milliseconds\n</code></pre> <p>\u867d\u7136\u6211\u4eec\u7684\u7b2c\u4e00\u6b21\u6d4b\u8bd5\u786e\u5b9e\u8868\u660e <code>pop(0)</code> \u6bd4 <code>pop()</code> \u6162\uff0c\u4f46\u5b83\u5e76\u6ca1\u6709\u9a8c\u8bc1 <code>pop(0)</code> \u662f \\(O(n)\\) \u800c <code>pop()</code> \u662f \\(O(1)\\) \u7684\u8bf4\u6cd5\u3002\u4e3a\u4e86\u9a8c\u8bc1\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u9700\u8981\u5728\u4e0d\u540c\u5927\u5c0f\u7684\u5217\u8868\u4e0a\u6d4b\u8bd5\u8fd9\u4e24\u79cd\u8c03\u7528\u7684\u6027\u80fd\u3002<code>\u5217\u8868 5</code> \u5b9e\u73b0\u4e86\u8fd9\u4e2a\u6d4b\u8bd5\u3002</p> \u5217\u8868 5<pre><code>pop_zero = Timer(\"x.pop(0)\", \"from __main__ import x\")\npop_end = Timer(\"x.pop()\", \"from __main__ import x\")\nprint(f\"{'n':10s}{'pop(0)':&gt;15s}{'pop()':&gt;15s}\")\nfor i in range(1_000_000, 100_000_001, 1_000_000):\n    x = list(range(i))\n    pop_zero_t = pop_zero.timeit(number=1000)\n    x = list(range(i))\n    pop_end_t = pop_end.timeit(number=1000)\n    print(f\"{i:&lt;10d}{pop_zero_t:&gt;15.5f}{pop_end_t:&gt;15.5f}\")\n</code></pre> <p><code>\u56fe 3</code> \u663e\u793a\u4e86\u6211\u4eec\u7684\u5b9e\u9a8c\u7ed3\u679c\u3002\u4f60\u53ef\u4ee5\u770b\u5230\uff0c\u968f\u7740\u5217\u8868\u8d8a\u6765\u8d8a\u957f\uff0c<code>pop(0)</code> \u6240\u82b1\u7684\u65f6\u95f4\u4e5f\u589e\u52a0\uff0c\u800c <code>pop</code> \u7684\u65f6\u95f4\u51e0\u4e4e\u6ca1\u6709\u53d8\u5316\u3002\u8fd9\u6b63\u662f\u6211\u4eec\u671f\u671b\u4ece \\(O(n)\\) \u548c $O(1</p> <p>)$ \u7b97\u6cd5\u4e2d\u770b\u5230\u7684\u7ed3\u679c\u3002</p> <p> \u56fe 3\uff1a\u6bd4\u8f83 <code>pop</code> \u548c <code>pop(0)</code> \u7684\u6027\u80fd </p> <p>\u6211\u4eec\u7684\u5b9e\u9a8c\u4e2d\u53ef\u80fd\u5b58\u5728\u7684\u4e00\u4e9b\u8bef\u5dee\u6765\u6e90\u5305\u62ec\uff1a\u5728\u6211\u4eec\u6d4b\u91cf\u4ee3\u7801\u65f6\uff0c\u8ba1\u7b97\u673a\u4e0a\u8fd0\u884c\u7684\u5176\u4ed6\u8fdb\u7a0b\u53ef\u80fd\u4f1a\u62d6\u6162\u7a0b\u5e8f\u901f\u5ea6\uff0c\u56e0\u6b64\u5373\u4f7f\u6211\u4eec\u5c1d\u8bd5\u5c06\u5176\u4ed6\u6d3b\u52a8\u964d\u5230\u6700\u4f4e\uff0c\u4e5f\u96be\u514d\u4f1a\u51fa\u73b0\u4e00\u4e9b\u65f6\u95f4\u4e0a\u7684\u6ce2\u52a8\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u5faa\u73af\u4f1a\u8fd0\u884c\u4e00\u5343\u6b21\uff0c\u4ee5\u4fbf\u7edf\u8ba1\u6536\u96c6\u8db3\u591f\u7684\u4fe1\u606f\u6765\u4f7f\u6d4b\u91cf\u7ed3\u679c\u66f4\u52a0\u53ef\u9760\u3002</p> <p>The designers of Python had many choices to make when they implemented the list data structure. Each of these choices could have an impact on how fast list operations perform. To help them make the right choices they looked at the ways that people would most commonly use the list data structure, and they optimized their implementation of a list so that the most common operations were very fast. Of course they also tried to make the less common operations fast, but when a trade-off had to be made the performance of a less common operation was often sacrificed in favor of the more common operation.</p> <p>Two common operations are indexing and assigning to an index position. Both of these operations take the same amount of time no matter how large the list becomes. When an operation like this is independent of the size of the list, it is \\(O(1)\\).</p> <p>Another very common programming task is to grow a list. There are two ways to create a longer list. You can use the append method or the concatenation operator. The <code>append</code> method is \\(O(1)\\). However, the concatenation operator is \\(O(k)\\) where \\(k\\) is the size of the list that is being concatenated. This is important for you to know because it can help you make your own programs more efficient by choosing the right tool for the job.</p> <p>Let's look at four different ways we might generate a list of <code>n</code> numbers starting with 0. First we\u2019ll try a <code>for</code> loop and create the list by concatenation, then we\u2019ll use <code>append</code> rather than concatenation. Next, we\u2019ll try creating the list using list comprehension and finally, and perhaps the most obvious way, using the range function wrapped by a call to the list constructor. <code>Listing 3</code> shows the code for making our list four different ways.</p> Listing 3<pre><code>def test1():\n    l = []\n    for i in range(1000):\n        l = l + [i]\n\n\ndef test2():\n    l = []\n    for i in range(1000):\n        l.append(i)\n\n\ndef test3():\n    l = [i for i in range(1000)]\n\n\ndef test4():\n    l = list(range(1000))\n</code></pre> <p>To capture the time it takes for each of our functions to execute we will use Python\u2019s <code>timeit</code> module. The <code>timeit</code> module is designed to allow Python developers to make cross-platform timing measurements by running functions in a consistent environment and using timing mechanisms that are as similar as possible across operating systems.</p> <p>To use <code>timeit</code> you create a <code>Timer</code> object whose parameters are two Python statements. The first parameter is a Python statement that you want to time; the second parameter is a statement that will run once to set up the test. The <code>timeit</code> module will then time how long it takes to execute the statement some number of times. By default <code>timeit</code> will try to run the statement one million times. When it's done it returns the time as a floating-point value representing the total number of seconds. However, since it executes the statement a million times, you can read the result as the number of microseconds to execute the test one time. You can also pass <code>timeit</code> a named parameter called <code>number</code> that allows you to specify how many times the test statement is executed. The following session shows how long it takes to run each of our test functions a thousand times.</p> <pre><code>from timeit import Timer\n\n\nt1 = Timer(\"test1()\", \"from __main__ import test1\")\nprint(f\"concatenation: {t1.timeit(number=1000):15.2f} milliseconds\")\nt2 = Timer(\"test2()\", \"from __main__ import test2\")\nprint(f\"appending: {t2.timeit(number=1000):19.2f} milliseconds\")\nt3 = Timer(\"test3()\", \"from __main__ import test3\")\nprint(f\"list comprehension: {t3.timeit(number=1000):10.2f} milliseconds\")\nt4 = Timer(\"test4()\", \"from __main__ import test4\")\nprint(f\"list range: {t4.timeit(number=1000):18.2f} milliseconds\")\n\nconcatenation:           6.54 milliseconds\nappending:               0.31 milliseconds\nlist comprehension:      0.15 milliseconds\nlist range:              0.07 milliseconds\n</code></pre> <p>In the experiment above the statement that we are timing is the function call to <code>test1()</code>, <code>test2()</code>, and so on. The setup statement may look very strange to you, so let\u2019s consider it in more detail. You are probably very familiar with the <code>from...import</code> statement, but this is usually used at the beginning of a Python program file. In this case the statement <code>from __main__ import test1</code> imports the function <code>test1</code> from the <code>__main__</code> namespace into the namespace that <code>timeit</code> sets up for the timing experiment. The <code>timeit</code> module does this because it wants to run the timing tests in an environment that is uncluttered by any stray variables you may have created that may interfere with your function\u2019s performance in some unforeseen way.</p> <p>From the experiment above it is clear that the <code>append</code> operation at 0.31 milliseconds is much faster than concatenation at 6.54 milliseconds. We also show the times for two additional methods for creating a list: using the list constructor with a call to <code>range</code> and a list comprehension. It is interesting to note that the list comprehension is twice as fast as a <code>for</code> loop with an <code>append</code> operation.</p> <p>One final observation about this little experiment is that all of the times that you see above include some overhead for actually calling the test function, but we can assume that the function call overhead is identical in all four cases so we still get a meaningful comparison of the operations. So it would not be accurate to say that the concatenation operation takes 6.54 milliseconds but rather the concatenation test function takes 6.54 milliseconds. As an exercise you could test the time it takes to call an empty function and subtract that from the numbers above.</p> <p>Now that we have seen how performance can be measured concretely, you can look at <code>Table 2</code> to see the Big O efficiency of all the basic list operations. After thinking carefully about <code>Table 2</code>, you may be wondering about the two different times for <code>pop</code>. When <code>pop</code> is called on the end of the list it takes \\(O(1)\\), but when <code>pop</code> is called on the first element in the list---or anywhere in the middle it---is \\(O(n)\\) The reason for this lies in how Python chooses to implement lists. When an item is taken from the front of the list, all the other elements in the list are shifted one position closer to the beginning. This may seem silly to you now, but if you look at <code>Table 2</code> you will see that this implementation also allows the index operation to be \\(O(1)\\). This is a tradeoff that the Python designers thought was a good one.</p> <p>Table 2: Big O Efficiency of Python List Operators</p> Operation Big O Efficiency <code>index []</code> O(1) <code>index assignment</code> O(1) <code>append</code> O(1) <code>pop()</code> O(1) <code>pop(i)</code> O(n) <code>insert(i, item)</code> O(n) <code>del operator</code> O(n) <code>iteration</code> O(n) <code>contains (in)</code> O(n) <code>get slice [x:y]</code> O(k) <code>del slice</code> O(n) <code>set slice</code> O(n+k) <code>reverse</code> O(n) <code>concatenate</code> O(k) <code>sort</code> O(n log n) <code>multiply</code> O(nk) <p>As a way of demonstrating this difference in performance, let\u2019s do another experiment using the <code>timeit</code> module. Our goal is to be able to verify the performance of the <code>pop</code> operation on a list of a known size when the program pops from the end of the list, and again when the program pops from the beginning of the list. We will also want to measure this time for lists of different sizes. What we would expect to see is that the time required to pop from the end of the list will stay constant even as the list grows in size, while the time to pop from the beginning of the list will continue to increase as the list grows.</p> <p><code>Listing 4</code> shows one attempt to measure the difference between the two uses of <code>pop</code>. As you can see from this first example, popping from the end takes 0.00014 milliseconds, whereas popping from the beginning takes 2.09779 milliseconds. For a list of two million elements this is a factor of 15,000.</p> <p>There are a couple of things to notice about <code>Listing 4</code>. The first is the statement <code>from __main__ import x</code>. Although we did not define a function, we do want to be able to use the list object x in our test. This approach allows us to time just the single <code>pop</code> statement and get the most accurate measure of the time for that single operation. Because the timer repeats a thousand times, it is also important to point out that the list is decreasing in size by one each time through the loop. But since the initial list is two million elements in size, we only reduce the overall size by \\(0.05\\%\\).</p> Listing 4<pre><code>pop_zero = Timer(\"x.pop(0)\", \"from __main__ import x\")\npop_end = Timer(\"x.pop()\", \"from __main__ import x\")\n\nx = list(range(2000000))\nprint(f\"pop(0): {pop_zero.timeit(number=1000):10.5f} milliseconds\")\n\nx = list(range(2000000))\nprint(f\"pop(): {pop_end.timeit(number=1000):11.5f} milliseconds\")\n\npop(0):    2.09779 milliseconds\npop():     0.00014 milliseconds\n</code></pre> <p>While our first test does show that <code>pop(0)</code> is indeed slower than <code>pop()</code>, it does not validate the claim that <code>pop(0)</code> is \\(O(n)\\) while <code>pop()</code> is \\(O(1)\\). To validate that claim we need to look at the performance of both calls over a range of list sizes. <code>Listing 5</code> implements this test.</p> Listing 5<pre><code>pop_zero = Timer(\"x.pop(0)\", \"from __main__ import x\")\npop_end = Timer(\"x.pop()\", \"from __main__ import x\")\nprint(f\"{'n':10s}{'pop(0)':&gt;15s}{'pop()':&gt;15s}\")\nfor i in range(1_000_000, 100_000_001, 1_000_000):\n    x = list(range(i))\n    pop_zero_t = pop_zero.timeit(number=1000)\n    x = list(range(i))\n    pop_end_t = pop_end.timeit(number=1000)\n    print(f\"{i:&lt;10d}{pop_zero_t:&gt;15.5f}{pop_end_t:&gt;15.5f}\")\n</code></pre> <p><code>Figure 3</code> shows the results of our experiment. You can see that as the list gets longer and longer the time it takes to <code>pop(0)</code> also increases while the time for <code>pop</code> stays very flat. This is exactly what we would expect to see for an \\(O(n)\\) and \\(O(1)\\) algorithm.</p> <p> Figure 3: Comparing the Performance of <code>pop</code> and <code>pop(0)</code> </p> <p>Among the sources of error in our little experiment is the fact that there are other processes running on the computer as we measure that may slow down our code, so even though we try to minimize other things happening on the computer there is bound to be some variation in time. That is why the loop runs the test one thousand times in the first place to statistically gather enough information to make the measurement reliable.</p>"},{"location":"c2/s7/","title":"2.7. \u5b57\u5178","text":"<p>2.7. Dictionaries</p> \u4e2d\u6587\u82f1\u6587 <p>\u7b2c\u4e8c\u79cd\u4e3b\u8981\u7684 Python \u6570\u636e\u7ed3\u6784\u662f\u5b57\u5178\u3002\u6b63\u5982\u4f60\u53ef\u80fd\u8bb0\u5f97\u7684\uff0c\u5b57\u5178\u4e0e\u5217\u8868\u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u952e\u6765\u8bbf\u95ee\u5b57\u5178\u4e2d\u7684\u5143\u7d20\uff0c\u800c\u4e0d\u662f\u901a\u8fc7\u4f4d\u7f6e\u3002\u5728\u672c\u4e66\u7684\u540e\u9762\u7ae0\u8282\u4e2d\uff0c\u4f60\u4f1a\u770b\u5230\u5b9e\u73b0\u5b57\u5178\u7684\u8bb8\u591a\u65b9\u5f0f\u3002\u6b64\u65f6\u6700\u91cd\u8981\u7684\u662f\u6ce8\u610f\u5b57\u5178\u4e2d\u7684 <code>\u83b7\u53d6\u5143\u7d20</code> \u548c <code>\u8bbe\u7f6e\u5143\u7d20</code> \u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f \\(O(1)\\)\u3002\u53e6\u4e00\u4e2a\u91cd\u8981\u7684\u5b57\u5178\u64cd\u4f5c\u662f <code>\u5305\u542b</code> \u64cd\u4f5c\uff0c\u68c0\u67e5\u4e00\u4e2a\u952e\u662f\u5426\u5728\u5b57\u5178\u4e2d\u4e5f\u662f \\(O(1)\\)\u3002\u6240\u6709\u5b57\u5178\u64cd\u4f5c\u7684\u6548\u7387\u603b\u7ed3\u5728 <code>\u8868 3</code> \u4e2d\u3002\u5173\u4e8e\u5b57\u5178\u6027\u80fd\u7684\u4e00\u4e2a\u91cd\u8981\u6ce8\u91ca\u662f\uff0c\u8868\u4e2d\u7ed9\u51fa\u7684\u6548\u7387\u662f\u5e73\u5747\u6027\u80fd\u3002\u5728\u4e00\u4e9b\u7f55\u89c1\u7684\u60c5\u51b5\u4e0b\uff0c<code>\u5305\u542b</code>\u3001<code>\u83b7\u53d6\u5143\u7d20</code> \u548c <code>\u8bbe\u7f6e\u5143\u7d20</code> \u64cd\u4f5c\u53ef\u80fd\u4f1a\u9000\u5316\u4e3a \\(O(n)\\)\uff0c\u4f46\u6211\u4eec\u4f1a\u5728\u7b2c 8 \u7ae0\u8ba8\u8bba\u5b57\u5178\u53ef\u80fd\u7684\u4e0d\u540c\u5b9e\u73b0\u65b9\u5f0f\u65f6\u8be6\u7ec6\u8bf4\u660e\u3002</p> <p>\u8868 3\uff1aPython \u5b57\u5178\u64cd\u4f5c\u7684 Big O \u6548\u7387</p> \u64cd\u4f5c Big O \u6548\u7387 <code>\u590d\u5236(copy)</code> O(n) <code>\u83b7\u53d6\u5143\u7d20(get item)</code> O(1) <code>\u8bbe\u7f6e\u5143\u7d20(set item)</code> O(1) <code>\u5220\u9664\u5143\u7d20(delete item)</code> O(1) <code>\u5305\u542b (in)</code> O(1) <code>\u8fed\u4ee3(iteration)</code> O(n) <p>\u5728\u6211\u4eec\u6700\u540e\u7684\u6027\u80fd\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u6bd4\u8f83\u5217\u8868\u548c\u5b57\u5178\u7684 <code>\u5305\u542b</code> \u64cd\u4f5c\u7684\u6027\u80fd\u3002\u6211\u4eec\u4f1a\u9a8c\u8bc1\u5217\u8868\u7684 <code>\u5305\u542b</code> \u64cd\u4f5c\u662f \\(O(n)\\)\uff0c\u800c\u5b57\u5178\u7684 <code>\u5305\u542b</code> \u64cd\u4f5c\u662f \\(O(1)\\)\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u4e00\u4e2a\u7b80\u5355\u7684\u5b9e\u9a8c\u6765\u6bd4\u8f83\u8fd9\u4e24\u8005\uff1a\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u6570\u5b57\u8303\u56f4\u7684\u5217\u8868\uff0c\u7136\u540e\u968f\u673a\u6311\u9009\u6570\u5b57\uff0c\u68c0\u67e5\u8be5\u6570\u5b57\u662f\u5426\u5728\u5217\u8868\u4e2d\u3002\u5982\u679c\u6211\u4eec\u7684\u6027\u80fd\u8868\u662f\u6b63\u786e\u7684\uff0c\u90a3\u4e48\u5217\u8868\u8d8a\u5927\uff0c\u786e\u5b9a\u67d0\u4e2a\u6570\u5b57\u662f\u5426\u5728\u5217\u8868\u4e2d\u7684\u65f6\u95f4\u5e94\u8be5\u8d8a\u957f\u3002</p> <p>\u6211\u4eec\u5c06\u5bf9\u4e00\u4e2a\u5305\u542b\u6570\u5b57\u4f5c\u4e3a\u952e\u7684\u5b57\u5178\u91cd\u590d\u76f8\u540c\u7684\u5b9e\u9a8c\u3002\u5728\u8fd9\u4e2a\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u786e\u5b9a\u67d0\u4e2a\u6570\u5b57\u662f\u5426\u5728\u5b57\u5178\u4e2d\u7684\u901f\u5ea6\u4e0d\u4ec5\u8981\u5feb\u5f97\u591a\uff0c\u800c\u4e14\u968f\u7740\u5b57\u5178\u53d8\u5927\uff0c\u68c0\u67e5\u6240\u9700\u7684\u65f6\u95f4\u5e94\u8be5\u4fdd\u6301\u4e0d\u53d8\u3002</p> <p><code>\u5217\u8868 6</code> \u5b9e\u73b0\u4e86\u8fd9\u4e2a\u6bd4\u8f83\u3002\u6ce8\u610f\u6211\u4eec\u6267\u884c\u7684\u662f\u5b8c\u5168\u76f8\u540c\u7684\u64cd\u4f5c\uff0c<code>number in container</code>\u3002\u533a\u522b\u5728\u4e8e\u7b2c 8 \u884c\u7684 <code>x</code> \u662f\u4e00\u4e2a\u5217\u8868\uff0c\u800c\u7b2c 10 \u884c\u7684 <code>x</code> \u662f\u4e00\u4e2a\u5b57\u5178\u3002</p> \u5217\u8868 6<pre><code>import timeit\nimport random\n\nprint(f\"{'n':10s}{'list':&gt;10s}{'dict':&gt;10s}\")\nfor i in range(10_000, 1_000_001, 20_000):\n    t = timeit.Timer(f\"random.randrange({i}) in x\", \n    \"from __main__ import random, x\")\n    x = list(range(i))\n    lst_time = t.timeit(number=1000)\n    x = {j: None for j in range(i)}\n    dict_time = t.timeit(number=1000)\n    print(f\"{i:&lt;10,}{lst_time:&gt;10.3f}{dict_time:&gt;10.3f}\")\n</code></pre> <p><code>\u56fe 4</code> \u603b\u7ed3\u4e86\u8fd0\u884c <code>\u5217\u8868 6</code> \u7684\u7ed3\u679c\u3002\u4f60\u53ef\u4ee5\u770b\u5230\u5b57\u5178\u59cb\u7ec8\u66f4\u5feb\u3002\u5bf9\u4e8e\u5305\u542b 10,000 \u4e2a\u5143\u7d20\u7684\u6700\u5c0f\u5217\u8868\uff0c\u5b57\u5178\u6bd4\u5217\u8868\u5feb 89.4 \u500d\u3002\u5bf9\u4e8e\u5305\u542b 990,000 \u4e2a\u5143\u7d20\u7684\u6700\u5927\u5217\u8868\uff0c\u5b57\u5178\u6bd4\u5217\u8868\u5feb 11,603 \u500d\uff01\u4f60\u8fd8\u53ef\u4ee5\u770b\u5230\uff0c\u5217\u8868\u4e0a <code>\u5305\u542b</code> \u64cd\u4f5c\u7684\u65f6\u95f4\u968f\u7740\u5217\u8868\u5927\u5c0f\u5448\u7ebf\u6027\u589e\u957f\u3002\u8fd9\u9a8c\u8bc1\u4e86\u5217\u8868\u4e0a <code>\u5305\u542b</code> \u64cd\u4f5c\u662f \\(O(n)\\)\u3002\u8fd8\u53ef\u4ee5\u770b\u51fa\uff0c\u5b57\u5178\u4e0a <code>\u5305\u542b</code> \u64cd\u4f5c\u7684\u65f6\u95f4\u5373\u4f7f\u5728\u5b57\u5178\u5927\u5c0f\u589e\u957f\u65f6\u4e5f\u662f\u6052\u5b9a\u7684\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5bf9\u4e8e\u5927\u5c0f\u4e3a 10,000 \u7684\u5b57\u5178\uff0c<code>\u5305\u542b</code> \u64cd\u4f5c\u8017\u65f6 0.004 \u6beb\u79d2\uff0c\u800c\u5bf9\u4e8e\u5927\u5c0f\u4e3a 990,000 \u7684\u5b57\u5178\uff0c<code>\u5305\u542b</code> \u64cd\u4f5c\u540c\u6837\u8017\u65f6 0.004 \u6beb\u79d2\u3002</p> <p> \u56fe 4\uff1a\u6bd4\u8f83 Python \u5217\u8868\u548c\u5b57\u5178\u7684 <code>in</code> \u64cd\u4f5c </p> <p>\u7531\u4e8e Python \u662f\u4e00\u79cd\u4e0d\u65ad\u53d1\u5c55\u7684\u8bed\u8a00\uff0c\u5e55\u540e\u603b\u662f\u5728\u8fdb\u884c\u4e00\u4e9b\u53d8\u5316\u3002\u5173\u4e8e Python \u6570\u636e\u7ed3\u6784\u6027\u80fd\u7684\u6700\u65b0\u4fe1\u606f\u53ef\u4ee5\u5728 Python \u7f51\u7ad9\u4e0a\u627e\u5230\u3002\u622a\u81f3\u672c\u6587\u64b0\u5199\u65f6\uff0cPython Wiki \u4e0a\u6709\u4e00\u4e2a\u5173\u4e8e \u65f6\u95f4\u590d\u6742\u5ea6 \u7684\u9875\u9762\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee Time Complexity Wiki \u4e86\u89e3\u66f4\u591a\u3002</p> <p>\u81ea\u6d4b</p> \u6d3b\u52a8\uff1a2.7.1 \u9009\u62e9\u9898\u6d3b\u52a8\uff1a2.7.2 \u9009\u62e9\u9898 <p>\u4ee5\u4e0b\u5217\u8868\u64cd\u4f5c\u4e2d\uff0c\u54ea\u4e00\u4e2a\u4e0d\u662f O(1)\uff1f</p> <ul> <li> a: a_list.pop(0)</li> <li> b: a_list.pop()</li> <li> c: a_list.append()</li> <li> d: a_list[10]</li> <li> e: \u4e0a\u8ff0\u6240\u6709\u64cd\u4f5c\u90fd\u662f O(1)</li> </ul> <p>\u6b63\u786e\u7b54\u6848\uff1aa</p> <ul> <li> \u53cd\u9988 a: \u5f53\u4f60\u5220\u9664\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u5217\u8868\u4e2d\u7684\u6240\u6709\u5176\u4ed6\u5143\u7d20\u5fc5\u987b\u524d\u79fb\u3002</li> <li> \u53cd\u9988 b: \u4ece\u5217\u8868\u672b\u5c3e\u5220\u9664\u5143\u7d20\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\u3002</li> <li> \u53cd\u9988 c: \u5411\u5217\u8868\u672b\u5c3e\u6dfb\u52a0\u5143\u7d20\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\u3002</li> <li> \u53cd\u9988 d: \u7d22\u5f15\u5217\u8868\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\u3002</li> <li> \u53cd\u9988 e: \u6709\u4e00\u4e2a\u64cd\u4f5c\u9700\u8981\u79fb\u52a8\u5217\u8868\u4e2d\u7684\u6240\u6709\u5176\u4ed6\u5143\u7d20\u3002</li> </ul> <p>\u4ee5\u4e0b\u5b57\u5178\u64cd\u4f5c\u4e2d\uff0c\u54ea\u4e2a\u662f O(1)\uff1f</p> <ul> <li> a: \"x\" in a_dict</li> <li> b: del a_dict[\"x\"]</li> <li> c: a_dict[\"x\"] == 10</li> <li> d: a_dict[\"x\"] = a_dict[\"x\"] + 1</li> <li> e: \u4e0a\u8ff0\u6240\u6709\u64cd\u4f5c\u90fd\u662f O(1)</li> </ul> <p>\u6b63\u786e\u7b54\u6848\uff1ae</p> <ul> <li> \u53cd\u9988 a: \u5728\u5b57\u5178\u4e2d\u4f7f\u7528 <code>in</code> \u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\uff0c\u56e0\u4e3a\u4f60\u4e0d\u9700\u8981\u904d\u5386\u6574\u4e2a\u5b57\u5178\uff0c\u4f46\u6709\u66f4\u597d\u7684\u7b54\u6848\u3002</li> <li> \u53cd\u9988 b: \u4ece\u5b57\u5178\u4e2d\u5220\u9664\u5143\u7d20\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\uff0c\u4f46\u6709\u66f4\u597d\u7684\u7b54\u6848\u3002</li> <li> \u53cd\u9988 c: \u4e3a\u5b57\u5178\u952e\u8d4b\u503c\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\uff0c\u4f46\u6709\u66f4\u597d\u7684\u7b54\u6848\u3002</li> <li> \u53cd\u9988 d: \u91cd\u65b0\u4e3a\u5b57\u5178\u952e\u8d4b\u503c\u662f\u4e00\u4e2a\u5e38\u91cf\u64cd\u4f5c\uff0c\u4f46\u6709\u66f4\u597d\u7684\u7b54\u6848\u3002</li> <li> \u53cd\u9988 e: \u552f\u4e00\u4e0d\u662f O(1) \u7684\u5b57\u5178\u64cd\u4f5c\u662f\u90a3\u4e9b\u9700\u8981\u8fed\u4ee3\u7684\u64cd\u4f5c\u3002</li> </ul> <p></p> <p>The second major Python data structure is the dictionary. As you probably recall, dictionaries differ from lists in that you can access items in a dictionary by a key rather than a position. Later in this book you will see that there are many ways to implement a dictionary. The thing that is most important to notice right now is that the <code>get item</code> and <code>set item</code> operations on a dictionary are \\(O(1)\\). Another important dictionary operation is the <code>contains</code> operation. Checking to see whether a key is in the dictionary or not is also \\(O(1)\\). The efficiency of all dictionary operations is summarized in <code>Table 3</code>. One important side note on dictionary performance is that the efficiencies we provide in the table are for average performance. In some rare cases the <code>contains</code>, <code>get item</code>, and <code>set item</code> operations can degenerate into \\(O(n)\\) performance, but we will get into that in Chapter 8 when we talk about the different ways that a dictionary could be implemented.</p> <p>Table 3: Big O Efficiency of Python Dictionary Operations</p> Operation Big O Efficiency <code>copy</code> O(n) <code>get item</code> O(1) <code>set item</code> O(1) <code>delete item</code> O(1) <code>contains (in)</code> O(1) <code>iteration</code> O(n) <p>For our last performance experiment we will compare the performance of the contains operation between lists and dictionaries. In the process we will confirm that the contains operator for lists is \\(O(n)\\) and the contains operator for dictionaries is \\(O(1)\\). The experiment we will use to compare the two is simple: we\u2019ll make a list with a range of numbers in it, then we will pick numbers at random and check to see if the numbers are in the list. If our performance tables are correct, the bigger the list, the longer it should take to determine if any one number is contained in the list.</p> <p>We will repeat the same experiment for a dictionary that contains numbers as the keys. In this experiment we should see that determining whether or not a number is in the dictionary is not only much faster, but the time it takes to check should remain constant even as the dictionary grows larger.</p> <p><code>Listing 6</code> implements this comparison. Notice that we are performing exactly the same operation, <code>number in container</code>. The difference is that on line 8 <code>x</code> is a list, and on line 10 <code>x</code> is a dictionary.</p> Listing 6<pre><code>import timeit\nimport random\n\nprint(f\"{'n':10s}{'list':&gt;10s}{'dict':&gt;10s}\")\nfor i in range(10_000, 1_000_001, 20_000):\n    t = timeit.Timer(f\"random.randrange({i}) in x\", \n    \"from __main__ import random, x\")\n    x = list(range(i))\n    lst_time = t.timeit(number=1000)\n    x = {j: None for j in range(i)}\n    dict_time = t.timeit(number=1000)\n    print(f\"{i:&lt;10,}{lst_time:&gt;10.3f}{dict_time:&gt;10.3f}\")\n</code></pre> <p><code>Figure 4</code> summarizes the results of running <code>Listing 6</code>. You can see that the dictionary is consistently faster. For the smallest list size of 10,000 elements a dictionary is 89.4 times faster than a list. For the largest list size of 990,000 elements the dictionary is 11,603 times faster! You can also see that the time it takes for the <code>contains</code> operator on the list grows linearly with the size of the list. This verifies the assertion that the <code>contains</code> operator on a list is :math:<code>O(n)</code>. It can also be seen that the time for the <code>contains</code> operator on a dictionary is constant even as the dictionary size grows. In fact, for a dictionary size of 10,000 the <code>contains</code> operation took 0.004 milliseconds, and for the dictionary size of 990,000 it also took 0.004 milliseconds.</p> <p> Figure 4: Comparing the <code>in</code> Operator for Python Lists and Dictionaries </p> <p>Since Python is an evolving language, there are always changes going on behind the scenes. The latest information on the performance of Python data structures can be found on the Python website. As of this writing the Python wiki has a nice time complexity page that can be found at the Time Complexity Wiki.</p> <p>Self Check</p> Activity: 2.7.1 Multiple ChoiceActivity: 2.7.2 Multiple Choice <p>Which of the list operations shown below is not O(1)?</p> <ul> <li> a: a_list.pop(0)</li> <li> b: a_list.pop()</li> <li> c: a_list.append()</li> <li> d: a_list[10]</li> <li> e: all of the above are O(1)</li> </ul> <p>correct: a</p> <ul> <li> feedback a: When you remove the first element of a list, all the other elements of the list must be shifted forward.</li> <li> feedback b: Removing an element from the end of the list is a constant operation.</li> <li> feedback c: Appending to the end of the list is a constant operation</li> <li> feedback d: Indexing a list is a constant operation</li> <li> feedback e: There is one operation that requires all other list elements to be moved.</li> </ul> <p>Which of the dictionary operations shown below is O(1)?</p> <ul> <li> a: \"x\" in a_dict</li> <li> b: del a_dict[\"x\"]</li> <li> c: a_dict[\"x\"] == 10</li> <li> d: a_dict[\"x\"] = a_dict[\"x\"] + 1</li> <li> e: all of the above are O(1)</li> </ul> <p>correct: e</p> <ul> <li> feedback a: in is a constant operation for a dictionary because you do not have to iterate but there is a better answer.</li> <li> feedback b: deleting an element from a dictionary is a constant operation but there is a better answer.</li> <li> feedback c: Assignment to a dictionary key is constant but there is a better answer.</li> <li> feedback d: Re-assignment to a dictionary key is constant but there is a better answer.</li> <li> feedback e: The only dictionary operations that are not O(1) are those that require iteration.</li> </ul> <p></p>"},{"location":"c2/s8/","title":"2.8. \u603b\u7ed3","text":"<p>2.8. Summary</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>\u7b97\u6cd5\u5206\u6790\u662f\u4e00\u79cd\u4e0e\u5b9e\u73b0\u65e0\u5173\u7684\u6d4b\u91cf\u7b97\u6cd5\u7684\u65b9\u6cd5\u3002</li> <li>Big O \u8868\u793a\u6cd5\u5141\u8bb8\u6839\u636e\u7b97\u6cd5\u7684\u4e3b\u8981\u8fc7\u7a0b\uff08\u76f8\u5bf9\u4e8e\u95ee\u9898\u7684\u89c4\u6a21\uff09\u5bf9\u7b97\u6cd5\u8fdb\u884c\u5206\u7c7b\u3002</li> </ul> <ul> <li>Algorithm analysis is an implementation-independent way of measuring an algorithm.</li> <li>Big O notation allows algorithms to be classified by their dominant process with respect to the size of the problem.</li> </ul>"},{"location":"c2/s9/","title":"2.9. \u5173\u952e\u672f\u8bed","text":"<p>2.9. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - average case constant logarithmic benchmark analysis cubic order of magnitude Big O notation exponential quadratic brute force linear time complexity checking off log linear worst case - - - average case constant logarithmic benchmark analysis cubic order of magnitude Big O notation exponential quadratic brute force linear time complexity checking off log linear worst case"},{"location":"c3/","title":"3. \u57fa\u672c\u6570\u636e\u7ed3\u6784","text":"<p>3. Basic Data Structures</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>3.1. \u76ee\u6807 </li> <li>3.2. \u4ec0\u4e48\u662f\u7ebf\u6027\u7ed3\u6784\uff1f </li> <li>3.3. \u6808 </li> <li>3.4. \u6808\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.5. \u7528Python\u5b9e\u73b0\u6808 </li> <li>3.6. \u7b80\u5355\u7684\u62ec\u53f7\u5339\u914d </li> <li>3.7. \u7b26\u53f7\u5339\u914d\uff08\u4e00\u822c\u60c5\u51b5\uff09 </li> <li>3.8. \u5c06\u5341\u8fdb\u5236\u6570\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u6570 </li> <li>3.9. \u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f <ul> <li>3.9.1. \u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u524d\u7f00\u548c\u540e\u7f00 </li> <li>3.9.2. \u4e00\u822c\u7684\u4e2d\u7f00\u8f6c\u540e\u7f00\u8f6c\u6362 </li> <li>3.9.3. \u540e\u7f00\u8868\u8fbe\u5f0f\u6c42\u503c </li> </ul> </li> <li>3.10. \u961f\u5217 </li> <li>3.11. \u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.12. \u7528Python\u5b9e\u73b0\u961f\u5217 </li> <li>3.13. \u961f\u5217\u6a21\u62df\uff1a\u70eb\u624b\u5c71\u828b\u6e38\u620f </li> <li>3.14. \u961f\u5217\u6a21\u62df\uff1a\u6253\u5370\u4efb\u52a1 <ul> <li>3.14.1. \u4e3b\u8981\u6a21\u62df\u6b65\u9aa4 </li> <li>3.14.2. Python\u5b9e\u73b0 </li> <li>3.14.3. \u8ba8\u8bba </li> </ul> </li> <li>3.15. \u53cc\u7aef\u961f\u5217 </li> <li>3.16. \u53cc\u7aef\u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.17. \u7528Python\u5b9e\u73b0\u53cc\u7aef\u961f\u5217 </li> <li>3.18. \u56de\u6587\u68c0\u6d4b\u5668 </li> <li>3.19. \u5217\u8868 </li> <li>3.20. \u65e0\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.21. \u7528\u94fe\u8868\u5b9e\u73b0\u65e0\u5e8f\u5217\u8868 <ul> <li>3.21.1. \u8282\u70b9\u7c7b </li> <li>3.21.2. \u65e0\u5e8f\u5217\u8868\u7c7b </li> </ul> </li> <li>3.22. \u6709\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>3.23. \u5b9e\u73b0\u6709\u5e8f\u5217\u8868 <ul> <li>3.23.1. \u94fe\u8868\u5206\u6790 </li> </ul> </li> <li>3.24. \u603b\u7ed3 </li> <li>3.25. \u5173\u952e\u672f\u8bed </li> <li>3.26. \u7ec3\u4e60</li> </ul> <ul> <li>3.1. Objectives</li> <li>3.2. What Are Linear Structures?</li> <li>3.3. Stacks</li> <li>3.4. The Stack Abstract Data Type</li> <li>3.5. Implementing a Stack in Python</li> <li>3.6. Simple Balanced Parentheses</li> <li>3.7. Balanced Symbols (A General Case)</li> <li>3.8. Converting Decimal Numbers to Binary Numbers</li> <li>3.9. Infix, Prefix, and Postfix Expressions<ul> <li>3.9.1. Conversion of Infix Expressions to Prefix and Postfix</li> <li>3.9.2. General Infix-to-Postfix Conversion</li> <li>3.9.3. Postfix Evaluation</li> </ul> </li> <li>3.10. Queues</li> <li>3.11. The Queue Abstract Data Type</li> <li>3.12. Implementing a Queue in Python</li> <li>3.13. Queue Simulation: Hot Potato</li> <li>3.14. Queue Simulation: Printing Tasks<ul> <li>3.14.1. Main Simulation Steps</li> <li>3.14.2. Python Implementation</li> <li>3.14.3. Discussion</li> </ul> </li> <li>3.15. Deques</li> <li>3.16. The Deque Abstract Data Type</li> <li>3.17. Implementing a Deque in Python</li> <li>3.18. Palindrome Checker</li> <li>3.19. Lists</li> <li>3.20. The Unordered List Abstract Data Type</li> <li>3.21. Implementing an Unordered List: Linked Lists<ul> <li>3.21.1. The Node Class</li> <li>3.21.2. The UnorderedList Class</li> </ul> </li> <li>3.22. The Ordered List Abstract Data Type</li> <li>3.23. Implementing an Ordered List<ul> <li>3.23.1. Analysis of Linked Lists</li> </ul> </li> <li>3.24. Summary</li> <li>3.25. Key Terms</li> <li>3.26. Exercises</li> </ul>"},{"location":"c3/s1/","title":"3.1. \u76ee\u6807","text":"<p>3.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>\u4e86\u89e3\u62bd\u8c61\u6570\u636e\u7c7b\u578b\uff08ADT\uff09\u4e2d\u7684\u6808\uff08stack\uff09\u3001\u961f\u5217\uff08queue\uff09\u3001\u53cc\u7aef\u961f\u5217\uff08deque\uff09\u548c\u5217\u8868\uff08list\uff09\u3002</li> <li>\u80fd\u591f\u4f7f\u7528 Python \u5217\u8868\u5b9e\u73b0\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u4e2d\u7684\u6808\u3001\u961f\u5217\u548c\u53cc\u7aef\u961f\u5217\u3002</li> <li>\u4e86\u89e3\u57fa\u672c\u7ebf\u6027\u6570\u636e\u7ed3\u6784\u5b9e\u73b0\u7684\u6027\u80fd\u3002</li> <li>\u7406\u89e3\u524d\u7f00\u8868\u8fbe\u5f0f\u3001\u4e2d\u7f00\u8868\u8fbe\u5f0f\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u683c\u5f0f\u3002</li> <li>\u4f7f\u7528\u6808\u6765\u6c42\u503c\u540e\u7f00\u8868\u8fbe\u5f0f\u3002</li> <li>\u4f7f\u7528\u6808\u5c06\u8868\u8fbe\u5f0f\u4ece\u4e2d\u7f00\u8f6c\u6362\u4e3a\u540e\u7f00\u3002</li> <li>\u4f7f\u7528\u961f\u5217\u8fdb\u884c\u57fa\u672c\u7684\u65f6\u95f4\u6a21\u62df\u3002</li> <li>\u80fd\u591f\u8bc6\u522b\u9002\u5408\u4f7f\u7528\u6808\u3001\u961f\u5217\u548c\u53cc\u7aef\u961f\u5217\u7684\u6570\u636e\u7ed3\u6784\u95ee\u9898\u3002</li> <li>\u80fd\u591f\u4f7f\u7528\u8282\u70b9\u548c\u5f15\u7528\u6a21\u5f0f\u5c06\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u5217\u8868\u5b9e\u73b0\u4e3a\u94fe\u8868\u3002</li> <li>\u80fd\u591f\u6bd4\u8f83\u6211\u4eec\u94fe\u8868\u5b9e\u73b0\u4e0e Python \u5217\u8868\u5b9e\u73b0\u7684\u6027\u80fd\u3002</li> </ul> <ul> <li>To understand the abstract data types stack, queue, deque, and list.</li> <li>To be able to implement the ADTs stack, queue, and deque using Python lists.</li> <li>To understand the performance of the implementations of basic linear data structures.</li> <li>To understand prefix, infix, and postfix expression formats.</li> <li>To use stacks to evaluate postfix expressions.</li> <li>To use stacks to convert expressions from infix to postfix.</li> <li>To use queues for basic timing simulations.</li> <li>To be able to recognize problem properties where stacks, queues, and deques are appropriate data structures.</li> <li>To be able to implement the abstract data type list as a linked list using the node and reference pattern.</li> <li>To be able to compare the performance of our linked list implementation with Python\u2019s list implementation.</li> </ul>"},{"location":"c3/s10/","title":"3.10. \u961f\u5217","text":"<p>3.10. Queues</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/WhatIsaQueue.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u961f\u5217 \u662f\u4e00\u79cd\u6709\u5e8f\u7684\u9879\u76ee\u96c6\u5408\uff0c\u5176\u4e2d\u65b0\u9879\u76ee\u7684\u6dfb\u52a0\u53d1\u751f\u5728\u4e00\u4e2a\u7aef\u70b9\uff0c\u79f0\u4e3a \u5c3e\u90e8\uff0c\u800c\u73b0\u6709\u9879\u76ee\u7684\u79fb\u9664\u53d1\u751f\u5728\u53e6\u4e00\u4e2a\u7aef\u70b9\uff0c\u901a\u5e38\u79f0\u4e3a \u524d\u7aef\u3002\u5f53\u4e00\u4e2a\u5143\u7d20\u8fdb\u5165\u961f\u5217\u65f6\uff0c\u5b83\u4ece\u5c3e\u90e8\u5f00\u59cb\uff0c\u5411\u524d\u79fb\u52a8\uff0c\u76f4\u5230\u6210\u4e3a\u4e0b\u4e00\u4e2a\u88ab\u79fb\u9664\u7684\u5143\u7d20\u65f6\u624d\u4f1a\u88ab\u5904\u7406\u3002</p> <p>\u961f\u5217\u4e2d\u6700\u8fd1\u6dfb\u52a0\u7684\u9879\u76ee\u5fc5\u987b\u5728\u96c6\u5408\u7684\u672b\u5c3e\u7b49\u5f85\u3002\u800c\u5728\u96c6\u5408\u4e2d\u5b58\u5728\u65f6\u95f4\u6700\u957f\u7684\u9879\u76ee\u4f4d\u4e8e\u524d\u7aef\u3002\u8fd9\u79cd\u6392\u5e8f\u539f\u5219\u6709\u65f6\u88ab\u79f0\u4e3a FIFO\uff0c\u5373 \u5148\u8fdb\u5148\u51fa\u3002\u5b83\u4e5f\u88ab\u79f0\u4e3a \u5148\u5230\u5148\u5f97\u3002</p> <p>\u961f\u5217\u7684\u6700\u7b80\u5355\u793a\u4f8b\u662f\u6211\u4eec\u90fd\u53c2\u4e0e\u8fc7\u7684\u5178\u578b\u6392\u961f\u573a\u666f\u3002\u6211\u4eec\u5728\u6392\u961f\u7b49\u7535\u5f71\uff0c\u6211\u4eec\u5728\u8d85\u5e02\u7ed3\u8d26\u65f6\u6392\u961f\uff0c\u6211\u4eec\u5728\u9910\u5385\u6392\u961f\uff08\u4ee5\u4fbf\u53ef\u4ee5\u53d6\u9910\u76d8\uff09\u3002\u6392\u961f\u6216\u8005\u8bf4\u961f\u5217\u7684\u884c\u4e3a\u662f\u975e\u5e38\u4e25\u683c\u7684\uff0c\u53ea\u6709\u4e00\u4e2a\u5165\u53e3\u548c\u4e00\u4e2a\u51fa\u53e3\u3002\u4f60\u4e0d\u80fd\u63d2\u961f\uff0c\u4e5f\u4e0d\u80fd\u5728\u7b49\u5f85\u5230\u524d\u9762\u4e4b\u524d\u5c31\u79bb\u5f00\u3002</p> <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u4e5f\u6709\u961f\u5217\u7684\u5e38\u89c1\u4f8b\u5b50\u3002<code>Figure 1</code> \u663e\u793a\u4e86\u4e00\u4e2a\u7b80\u5355\u7684 Python \u6570\u636e\u5bf9\u8c61\u961f\u5217\u3002\u6211\u4eec\u7684\u8ba1\u7b97\u673a\u5b9e\u9a8c\u5ba4\u6709 30 \u53f0\u8ba1\u7b97\u673a\u8fde\u63a5\u5230\u4e00\u53f0\u6253\u5370\u673a\u3002\u5f53\u5b66\u751f\u4eec\u60f3\u8981\u6253\u5370\u65f6\uff0c\u4ed6\u4eec\u7684\u6253\u5370\u4efb\u52a1\u4f1a\u201c\u6392\u961f\u201d\u5728\u5176\u4ed6\u7b49\u5f85\u7684\u6253\u5370\u4efb\u52a1\u4e4b\u540e\u3002\u7b2c\u4e00\u4e2a\u8fdb\u5165\u961f\u5217\u7684\u4efb\u52a1\u662f\u4e0b\u4e00\u4e2a\u88ab\u5b8c\u6210\u7684\u4efb\u52a1\u3002\u5982\u679c\u4f60\u5728\u961f\u5217\u7684\u6700\u540e\uff0c\u4f60\u5fc5\u987b\u7b49\u6240\u6709\u5176\u4ed6\u4efb\u52a1\u5b8c\u6210\u4e4b\u540e\u624d\u80fd\u6253\u5370\u3002\u6211\u4eec\u4f1a\u5728\u7a0d\u540e\u8be6\u7ec6\u63a2\u8ba8\u8fd9\u4e2a\u6709\u8da3\u7684\u4f8b\u5b50\u3002</p> <p> \u56fe 1\uff1aPython \u6570\u636e\u5bf9\u8c61\u961f\u5217 </p> <p>\u9664\u4e86\u6253\u5370\u961f\u5217\uff0c\u64cd\u4f5c\u7cfb\u7edf\u8fd8\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u7684\u961f\u5217\u6765\u63a7\u5236\u8ba1\u7b97\u673a\u5185\u90e8\u7684\u8fdb\u7a0b\u3002\u4e0b\u4e00\u6b65\u505a\u4ec0\u4e48\u901a\u5e38\u57fa\u4e8e\u4e00\u4e2a\u961f\u5217\u7b97\u6cd5\uff0c\u8be5\u7b97\u6cd5\u8bd5\u56fe\u5c3d\u53ef\u80fd\u5feb\u901f\u5730\u6267\u884c\u7a0b\u5e8f\uff0c\u5e76\u670d\u52a1\u4e8e\u5c3d\u53ef\u80fd\u591a\u7684\u7528\u6237\u3002\u6b64\u5916\uff0c\u5f53\u6211\u4eec\u8f93\u5165\u65f6\uff0c\u6709\u65f6\u6309\u952e\u64cd\u4f5c\u4f1a\u5728\u5c4f\u5e55\u4e0a\u51fa\u73b0\u7684\u5b57\u7b26\u4e4b\u524d\u3002\u8fd9\u662f\u7531\u4e8e\u8ba1\u7b97\u673a\u5728\u90a3\u4e00\u523b\u6b63\u5728\u505a\u5176\u4ed6\u5de5\u4f5c\u3002\u6309\u952e\u64cd\u4f5c\u88ab\u653e\u7f6e\u5728\u4e00\u4e2a\u7c7b\u4f3c\u961f\u5217\u7684\u7f13\u51b2\u533a\u4e2d\uff0c\u4ee5\u4fbf\u6700\u7ec8\u80fd\u591f\u6309\u7167\u6b63\u786e\u7684\u987a\u5e8f\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002</p> <p>A queue is an ordered collection of items where the addition of new items happens at one end, called the rear, and the removal of existing items occurs at the other end, commonly called the front. As an element enters the queue it starts at the rear and makes its way toward the front, waiting until that time when it is the next element to be removed.</p> <p>The most recently added item in the queue must wait at the end of the collection. The item that has been in the collection the longest is at the front. This ordering principle is sometimes called FIFO, first in, first out. It is also known as first come, first served.</p> <p>The simplest example of a queue is the typical line that we all participate in from time to time. We wait in a line for a movie, we wait in the checkout line at a grocery store, and we wait in the cafeteria line (so that we can pop the tray stack). Well-behaved lines, or queues, are very restrictive in that they have only one way in and only one way out. There is no jumping in the middle and no leaving before you have waited the necessary amount of time to get to the front.</p> <p>Computer science also has common examples of queues. <code>Figure 1</code>  shows a simple queue of Python data objects. Our computer laboratory has 30 computers networked with a single printer. When students want to print, their print tasks \u201cget in line\u201d with all the other printing tasks that are waiting. The first task in is the next to be completed. If you are last in line, you must wait for all the other tasks to print ahead of you. We will explore this interesting example in more detail later.</p> <p> Figure 1: A Queue of Python Data Objects </p> <p>In addition to printing queues, operating systems use a number of different queues to control processes within a computer. The scheduling of what gets done next is typically based on a queuing algorithm that tries to execute programs as quickly as possible and serve as many users as it can. Also, as we type, sometimes keystrokes get ahead of the characters that appear on the screen. This is due to the computer doing other work at that moment. The keystrokes are being placed in a queue-like buffer so that they can eventually be displayed on the screen in the proper order.</p>"},{"location":"c3/s11/","title":"3.11. \u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>3.11. The Queue Abstract Data Type</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/TheQueueAbstractDataType.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u961f\u5217\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7531\u4ee5\u4e0b\u7ed3\u6784\u548c\u64cd\u4f5c\u5b9a\u4e49\u3002\u961f\u5217\u7684\u7ed3\u6784\u5982\u4e0a\u6240\u8ff0\uff0c\u662f\u4e00\u4e2a\u6709\u5e8f\u7684\u9879\u96c6\u5408\uff0c\u65b0\u9879\u5728\u4e00\u4e2a\u7aef\u70b9\u6dfb\u52a0\uff0c\u79f0\u4e3a \u5c3e\u90e8\uff0c\u800c\u4ece\u53e6\u4e00\u4e2a\u7aef\u70b9\u79fb\u9664\uff0c\u79f0\u4e3a \u524d\u7aef\u3002\u961f\u5217\u4fdd\u6301 FIFO\uff08\u5148\u8fdb\u5148\u51fa\uff09\u6392\u5e8f\u5c5e\u6027\u3002\u961f\u5217\u64cd\u4f5c\u5982\u4e0b\uff1a</p> <ul> <li> <p><code>Queue()</code> \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7a7a\u961f\u5217\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u8fd4\u56de\u4e00\u4e2a\u7a7a\u961f\u5217\u3002</p> </li> <li> <p><code>enqueue(item)</code> \u5c06\u4e00\u4e2a\u65b0\u9879\u6dfb\u52a0\u5230\u961f\u5217\u7684\u5c3e\u90e8\u3002\u5b83\u9700\u8981\u9879\u4f5c\u4e3a\u53c2\u6570\uff0c\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c\u3002</p> </li> <li> <p><code>dequeue()</code> \u4ece\u961f\u5217\u7684\u524d\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u8fd4\u56de\u8be5\u9879\u3002\u961f\u5217\u4f1a\u88ab\u4fee\u6539\u3002</p> </li> <li> <p><code>is_empty()</code> \u6d4b\u8bd5\u961f\u5217\u662f\u5426\u4e3a\u7a7a\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u8fd4\u56de\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>size()</code> \u8fd4\u56de\u961f\u5217\u4e2d\u9879\u7684\u6570\u91cf\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u3002</p> </li> </ul> <p>\u4f5c\u4e3a\u793a\u4f8b\uff0c\u5047\u8bbe <code>q</code> \u662f\u4e00\u4e2a\u5df2\u7ecf\u521b\u5efa\u5e76\u4e14\u5f53\u524d\u4e3a\u7a7a\u7684\u961f\u5217\uff0c<code>Table 5</code> \u663e\u793a\u4e86\u4e00\u7cfb\u5217\u961f\u5217\u64cd\u4f5c\u7684\u7ed3\u679c\u3002\u961f\u5217\u7684\u5185\u5bb9\u663e\u793a\u5982\u4e0b\uff0c\u524d\u7aef\u5728\u53f3\u4fa7\u3002\u7b2c\u4e00\u4e2a\u5165\u961f\u7684\u9879\u662f <code>4</code>\uff0c\u56e0\u6b64\u5b83\u662f <code>dequeue</code> \u8fd4\u56de\u7684\u7b2c\u4e00\u4e2a\u9879\u3002</p> <p>\u8868 5\uff1a\u961f\u5217\u64cd\u4f5c\u793a\u4f8b</p> \u961f\u5217\u64cd\u4f5c \u961f\u5217\u5185\u5bb9 \u8fd4\u56de\u503c <code>q.is_empty()</code> <code>[]</code> <code>True</code> <code>q.enqueue(4)</code> <code>[4]</code> <code>q.enqueue(\"dog\")</code> <code>['dog', 4]</code> <code>q.enqueue(True)</code> <code>[True, 'dog', 4]</code> <code>q.size()</code> <code>[True, 'dog', 4]</code> <code>3</code> <code>q.is_empty()</code> <code>[True, 'dog', 4]</code> <code>False</code> <code>q.enqueue(8.4)</code> <code>[8.4, True, 'dog', 4]</code> <code>q.dequeue()</code> <code>[8.4, True, 'dog']</code> <code>4</code> <code>q.dequeue()</code> <code>[8.4, True]</code> <code>'dog'</code> <code>q.size()</code> <code>[8.4, True]</code> <code>2</code> <p>The queue abstract data type is defined by the following structure and operations. A queue is structured, as described above, as an ordered collection of items which are added at one end, called the rear, and removed from the other end, called the front. Queues maintain a FIFO ordering property. The queue operations are given below.</p> <ul> <li> <p><code>Queue()</code> creates a new queue that is empty. It needs no parameters and returns an empty queue.</p> </li> <li> <p><code>enqueue(item)</code> adds a new item to the rear of the queue. It needs the item and returns nothing.</p> </li> <li> <p><code>dequeue()</code> removes the front item from the queue. It needs no parameters and returns the item. The queue is modified.</p> </li> <li> <p><code>is_empty()</code> tests to see whether the queue is empty. It needs no parameters and returns a boolean value.</p> </li> <li> <p><code>size()</code> returns the number of items in the queue. It needs no parameters and returns an integer.</p> </li> </ul> <p>As an example, if we assume that <code>q</code> is a queue that has been created and is currently empty, then <code>Table 5</code> shows the results of a sequence of queue operations. The queue contents are shown such that the front is on the right. The first item enqueued was <code>4</code> so it is the first item returned by <code>dequeue</code>.</p> <p>Table 5: Example Queue Operations</p> Queue Operation Queue Contents Return Value <code>q.is_empty()</code> <code>[]</code> <code>True</code> <code>q.enqueue(4)</code> <code>[4]</code> <code>q.enqueue(\"dog\")</code> <code>['dog',4]</code> <code>q.enqueue(True)</code> <code>[True, 'dog', 4]</code> <code>q.size()</code> <code>[True, 'dog', 4]</code> <code>3</code> <code>q.is_empty()</code> <code>[True, 'dog', 4]</code> <code>False</code> <code>q.enqueue(8.4)</code> <code>[8.4,True, 'dog', 4]</code> <code>q.dequeue()</code> <code>[8.4, True, 'dog']</code> <code>4</code> <code>q.dequeue()</code> <code>[8.4, True]</code> <code>'dog'</code> <code>q.size()</code> <code>[8.4, True]</code> <code>2</code>"},{"location":"c3/s12/","title":"3.12. \u7528Python\u5b9e\u73b0\u961f\u5217","text":"<p>3.12. Implementing a Queue in Python</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/ImplementingaQueueinPython.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e3a\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u961f\u5217\u5b9e\u73b0\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7c7b\u662f\u5408\u9002\u7684\u3002\u5982\u4e4b\u524d\u6240\u8ff0\uff0c\u6211\u4eec\u5c06\u5229\u7528\u5217\u8868\u96c6\u5408\u7684\u5f3a\u5927\u548c\u7b80\u5355\u6765\u6784\u5efa\u961f\u5217\u7684\u5185\u90e8\u8868\u793a\u3002</p> <p>\u6211\u4eec\u9700\u8981\u51b3\u5b9a\u5217\u8868\u7684\u54ea\u4e00\u7aef\u4f5c\u4e3a\u5c3e\u90e8\uff0c\u54ea\u4e00\u7aef\u4f5c\u4e3a\u524d\u7aef\u3002\u5728 <code>Listing 1</code> \u4e2d\u7684\u5b9e\u73b0\u5047\u8bbe\u5c3e\u90e8\u5728\u5217\u8868\u7684\u7b2c 0 \u4e2a\u4f4d\u7f6e\u3002\u8fd9\u5141\u8bb8\u6211\u4eec\u4f7f\u7528\u5217\u8868\u7684 <code>insert</code> \u51fd\u6570\u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u961f\u5217\u7684\u5c3e\u90e8\u3002<code>pop</code> \u64cd\u4f5c\u53ef\u4ee5\u7528\u6765\u79fb\u9664\u524d\u7aef\u5143\u7d20\uff08\u5373\u5217\u8868\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff09\u3002\u8bf7\u8bb0\u4f4f\uff0c\u8fd9\u4e5f\u610f\u5473\u7740 <code>enqueue</code> \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(n)\\)\uff0c\u800c <code>dequeue</code> \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\(O(1)\\)\u3002</p> Listing 1<pre><code>class Queue:\n    \"\"\"\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u7684\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u521b\u5efa\u65b0\u7684\u961f\u5217\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"\u68c0\u67e5\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"\u83b7\u53d6\u961f\u5217\u4e2d\u9879\u7684\u6570\u91cf\"\"\"\n        return len(self._items)\n</code></pre> <p><code>CodeLens 1</code> \u663e\u793a\u4e86 <code>Queue</code> \u7c7b\u7684\u5b9e\u9645\u64cd\u4f5c\uff0c\u5c55\u793a\u4e86 <code>Table 1</code> \u4e2d\u64cd\u4f5c\u5e8f\u5217\u7684\u6548\u679c\u3002</p> Activity: CodeLens Example Queue Operations (ququeuetest)<pre><code>class Queue:\n    \"\"\"\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u7684\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u521b\u5efa\u65b0\u7684\u961f\u5217\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"\u68c0\u67e5\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"\u83b7\u53d6\u961f\u5217\u4e2d\u9879\u7684\u6570\u91cf\"\"\"\n        return len(self._items)\n\nq = Queue()\nq.enqueue(4)\nq.enqueue(\"dog\")\nq.enqueue(True)\nprint(q.size())\n</code></pre> <p>\u8fdb\u4e00\u6b65\u64cd\u4f5c\u8be5\u961f\u5217\u5c06\u5f97\u5230\u4ee5\u4e0b\u7ed3\u679c\uff1a</p> <pre><code>&gt;&gt;&gt; q.size()\n3\n&gt;&gt;&gt; q.is_empty()\nFalse\n&gt;&gt;&gt; q.enqueue(8.4)\n&gt;&gt;&gt; q.dequeue()\n4\n&gt;&gt;&gt; q.dequeue()\n'dog'\n&gt;&gt;&gt; q.size()\n2\n</code></pre> <p>\u81ea\u68c0</p> <p>\u5047\u8bbe\u4f60\u6709\u4ee5\u4e0b\u4e00\u7cfb\u5217\u961f\u5217\u64cd\u4f5c\u3002</p> <pre><code>q = Queue()\nq.enqueue(\"hello\")\nq.enqueue(\"dog\")\nq.enqueue(3)\nq.dequeue()\n</code></pre> <p>\u961f\u5217\u4e2d\u5269\u4e0b\u54ea\u4e9b\u9879\uff1f</p> <ul> <li>\u7b54\u6848 a: 'hello', 'dog'</li> <li>\u7b54\u6848 b: 'dog', 3</li> <li>\u7b54\u6848 c: 'hello', 3</li> <li>\u7b54\u6848 d: 'hello', 'dog', 3</li> </ul> <p>\u6b63\u786e\u7b54\u6848: b</p> <ul> <li>\u53cd\u9988 a: \u8bb0\u4f4f\uff0c\u961f\u5217\u4e2d\u7b2c\u4e00\u4e2a\u6dfb\u52a0\u7684\u9879\u662f\u7b2c\u4e00\u4e2a\u79fb\u9664\u7684\u3002\u5148\u8fdb\u5148\u51fa\uff08FIFO\uff09\u3002</li> <li>\u53cd\u9988 b: \u662f\u7684\uff0c\u5148\u8fdb\u5148\u51fa\u610f\u5473\u7740 \"hello\" \u5df2\u7ecf\u88ab\u79fb\u9664\u3002</li> <li>\u53cd\u9988 c: \u961f\u5217\u548c\u6808\u90fd\u662f\u53ea\u80fd\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u9879\u7684\u6570\u636e\u7ed3\u6784\u3002</li> <li>\u53cd\u9988 d: \u54e6\uff0c\u53ef\u80fd\u4f60\u9519\u8fc7\u4e86\u6700\u540e\u7684 <code>dequeue</code> \u8c03\u7528\uff1f</li> </ul> <p>It is again appropriate to create a new class for the implementation of the abstract data type queue. As before, we will use the power and simplicity of the list collection to build the internal representation of the queue.</p> <p>We need to decide which end of the list to use as the rear and which to use as the front. The implementation shown in <code>Listing 1</code> assumes that the rear is at position 0 in the list. This allows us to use the <code>insert</code> function on lists to add new elements to the rear of the queue. The <code>pop</code> operation can be used to remove the front element (the last element of the list). Recall that this also means that <code>enqueue</code> will be \\(O(n)\\) and <code>dequeue</code> will be \\(O(1)\\). </p> Listing 1<pre><code>class Queue:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new queue\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the queue\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the queue\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"Get the number of items in the queue\"\"\"\n        return len(self._items)\n</code></pre> <p>CodeLens 1 shows the <code>Queue</code> class in action as we perform the sequence of operations from <code>Table 1</code>.</p> Activity: CodeLens Example Queue Operations (ququeuetest)<pre><code>class Queue:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new queue\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the queue\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the queue\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"Get the number of items in the queue\"\"\"\n        return len(self._items)\n\nq = Queue()\nq.enqueue(4)\nq.enqueue(\"dog\")\nq.enqueue(True)\nprint(q.size())\n</code></pre> <p>Further manipulation of this queue would give the following results:</p> <pre><code>&gt;&gt;&gt; q.size()\n3\n&gt;&gt;&gt; q.is_empty()\nFalse\n&gt;&gt;&gt; q.enqueue(8.4)\n&gt;&gt;&gt; q.dequeue()\n4\n&gt;&gt;&gt; q.dequeue()\n'dog'\n&gt;&gt;&gt; q.size()\n2\n</code></pre> <p>Self Check</p> <p>Suppose you have the following series of queue operations.</p> <pre><code>q = Queue()\nq.enqueue(\"hello\")\nq.enqueue(\"dog\")\nq.enqueue(3)\nq.dequeue()\n</code></pre> <p>What items are left on the queue?</p> <ul> <li>answer a: 'hello', 'dog'</li> <li>answer b: 'dog', 3</li> <li>answer c: 'hello', 3</li> <li>answer d: 'hello', 'dog', 3</li> </ul> <p>correct: b</p> <ul> <li>feedback a: Remember the first thing added to the queue is the first thing removed.  FIFO</li> <li>feedback b: Yes, first in first out means that hello is gone</li> <li>feedback c: Queues, and Stacks are both data structures where you can only access the first and the last thing.</li> <li>feedback d: Ooops, maybe you missed the dequeue call at the end?</li> </ul>"},{"location":"c3/s13/","title":"3.13. \u961f\u5217\u6a21\u62df\uff1a\u70eb\u624b\u5c71\u828b\u6e38\u620f","text":"<p>3.13. Queue Simulation: Hot Potato</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/SimulationHotPotato.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e00\u4e2a\u5178\u578b\u7684\u5c55\u793a\u961f\u5217\u5e94\u7528\u7684\u573a\u666f\u662f\u6a21\u62df\u4e00\u4e2a\u9700\u8981\u4ee5 FIFO \u65b9\u5f0f\u7ba1\u7406\u6570\u636e\u7684\u5b9e\u9645\u60c5\u51b5\u3002\u6211\u4eec\u5148\u6765\u770b\u4e00\u4e2a\u513f\u7ae5\u6e38\u620f\u201c\u70ed\u571f\u8c46\u201d\u7684\u4f8b\u5b50\u3002\u5728\u8fd9\u4e2a\u6e38\u620f\u4e2d\uff08\u89c1 <code>Figure 2</code>\uff09\uff0c\u5b69\u5b50\u4eec\u6392\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u5c06\u4e00\u4e2a\u7269\u54c1\u4ece\u4e00\u4e2a\u90bb\u5c45\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u90bb\u5c45\uff0c\u5c3d\u53ef\u80fd\u5feb\u5730\u4f20\u9012\u3002\u5728\u6e38\u620f\u7684\u67d0\u4e2a\u65f6\u523b\uff0c\u884c\u52a8\u4f1a\u88ab\u505c\u6b62\uff0c\u6301\u6709\u7269\u54c1\uff08\u5373\u201c\u571f\u8c46\u201d\uff09\u7684\u5b69\u5b50\u5c06\u4ece\u5706\u5708\u4e2d\u88ab\u79fb\u9664\u3002\u6e38\u620f\u7ee7\u7eed\uff0c\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u5b69\u5b50\u3002</p> <p> Figure 2: \u516d\u4eba\u70ed\u571f\u8c46\u6e38\u620f </p> <p>\u8fd9\u4e2a\u6e38\u620f\u662f\u8457\u540d\u7684\u7ea6\u745f\u592b\u95ee\u9898\u7684\u73b0\u4ee3\u7248\u3002\u6839\u636e\u5173\u4e8e\u8457\u540d\u7684\u7b2c\u4e00\u4e16\u7eaa\u5386\u53f2\u5b66\u5bb6\u5f17\u62c9\u7ef4\u4e4c\u65af\u00b7\u7ea6\u745f\u592b\u65af\u7684\u4f20\u8bf4\uff0c\u6545\u4e8b\u8bb2\u8ff0\u4e86\u5728\u72b9\u592a\u4eba\u5bf9\u7f57\u9a6c\u7684\u53cd\u6297\u4e2d\uff0c\u7ea6\u745f\u592b\u65af\u548c\u4ed6\u7684 39 \u540d\u6218\u53cb\u5728\u4e00\u4e2a\u6d1e\u7a74\u4e2d\u575a\u5b88\u3002\u9762\u5bf9\u5373\u5c06\u5230\u6765\u7684\u5931\u8d25\uff0c\u4ed6\u4eec\u51b3\u5b9a\u5b81\u6b7b\u4e0d\u5c48\uff0c\u5b81\u613f\u6b7b\u4e5f\u4e0d\u613f\u6210\u4e3a\u7f57\u9a6c\u4eba\u7684\u5974\u96b6\u3002\u4ed6\u4eec\u6392\u6210\u4e00\u4e2a\u5706\u5708\u3002\u4e00\u4e2a\u4eba\u88ab\u6307\u5b9a\u4e3a\u7f16\u53f7 1\uff0c\u7136\u540e\u987a\u65f6\u9488\u6bcf\u9694\u4e03\u4e2a\u4eba\u6740\u6b7b\u4e00\u4e2a\u4eba\u3002\u636e\u4f20\u8bf4\uff0c\u7ea6\u745f\u592b\u65af\u4e0d\u4ec5\u662f\u4e00\u4e2a\u6770\u51fa\u7684\u5386\u53f2\u5b66\u5bb6\uff0c\u8fd8\u662f\u4e00\u4e2a\u51fa\u8272\u7684\u6570\u5b66\u5bb6\u3002\u4ed6\u7acb\u5373\u8ba1\u7b97\u51fa\u81ea\u5df1\u5e94\u8be5\u5750\u5728\u54ea\u91cc\uff0c\u4ee5\u4fbf\u6700\u540e\u4e00\u4e2a\u88ab\u6740\u3002\u5f53\u65f6\uff0c\u4ed6\u9009\u62e9\u4e86\u52a0\u5165\u7f57\u9a6c\u7684\u4e00\u65b9\uff0c\u800c\u4e0d\u662f\u81ea\u6740\u3002\u4f60\u53ef\u4ee5\u627e\u5230\u8bb8\u591a\u4e0d\u540c\u7248\u672c\u7684\u8fd9\u4e2a\u6545\u4e8b\uff0c\u6709\u7684\u6570\u6bcf\u7b2c\u4e09\u4e2a\u4eba\uff0c\u6709\u7684\u5141\u8bb8\u6700\u540e\u4e00\u4e2a\u4eba\u9a91\u9a6c\u9003\u8dd1\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u601d\u60f3\u90fd\u662f\u4e00\u6837\u7684\u3002</p> <p>\u6211\u4eec\u5c06\u5b9e\u73b0\u4e00\u4e2a\u901a\u7528\u7684 \u70ed\u571f\u8c46\u6a21\u62df\u3002\u6211\u4eec\u7684\u7a0b\u5e8f\u5c06\u8f93\u5165\u4e00\u4e2a\u540d\u5b57\u5217\u8868\u548c\u4e00\u4e2a\u5e38\u6570\uff0c\u79f0\u4e4b\u4e3a\u201cnum\u201d\uff0c\u7528\u4e8e\u8ba1\u6570\u3002\u5b83\u5c06\u8fd4\u56de\u5728\u91cd\u590d\u8ba1\u6570\u540e\u5269\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u4eba\u7684\u540d\u5b57\u3002\u90a3\u65f6\u53d1\u751f\u4ec0\u4e48\u4e8b\u60c5\u5c31\u7531\u4f60\u51b3\u5b9a\u4e86\u3002</p> <p>\u4e3a\u4e86\u6a21\u62df\u5706\u5708\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u4e00\u4e2a\u961f\u5217\uff08\u89c1 <code>Figure 3</code>\uff09\u3002\u5047\u8bbe\u6301\u6709\u571f\u8c46\u7684\u5b69\u5b50\u5728\u961f\u5217\u7684\u524d\u7aef\u3002\u4f20\u9012\u571f\u8c46\u65f6\uff0c\u6a21\u62df\u5c06\u7b80\u5355\u5730\u6267\u884c <code>dequeue</code> \u64cd\u4f5c\uff0c\u7136\u540e\u7acb\u5373\u6267\u884c <code>enqueue</code> \u64cd\u4f5c\uff0c\u5c06\u8be5\u5b69\u5b50\u653e\u5230\u961f\u5217\u7684\u672b\u5c3e\u3002\u7136\u540e\uff0c\u4ed6\u4eec\u5c06\u7b49\u5f85\uff0c\u76f4\u5230\u6240\u6709\u5176\u4ed6\u5b69\u5b50\u90fd\u5728\u524d\u9762\u65f6\uff0c\u8f6e\u5230\u4ed6\u4eec\u3002\u7ecf\u8fc7 <code>num</code> \u6b21 <code>dequeue/enqueue</code> \u64cd\u4f5c\u540e\uff0c\u524d\u9762\u7684\u5b69\u5b50\u5c06\u88ab\u6c38\u4e45\u79fb\u9664\uff0c\u53e6\u4e00\u4e2a\u5faa\u73af\u5c06\u5f00\u59cb\u3002\u8fd9\u4e00\u8fc7\u7a0b\u5c06\u7ee7\u7eed\uff0c\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u540d\u5b57\uff08\u961f\u5217\u7684\u5927\u5c0f\u4e3a 1\uff09\u3002</p> <p> Figure 3: \u70ed\u571f\u8c46\u7684\u961f\u5217\u5b9e\u73b0 </p> <p>\u7a0b\u5e8f\u663e\u793a\u5728 <code>:ref:ActiveCode 1 &lt;lst_josephussim&gt;</code> \u4e2d\u3002\u4f7f\u7528 7 \u4f5c\u4e3a\u8ba1\u6570\u5e38\u6570\u8c03\u7528 <code>hot_potato</code> \u51fd\u6570\u5c06\u8fd4\u56de <code>\u2018Susan\u2019</code>\u3002</p> Activity: 3.13.1 \u70ed\u571f\u8c46\u6a21\u62df<pre><code>from pythonds3.basic import Queue\n\n\ndef hot_potato(name_list, num):\n    sim_queue = Queue()\n    for name in name_list:\n        sim_queue.enqueue(name)\n\n    while sim_queue.size() &gt; 1:\n        for i in range(num):\n            sim_queue.enqueue(sim_queue.dequeue())\n\n        sim_queue.dequeue()\n\n    return sim_queue.dequeue()\n\n\nprint(hot_potato([\"Bill\", \"David\", \"Susan\", \"Jane\", \"Kent\", \"Brad\"], 7))\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u8ba1\u6570\u5e38\u6570\u7684\u503c\u5927\u4e8e\u540d\u5b57\u5217\u8868\u4e2d\u7684\u540d\u5b57\u6570\u91cf\u3002\u8fd9\u4e0d\u662f\u95ee\u9898\uff0c\u56e0\u4e3a\u961f\u5217\u50cf\u4e00\u4e2a\u5706\u5708\u4e00\u6837\u5de5\u4f5c\uff0c\u8ba1\u6570\u4f1a\u4ece\u5f00\u59cb\u5904\u7ee7\u7eed\uff0c\u76f4\u5230\u8fbe\u5230\u6307\u5b9a\u503c\u3002\u53e6\u5916\uff0c\u6ce8\u610f\u5217\u8868\u88ab\u52a0\u8f7d\u5230\u961f\u5217\u4e2d\uff0c\u4f7f\u5f97\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u540d\u5b57\u4f1a\u4f4d\u4e8e\u961f\u5217\u7684\u524d\u7aef\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u201cBill\u201d\u662f\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u9879\uff0c\u56e0\u6b64\u5b83\u4f1a\u79fb\u52a8\u5230\u961f\u5217\u7684\u524d\u9762\u3002\u8fd9\u79cd\u5b9e\u73b0\u7684\u53d8\u4f53\u5728\u7ec3\u4e60\u4e2d\u6709\u6240\u63cf\u8ff0\uff0c\u5141\u8bb8\u4f7f\u7528\u968f\u673a\u8ba1\u6570\u5668\u3002</p> <p>One of the typical applications for showing a queue in action is to simulate a real situation that requires data to be managed in a FIFO manner. To begin, let\u2019s consider the children\u2019s game hot potato. In this game (see <code>Figure 2</code>) children line up in a circle and pass an item from neighbor to neighbor as fast as they can. At a certain point in the game, the action is stopped and the child who has the item (the potato) is removed from the circle. Play continues until only one child is left.</p> <p> Figure 2: A Six-Person Game of Hot Potato </p> <p>This game is a modern-day equivalent of the famous Josephus problem. Based on a legend about the famous first-century historian Flavius Josephus, the story is told that in the Jewish revolt against Rome, Josephus and 39 of his comrades held out against the Romans in a cave. With defeat imminent, they decided that they would rather die than be slaves to the Romans. They arranged themselves in a circle. One man was designated as number one, and proceeding clockwise they killed every seventh man. Josephus, according to the legend, was among other things an accomplished mathematician. He instantly figured out where he ought to sit in order to be the last to go. When the time came, instead of killing himself, he joined the Roman side. You can find many different versions of this story. Some count every third man and some allow the last man to escape on a horse. In any case, the idea is the same.</p> <p>We will implement a general simulation of Hot Potato. Our program will input a list of names and a constant, call it \u201cnum,\u201d to be used for counting. It will return the name of the last person remaining after repetitive counting by <code>num</code>. What happens at that point is up to you.</p> <p>To simulate the circle, we will use a queue (see <code>Figure 3</code>). Assume that the child holding the potato will be at the front of the queue. Upon passing the potato, the simulation will simply dequeue and then immediately enqueue that child, putting them at the end of the line. They will then wait until all the others have been at the front before it will be their turn again. After <code>num</code> dequeue/enqueue operations, the child at the front will be removed permanently and another cycle will begin. This process will continue until only one name remains (the size of the queue is 1).</p> <p> Figure 3: A Queue Implementation of Hot Potato </p> <p>The program is shown in :ref:<code>ActiveCode 1 &lt;lst_josephussim&gt;</code>. A call to the <code>hot_potato</code> function using 7 as the counting constant returns <code>'Susan'</code>.</p> Activity: 3.13.1 Hot Potato Simulation<pre><code>from pythonds3.basic import Queue\n\n\ndef hot_potato(name_list, num):\n    sim_queue = Queue()\n    for name in name_list:\n        sim_queue.enqueue(name)\n\n    while sim_queue.size() &gt; 1:\n        for i in range(num):\n            sim_queue.enqueue(sim_queue.dequeue())\n\n        sim_queue.dequeue()\n\n    return sim_queue.dequeue()\n\n\nprint(hot_potato([\"Bill\", \"David\", \"Susan\", \"Jane\", \"Kent\", \"Brad\"], 7))\n</code></pre> <p>Note that in this example the value of the counting constant is greater than the number of names in the list. This is not a problem since the queue acts like a circle and counting continues back at the beginning until the value is reached. Also, notice that the list is loaded into the queue such that the first name on the list will be at the front of the queue. <code>'Bill'</code> in this case is the first item in the list and therefore moves to the front of the queue. A variation of this implementation, described in the exercises, allows for a random counter.</p>"},{"location":"c3/s14/","title":"3.14. \u961f\u5217\u6a21\u62df\uff1a\u6253\u5370\u4efb\u52a1","text":"<p>3.14. Queue Simulation: Printing Tasks</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/SimulationPrintingTasks.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e00\u4e2a\u66f4\u6709\u8da3\u7684\u6a21\u62df\u53ef\u4ee5\u8ba9\u6211\u4eec\u7814\u7a76\u4e4b\u524d\u63cf\u8ff0\u7684\u6253\u5370\u961f\u5217\u7684\u884c\u4e3a\u3002\u56de\u987e\u4e00\u4e0b\uff0c\u5f53\u5b66\u751f\u5c06\u6253\u5370\u4efb\u52a1\u53d1\u9001\u5230\u5171\u4eab\u6253\u5370\u673a\u65f6\uff0c\u8fd9\u4e9b\u4efb\u52a1\u4f1a\u88ab\u653e\u5165\u961f\u5217\u4e2d\uff0c\u6309\u5148\u5230\u5148\u670d\u52a1\u7684\u65b9\u5f0f\u5904\u7406\u3002\u5728\u8fd9\u79cd\u914d\u7f6e\u4e2d\u4f1a\u51fa\u73b0\u8bb8\u591a\u95ee\u9898\u3002\u5176\u4e2d\u6700\u91cd\u8981\u7684\u53ef\u80fd\u662f\u6253\u5370\u673a\u662f\u5426\u80fd\u591f\u5904\u7406\u4e00\u5b9a\u91cf\u7684\u5de5\u4f5c\u3002\u5982\u679c\u4e0d\u80fd\uff0c\u5b66\u751f\u53ef\u80fd\u9700\u8981\u7b49\u5f85\u5f88\u957f\u65f6\u95f4\uff0c\u751a\u81f3\u9519\u8fc7\u4e0b\u4e00\u8282\u8bfe\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b\u8ba1\u7b97\u673a\u5b9e\u9a8c\u5ba4\u7684\u60c5\u51b5\u3002\u5728\u4efb\u4f55\u4e00\u4e2a\u666e\u901a\u7684\u5de5\u4f5c\u65e5\uff0c\u5b9e\u9a8c\u5ba4\u91cc\u5927\u7ea6\u6709 10 \u4e2a\u5b66\u751f\u5728\u4f7f\u7528\u8ba1\u7b97\u673a\u3002\u8fd9\u4e9b\u5b66\u751f\u901a\u5e38\u5728\u8fd9\u4e00\u65f6\u95f4\u6bb5\u5185\u6253\u5370\u4e24\u6b21\uff0c\u4efb\u52a1\u957f\u5ea6\u4ece 1 \u5230 20 \u9875\u4e0d\u7b49\u3002\u5b9e\u9a8c\u5ba4\u4e2d\u7684\u6253\u5370\u673a\u8f83\u65e7\uff0c\u80fd\u591f\u4ee5\u6bcf\u5206\u949f 10 \u9875\u7684\u901f\u5ea6\u5904\u7406\u8349\u7a3f\u8d28\u91cf\u7684\u6253\u5370\u3002\u5982\u679c\u5207\u6362\u5230\u66f4\u9ad8\u8d28\u91cf\u7684\u6253\u5370\uff0c\u901f\u5ea6\u5c06\u964d\u4e3a\u6bcf\u5206\u949f 5 \u9875\u3002\u8f83\u6162\u7684\u6253\u5370\u901f\u5ea6\u53ef\u80fd\u4f1a\u8ba9\u5b66\u751f\u7b49\u5f85\u592a\u4e45\u3002\u90a3\u4e48\uff0c\u5e94\u8be5\u4f7f\u7528\u4ec0\u4e48\u6837\u7684\u9875\u9762\u6253\u5370\u901f\u5ea6\u5462\uff1f</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6784\u5efa\u4e00\u4e2a\u6a21\u62df\u6a21\u578b\u6765\u51b3\u5b9a\u3002\u6211\u4eec\u9700\u8981\u4e3a\u5b66\u751f\u3001\u6253\u5370\u4efb\u52a1\u548c\u6253\u5370\u673a\u6784\u5efa\u8868\u793a\uff08\u89c1 <code>Figure 4</code>\uff09\u3002\u5f53\u5b66\u751f\u63d0\u4ea4\u6253\u5370\u4efb\u52a1\u65f6\uff0c\u6211\u4eec\u5c06\u5b83\u4eec\u6dfb\u52a0\u5230\u7b49\u5f85\u5217\u8868\u4e2d\uff0c\u5373\u9644\u52a0\u5230\u6253\u5370\u673a\u7684\u6253\u5370\u4efb\u52a1\u961f\u5217\u3002\u5f53\u6253\u5370\u673a\u5b8c\u6210\u4e00\u4e2a\u4efb\u52a1\u65f6\uff0c\u5b83\u4f1a\u67e5\u770b\u961f\u5217\uff0c\u770b\u770b\u662f\u5426\u8fd8\u6709\u5269\u4f59\u7684\u4efb\u52a1\u9700\u8981\u5904\u7406\u3002\u6211\u4eec\u5173\u5fc3\u7684\u662f\u5b66\u751f\u7b49\u5f85\u6253\u5370\u4efb\u52a1\u5b8c\u6210\u7684\u5e73\u5747\u65f6\u95f4\u3002\u8fd9\u7b49\u4e8e\u4efb\u52a1\u5728\u961f\u5217\u4e2d\u7b49\u5f85\u7684\u5e73\u5747\u65f6\u95f4\u3002</p> <p> Figure 4: \u8ba1\u7b97\u673a\u5b9e\u9a8c\u5ba4\u6253\u5370\u961f\u5217 </p> <p>\u4e3a\u4e86\u6a21\u62df\u8fd9\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528\u4e00\u4e9b\u6982\u7387\u3002\u4f8b\u5982\uff0c\u5b66\u751f\u53ef\u80fd\u4f1a\u6253\u5370\u957f\u5ea6\u4ece 1 \u5230 20 \u9875\u7684\u6587\u4ef6\u3002\u5982\u679c\u6bcf\u79cd\u957f\u5ea6\u51fa\u73b0\u7684\u6982\u7387\u76f8\u540c\uff0c\u53ef\u4ee5\u901a\u8fc7\u751f\u6210 1 \u5230 20 \u4e4b\u95f4\u7684\u968f\u673a\u6570\u6765\u6a21\u62df\u5b9e\u9645\u7684\u6253\u5370\u4efb\u52a1\u957f\u5ea6\u3002\u8fd9\u610f\u5473\u7740\u4efb\u4f55\u957f\u5ea6\u4ece 1 \u5230 20 \u51fa\u73b0\u7684\u673a\u4f1a\u662f\u76f8\u7b49\u7684\u3002</p> <p>\u5982\u679c\u5b9e\u9a8c\u5ba4\u91cc\u6709 10 \u4e2a\u5b66\u751f\uff0c\u6bcf\u4e2a\u4eba\u6253\u5370\u4e24\u6b21\uff0c\u90a3\u4e48\u5e73\u5747\u6bcf\u5c0f\u65f6\u6709 20 \u4e2a\u6253\u5370\u4efb\u52a1\u3002\u90a3\u4e48\uff0c\u5728\u4efb\u4f55\u7ed9\u5b9a\u7684\u79d2\u6570\u5185\uff0c\u521b\u5efa\u4e00\u4e2a\u6253\u5370\u4efb\u52a1\u7684\u6982\u7387\u662f\u591a\u5c11\u5462\uff1f\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u7684\u65b9\u6cd5\u662f\u8003\u8651\u4efb\u52a1\u4e0e\u65f6\u95f4\u7684\u6bd4\u7387\u3002\u6bcf\u5c0f\u65f6 20 \u4e2a\u4efb\u52a1\u610f\u5473\u7740\u5e73\u5747\u6bcf 180 \u79d2\u4f1a\u6709\u4e00\u4e2a\u4efb\u52a1\u4ea7\u751f\uff1a</p> <p>\\(\\frac {20\\ tasks}{1\\ hour} \\times \\frac {1\\ hour} {60\\ minutes} \\times \\frac {1\\ minute} {60\\ seconds}=\\frac {1\\ task} {180\\ seconds}\\)</p> <p>\u5bf9\u4e8e\u6bcf\u4e00\u79d2\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u751f\u6210\u4e00\u4e2a 1 \u5230 180 \u4e4b\u95f4\u7684\u968f\u673a\u6570\u6765\u6a21\u62df\u6253\u5370\u4efb\u52a1\u7684\u53d1\u751f\u673a\u4f1a\u3002\u5982\u679c\u751f\u6210\u7684\u6570\u5b57\u662f 180\uff0c\u5219\u8868\u793a\u4efb\u52a1\u5df2\u88ab\u521b\u5efa\u3002\u6ce8\u610f\uff0c\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u4efb\u52a1\u8fde\u7eed\u521b\u5efa\uff0c\u6216\u8005\u6211\u4eec\u53ef\u80fd\u9700\u8981\u7b49\u5f85\u5f88\u957f\u65f6\u95f4\u624d\u80fd\u51fa\u73b0\u4e00\u4e2a\u4efb\u52a1\u3002\u8fd9\u5c31\u662f\u6a21\u62df\u7684\u672c\u8d28\u3002\u4f60\u60f3\u8981\u5c3d\u53ef\u80fd\u771f\u5b9e\u5730\u6a21\u62df\u5b9e\u9645\u60c5\u51b5\uff0c\u524d\u63d0\u662f\u4f60\u4e86\u89e3\u4e00\u822c\u53c2\u6570\u3002</p> <p>A more interesting simulation allows us to study the behavior of the printing queue described earlier in this section. Recall that as students send printing tasks to the shared printer, the tasks are placed in a queue to be processed in a first come, first served manner. Many questions arise with this configuration. The most important of these might be whether the printer is capable of handling a certain amount of work. If it cannot, students will be waiting too long for printing and may miss their next class.</p> <p>Consider the following situation in a computer science laboratory. On any average day about 10 students are working in the lab at any given hour. These students typically print up to twice during that time, and the length of these tasks ranges from 1 to 20 pages. The printer in the lab is older, capable of processing 10 pages per minute of draft quality. The printer could be switched to give better quality, but then it would produce only five pages per minute. The slower printing speed could make students wait too long. What page rate should be used?</p> <p>We could decide by building a simulation that models the laboratory. We will need to construct representations for students, printing tasks, and the printer (<code>Figure 4</code>). As students submit printing tasks, we will add them to a waiting list, a queue of print tasks attached to the printer. When the printer completes a task, it will look at the queue to see if there are any remaining tasks to process. Of interest for us is the average amount of time students will wait for their papers to be printed. This is equal to the average amount of time a task waits in the queue.</p> <p> Figure 4: Computer Science Laboratory Printing Queue </p> <p>To model this situation we need to use some probabilities. For example, students may print a paper from 1 to 20 pages in length. If each length from 1 to 20 is equally likely, the actual length for a print task can be simulated by using a random number between 1 and 20 inclusive. This means that there is equal chance of any length from 1 to 20 appearing. </p> <p>If there are 10 students in the lab and each prints twice, then there are 20 print tasks per hour on average. What is the chance that at any given second, a print task is going to be created? The way to answer this is to consider the ratio of tasks to time. Twenty tasks per hour means that on average there will be one task every 180 seconds:</p> <p>\\(\\frac {20\\ tasks}{1\\ hour} \\times \\frac {1\\ hour}  {60\\ minutes} \\times \\frac {1\\ minute} {60\\ seconds}=\\frac {1\\ task} {180\\ seconds}\\)</p> <p>For every second we can simulate the chance that a print task occurs by generating a random number between 1 and 180 inclusive. If the number is 180, we say a task has been created. Note that it is possible that many tasks could be created in a row or we may wait quite a while for a task to appear. That is the nature of simulation. You want to simulate the real situation as closely as possible given that you know general parameters.</p>"},{"location":"c3/s14/#3141-\u4e3b\u8981\u6a21\u62df\u6b65\u9aa4","title":"3.14.1. \u4e3b\u8981\u6a21\u62df\u6b65\u9aa4","text":"<p>3.14.1. Main Simulation Steps</p> \u4e2d\u6587\u82f1\u6587 <p>\u4ee5\u4e0b\u662f\u4e3b\u8981\u7684\u6a21\u62df\u6b65\u9aa4\uff1a</p> <ol> <li> <p>\u521b\u5efa\u4e00\u4e2a\u6253\u5370\u4efb\u52a1\u7684\u961f\u5217\u3002\u6bcf\u4e2a\u4efb\u52a1\u5728\u5230\u8fbe\u65f6\u90fd\u4f1a\u88ab\u8d4b\u4e88\u4e00\u4e2a\u65f6\u95f4\u6233\u3002\u961f\u5217\u5f00\u59cb\u65f6\u662f\u7a7a\u7684\u3002</p> </li> <li> <p>\u5bf9\u4e8e\u6bcf\u4e00\u79d2\uff08<code>current_second</code>\uff09\uff1a</p> <ul> <li> <p>\u68c0\u67e5\u662f\u5426\u521b\u5efa\u4e86\u65b0\u7684\u6253\u5370\u4efb\u52a1\uff1f\u5982\u679c\u662f\uff0c\u5c06\u5176\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\uff0c\u5e76\u4ee5<code>current_second</code>\u4f5c\u4e3a\u65f6\u95f4\u6233\u3002</p> </li> <li> <p>\u5982\u679c\u6253\u5370\u673a\u6ca1\u6709\u5fd9\u788c\u4e14\u6709\u4efb\u52a1\u5728\u7b49\u5f85\uff0c</p> <ul> <li> <p>\u4ece\u6253\u5370\u961f\u5217\u4e2d\u79fb\u9664\u4e0b\u4e00\u4e2a\u4efb\u52a1\uff0c\u5e76\u5c06\u5176\u5206\u914d\u7ed9\u6253\u5370\u673a\u3002</p> </li> <li> <p>\u4ece<code>current_second</code>\u4e2d\u51cf\u53bb\u65f6\u95f4\u6233\uff0c\u4ee5\u8ba1\u7b97\u8be5\u4efb\u52a1\u7684\u7b49\u5f85\u65f6\u95f4\u3002</p> </li> <li> <p>\u5c06\u8be5\u4efb\u52a1\u7684\u7b49\u5f85\u65f6\u95f4\u9644\u52a0\u5230\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u4ee5\u4fbf\u540e\u7eed\u5904\u7406\u3002</p> </li> <li> <p>\u6839\u636e\u6253\u5370\u4efb\u52a1\u7684\u9875\u6570\uff0c\u8ba1\u7b97\u6240\u9700\u7684\u6253\u5370\u65f6\u95f4\u3002</p> </li> </ul> </li> <li> <p>\u5982\u679c\u9700\u8981\uff0c\u6253\u5370\u673a\u73b0\u5728\u8fdb\u884c\u4e00\u79d2\u949f\u7684\u6253\u5370\u3002\u540c\u65f6\u5c06\u8be5\u4efb\u52a1\u6240\u9700\u7684\u65f6\u95f4\u51cf\u5c11\u4e00\u79d2\u3002</p> </li> <li> <p>\u5982\u679c\u4efb\u52a1\u5df2\u5b8c\u6210\uff0c\u5373\u6240\u9700\u7684\u65f6\u95f4\u5df2\u964d\u81f3\u96f6\uff0c\u5219\u6253\u5370\u673a\u4e0d\u518d\u5fd9\u788c\u3002</p> </li> </ul> </li> <li> <p>\u6a21\u62df\u5b8c\u6210\u540e\uff0c\u4ece\u751f\u6210\u7684\u7b49\u5f85\u65f6\u95f4\u5217\u8868\u4e2d\u8ba1\u7b97\u5e73\u5747\u7b49\u5f85\u65f6\u95f4\u3002</p> </li> </ol> <p>Here is the main simulation.</p> <ol> <li> <p>Create a queue of print tasks. Each task will be given a timestamp upon its arrival. The queue is empty to start.</p> </li> <li> <p>For each second (<code>current_second</code>):</p> <ul> <li> <p>Does a new print task get created? If so, add it to the queue with the <code>current_second</code> as the timestamp.</p> </li> <li> <p>If the printer is not busy and if a task is waiting,</p> <ul> <li> <p>Remove the next task from the print queue and assign it to the printer.</p> </li> <li> <p>Subtract the timestamp from the <code>current_second</code> to compute the waiting time for that task.</p> </li> <li> <p>Append the waiting time for that task to a list for later processing.</p> </li> <li> <p>Based on the number of pages in the print task, figure out how much time will be required.</p> </li> </ul> </li> <li> <p>The printer now does one second of printing if necessary. It also subtracts one second from the time required for that task.</p> </li> <li> <p>If the task has been completed, in other words the time required has reached zero, the printer is no longer busy.</p> </li> </ul> </li> <li> <p>After the simulation is complete, compute the average waiting time from the list of waiting times generated.</p> </li> </ol>"},{"location":"c3/s14/#3142-python\u5b9e\u73b0","title":"3.14.2. Python\u5b9e\u73b0","text":"<p>3.14.2. Python Implementation</p> \u4e2d\u6587\u82f1\u6587 <p>\u4ee5\u4e0b\u662f\u4e3b\u8981\u7684\u6a21\u62df\u5185\u5bb9\uff1a</p> <p>\u4e3a\u4e86\u8bbe\u8ba1\u8fd9\u4e2a\u6a21\u62df\uff0c\u6211\u4eec\u5c06\u521b\u5efa\u4e09\u4e2a\u8868\u793a\u5b9e\u9645\u5bf9\u8c61\u7684\u7c7b\uff1a<code>Printer</code>\uff08\u6253\u5370\u673a\uff09\u3001<code>Task</code>\uff08\u4efb\u52a1\uff09\u548c<code>PrintQueue</code>\uff08\u6253\u5370\u961f\u5217\uff09\u3002</p> <p><code>Printer</code> \u7c7b\uff08<code>Listing 2</code>\uff09\u9700\u8981\u8ddf\u8e2a\u662f\u5426\u6709\u5f53\u524d\u4efb\u52a1\u3002\u5982\u679c\u6709\uff0c\u5219\u8868\u793a\u6253\u5370\u673a\u6b63\u5728\u5fd9\u788c\uff08\u7b2c13-17\u884c\uff09\uff0c\u5e76\u4e14\u53ef\u4ee5\u6839\u636e\u4efb\u52a1\u7684\u9875\u6570\u8ba1\u7b97\u6240\u9700\u7684\u65f6\u95f4\u3002\u6784\u9020\u51fd\u6570\u8fd8\u5141\u8bb8\u521d\u59cb\u5316\u6bcf\u5206\u949f\u9875\u6570\u8bbe\u7f6e\u3002<code>tick</code> \u65b9\u6cd5\u4f1a\u51cf\u5c11\u5185\u90e8\u8ba1\u65f6\u5668\uff0c\u5e76\u5728\u4efb\u52a1\u5b8c\u6210\u65f6\u5c06\u6253\u5370\u673a\u8bbe\u7f6e\u4e3a\u7a7a\u95f2\u72b6\u6001\uff08\u7b2c11\u884c\uff09\u3002</p> Listing 2<pre><code>class Printer:\n    def __init__(self, ppm):\n        self.page_rate = ppm\n        self.current_task = None\n        self.time_remaining = 0\n\n    def tick(self):\n        if self.current_task is not None:\n            self.time_remaining = self.time_remaining - 1\n            if self.time_remaining &lt;= 0:\n                self.current_task = None\n\n    def busy(self):\n        return self.current_task is not None\n\n    def start_next(self, new_task):\n        self.current_task = new_task\n        self.time_remaining = new_task.get_pages() * 60 / self.page_rate\n</code></pre> <p><code>Task</code> \u7c7b\uff08<code>Listing 3</code>\uff09\u5c06\u8868\u793a\u4e00\u4e2a\u5355\u4e00\u7684\u6253\u5370\u4efb\u52a1\u3002\u5f53\u4efb\u52a1\u88ab\u521b\u5efa\u65f6\uff0c\u968f\u673a\u6570\u751f\u6210\u5668\u5c06\u63d0\u4f9b\u4e00\u4e2a1\u523020\u9875\u7684\u957f\u5ea6\u3002\u6211\u4eec\u9009\u62e9\u4f7f\u7528 <code>random</code> \u6a21\u5757\u7684 <code>randrange</code> \u51fd\u6570\u3002</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.randrange(1,21)\n18\n&gt;&gt;&gt; random.randrange(1,21)\n8\n&gt;&gt;&gt;\n</code></pre> <p>\u6bcf\u4e2a\u4efb\u52a1\u8fd8\u9700\u8981\u4fdd\u6301\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u7528\u4e8e\u8ba1\u7b97\u7b49\u5f85\u65f6\u95f4\u3002\u8fd9\u4e2a\u65f6\u95f4\u6233\u8868\u793a\u4efb\u52a1\u521b\u5efa\u5e76\u653e\u5165\u6253\u5370\u961f\u5217\u7684\u65f6\u95f4\u3002<code>wait_time</code> \u65b9\u6cd5\u53ef\u4ee5\u7528\u6765\u68c0\u7d22\u4efb\u52a1\u5728\u6253\u5370\u5f00\u59cb\u4e4b\u524d\u5728\u961f\u5217\u4e2d\u7b49\u5f85\u7684\u65f6\u95f4\u3002</p> Listing 3<pre><code>import random\n\n\nclass Task:\n    def __init__(self, time):\n        self.timestamp = time\n        self.pages = random.randrange(1, 21)\n\n    def get_stamp(self):\n        return self.timestamp\n\n    def get_pages(self):\n        return self.pages\n\n    def wait_time(self, current_time):\n        return current_time - self.timestamp\n</code></pre> <p>\u4e3b\u8981\u6a21\u62df\uff08<code>Listing 4</code>\uff09\u5b9e\u73b0\u4e86\u4e0a\u8ff0\u7b97\u6cd5\u3002<code>print_queue</code> \u5bf9\u8c61\u662f\u6211\u4eec\u73b0\u6709\u961f\u5217ADT\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002\u4e00\u4e2a\u5e03\u5c14\u8f85\u52a9\u51fd\u6570 <code>new_print_task</code> \u51b3\u5b9a\u662f\u5426\u521b\u5efa\u4e86\u65b0\u7684\u6253\u5370\u4efb\u52a1\u3002\u6211\u4eec\u518d\u6b21\u9009\u62e9\u4f7f\u7528 <code>random</code> \u6a21\u5757\u7684 <code>randrange</code> \u51fd\u6570\u6765\u8fd4\u56de1\u5230180\u4e4b\u95f4\u7684\u968f\u673a\u6574\u6570\u3002\u6253\u5370\u4efb\u52a1\u6bcf180\u79d2\u5230\u8fbe\u4e00\u6b21\u3002\u901a\u8fc7\u5728\u968f\u673a\u6574\u6570\u8303\u56f4\u5185\u4efb\u610f\u9009\u62e9180\uff08\u7b2c31\u884c\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u6a21\u62df\u8fd9\u4e2a\u968f\u673a\u4e8b\u4ef6\u3002\u6a21\u62df\u51fd\u6570\u5141\u8bb8\u6211\u4eec\u8bbe\u7f6e\u603b\u65f6\u95f4\u548c\u6253\u5370\u673a\u7684\u6bcf\u5206\u949f\u9875\u6570\u3002</p> Listing 4<pre><code>import random\nfrom pythonds3.basic import Queue\n\n\ndef simulation(num_seconds, pages_per_minute):\n    lab_printer = Printer(pages_per_minute)\n    print_queue = Queue()\n    waiting_times = []\n\n    for current_second in range(num_seconds):\n        if new_print_task():\n            task = Task(current_second)\n            print_queue.enqueue(task)\n\n        if (not lab_printer.busy()) and (not print_queue.is_empty()):\n            nexttask = print_queue.dequeue()\n            waiting_times.append(nexttask.wait_time(current_second))\n            lab_printer.start_next(nexttask)\n\n        lab_printer.tick()\n\n    average_wait = sum(waiting_times) / len(waiting_times)\n    print(\n        f\"Average Wait {average_wait:6.2f} secs\" \\\n        + f\"{print_queue.size():3d} tasks remaining.\"\n    )\n\n\ndef new_print_task():\n    num = random.randrange(1, 181)\n    return num == 180\n\n\nfor i in range(10):\n    simulation(3600, 5)\n</code></pre> <p>\u5f53\u6211\u4eec\u8fd0\u884c\u6a21\u62df\u65f6\uff0c\u4e0d\u5fc5\u62c5\u5fc3\u6bcf\u6b21\u7ed3\u679c\u90fd\u4e0d\u540c\u3002\u8fd9\u662f\u7531\u4e8e\u968f\u673a\u6570\u7684\u6982\u7387\u7279\u6027\u3002\u6211\u4eec\u611f\u5174\u8da3\u7684\u662f\u5728\u8c03\u6574\u6a21\u62df\u53c2\u6570\u65f6\u53ef\u80fd\u51fa\u73b0\u7684\u8d8b\u52bf\u3002\u4ee5\u4e0b\u662f\u4e00\u4e9b\u7ed3\u679c\u3002</p> <p>\u9996\u5148\uff0c\u6211\u4eec\u5c06\u6a21\u62df\u8fd0\u884c60\u5206\u949f\uff083,600\u79d2\uff09\uff0c\u6253\u5370\u901f\u5ea6\u4e3a\u6bcf\u5206\u949f5\u9875\u3002\u6b64\u5916\uff0c\u6211\u4eec\u5c06\u8fd0\u884c10\u6b21\u72ec\u7acb\u7684\u8bd5\u9a8c\u3002\u8bf7\u8bb0\u4f4f\uff0c\u7531\u4e8e\u6a21\u62df\u4f7f\u7528\u968f\u673a\u6570\uff0c\u6bcf\u6b21\u8fd0\u884c\u5c06\u8fd4\u56de\u4e0d\u540c\u7684\u7ed3\u679c\u3002</p> <pre><code>&gt;&gt;&gt; for i in range(10):\n...     simulation(3600, 5)\n... \nAverage Wait 165.38 secs 2 tasks remaining.\nAverage Wait  95.07 secs 1 tasks remaining.\nAverage Wait  65.05 secs 2 tasks remaining.\nAverage Wait  99.74 secs 1 tasks remaining.\nAverage Wait  17.27 secs 0 tasks remaining.\nAverage Wait 239.61 secs 5 tasks remaining.\nAverage Wait  75.11 secs 1 tasks remaining.\nAverage Wait  48.33 secs 0 tasks remaining.\nAverage Wait  39.31 secs 3 tasks remaining.\nAverage Wait 376.05 secs 1 tasks remaining.\n&gt;&gt;&gt; \n</code></pre> <p>\u5728\u8fdb\u884c10\u6b21\u8bd5\u9a8c\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u5e73\u5747\u7b49\u5f85\u65f6\u95f4\u662f (165.38 + 95.07 + 65.05 + 99.74 + 17.27 + 239.61 + 75.11 + 48.33 + 39.31 + 376.05) / 10 = 122.09\u79d2\u3002\u60a8\u8fd8\u53ef\u4ee5\u770b\u5230\u5e73\u5747\u7b49\u5f85\u65f6\u95f4\u7684\u53d8\u5316\u5f88\u5927\uff0c\u6700\u5c0f\u5e73\u5747\u7b49\u5f85\u65f6\u95f4\u4e3a17.27\u79d2\uff0c\u6700\u5927\u4e3a376.05\u79d2\u3002\u60a8\u8fd8\u53ef\u80fd\u6ce8\u610f\u5230\uff0c\u5728\u4ec5\u6709\u4e24\u4e2a\u60c5\u51b5\u4e0b\uff0c\u6240\u6709\u4efb\u52a1\u90fd\u88ab\u5b8c\u6210\u4e86\u3002</p> <p>\u73b0\u5728\u6211\u4eec\u5c06\u6253\u5370\u901f\u5ea6\u8c03\u6574\u4e3a\u6bcf\u5206\u949f10\u9875\uff0c\u5e76\u518d\u6b21\u8fd0\u884c10\u6b21\u8bd5\u9a8c\u3002\u5e0c\u671b\u901a\u8fc7\u66f4\u5feb\u7684\u6253\u5370\u901f\u5ea6\uff0c\u66f4\u591a\u4efb\u52a1\u80fd\u591f\u5728\u4e00\u5c0f\u65f6\u7684\u65f6\u95f4\u6846\u67b6\u5185\u5b8c\u6210\u3002</p> <pre><code>&gt;&gt;&gt; for i in range(10):\n...     simulation(3600, 10)\n... \nAverage Wait   1.29 secs 0 tasks remaining.\nAverage Wait   7.00 secs 0 tasks remaining.\nAverage Wait  28.96 secs 1 tasks remaining.\nAverage Wait  13.55 secs 0 tasks remaining.\nAverage Wait  12.67 secs 0 tasks remaining.\nAverage Wait   6.46 secs 0 tasks remaining.\nAverage Wait  22.33 secs 0 tasks remaining.\nAverage Wait  12.39 secs 0 tasks remaining.\nAverage Wait   7.27 secs 0 tasks remaining.\nAverage Wait  18.17 secs 0 tasks remaining.\n&gt;&gt;&gt; \n</code></pre> <p>\u60a8\u53ef\u4ee5\u5728 ActiveCode 2 \u4e2d\u81ea\u5df1\u8fd0\u884c\u8fd9\u4e2a\u6a21\u62df\u3002</p> <p>To design this simulation we will create classes for the three real-world objects described above: <code>Printer</code>, <code>Task</code>, and <code>PrintQueue</code>.</p> <p>The <code>Printer</code> class (<code>Listing 2</code>) will need to track whether it has a current task. If it does, then it is busy (lines 13\u201317) and the amount of time needed can be computed from the number of pages in the task. The constructor will also allow the pages-per-minute setting to be initialized. The <code>tick</code> method decrements the internal timer and sets the printer to idle (line 11) if the task is completed.</p> Listing 2<pre><code>class Printer:\n    def __init__(self, ppm):\n        self.page_rate = ppm\n        self.current_task = None\n        self.time_remaining = 0\n\n    def tick(self):\n        if self.current_task is not None:\n            self.time_remaining = self.time_remaining - 1\n            if self.time_remaining &lt;= 0:\n                self.current_task = None\n\n    def busy(self):\n        return self.current_task is not None\n\n    def start_next(self, new_task):\n        self.current_task = new_task\n        self.time_remaining = new_task.get_pages() * 60 / self.page_rate\n</code></pre> <p>The <code>Task</code> class (<code>Listing 3</code>) will represent a single printing task. When the task is created, a random number generator will provide a length from 1 to 20 pages. We have chosen to use the <code>randrange</code> function from the <code>random</code> module.</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.randrange(1,21)\n18\n&gt;&gt;&gt; random.randrange(1,21)\n8\n&gt;&gt;&gt;\n</code></pre> <p>Each task will also need to keep a timestamp to be used for computing waiting time. This timestamp will represent the time that the task was created and placed in the printer queue. The <code>wait_time</code> method can then be used to retrieve the amount of time spent in the queue before printing begins.</p> Listing 3<pre><code>import random\n\n\nclass Task:\n    def __init__(self, time):\n        self.timestamp = time\n        self.pages = random.randrange(1, 21)\n\n    def get_stamp(self):\n        return self.timestamp\n\n    def get_pages(self):\n        return self.pages\n\n    def wait_time(self, current_time):\n        return current_time - self.timestamp\n</code></pre> <p>The main simulation (<code>Listing 4</code>) implements the algorithm described above. The <code>print_queue</code> object is an instance of our existing queue ADT. A boolean helper function, <code>new_print_task</code>, decides whether a new printing task has been created. We have again chosen to use the <code>randrange</code> function from the <code>random</code> module to return a random integer between 1 and 180. Print tasks arrive once every 180 seconds. By arbitrarily choosing 180 from the range of random integers (line 31), we can simulate this random event. The simulation function allows us to set the total time and the pages per minute for the printer.</p> Listing 4<pre><code>import random\nfrom pythonds3.basic.queue Queue\n\n\ndef simulation(num_seconds, pages_per_minute):\n    lab_printer = Printer(pages_per_minute)\n    print_queue = Queue()\n    waiting_times = []\n\n    for current_second in range(num_seconds):\n        if new_print_task():\n            task = Task(current_second)\n            print_queue.enqueue(task)\n\n        if (not lab_printer.busy()) and (not print_queue.is_empty()):\n            nexttask = print_queue.dequeue()\n            waiting_times.append(nexttask.wait_time(current_second))\n            lab_printer.start_next(nexttask)\n\n        lab_printer.tick()\n\n    average_wait = sum(waiting_times) / len(waiting_times)\n    print(\n        f\"Average Wait {average_wait:6.2f} secs\" \\\n        + f\"{print_queue.size():3d} tasks remaining.\"\n    )\n\n\ndef new_print_task():\n    num = random.randrange(1, 181)\n    return num == 180\n\n\nfor i in range(10):\n    simulation(3600, 5)\n</code></pre> <p>When we run the simulation, we should not be concerned that the results are different each time. This is due to the probabilistic nature of the random numbers. We are interested in the trends that may be occurring as the parameters to the simulation are adjusted. Here are some results.</p> <p>First, we will run the simulation for a period of 60 minutes (3,600 seconds) using a page rate of five pages per minute. In addition, we will run 10 independent trials. Remember that because the simulation works with random numbers each run will return different results.</p> <pre><code>&gt;&gt;&gt; for i in range(10):\n...     simulation(3600, 5)\n... \nAverage Wait 165.38 secs 2 tasks remaining.\nAverage Wait  95.07 secs 1 tasks remaining.\nAverage Wait  65.05 secs 2 tasks remaining.\nAverage Wait  99.74 secs 1 tasks remaining.\nAverage Wait  17.27 secs 0 tasks remaining.\nAverage Wait 239.61 secs 5 tasks remaining.\nAverage Wait  75.11 secs 1 tasks remaining.\nAverage Wait  48.33 secs 0 tasks remaining.\nAverage Wait  39.31 secs 3 tasks remaining.\nAverage Wait 376.05 secs 1 tasks remaining.\n&gt;&gt;&gt; \n</code></pre> <p>After running our 10 trials we can see that the mean average wait time is (165.38 + 95.07 + 65.05 + 99.74 + 17.27 + 239.61 + 75.11 + 48.33 + 39.31 + 376.05) / 10 = 122.09 seconds. You can also see that there is a large variation in the average wait time with a minimum average of 17.27 seconds and a maximum of 376.05 seconds. You may also notice that in only two of the cases were all the tasks completed.</p> <p>Now we will adjust the page rate to 10 pages per minute and run the 10 trials again. With a faster page rate, our hope would be that more tasks would be completed in the one-hour time frame.</p> <pre><code>&gt;&gt;&gt; for i in range(10):\n...     simulation(3600, 10)\n... \nAverage Wait   1.29 secs 0 tasks remaining.\nAverage Wait   7.00 secs 0 tasks remaining.\nAverage Wait  28.96 secs 1 tasks remaining.\nAverage Wait  13.55 secs 0 tasks remaining.\nAverage Wait  12.67 secs 0 tasks remaining.\nAverage Wait   6.46 secs 0 tasks remaining.\nAverage Wait  22.33 secs 0 tasks remaining.\nAverage Wait  12.39 secs 0 tasks remaining.\nAverage Wait   7.27 secs 0 tasks remaining.\nAverage Wait  18.17 secs 0 tasks remaining.\n&gt;&gt;&gt; \n</code></pre> <p>You can run the simulation for yourself in ActiveCode 2.</p> Activity: 3.14.2.1 Printer Queue Simulation<pre><code>import random\nfrom pythonds3.basic import Queue\n\n\nclass Printer:\n    def __init__(self, ppm):\n        self.page_rate = ppm\n        self.current_task = None\n        self.time_remaining = 0\n\n    def tick(self):\n        if self.current_task is not None:\n            self.time_remaining = self.time_remaining - 1\n            if self.time_remaining &lt;= 0:\n                self.current_task = None\n\n    def busy(self):\n        return self.current_task is not None\n\n    def start_next(self, new_task):\n        self.current_task = new_task\n        self.time_remaining = new_task.get_pages() * 60 / self.page_rate\n\n\nclass Task:\n    def __init__(self, time):\n        self.timestamp = time\n        self.pages = random.randrange(1, 21)\n\n    def get_stamp(self):\n        return self.timestamp\n\n    def get_pages(self):\n        return self.pages\n\n    def wait_time(self, current_time):\n        return current_time - self.timestamp\n\n\ndef simulation(num_seconds, pages_per_minute):\n    lab_printer = Printer(pages_per_minute)\n    print_queue = Queue()\n    waiting_times = []\n\n    for current_second in range(num_seconds):\n        if new_print_task():\n            task = Task(current_second)\n            print_queue.enqueue(task)\n\n        if (not lab_printer.busy()) and (not print_queue.is_empty()):\n            nexttask = print_queue.dequeue()\n            waiting_times.append(nexttask.wait_time(current_second))\n            lab_printer.start_next(nexttask)\n\n        lab_printer.tick()\n\n    average_wait = sum(waiting_times) / len(waiting_times)\n    print(\"Average Wait %6.2f secs %3d tasks remaining.\" % (average_wait, print_queue.size()))\n\n\ndef new_print_task():\n    num = random.randrange(1, 181)\n    return num == 180\n\n\nfor i in range(10):\n    simulation(3600, 5)\n</code></pre>"},{"location":"c3/s14/#3143-\u8ba8\u8bba","title":"3.14.3. \u8ba8\u8bba","text":"<p>3.14.3. Discussion</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u8bd5\u56fe\u56de\u7b54\u4e00\u4e2a\u95ee\u9898\uff0c\u5373\u5982\u679c\u5f53\u524d\u6253\u5370\u673a\u8bbe\u7f6e\u4e3a\u66f4\u9ad8\u8d28\u91cf\u4f46\u6253\u5370\u901f\u5ea6\u8f83\u6162\uff0c\u662f\u5426\u80fd\u5904\u7406\u4efb\u52a1\u8d1f\u8f7d\u3002\u6211\u4eec\u91c7\u53d6\u7684\u65b9\u6cd5\u662f\u7f16\u5199\u4e00\u4e2a\u6a21\u62df\u7a0b\u5e8f\uff0c\u5c06\u6253\u5370\u4efb\u52a1\u5efa\u6a21\u4e3a\u4e0d\u540c\u957f\u5ea6\u548c\u5230\u8fbe\u65f6\u95f4\u7684\u968f\u673a\u4e8b\u4ef6\u3002</p> <p>\u4e0a\u9762\u7684\u8f93\u51fa\u663e\u793a\uff0c\u5f53\u6253\u5370\u901f\u5ea6\u4e3a\u6bcf\u5206\u949f5\u9875\u65f6\uff0c\u5e73\u5747\u7b49\u5f85\u65f6\u95f4\u4ece\u6700\u4f4e17\u79d2\u5230\u6700\u9ad8376\u79d2\uff08\u7ea66\u5206\u949f\uff09\u4e0d\u7b49\u3002\u4f7f\u7528\u66f4\u5feb\u7684\u6253\u5370\u901f\u5ea6\u65f6\uff0c\u6700\u4f4e\u503c\u4e3a1\u79d2\uff0c\u6700\u9ad8\u503c\u4ec5\u4e3a28\u79d2\u3002\u6b64\u5916\uff0c\u5728\u6bcf\u5206\u949f5\u9875\u7684\u60c5\u51b5\u4e0b\uff0c10\u6b21\u8fd0\u884c\u4e2d\u76848\u6b21\u5728\u4e00\u5c0f\u65f6\u7ed3\u675f\u65f6\u4ecd\u6709\u6253\u5370\u4efb\u52a1\u5728\u961f\u5217\u4e2d\u7b49\u5f85\u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u8ba4\u4e3a\uff0c\u964d\u4f4e\u6253\u5370\u673a\u901f\u5ea6\u4ee5\u83b7\u5f97\u66f4\u9ad8\u8d28\u91cf\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\u3002\u5b66\u751f\u4eec\u4e0d\u80fd\u7b49\u5f85\u90a3\u4e48\u957f\u65f6\u95f4\u624d\u80fd\u6253\u5370\u5b8c\u4ed6\u4eec\u7684\u6587\u4ef6\uff0c\u7279\u522b\u662f\u5f53\u4ed6\u4eec\u9700\u8981\u8d76\u5f80\u4e0b\u8282\u8bfe\u65f6\u3002\u516d\u5206\u949f\u7684\u7b49\u5f85\u65f6\u95f4\u7b80\u76f4\u592a\u957f\u4e86\u3002</p> <p>\u8fd9\u79cd\u7c7b\u578b\u7684\u6a21\u62df\u5206\u6790\u53ef\u4ee5\u56de\u7b54\u8bb8\u591a\u95ee\u9898\uff0c\u901a\u5e38\u79f0\u4e3a\u201c\u5047\u8bbe\u95ee\u9898\u201d\u3002\u6211\u4eec\u53ea\u9700\u6539\u53d8\u6a21\u62df\u4e2d\u4f7f\u7528\u7684\u53c2\u6570\uff0c\u5c31\u53ef\u4ee5\u6a21\u62df\u4efb\u4f55\u6570\u91cf\u7684\u6709\u8da3\u884c\u4e3a\u3002\u4f8b\u5982\uff0c</p> <ul> <li> <p>\u5982\u679c\u5165\u5b66\u4eba\u6570\u589e\u52a0\uff0c\u5e73\u5747\u5b66\u751f\u4eba\u6570\u589e\u52a020%\u4f1a\u600e\u6837\uff1f</p> </li> <li> <p>\u5982\u679c\u662f\u5468\u516d\uff0c\u5b66\u751f\u4eec\u4e0d\u9700\u8981\u4e0a\u8bfe\uff1f\u4ed6\u4eec\u80fd\u627f\u53d7\u7b49\u5f85\u5417\uff1f</p> </li> <li> <p>\u5982\u679c\u5e73\u5747\u6253\u5370\u4efb\u52a1\u7684\u5927\u5c0f\u51cf\u5c11\uff0c\u56e0\u4e3aPython\u662f\u4e00\u79cd\u5f3a\u5927\u7684\u8bed\u8a00\uff0c\u7a0b\u5e8f\u901a\u5e38\u8f83\u77ed\u5462\uff1f</p> </li> </ul> <p>\u8fd9\u4e9b\u95ee\u9898\u90fd\u53ef\u4ee5\u901a\u8fc7\u4fee\u6539\u4e0a\u8ff0\u6a21\u62df\u6765\u56de\u7b54\u3002\u7136\u800c\uff0c\u91cd\u8981\u7684\u662f\u8981\u8bb0\u4f4f\uff0c\u6a21\u62df\u7684\u6548\u679c\u4ec5\u53d6\u51b3\u4e8e\u7528\u4e8e\u6784\u5efa\u5b83\u7684\u5047\u8bbe\u3002\u6709\u5173\u6bcf\u5c0f\u65f6\u6253\u5370\u4efb\u52a1\u6570\u91cf\u548c\u6bcf\u5c0f\u65f6\u5b66\u751f\u6570\u91cf\u7684\u771f\u5b9e\u6570\u636e\u5bf9\u4e8e\u6784\u5efa\u4e00\u4e2a\u7a33\u5065\u7684\u6a21\u62df\u662f\u5fc5\u8981\u7684\u3002</p> <p>\u81ea\u6211\u68c0\u67e5</p> <p>\u4f60\u4f1a\u5982\u4f55\u4fee\u6539\u6253\u5370\u673a\u6a21\u62df\u4ee5\u53cd\u6620\u66f4\u591a\u7684\u5b66\u751f\uff1f\u5047\u8bbe\u5b66\u751f\u4eba\u6570\u7ffb\u4e86\u4e00\u756a\u3002\u4f60\u53ef\u80fd\u9700\u8981\u5bf9\u8fd9\u4e2a\u6a21\u62df\u662f\u5982\u4f55\u6784\u5efa\u7684\u505a\u4e00\u4e9b\u5408\u7406\u7684\u5047\u8bbe\uff0c\u4f46\u4f60\u4f1a\u6539\u53d8\u4ec0\u4e48\uff1f\u4fee\u6539\u4ee3\u7801\u3002\u540c\u65f6\u5047\u8bbe\u5e73\u5747\u6253\u5370\u4efb\u52a1\u7684\u957f\u5ea6\u51cf\u5c11\u4e86\u4e00\u534a\u3002\u66f4\u6539\u4ee3\u7801\u4ee5\u53cd\u6620\u8fd9\u4e00\u53d8\u5316\u3002\u6700\u540e\uff0c\u5982\u4f55\u5c06\u5b66\u751f\u4eba\u6570\u53c2\u6570\u5316\uff0c\u800c\u4e0d\u662f\u6539\u53d8\u4ee3\u7801\uff0c\u6211\u4eec\u5e0c\u671b\u5c06\u5b66\u751f\u4eba\u6570\u4f5c\u4e3a\u6a21\u62df\u7684\u53c2\u6570\u3002</p> Activity: 3.14.3.1 ActiveCode<pre><code>import random\nfrom pythonds3.basic import Queue\n\n\nclass Printer:\n    def __init__(self, ppm):\n        self.page_rate = ppm\n        self.current_task = None\n        self.time_remaining = 0\n\n    def tick(self):\n        if self.current_task is not None:\n            self.time_remaining = self.time_remaining - 1\n            if self.time_remaining &lt;= 0:\n                self.current_task = None\n\n    def busy(self):\n        return self.current_task is not None\n\n    def start_next(self, new_task):\n        self.current_task = new_task\n        self.time_remaining = new_task.get_pages() * 60 / self.page_rate\n\n\nclass Task:\n    def __init__(self, time):\n        self.timestamp = time\n        self.pages = random.randrange(1, 21)\n\n    def get_stamp(self):\n        return self.timestamp\n\n    def get_pages(self):\n        return self.pages\n\n    def wait_time(self, current_time):\n        return current_time - self.timestamp\n\n\ndef simulation(num_seconds, pages_per_minute, num_students):\n    lab_printer = Printer(pages_per_minute)\n    print_queue = Queue()\n    waiting_times = []\n\n    for current_second in range(num_seconds):\n        if new_print_task(num_students):\n            task = Task(current_second)\n            print_queue.enqueue(task)\n\n        if (not lab_printer.busy()) and (not print_queue.is_empty()):\n            nexttask = print_queue.dequeue()\n            waiting_times.append(nexttask.wait_time(current_second))\n            lab_printer.start_next(nexttask)\n\n        lab_printer.tick()\n\n    average_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0\n    print(\"Average Wait %6.2f secs %3d tasks remaining.\" % (average_wait, print_queue.size()))\n\n\ndef new_print_task(num_students):\n    num = random.randrange(1, 181)\n    return num == 180 / num_students\n\n\nfor i in range(10):\n    simulation(3600, 5, 2)  # Example with doubled number of students\n</code></pre> <p>We were trying to answer a question about whether the current printer could handle the task load if it were set to print with a better quality but slower page rate. The approach we took was to write a simulation that modeled the printing tasks as random events of various lengths and arrival times.</p> <p>The output above shows that with 5 pages per minute printing, the average waiting time varied from a low of 17 seconds to a high of 376 seconds (about 6 minutes). With a faster printing rate, the low value was 1 second with a high of only 28. In addition, in 8 out of 10 runs at 5 pages per minute there were print tasks still waiting in the queue at the end of the hour.</p> <p>Therefore, we are perhaps persuaded that slowing the printer down to get better quality may not be a good idea. Students cannot afford to wait that long for their papers, especially when they need to be getting on to their next class. A six-minute wait would simply be too long.</p> <p>This type of simulation analysis allows us to answer many questions, commonly known as what-if questions. All we need to do is vary the parameters used by the simulation and we can simulate any number of interesting behaviors. For example,</p> <ul> <li> <p>What if enrollment goes up and the average number of students increases by 20?</p> </li> <li> <p>What if it is Saturday and students do not need to get to class? Can they afford to wait?</p> </li> <li> <p>What if the size of the average print task decreases since Python is such a powerful language and programs tend to be much shorter?</p> </li> </ul> <p>These questions could all be answered by modifying the above simulation. However, it is important to remember that the simulation is only as good as the assumptions that are used to build it. Real data about the number of print tasks per hour and the number of students per hour was necessary to construct a robust simulation.</p> <p>Self Check</p> <p>How would you modify the printer simulation to reflect a larger number of students?  Suppose that the number of students was doubled.  You make need to make some reasonable assumptions about how this simulation was put together but what would you change?  Modify the code.  Also suppose that the length of the average print task was cut in half.  Change the code to reflect that change.  Finally How would you parametertize the number of students, rather than changing the code we would like to make the number of students a parameter of the simulation.</p> Activity: 3.14.3.1 ActiveCode<pre><code>import random\nfrom pythonds3.basic import Queue\n\n\nclass Printer:\n    def __init__(self, ppm):\n        self.page_rate = ppm\n        self.current_task = None\n        self.time_remaining = 0\n\n    def tick(self):\n        if self.current_task is not None:\n            self.time_remaining = self.time_remaining - 1\n            if self.time_remaining &lt;= 0:\n                self.current_task = None\n\n    def busy(self):\n        return self.current_task is not None\n\n    def start_next(self, new_task):\n        self.current_task = new_task\n        self.time_remaining = new_task.get_pages() * 60 / self.page_rate\n\n\nclass Task:\n    def __init__(self, time):\n        self.timestamp = time\n        self.pages = random.randrange(1, 21)\n\n    def get_stamp(self):\n        return self.timestamp\n\n    def get_pages(self):\n        return self.pages\n\n    def wait_time(self, current_time):\n        return current_time - self.timestamp\n\n\ndef simulation(num_seconds, pages_per_minute):\n    lab_printer = Printer(pages_per_minute)\n    print_queue = Queue()\n    waiting_times = []\n\n    for current_second in range(num_seconds):\n        if new_print_task():\n            task = Task(current_second)\n            print_queue.enqueue(task)\n\n        if (not lab_printer.busy()) and (not print_queue.is_empty()):\n            nexttask = print_queue.dequeue()\n            waiting_times.append(nexttask.wait_time(current_second))\n            lab_printer.start_next(nexttask)\n\n        lab_printer.tick()\n\n    average_wait = sum(waiting_times) / len(waiting_times)\n    print(\"Average Wait %6.2f secs %3d tasks remaining.\" % (average_wait, print_queue.size()))\n\n\ndef new_print_task():\n    num = random.randrange(1, 181)\n    return num == 180\n\n\nfor i in range(10):\n    simulation(3600, 5)\n</code></pre>"},{"location":"c3/s15/","title":"3.15. \u53cc\u7aef\u961f\u5217","text":"<p>3.15. Deques</p> \u4e2d\u6587\u82f1\u6587 <p>\u53cc\u7aef\u961f\u5217\uff08deque\uff09\uff0c\u5373\u53cc\u7aef\u961f\u5217\uff0c\u662f\u4e00\u79cd\u7c7b\u4f3c\u4e8e\u961f\u5217\u7684\u6709\u5e8f\u96c6\u5408\u3002\u5b83\u6709\u4e24\u4e2a\u7aef\u70b9\uff1a\u524d\u7aef\u548c\u540e\u7aef\uff0c\u9879\u5728\u96c6\u5408\u4e2d\u4fdd\u6301\u6709\u5e8f\u3002\u4e0e\u961f\u5217\u4e0d\u540c\u7684\u662f\uff0c\u53cc\u7aef\u961f\u5217\u5728\u6dfb\u52a0\u548c\u79fb\u9664\u9879\u65f6\u6ca1\u6709\u9650\u5236\u3002\u65b0\u9879\u53ef\u4ee5\u6dfb\u52a0\u5230\u524d\u7aef\u6216\u540e\u7aef\uff0c\u540c\u6837\uff0c\u73b0\u6709\u9879\u4e5f\u53ef\u4ee5\u4ece\u4efb\u4f55\u4e00\u7aef\u79fb\u9664\u3002\u4ece\u67d0\u79cd\u610f\u4e49\u4e0a\u8bf4\uff0c\u8fd9\u79cd\u6df7\u5408\u7ebf\u6027\u7ed3\u6784\u5728\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u4e2d\u63d0\u4f9b\u4e86\u6808\u548c\u961f\u5217\u7684\u6240\u6709\u529f\u80fd\u3002<code>\u56fe1</code> \u663e\u793a\u4e86\u4e00\u4e2a Python \u6570\u636e\u5bf9\u8c61\u7684\u53cc\u7aef\u961f\u5217\u3002</p> <p>\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5c3d\u7ba1\u53cc\u7aef\u961f\u5217\u53ef\u4ee5\u5177\u6709\u6808\u548c\u961f\u5217\u7684\u8bb8\u591a\u7279\u6027\uff0c\u4f46\u5b83\u4e0d\u8981\u6c42\u50cf\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u90a3\u6837\u5f3a\u5236\u6267\u884c LIFO\uff08\u540e\u8fdb\u5148\u51fa\uff09\u548c FIFO\uff08\u5148\u8fdb\u5148\u51fa\uff09\u987a\u5e8f\u3002\u4f60\u9700\u8981\u6839\u636e\u9700\u8981\u4e00\u81f4\u5730\u4f7f\u7528\u6dfb\u52a0\u548c\u79fb\u9664\u64cd\u4f5c\u3002</p> <p> Figure 1: A Deque of Python Data Objects </p> <p>A deque, also known as a double-ended queue, is an ordered collection of items similar to the queue. It has two ends, a front and a rear, and the items remain positioned in the collection. What makes a deque different is the unrestrictive nature of adding and removing items. New items can be added at either the front or the rear. Likewise, existing items can be removed from either end. In a sense, this hybrid linear structure provides all the capabilities of stacks and queues in a single data structure. <code>Figure 1</code> shows a deque of Python data objects.</p> <p>It is important to note that even though the deque can assume many of the characteristics of stacks and queues, it does not require the LIFO and FIFO orderings that are enforced by those data structures. It is up to you to make consistent use of the addition and removal operations.</p> <p> Figure 1: A Deque of Python Data Objects </p>"},{"location":"c3/s16/","title":"3.16. \u53cc\u7aef\u961f\u5217\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>3.16. The Deque Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>\u53cc\u7aef\u961f\u5217\uff08deque\uff09\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7684\u7ed3\u6784\u548c\u64cd\u4f5c\u5b9a\u4e49\u5982\u4e0b\u3002\u53cc\u7aef\u961f\u5217\u5982\u4e0a\u6240\u8ff0\uff0c\u662f\u4e00\u4e2a\u6709\u5e8f\u9879\u7684\u96c6\u5408\uff0c\u9879\u53ef\u4ee5\u4ece\u524d\u7aef\u6216\u540e\u7aef\u6dfb\u52a0\u548c\u79fb\u9664\u3002\u53cc\u7aef\u961f\u5217\u7684\u64cd\u4f5c\u5982\u4e0b\u6240\u793a\uff1a</p> <ul> <li> <p><code>Deque()</code> \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7a7a\u53cc\u7aef\u961f\u5217\u3002\u6b64\u64cd\u4f5c\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7684\u53cc\u7aef\u961f\u5217\u3002</p> </li> <li> <p><code>add_front(item)</code> \u5c06\u65b0\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u3002\u6b64\u64cd\u4f5c\u9700\u8981\u9879\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u4e14\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c\u3002</p> </li> <li> <p><code>add_rear(item)</code> \u5c06\u65b0\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u3002\u6b64\u64cd\u4f5c\u9700\u8981\u9879\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u4e14\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c\u3002</p> </li> <li> <p><code>remove_front()</code> \u4ece\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\u3002\u6b64\u64cd\u4f5c\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u88ab\u79fb\u9664\u7684\u9879\u3002\u53cc\u7aef\u961f\u5217\u4f1a\u88ab\u4fee\u6539\u3002</p> </li> <li> <p><code>remove_rear()</code> \u4ece\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\u3002\u6b64\u64cd\u4f5c\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u88ab\u79fb\u9664\u7684\u9879\u3002\u53cc\u7aef\u961f\u5217\u4f1a\u88ab\u4fee\u6539\u3002</p> </li> <li> <p><code>is_empty()</code> \u6d4b\u8bd5\u53cc\u7aef\u961f\u5217\u662f\u5426\u4e3a\u7a7a\u3002\u6b64\u64cd\u4f5c\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>size()</code> \u8fd4\u56de\u53cc\u7aef\u961f\u5217\u4e2d\u9879\u7684\u6570\u91cf\u3002\u6b64\u64cd\u4f5c\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u3002</p> </li> </ul> <p>\u4f8b\u5982\uff0c\u5982\u679c\u5047\u8bbe <code>d</code> \u662f\u4e00\u4e2a\u5df2\u7ecf\u521b\u5efa\u5e76\u4e14\u5f53\u524d\u4e3a\u7a7a\u7684\u53cc\u7aef\u961f\u5217\uff0c\u90a3\u4e48 <code>\u88686</code> \u663e\u793a\u4e86\u4e00\u7cfb\u5217\u53cc\u7aef\u961f\u5217\u64cd\u4f5c\u7684\u7ed3\u679c\u3002\u6ce8\u610f\uff0c\u524d\u7aef\u7684\u5185\u5bb9\u5217\u5728\u53f3\u4fa7\u3002\u8ddf\u8e2a\u524d\u7aef\u548c\u540e\u7aef\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5728\u5f80\u53cc\u7aef\u961f\u5217\u4e2d\u6dfb\u52a0\u548c\u79fb\u9664\u9879\u65f6\uff0c\u60c5\u51b5\u53ef\u80fd\u4f1a\u53d8\u5f97\u6709\u4e9b\u6df7\u4e71\u3002</p> <p>\u88686\uff1a\u53cc\u7aef\u961f\u5217\u64cd\u4f5c\u793a\u4f8b</p> \u53cc\u7aef\u961f\u5217\u64cd\u4f5c \u53cc\u7aef\u961f\u5217\u5185\u5bb9 \u8fd4\u56de\u503c <code>d.is_empty()</code> <code>[]</code> <code>True</code> <code>d.add_rear(4)</code> <code>[4]</code> <code>d.add_rear(\"dog\")</code> <code>['dog', 4]</code> <code>d.add_front(\"cat\")</code> <code>['dog', 4, 'cat']</code> <code>d.add_front(True)</code> <code>['dog', 4, 'cat', True]</code> <code>d.size()</code> <code>['dog', 4, 'cat', True]</code> <code>4</code> <code>d.is_empty()</code> <code>['dog', 4, 'cat', True]</code> <code>False</code> <code>d.add_rear(8.4)</code> <code>[8.4, 'dog', 4, 'cat', True]</code> <code>d.remove_rear()</code> <code>['dog', 4, 'cat', True]</code> <code>8.4</code> <code>d.remove_front()</code> <code>['dog', 4, 'cat']</code> <code>True</code> <p>The deque abstract data type is defined by the following structure and operations. A deque is structured, as described above, as an ordered collection of items where items are added and removed from either end, either front or rear. The deque operations are given below.</p> <ul> <li> <p><code>Deque()</code> creates a new deque that is empty. It needs no parameters and returns an empty deque.</p> </li> <li> <p><code>add_front(item)</code> adds a new item to the front of the deque. It needs the item and returns nothing.</p> </li> <li> <p><code>add_rear(item)</code> adds a new item to the rear of the deque. It needs the item and returns nothing.</p> </li> <li> <p><code>remove_front()</code> removes the front item from the deque. It needs no parameters and returns the item. The deque is modified.</p> </li> <li> <p><code>remove_rear()</code> removes the rear item from the deque. It needs no parameters and returns the item. The deque is modified.</p> </li> <li> <p><code>is_empty()</code> tests to see whether the deque is empty. It needs no parameters and returns a boolean value.</p> </li> <li> <p><code>size()</code> returns the number of items in the deque. It needs no parameters and returns an integer.</p> </li> </ul> <p>As an example, if we assume that <code>d</code> is a deque that has been created and is currently empty, then <code>Table 6</code> shows the results of a sequence of deque operations. Note that the contents in front are listed on the right. It is very important to keep track of the front and the rear as you move items in and out of the collection as things can get a bit confusing.</p> <p>Table 6: Examples of Deque Operations</p> Deque Operation Deque Contents Return Value <code>d.is_empty()</code> <code>[]</code> <code>True</code> <code>d.add_rear(4)</code> <code>[4]</code> <code>d.add_rear(\"dog\")</code> <code>['dog', 4]</code> <code>d.add_front(\"cat\")</code> <code>['dog', 4, 'cat']</code> <code>d.add_front(True)</code> <code>['dog', 4, 'cat', True]</code> <code>d.size()</code> <code>['dog', 4, 'cat', True]</code> <code>4</code> <code>d.is_empty()</code> <code>['dog', 4, 'cat', True]</code> <code>False</code> <code>d.add_rear(8.4)</code> <code>[8.4,'dog', 4, 'cat', True]</code> <code>d.remove_rear()</code> <code>['dog', 4, 'cat', True]</code> <code>8.4</code> <code>d.remove_front()</code> <code>['dog', 4, 'cat']</code> <code>True</code>"},{"location":"c3/s17/","title":"3.17. \u7528Python\u5b9e\u73b0\u53cc\u7aef\u961f\u5217","text":"<p>3.17. Implementing a Deque in Python</p> \u4e2d\u6587\u82f1\u6587 <p>\u6b63\u5982\u6211\u4eec\u5728\u4e4b\u524d\u7684\u7ae0\u8282\u4e2d\u6240\u505a\u7684\uff0c\u6211\u4eec\u5c06\u4e3a\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u53cc\u7aef\u961f\u5217\uff08deque\uff09\u7684\u5b9e\u73b0\u521b\u5efa\u4e00\u4e2a\u65b0\u7c7b\u3002\u518d\u6b21\u4f7f\u7528 Python \u5217\u8868\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u5176\u63d0\u4f9b\u7684\u4e30\u5bcc\u65b9\u6cd5\u6765\u6784\u5efa\u53cc\u7aef\u961f\u5217\u7684\u7ec6\u8282\u3002\u6211\u4eec\u7684\u5b9e\u73b0\uff08<code>Listing 1</code>\uff09\u5c06\u5047\u8bbe\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u5728\u5217\u8868\u7684\u7b2c 0 \u4e2a\u4f4d\u7f6e\u3002</p> Listing 1<pre><code>class Deque:\n    \"\"\"\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u53cc\u7aef\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53cc\u7aef\u961f\u5217\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"\u68c0\u67e5\u53cc\u7aef\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"\u4ece\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"\u4ece\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"\u83b7\u53d6\u53cc\u7aef\u961f\u5217\u4e2d\u7684\u9879\u6570\"\"\"\n        return len(self._items)\n</code></pre> <p>\u5728 <code>remove_front</code> \u65b9\u6cd5\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 <code>pop</code> \u65b9\u6cd5\u4ece\u5217\u8868\u4e2d\u79fb\u9664\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002\u7136\u800c\uff0c\u5728 <code>remove_rear</code> \u65b9\u6cd5\u4e2d\uff0c<code>pop(0)</code> \u65b9\u6cd5\u5fc5\u987b\u79fb\u9664\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u3002\u540c\u6837\uff0c\u5728 <code>add_rear</code> \u65b9\u6cd5\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 <code>insert</code> \u65b9\u6cd5\uff08\u7b2c 12 \u884c\uff09\uff0c\u56e0\u4e3a <code>append</code> \u65b9\u6cd5\u5047\u8bbe\u5c06\u65b0\u5143\u7d20\u6dfb\u52a0\u5230\u5217\u8868\u7684\u672b\u5c3e\u3002</p> <p><code>CodeLens 1</code> \u5c55\u793a\u4e86 <code>Deque</code> \u7c7b\u7684\u5b9e\u9645\u64cd\u4f5c\uff0c\u6309\u7167 <code>\u8868 1</code> \u4e2d\u7684\u64cd\u4f5c\u5e8f\u5217\u6267\u884c\u3002</p> Activity: CodeLens Example Deque Operations (deqtest)<pre><code>class Deque:\n    \"\"\"\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u53cc\u7aef\u961f\u5217\"\"\"\n\n    def __init__(self):\n        \"\"\"\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53cc\u7aef\u961f\u5217\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"\u68c0\u67e5\u53cc\u7aef\u961f\u5217\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"\u5c06\u4e00\u4e2a\u9879\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"\u4ece\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"\u4ece\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u79fb\u9664\u4e00\u4e2a\u9879\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"\u83b7\u53d6\u53cc\u7aef\u961f\u5217\u4e2d\u7684\u9879\u6570\"\"\"\n        return len(self._items)\n\nd = Deque()\nprint(d.is_empty())\nd.add_rear(4)\nd.add_rear('dog')\nd.add_front('cat')\nd.add_front(True)\nprint(d.size())\nprint(d.is_empty())\nd.add_rear(8.4)\nprint(d.remove_rear())\nprint(d.remove_front())\n</code></pre> <p>\u4f60\u53ef\u4ee5\u770b\u5230\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u4e0e\u4e4b\u524d\u63cf\u8ff0\u7684\u6808\u548c\u961f\u5217\u7684 Python \u4ee3\u7801\u6709\u5f88\u591a\u76f8\u4f3c\u4e4b\u5904\u3002\u4f60\u8fd8\u4f1a\u53d1\u73b0\uff0c\u5728\u8fd9\u4e2a\u5b9e\u73b0\u4e2d\uff0c\u4ece\u524d\u7aef\u6dfb\u52a0\u548c\u79fb\u9664\u9879\u7684\u64cd\u4f5c\u662f \\(O(1)\\)\uff0c\u800c\u4ece\u540e\u7aef\u6dfb\u52a0\u548c\u79fb\u9664\u9879\u7684\u64cd\u4f5c\u662f \\(O(n)\\)\u3002\u8fd9\u7b26\u5408\u5e38\u89c1\u7684\u64cd\u4f5c\u590d\u6742\u5ea6\u3002\u518d\u6b21\u5f3a\u8c03\uff0c\u4e86\u89e3\u5728\u5b9e\u73b0\u4e2d\u524d\u7aef\u548c\u540e\u7aef\u7684\u4f4d\u7f6e\u975e\u5e38\u91cd\u8981\u3002</p> <p>As we have done in previous sections, we will create a new class for the implementation of the abstract data type deque. Again, the Python list will provide a very nice set of methods upon which to build the details of the deque. Our implementation (<code>Listing 1</code>) will assume that the rear of the deque is at position 0 in the list.</p> Listing 1<pre><code>class Deque:\n    \"\"\"Deque implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new deque\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"Remove an item from the front of the deque\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"Remove an item from the rear of the deque\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"Get the number of items in the deque\"\"\"\n        return len(self._items)\n</code></pre> <p>In <code>remove_front</code> we use the <code>pop</code> method to remove the last element from the list. However, in <code>remove_rear</code>, the <code>pop(0)</code> method must remove the first element of the list. Likewise, we need to use the <code>insert</code> method (line 12) in <code>add_rear</code> since the <code>append</code> method assumes the addition of a new element to the end of the list.</p> <p>CodeLens 1 shows the <code>Deque</code> class in action as we perform the sequence of operations from <code>Table 1</code>.</p> Activity: CodeLens Example Deque Operations (deqtest)<pre><code>class Deque:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new deque\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"Remove an item from the front of the deque\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"Remove an item from the rear of the deque\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"Get the number of items in the deque\"\"\"\n        return len(self._items)\n\nd=Deque()\nprint(d.is_empty())\nd.add_rear(4)\nd.add_rear('dog')\nd.add_front('cat')\nd.add_front(True)\nprint(d.size())\nprint(d.is_empty())\nd.add_rear(8.4)\nprint(d.remove_rear())\nprint(d.remove_front())\n</code></pre> <p>You can see many similarities to Python code already described for stacks and queues. You are also likely to observe that in this implementation adding and removing items from the front is \\(O(1)\\) whereas adding and removing from the rear is \\(O(n)\\). This is to be expected given the common operations that appear for adding and removing items. Again, the important thing is to be certain that we know where the front and rear are assigned in the implementation.</p>"},{"location":"c3/s18/","title":"3.18. \u56de\u6587\u68c0\u6d4b\u5668","text":"<p>3.18. Palindrome Checker</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e00\u4e2a\u6709\u8da3\u7684\u95ee\u9898\u662f\u4f7f\u7528\u53cc\u7aef\u961f\u5217\uff08deque\uff09\u6570\u636e\u7ed3\u6784\u6765\u89e3\u51b3\u7ecf\u5178\u7684\u56de\u6587\u95ee\u9898\u3002\u56de\u6587\u662f\u6307\u4e00\u4e2a\u5b57\u7b26\u4e32\u4ece\u524d\u5411\u540e\u8bfb\u548c\u4ece\u540e\u5411\u524d\u8bfb\u90fd\u76f8\u540c\uff0c\u4f8b\u5982 radar\u3001toot \u548c madam\u3002\u6211\u4eec\u60f3\u6784\u9020\u4e00\u4e2a\u7b97\u6cd5\u6765\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u5b57\u7b26\u4e32\uff0c\u5e76\u68c0\u67e5\u5b83\u662f\u5426\u662f\u56de\u6587\u3002</p> <p>\u8fd9\u4e2a\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u5c06\u4f7f\u7528\u53cc\u7aef\u961f\u5217\u6765\u5b58\u50a8\u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u3002\u6211\u4eec\u5c06\u4ece\u5de6\u5230\u53f3\u5904\u7406\u5b57\u7b26\u4e32\uff0c\u5e76\u5c06\u6bcf\u4e2a\u5b57\u7b26\u6dfb\u52a0\u5230\u53cc\u7aef\u961f\u5217\u7684\u540e\u7aef\u3002\u6b64\u65f6\uff0c\u53cc\u7aef\u961f\u5217\u5c06\u7c7b\u4f3c\u4e8e\u4e00\u4e2a\u666e\u901a\u7684\u961f\u5217\u3002\u7136\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u53cc\u7aef\u961f\u5217\u7684\u53cc\u91cd\u529f\u80fd\u3002\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u5c06\u4fdd\u5b58\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c\u540e\u7aef\u5c06\u4fdd\u5b58\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff08\u89c1 <code>Figure 2</code>\uff09\u3002</p> <p> Figure 2: \u53cc\u7aef\u961f\u5217 </p> <p>\u7531\u4e8e\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4ece\u53cc\u7aef\u961f\u5217\u7684\u524d\u7aef\u548c\u540e\u7aef\u79fb\u9664\u5b57\u7b26\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5b83\u4eec\u8fdb\u884c\u6bd4\u8f83\uff0c\u5e76\u4ec5\u5728\u5b83\u4eec\u5339\u914d\u65f6\u7ee7\u7eed\u3002\u5982\u679c\u6211\u4eec\u80fd\u591f\u6301\u7eed\u5339\u914d\u9996\u5c3e\u5b57\u7b26\uff0c\u6700\u7ec8\u8981\u4e48\u4f1a\u8017\u5c3d\u5b57\u7b26\uff0c\u8981\u4e48\u4f1a\u5269\u4e0b\u4e00\u4e2a\u5927\u5c0f\u4e3a 1 \u7684\u53cc\u7aef\u961f\u5217\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u539f\u59cb\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u662f\u5076\u6570\u8fd8\u662f\u5947\u6570\u3002\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u5b57\u7b26\u4e32\u5fc5\u987b\u662f\u56de\u6587\u3002\u5b8c\u6574\u7684\u56de\u6587\u68c0\u67e5\u51fd\u6570\u5982\u4e0b <code>ActiveCode 1</code>\u3002</p> Activity: 3.18.1 A Palindrome Checker Using Deque<pre><code>from pythonds3.basic import Deque\n\n\ndef pal_checker(a_string):\n    char_deque = Deque()\n\n    for ch in a_string:\n        char_deque.add_rear(ch)\n\n    while char_deque.size() &gt; 1:\n        first = char_deque.remove_front()\n        last = char_deque.remove_rear()\n        if first != last:\n            return False\n\n    return True\n\nprint(pal_checker(\"lsdkjfskf\"))\nprint(pal_checker(\"radar\"))\n</code></pre> <p>An interesting problem that can be easily solved using the deque data structure is the classic palindrome problem. A palindrome is a string that reads the same forward and backward, for example, radar, toot, and madam. We would like to construct an algorithm to input a string of characters and check whether it is a palindrome.</p> <p>The solution to this problem will use a deque to store the characters of the string. We will process the string from left to right and add each character to the rear of the deque. At this point, the deque will be acting very much like an ordinary queue. However, we can now make use of the dual functionality of the deque. The front of the deque will hold the first character of the string and the rear of the deque will hold the last character (see <code>Figure 2</code>).</p> <p> Figure 2: A Deque </p> <p>Since we can remove both of the front and rear characters directly, we can compare them and continue only if they match. If we can keep matching first and the last items, we will eventually either run out of characters or be left with a deque of size 1 depending on whether the length of the original string was even or odd. In either case, the string must be a palindrome. The complete function for palindrome-checking appears in <code>ActiveCode 1</code>.</p> Activity: 3.18.1 A Palindrome Checker Using Deque<pre><code>from pythonds3.basic import Deque\n\n\ndef pal_checker(a_string):\n    char_deque = Deque()\n\n    for ch in a_string:\n        char_deque.add_rear(ch)\n\n    while char_deque.size() &gt; 1:\n        first = char_deque.remove_front()\n        last = char_deque.remove_rear()\n        if first != last:\n            return False\n\n    return True\n\nprint(pal_checker(\"lsdkjfskf\"))\nprint(pal_checker(\"radar\"))\n</code></pre>"},{"location":"c3/s19/","title":"3.19. \u5217\u8868","text":"<p>3.19. Lists</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u57fa\u672c\u6570\u636e\u7ed3\u6784\u7684\u8ba8\u8bba\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 Python \u5217\u8868\u6765\u5b9e\u73b0\u6240\u4ecb\u7ecd\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u3002\u5217\u8868\u662f\u4e00\u79cd\u5f3a\u5927\u800c\u7b80\u5355\u7684\u96c6\u5408\u673a\u5236\uff0c\u5b83\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u591a\u79cd\u64cd\u4f5c\u3002\u7136\u800c\uff0c\u5e76\u4e0d\u662f\u6240\u6709\u7f16\u7a0b\u8bed\u8a00\u90fd\u5305\u542b\u5217\u8868\u96c6\u5408\u3002\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5217\u8868\u7684\u6982\u5ff5\u5fc5\u987b\u7531\u7a0b\u5e8f\u5458\u5b9e\u73b0\u3002</p> <p>\u5217\u8868 \u662f\u4e00\u7ec4\u9879\u76ee\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u6bcf\u4e2a\u9879\u76ee\u76f8\u5bf9\u4e8e\u5176\u4ed6\u9879\u76ee\u5177\u6709\u76f8\u5bf9\u4f4d\u7f6e\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u6211\u4eec\u5c06\u8fd9\u79cd\u7c7b\u578b\u7684\u5217\u8868\u79f0\u4e3a \u65e0\u5e8f\u5217\u8868\u3002\u6211\u4eec\u53ef\u4ee5\u5c06\u5217\u8868\u89c6\u4e3a\u5177\u6709\u7b2c\u4e00\u4e2a\u9879\u76ee\u3001\u7b2c\u4e8c\u4e2a\u9879\u76ee\u3001\u7b2c\u4e09\u4e2a\u9879\u76ee\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u53c2\u8003\u5217\u8868\u7684\u5f00\u59cb\uff08\u7b2c\u4e00\u4e2a\u9879\u76ee\uff09\u6216\u7ed3\u675f\uff08\u6700\u540e\u4e00\u4e2a\u9879\u76ee\uff09\u3002\u4e3a\u4e86\u7b80\u5316\u8d77\u89c1\uff0c\u6211\u4eec\u5c06\u5047\u8bbe\u5217\u8868\u4e0d\u80fd\u5305\u542b\u91cd\u590d\u9879\u76ee\u3002</p> <p>\u4f8b\u5982\uff0c\u6574\u6570\u96c6\u5408 54\u300126\u300193\u300117\u300177 \u548c 31 \u53ef\u80fd\u4ee3\u8868\u4e00\u4e2a\u7b80\u5355\u7684\u65e0\u5e8f\u8003\u8bd5\u6210\u7ee9\u5217\u8868\u3002\u6ce8\u610f\uff0c\u6211\u4eec\u5c06\u5b83\u4eec\u5199\u6210\u7528\u9017\u53f7\u5206\u9694\u7684\u503c\uff0c\u8fd9\u662f\u4e00\u79cd\u5e38\u89c1\u7684\u663e\u793a\u5217\u8868\u7ed3\u6784\u7684\u65b9\u5f0f\u3002\u5f53\u7136\uff0cPython \u4f1a\u5c06\u6b64\u5217\u8868\u663e\u793a\u4e3a <code>[54, 26, 93, 17, 77, 31]</code>\u3002</p> <p>Throughout the discussion of basic data structures, we have used Python lists to implement the abstract data types presented. The list is a powerful, yet simple collection mechanism that provides the programmer with a wide variety of operations. However, not all programming languages include a list collection. In these cases, the notion of a list must be implemented by the programmer.</p> <p>A list is a collection of items where each item holds a relative position with respect to the others. More specifically, we will refer to this type of list as an unordered list. We can consider the list as having a first item, a second item, a third item, and so on. We can also refer to the beginning of the list (the first item) or the end of the list (the last item). For simplicity we will assume that lists cannot contain duplicate items.</p> <p>For example, the collection of integers 54, 26, 93, 17, 77, and 31 might represent a simple unordered list of exam scores. Note that we have written them as comma-delimited values, a common way of showing the list structure. Of course, Python would show this list as <code>[54, 26, 93, 17, 77, 31]</code>.</p>"},{"location":"c3/s2/","title":"3.2. \u4ec0\u4e48\u662f\u7ebf\u6027\u7ed3\u6784\uff1f","text":"<p>3.2. What Are Linear Structures?</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5c06\u4ece\u7814\u7a76\u56db\u4e2a\u7b80\u5355\u4f46\u975e\u5e38\u5f3a\u5927\u7684\u6982\u5ff5\u5f00\u59cb\uff1a\u6808\u3001\u961f\u5217\u3001\u53cc\u7aef\u961f\u5217\u548c\u5217\u8868\u3002\u8fd9\u4e9b\u662f\u6570\u636e\u96c6\u5408\u7684\u793a\u4f8b\uff0c\u5176\u9879\u7684\u987a\u5e8f\u53d6\u51b3\u4e8e\u5b83\u4eec\u7684\u6dfb\u52a0\u6216\u79fb\u9664\u65b9\u5f0f\u3002\u4e00\u65e6\u4e00\u4e2a\u9879\u88ab\u6dfb\u52a0\uff0c\u5b83\u5c06\u4fdd\u6301\u76f8\u5bf9\u4e8e\u5176\u4ed6\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u5143\u7d20\u7684\u4f4d\u7f6e\u3002\u8fd9\u4e9b\u96c6\u5408\u901a\u5e38\u88ab\u79f0\u4e3a\u7ebf\u6027\u6570\u636e\u7ed3\u6784\u3002</p> <p>\u7ebf\u6027\u7ed3\u6784\u53ef\u4ee5\u88ab\u770b\u4f5c\u6709\u4e24\u4e2a\u7aef\u70b9\u3002\u6709\u65f6\u8fd9\u4e9b\u7aef\u70b9\u88ab\u79f0\u4e3a\u5de6\u548c\u53f3\uff0c\u6216\u8005\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u662f\u524d\u548c\u540e\u3002\u4f60\u4e5f\u53ef\u4ee5\u79f0\u5b83\u4eec\u4e3a\u201c\u9876\u90e8\u201d\u548c\u5e95\u90e8\u3002\u8fd9\u4e9b\u540d\u79f0\u7684\u7ed9\u4e88\u5e76\u4e0d\u91cd\u8981\u3002\u533a\u522b\u4e00\u4e2a\u7ebf\u6027\u7ed3\u6784\u4e0e\u53e6\u4e00\u4e2a\u7ed3\u6784\u7684\u662f\u9879\u7684\u6dfb\u52a0\u548c\u79fb\u9664\u65b9\u5f0f\uff0c\u7279\u522b\u662f\u8fd9\u4e9b\u6dfb\u52a0\u548c\u79fb\u9664\u53d1\u751f\u7684\u4f4d\u7f6e\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u7ed3\u6784\u53ef\u80fd\u53ea\u5141\u8bb8\u5728\u4e00\u4e2a\u7aef\u70b9\u6dfb\u52a0\u65b0\u9879\u3002\u6709\u4e9b\u7ed3\u6784\u53ef\u80fd\u5141\u8bb8\u4ece\u4efb\u610f\u4e00\u4e2a\u7aef\u70b9\u79fb\u9664\u9879\u3002</p> <p>\u8fd9\u4e9b\u53d8\u5316\u4ea7\u751f\u4e86\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u6700\u6709\u7528\u7684\u6570\u636e\u7ed3\u6784\u4e4b\u4e00\u3002\u5b83\u4eec\u51fa\u73b0\u5728\u8bb8\u591a\u7b97\u6cd5\u4e2d\uff0c\u5e76\u53ef\u4ee5\u7528\u6765\u89e3\u51b3\u5404\u79cd\u91cd\u8981\u7684\u95ee\u9898\u3002</p> <p>We will begin our study of data structures by considering four simple but very powerful concepts. Stacks, queues, deques, and lists are examples of data collections whose items are ordered depending on how they are added or removed. Once an item is added, it stays in that position relative to the other elements that came before and came after it. Collections such as these are often referred to as linear data structures.</p> <p>Linear structures can be thought of as having two ends. Sometimes these ends are referred to as the left and the right, or in some cases the front and the rear. You could also call them the \u201ctop\u201d and the bottom. The names given to the ends are not significant. What distinguishes one linear structure from another is the way in which items are added and removed, in particular the location where these additions and removals occur. For example, a structure might allow new items to be added at only one end. Some structures might allow items to be removed from either end.</p> <p>These variations give rise to some of the most useful data structures in computer science. They appear in many algorithms and can be used to solve a variety of important problems.</p>"},{"location":"c3/s20/","title":"3.20. \u65e0\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>3.20. The Unordered List Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>\u65e0\u5e8f\u5217\u8868\u7684\u7ed3\u6784\uff0c\u5982\u4e0a\u6240\u8ff0\uff0c\u662f\u4e00\u4e2a\u9879\u76ee\u96c6\u5408\uff0c\u5176\u4e2d\u6bcf\u4e2a\u9879\u76ee\u76f8\u5bf9\u4e8e\u5176\u4ed6\u9879\u76ee\u5177\u6709\u76f8\u5bf9\u4f4d\u7f6e\u3002\u4ee5\u4e0b\u662f\u4e00\u4e9b\u53ef\u80fd\u7684\u65e0\u5e8f\u5217\u8868\u64cd\u4f5c\uff1a</p> <ul> <li> <p><code>List()</code> \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7a7a\u5217\u8868\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5217\u8868\u3002</p> </li> <li> <p><code>add(item)</code> \u5c06\u65b0\u9879\u76ee\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\uff0c\u5e76\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u3002\u5047\u8bbe\u8be5\u9879\u76ee\u5c1a\u4e0d\u5728\u5217\u8868\u4e2d\u3002</p> </li> <li> <p><code>remove(item)</code> \u4ece\u5217\u8868\u4e2d\u5220\u9664\u6307\u5b9a\u9879\u76ee\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\uff0c\u5e76\u4fee\u6539\u5217\u8868\u3002\u5982\u679c\u9879\u76ee\u4e0d\u5728\u5217\u8868\u4e2d\uff0c\u5219\u629b\u51fa\u9519\u8bef\u3002</p> </li> <li> <p><code>search(item)</code> \u5728\u5217\u8868\u4e2d\u641c\u7d22\u6307\u5b9a\u9879\u76ee\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\uff0c\u5e76\u8fd4\u56de\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>is_empty()</code> \u68c0\u67e5\u5217\u8868\u662f\u5426\u4e3a\u7a7a\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>size()</code> \u8fd4\u56de\u5217\u8868\u4e2d\u9879\u76ee\u7684\u6570\u91cf\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u3002</p> </li> <li> <p><code>append(item)</code> \u5c06\u65b0\u9879\u76ee\u6dfb\u52a0\u5230\u5217\u8868\u7684\u672b\u5c3e\uff0c\u4f7f\u5176\u6210\u4e3a\u96c6\u5408\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u9879\u76ee\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\uff0c\u5e76\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u3002\u5047\u8bbe\u8be5\u9879\u76ee\u5c1a\u4e0d\u5728\u5217\u8868\u4e2d\u3002</p> </li> <li> <p><code>index(item)</code> \u8fd4\u56de\u5217\u8868\u4e2d\u6307\u5b9a\u9879\u76ee\u7684\u4f4d\u7f6e\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\uff0c\u5e76\u8fd4\u56de\u7d22\u5f15\u3002\u5047\u8bbe\u8be5\u9879\u76ee\u5728\u5217\u8868\u4e2d\u3002</p> </li> <li> <p><code>insert(pos, item)</code> \u5c06\u65b0\u9879\u76ee\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\u7684\u4f4d\u7f6e <code>pos</code>\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u4f4d\u7f6e\u548c\u9879\u76ee\uff0c\u5e76\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u3002\u5047\u8bbe\u8be5\u9879\u76ee\u5c1a\u4e0d\u5728\u5217\u8868\u4e2d\uff0c\u5e76\u4e14\u5b58\u5728\u8db3\u591f\u7684\u73b0\u6709\u9879\u76ee\u6765\u5bb9\u7eb3\u4f4d\u7f6e <code>pos</code>\u3002</p> </li> <li> <p><code>pop()</code> \u5220\u9664\u5e76\u8fd4\u56de\u5217\u8868\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u9879\u76ee\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u9879\u76ee\u3002\u5047\u8bbe\u5217\u8868\u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u9879\u76ee\u3002</p> </li> <li> <p><code>pop(pos)</code> \u5220\u9664\u5e76\u8fd4\u56de\u4f4d\u7f6e <code>pos</code> \u4e0a\u7684\u9879\u76ee\u3002\u5b83\u9700\u8981\u4f4d\u7f6e\uff0c\u5e76\u8fd4\u56de\u9879\u76ee\u3002\u5047\u8bbe\u8be5\u9879\u76ee\u5728\u5217\u8868\u4e2d\u3002</p> </li> </ul> <p>The structure of an unordered list, as described above, is a collection of items where each item holds a relative position with respect to the others. Some possible unordered list operations are given below.</p> <ul> <li> <p><code>List()</code> creates a new list that is empty. It needs no parameters and returns an empty list.</p> </li> <li> <p><code>add(item)</code> adds a new item to the list. It needs the item and returns nothing. Assume the item is not already in the list.</p> </li> <li> <p><code>remove(item)</code> removes the item from the list. It needs the item and modifies the list. Raise an error if the item is not present in the list.</p> </li> <li> <p><code>search(item)</code> searches for the item in the list. It needs the item and returns a Boolean value.</p> </li> <li> <p><code>is_empty()</code> tests to see whether the list is empty. It needs no parameters and returns a Boolean value.</p> </li> <li> <p><code>size()</code> returns the number of items in the list. It needs no parameters and returns an integer.</p> </li> <li> <p><code>append(item)</code> adds a new item to the end of the list making it the    last item in the collection. It needs the item and returns nothing. Assume the item is not already in the list.</p> </li> <li> <p><code>index(item)</code> returns the position of item in the list. It needs the item and returns the index. Assume the item is in the list.</p> </li> <li> <p><code>insert(pos, item)</code> adds a new item to the list at position <code>pos</code>. It needs the item and returns nothing. Assume the item is not already in the list and there are enough existing items to have position <code>pos</code>.</p> </li> <li> <p><code>pop()</code> removes and returns the last item in the list. It needs nothing and returns an item. Assume the list has at least one item.</p> </li> <li> <p><code>pop(pos)</code> removes and returns the item at position <code>pos</code>. It needs the position and returns the item. Assume the item is in the list.</p> </li> </ul>"},{"location":"c3/s21/","title":"3.21. \u7528\u94fe\u8868\u5b9e\u73b0\u65e0\u5e8f\u5217\u8868","text":"<p>3.21. Implementing an Unordered List: Linked Lists</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/ImplementinganUnorderedListLinkedLists.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e3a\u4e86\u5b9e\u73b0\u4e00\u4e2a\u65e0\u5e8f\u5217\u8868\uff0c\u6211\u4eec\u5c06\u6784\u9020\u4e00\u4e2a\u901a\u5e38\u79f0\u4e3a\u94fe\u8868\u7684\u6570\u636e\u7ed3\u6784\u3002\u8bf7\u8bb0\u4f4f\uff0c\u6211\u4eec\u9700\u8981\u786e\u4fdd\u80fd\u591f\u4fdd\u6301\u9879\u76ee\u7684\u76f8\u5bf9\u4f4d\u7f6e\u3002\u7136\u800c\uff0c\u5e76\u4e0d\u8981\u6c42\u6211\u4eec\u5728\u8fde\u7eed\u7684\u5185\u5b58\u4e2d\u4fdd\u6301\u8fd9\u4e9b\u4f4d\u7f6e\u3002\u4f8b\u5982\uff0c\u8003\u8651<code>\u56fe 1</code>\u4e2d\u663e\u793a\u7684\u9879\u76ee\u96c6\u5408\u3002\u8fd9\u4e9b\u503c\u4f3c\u4e4e\u662f\u968f\u673a\u653e\u7f6e\u7684\u3002\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u5728\u6bcf\u4e2a\u9879\u76ee\u4e2d\u4fdd\u6301\u4e00\u4e9b\u663e\u5f0f\u7684\u4fe1\u606f\uff0c\u5373\u4e0b\u4e00\u4e2a\u9879\u76ee\u7684\u4f4d\u7f6e\uff08\u53c2\u89c1<code>\u56fe 2</code>\uff09\uff0c\u90a3\u4e48\u6bcf\u4e2a\u9879\u76ee\u7684\u76f8\u5bf9\u4f4d\u7f6e\u53ef\u4ee5\u901a\u8fc7\u7b80\u5355\u5730\u8ddf\u968f\u4ece\u4e00\u4e2a\u9879\u76ee\u5230\u4e0b\u4e00\u4e2a\u9879\u76ee\u7684\u94fe\u63a5\u6765\u8868\u793a\u3002</p> <p> \u56fe 1: \u9879\u76ee\u4e0d\u53d7\u7269\u7406\u4f4d\u7f6e\u7684\u9650\u5236 </p> <p> \u56fe 2: \u901a\u8fc7\u663e\u5f0f\u94fe\u63a5\u4fdd\u6301\u76f8\u5bf9\u4f4d\u7f6e </p> <p>\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5217\u8868\u4e2d\u7b2c\u4e00\u4e2a\u9879\u76ee\u7684\u4f4d\u7f6e\u5fc5\u987b\u660e\u786e\u6307\u5b9a\u3002\u4e00\u65e6\u77e5\u9053\u4e86\u7b2c\u4e00\u4e2a\u9879\u76ee\u7684\u4f4d\u7f6e\uff0c\u7b2c\u4e00\u4e2a\u9879\u76ee\u53ef\u4ee5\u544a\u8bc9\u6211\u4eec\u7b2c\u4e8c\u4e2a\u9879\u76ee\u7684\u4f4d\u7f6e\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002\u5916\u90e8\u5f15\u7528\u901a\u5e38\u88ab\u79f0\u4e3a\u5217\u8868\u7684\u5934\u3002\u7c7b\u4f3c\u5730\uff0c\u6700\u540e\u4e00\u4e2a\u9879\u76ee\u9700\u8981\u77e5\u9053\u6ca1\u6709\u4e0b\u4e00\u4e2a\u9879\u76ee\u3002</p> <p>In order to implement an unordered list, we will construct what is commonly known as a linked list. Recall that we need to be sure that we can maintain the relative positioning of the items. However, there is no requirement that we maintain that positioning in contiguous memory. For example, consider the collection of items shown in <code>Figure 1</code>. It appears that these values have been placed randomly. If we can maintain some explicit information in each item, namely the location of the next item (see <code>Figure 2</code>), then the relative position of each item can be expressed by simply following the link from one item to the next.</p> <p> Figure 1: Items Not Constrained in Their Physical Placement </p> <p> Figure 2: Relative Positions Maintained by Explicit Links </p> <p>It is important to note that the location of the first item of the list must be explicitly specified. Once we know where the first item is, the first item can tell us where the second is, and so on. The external reference is often referred to as the head of the list. Similarly, the last item needs to know that there is no next item.</p>"},{"location":"c3/s21/#3211-\u8282\u70b9\u7c7b","title":"3.21.1. \u8282\u70b9\u7c7b","text":"<p>3.21.1. The Node Class</p> \u4e2d\u6587\u82f1\u6587 <p>\u94fe\u8868\u5b9e\u73b0\u7684\u57fa\u672c\u6784\u5efa\u5757\u662f\u8282\u70b9\u3002\u6bcf\u4e2a\u8282\u70b9\u5bf9\u8c61\u5fc5\u987b\u81f3\u5c11\u5305\u542b\u4e24\u4e2a\u4fe1\u606f\u3002\u9996\u5148\uff0c\u8282\u70b9\u5fc5\u987b\u5305\u542b\u5217\u8868\u9879\u672c\u8eab\u3002\u6211\u4eec\u5c06\u79f0\u4e4b\u4e3a\u8282\u70b9\u7684\u6570\u636e\u5b57\u6bb5\u3002\u6b64\u5916\uff0c\u6bcf\u4e2a\u8282\u70b9\u5fc5\u987b\u6301\u6709\u5bf9\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528\u3002<code>Listing 1</code>\u5c55\u793a\u4e86Python\u7684\u5b9e\u73b0\u3002\u8981\u6784\u9020\u4e00\u4e2a\u8282\u70b9\uff0c\u9700\u8981\u63d0\u4f9b\u8282\u70b9\u7684\u521d\u59cb\u6570\u636e\u503c\u3002\u4ee5\u4e0b\u8d4b\u503c\u8bed\u53e5\u5c06\u751f\u6210\u4e00\u4e2a\u5305\u542b\u503c<code>93</code>\u7684<code>Node</code>\u5bf9\u8c61\uff08\u89c1<code>\u56fe 3</code>\uff09\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u901a\u5e38\u5c06\u8282\u70b9\u5bf9\u8c61\u8868\u793a\u5982<code>\u56fe 4</code>\u6240\u793a\u3002<code>Node</code>\u7c7b\u4e2d\u7684\u9690\u85cf\u5b57\u6bb5<code>_data</code>\u548c<code>_next</code>\u88ab\u8f6c\u6362\u4e3a\u5c5e\u6027\uff0c\u53ef\u4ee5\u5206\u522b\u901a\u8fc7<code>data</code>\u548c<code>next</code>\u8bbf\u95ee\u3002</p> Listing 1<pre><code>class Node:\n    \"\"\"\u94fe\u8868\u8282\u70b9\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"\u83b7\u53d6\u8282\u70b9\u6570\u636e\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"\u8bbe\u7f6e\u8282\u70b9\u6570\u636e\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"\u5b57\u7b26\u4e32\u8868\u793a\"\"\"\n        return str(self._data)\n</code></pre> <p>\u6211\u4eec\u6309\u7167\u901a\u5e38\u7684\u65b9\u5f0f\u521b\u5efa<code>Node</code>\u5bf9\u8c61\u3002</p> <pre><code>&gt;&gt;&gt; temp = Node(93)\n&gt;&gt;&gt; temp.data\n93\n</code></pre> <p>\u7279\u6b8a\u7684Python\u5f15\u7528\u503c<code>None</code>\u5c06\u5728<code>Node</code>\u7c7b\u4e2d\u4ee5\u53ca\u540e\u6765\u7684\u94fe\u8868\u5b9e\u73b0\u4e2d\u626e\u6f14\u91cd\u8981\u89d2\u8272\u3002\u5bf9<code>None</code>\u7684\u5f15\u7528\u8868\u793a\u6ca1\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u8bf7\u6ce8\u610f\uff0c\u5728\u6784\u9020\u51fd\u6570\u4e2d\uff0c\u8282\u70b9\u6700\u521d\u521b\u5efa\u65f6<code>next</code>\u88ab\u8bbe\u7f6e\u4e3a<code>None</code>\u3002\u7531\u4e8e\u8fd9\u6709\u65f6\u88ab\u79f0\u4e3a\u201c\u8282\u70b9\u7684\u57fa\u7840\u201d\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u6807\u51c6\u7684\u57fa\u7840\u7b26\u53f7\u8868\u793a\u5f15\u7528\u6307\u5411<code>None</code>\u3002\u663e\u5f0f\u5730\u5c06<code>None</code>\u5206\u914d\u7ed9\u521d\u59cb\u7684\u4e0b\u4e00\u4e2a\u5f15\u7528\u503c\u603b\u662f\u4e00\u4e2a\u597d\u4e3b\u610f\u3002</p> <p> \u56fe 3: \u4e00\u4e2a\u8282\u70b9\u5bf9\u8c61\u5305\u542b\u9879\u76ee\u548c\u5bf9\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528 </p> <p> \u56fe 4: \u8282\u70b9\u7684\u5178\u578b\u8868\u793a </p> <p>The basic building block for the linked list implementation is the node. Each node object must hold at least two pieces of information. First, the node must contain the list item itself. We will call this the data field of the node. In addition, each node must hold a reference to the next node. <code>Listing 1</code> shows the Python implementation. To construct a node, you need to supply the initial data value for the node. Evaluating the assignment statement below will yield a <code>Node</code> object containing the value <code>93</code> (see <code>Figure 3</code>). You should note that we will typically represent a node object as shown in <code>Figure 4</code>. Hidden fields <code>_data</code> and <code>_next</code> of the <code>Node</code> class are turned into properties and can be accessed as <code>data</code> and <code>next</code> respectively.</p> Listing 1<pre><code>class Node:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n</code></pre> <p>We create <code>Node</code> objects in the usual way.</p> <pre><code>&gt;&gt;&gt; temp = Node(93)\n&gt;&gt;&gt; temp.data\n93\n</code></pre> <p>The special Python reference value <code>None</code> will play an important role in the <code>Node</code> class and later in the linked list itself. A reference to <code>None</code> will denote the fact that there is no next node. Note in the constructor that a node is initially created with <code>next</code> set to <code>None</code>. Since this is sometimes referred to as \u201cgrounding the node,\u201d we will use the standard ground symbol to denote a reference that is referring to <code>None</code>. It is always a good idea to explicitly assign <code>None</code> to your initial next reference values.</p> <p> Figure 3: A Node Object Contains the Item and a Reference to the Next Node </p> <p> Figure 4: A Typical Representation for a Node </p>"},{"location":"c3/s21/#3212-\u65e0\u5e8f\u5217\u8868\u7c7b","title":"3.21.2. \u65e0\u5e8f\u5217\u8868\u7c7b","text":"<p>3.21.2. The UnorderedList Class</p> \u4e2d\u6587\u82f1\u6587 <p>\u6b63\u5982\u6211\u4eec\u524d\u9762\u6240\u63d0\u5230\u7684\uff0c\u65e0\u5e8f\u5217\u8868\u5c06\u7531\u4e00\u7cfb\u5217\u8282\u70b9\u6784\u6210\uff0c\u6bcf\u4e2a\u8282\u70b9\u901a\u8fc7\u663e\u5f0f\u5f15\u7528\u94fe\u63a5\u5230\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u53ea\u8981\u6211\u4eec\u77e5\u9053\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u4f4d\u7f6e\uff08\u5305\u542b\u7b2c\u4e00\u4e2a\u9879\uff09\uff0c\u4e4b\u540e\u7684\u6bcf\u4e2a\u9879\u90fd\u53ef\u4ee5\u901a\u8fc7\u4f9d\u6b21\u8ddf\u968f\u201c\u4e0b\u4e00\u4e2a\u201d\u94fe\u63a5\u6765\u627e\u5230\u3002\u8003\u8651\u5230\u8fd9\u4e00\u70b9\uff0c<code>UnorderedList</code> \u7c7b\u5fc5\u987b\u7ef4\u62a4\u5bf9\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528\u3002<code>Listing 2</code> \u663e\u793a\u4e86\u6784\u9020\u51fd\u6570\u3002\u8bf7\u6ce8\u610f\uff0c\u6bcf\u4e2a\u5217\u8868\u5bf9\u8c61\u5c06\u7ef4\u62a4\u5bf9\u5217\u8868\u5934\u7684\u5355\u4e2a\u5f15\u7528\u3002</p> Listing 2<pre><code>class UnorderedList:\n\n    def __init__(self):\n        self.head = None\n</code></pre> <p>\u521d\u59cb\u65f6\uff0c\u5f53\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u5217\u8868\u65f6\uff0c\u5217\u8868\u4e2d\u6ca1\u6709\u4efb\u4f55\u9879\u3002\u8d4b\u503c\u8bed\u53e5</p> <pre><code>&gt;&gt;&gt; my_list = UnorderedList()\n</code></pre> <p>\u521b\u5efa\u4e86\u5982<code>\u56fe 5</code>\u6240\u793a\u7684\u94fe\u8868\u8868\u793a\u3002\u6b63\u5982\u6211\u4eec\u5728<code>Node</code>\u7c7b\u4e2d\u8ba8\u8bba\u7684\uff0c\u7279\u6b8a\u7684\u5f15\u7528\u503c<code>None</code>\u5c06\u518d\u6b21\u7528\u4e8e\u8868\u793a\u5217\u8868\u5934\u4e0d\u6307\u5411\u4efb\u4f55\u5185\u5bb9\u3002\u6700\u7ec8\uff0c\u4e4b\u524d\u7ed9\u51fa\u7684\u793a\u4f8b\u5217\u8868\u5c06\u88ab\u8868\u793a\u4e3a\u5982<code>\u56fe 6</code>\u6240\u793a\u7684\u94fe\u8868\u3002\u5217\u8868\u7684\u5934\u6307\u5411\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u8be5\u8282\u70b9\u5305\u542b\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u9879\u3002\u8be5\u8282\u70b9\u53c8\u6301\u6709\u5bf9\u4e0b\u4e00\u4e2a\u8282\u70b9\uff08\u4e0b\u4e00\u4e2a\u9879\uff09\u7684\u5f15\u7528\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u975e\u5e38\u91cd\u8981\u7684\u4e00\u70b9\u662f\uff0c\u5217\u8868\u7c7b\u672c\u8eab\u4e0d\u5305\u542b\u4efb\u4f55\u8282\u70b9\u5bf9\u8c61\u3002\u5b83\u53ea\u5305\u542b\u5bf9\u94fe\u8868\u7ed3\u6784\u4e2d\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u5355\u4e2a\u5f15\u7528\u3002</p> <p> \u56fe 5: \u7a7a\u5217\u8868 </p> <p> \u56fe 6: \u6574\u6570\u94fe\u8868 </p> <p><code>is_empty</code> \u65b9\u6cd5\uff0c\u5982<code>Listing 3</code>\u6240\u793a\uff0c\u7b80\u5355\u5730\u68c0\u67e5\u5217\u8868\u7684\u5934\u662f\u5426\u5f15\u7528<code>None</code>\u3002\u5e03\u5c14\u8868\u8fbe\u5f0f<code>self.head == None</code>\u7684\u7ed3\u679c\u53ea\u6709\u5728\u94fe\u8868\u4e2d\u6ca1\u6709\u8282\u70b9\u65f6\u624d\u4e3a\u771f\u3002\u7531\u4e8e\u65b0\u5217\u8868\u662f\u7a7a\u7684\uff0c\u6784\u9020\u51fd\u6570\u548c\u7a7a\u68c0\u67e5\u5fc5\u987b\u662f\u4e00\u81f4\u7684\u3002\u8fd9\u5c55\u793a\u4e86\u4f7f\u7528\u5f15\u7528<code>None</code>\u6765\u8868\u793a\u94fe\u8868\u7ed3\u6784\u672b\u5c3e\u7684\u4f18\u70b9\u3002\u5728Python\u4e2d\uff0c<code>None</code>\u53ef\u4ee5\u4e0e\u4efb\u4f55\u5f15\u7528\u8fdb\u884c\u6bd4\u8f83\u3002\u5982\u679c\u4e24\u4e2a\u5f15\u7528\u90fd\u6307\u5411\u76f8\u540c\u7684\u5bf9\u8c61\uff0c\u5219\u5b83\u4eec\u76f8\u7b49\u3002\u6211\u4eec\u5c06\u5728\u5176\u4f59\u7684\u65b9\u6cd5\u4e2d\u7ecf\u5e38\u4f7f\u7528\u8fd9\u4e00\u70b9\u3002</p> Listing 3<pre><code>def is_empty(self):\n    return self.head == None\n</code></pre> <p>\u90a3\u4e48\uff0c\u6211\u4eec\u5982\u4f55\u5c06\u9879\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\u5462\uff1f\u6211\u4eec\u9700\u8981\u5b9e\u73b0<code>add</code>\u65b9\u6cd5\u3002\u7136\u800c\uff0c\u5728\u6b64\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u89e3\u51b3\u4e00\u4e2a\u91cd\u8981\u7684\u95ee\u9898\uff0c\u5373\u5728\u94fe\u8868\u4e2d\u5c06\u65b0\u9879\u653e\u7f6e\u5728\u54ea\u91cc\u3002\u7531\u4e8e\u8be5\u5217\u8868\u662f\u65e0\u5e8f\u7684\uff0c\u65b0\u9879\u76f8\u5bf9\u4e8e\u5217\u8868\u4e2d\u5176\u4ed6\u9879\u7684\u5177\u4f53\u4f4d\u7f6e\u5e76\u4e0d\u91cd\u8981\u3002\u65b0\u9879\u53ef\u4ee5\u653e\u5728\u4efb\u4f55\u5730\u65b9\u3002\u8003\u8651\u5230\u8fd9\u4e00\u70b9\uff0c\u5c06\u65b0\u9879\u653e\u5728\u6700\u7b80\u5355\u7684\u4f4d\u7f6e\u662f\u6709\u610f\u4e49\u7684\u3002</p> <p>\u8bf7\u8bb0\u4f4f\uff0c\u94fe\u8868\u7ed3\u6784\u63d0\u4f9b\u4e86\u552f\u4e00\u7684\u5165\u53e3\u70b9\uff0c\u5373\u5217\u8868\u7684\u5934\u3002\u6240\u6709\u5176\u4ed6\u8282\u70b9\u53ea\u80fd\u901a\u8fc7\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u8ddf\u968f\u201c\u4e0b\u4e00\u4e2a\u201d\u94fe\u63a5\u6765\u5230\u8fbe\u3002\u8fd9\u610f\u5473\u7740\uff0c\u6dfb\u52a0\u65b0\u8282\u70b9\u7684\u6700\u7b80\u5355\u4f4d\u7f6e\u662f\u5217\u8868\u7684\u5934\u90e8\uff0c\u6216\u5f00\u59cb\u90e8\u5206\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u5c06\u65b0\u9879\u4f5c\u4e3a\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u9879\uff0c\u5e76\u4e14\u73b0\u6709\u9879\u9700\u8981\u94fe\u63a5\u5230\u8fd9\u4e2a\u65b0\u7684\u7b2c\u4e00\u4e2a\u9879\uff0c\u4f7f\u5176\u8ddf\u968f\u3002</p> <p>\u5982<code>\u56fe 6</code>\u6240\u793a\u7684\u94fe\u8868\u662f\u901a\u8fc7\u591a\u6b21\u8c03\u7528<code>add</code>\u65b9\u6cd5\u6784\u5efa\u7684\u3002</p> <pre><code>&gt;&gt;&gt; my_list.add(31)\n&gt;&gt;&gt; my_list.add(77)\n&gt;&gt;&gt; my_list.add(17)\n&gt;&gt;&gt; my_list.add(93)\n&gt;&gt;&gt; my_list.add(26)\n&gt;&gt;&gt; my_list.add(54)\n</code></pre> <p>\u6ce8\u610f\uff0c\u7531\u4e8e<code>31</code>\u662f\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u9879\uff0c\u5b83\u6700\u7ec8\u5c06\u6210\u4e3a\u94fe\u8868\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u8282\u70b9\uff0c\u56e0\u4e3a\u6240\u6709\u5176\u4ed6\u9879\u90fd\u88ab\u6dfb\u52a0\u5728\u5b83\u4e4b\u524d\u3002\u6b64\u5916\uff0c\u7531\u4e8e<code>54</code>\u662f\u6700\u540e\u4e00\u4e2a\u6dfb\u52a0\u7684\u9879\uff0c\u5b83\u5c06\u6210\u4e3a\u94fe\u8868\u4e2d\u7b2c\u4e00\u4e2a\u8282\u70b9\u7684\u6570\u636e\u503c\u3002</p> <p><code>add</code>\u65b9\u6cd5\u5982<code>Listing 4</code>\u6240\u793a\u3002\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u9879\u5fc5\u987b\u4f4d\u4e8e\u4e00\u4e2a\u8282\u70b9\u5bf9\u8c61\u4e2d\u3002\u7b2c2\u884c\u521b\u5efa\u4e00\u4e2a\u65b0\u8282\u70b9\uff0c\u5e76\u5c06\u9879\u4f5c\u4e3a\u5176\u6570\u636e\u3002\u73b0\u5728\u6211\u4eec\u5fc5\u987b\u901a\u8fc7\u5c06\u65b0\u8282\u70b9\u94fe\u63a5\u5230\u73b0\u6709\u7ed3\u6784\u4e2d\u6765\u5b8c\u6210\u8fc7\u7a0b\u3002\u8fd9\u9700\u8981\u4e24\u4e2a\u6b65\u9aa4\uff0c\u5982<code>\u56fe 7</code>\u6240\u793a\u3002\u7b2c1\u6b65\uff08\u7b2c3\u884c\uff09\u5c06\u65b0\u8282\u70b9\u7684\u201c\u4e0b\u4e00\u4e2a\u201d\u5f15\u7528\u66f4\u6539\u4e3a\u6307\u5411\u65e7\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002\u73b0\u5728\uff0c\u5217\u8868\u7684\u5176\u4f59\u90e8\u5206\u5df2\u6b63\u786e\u9644\u52a0\u5230\u65b0\u8282\u70b9\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u5217\u8868\u7684\u5934\u4ee5\u6307\u5411\u65b0\u8282\u70b9\u3002\u7b2c4\u884c\u7684\u8d4b\u503c\u8bed\u53e5\u8bbe\u7f6e\u4e86\u5217\u8868\u7684\u5934\u3002</p> Listing 4<pre><code>def add(self, item):\n    temp = Node(item)\n    temp.set_next(self.head)\n    self.head = temp\n</code></pre> <p> \u56fe 7: \u6dfb\u52a0\u65b0\u8282\u70b9\u662f\u4e00\u4e2a\u4e24\u6b65\u8fc7\u7a0b </p> <p>\u4e0a\u8ff0\u4e24\u4e2a\u6b65\u9aa4\u7684\u987a\u5e8f\u975e\u5e38\u91cd\u8981\u3002\u5982\u679c\u7b2c3\u884c\u548c\u7b2c4\u884c\u7684\u987a\u5e8f\u88ab\u98a0\u5012\u4e86\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u5982\u679c\u9996\u5148\u4fee\u6539\u5217\u8868\u7684\u5934\uff0c\u7ed3\u679c\u53ef\u4ee5\u5728<code>\u56fe 8</code>\u4e2d\u770b\u5230\u3002\u7531\u4e8e\u5934\u662f\u94fe\u8868\u8282\u70b9\u7684\u552f\u4e00\u5916\u90e8\u5f15\u7528\uff0c\u6240\u6709\u539f\u59cb\u8282\u70b9\u90fd\u88ab\u4e22\u5931\uff0c\u65e0\u6cd5\u518d\u8bbf\u95ee\u3002</p> <p> \u56fe 8: \u98a0\u5012\u4e24\u4e2a\u6b65\u9aa4\u7684\u987a\u5e8f\u7684\u7ed3\u679c </p> <p>\u63a5\u4e0b\u6765\u6211\u4eec\u5c06\u5b9e\u73b0\u7684\u65b9\u6cd5\u2014\u2014<code>size</code>\u3001<code>search</code> \u548c <code>remove</code>\u2014\u2014\u90fd\u57fa\u4e8e\u4e00\u79cd\u79f0\u4e3a\u94fe\u8868\u904d\u5386\u7684\u6280\u672f\u3002\u904d\u5386\u6307\u7684\u662f\u7cfb\u7edf\u5730\u8bbf\u95ee\u6bcf\u4e2a\u8282\u70b9\u7684\u8fc7\u7a0b\u3002\u4e3a\u6b64\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a\u5916\u90e8\u5f15\u7528\uff0c\u8be5\u5f15\u7528\u4ece\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u3002\u5f53\u6211\u4eec\u8bbf\u95ee\u6bcf\u4e2a\u8282\u70b9\u65f6\uff0c\u6211\u4eec\u901a\u8fc7\u201c\u904d\u5386\u201d\u4e0b\u4e00\u4e2a\u5f15\u7528\u6765\u79fb\u52a8\u5f15\u7528\u5230\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002</p> <p>\u8981\u5b9e\u73b0 <code>size</code> \u65b9\u6cd5\uff0c\u6211\u4eec\u9700\u8981\u904d\u5386\u94fe\u8868\u5e76\u7edf\u8ba1\u8282\u70b9\u7684\u6570\u91cf\u3002<code>Listing 5</code> \u663e\u793a\u4e86\u8ba1\u6570\u94fe\u8868\u4e2d\u8282\u70b9\u6570\u91cf\u7684 Python \u4ee3\u7801\u3002\u5916\u90e8\u5f15\u7528\u540d\u4e3a <code>current</code>\uff0c\u5728\u7b2c 2 \u884c\u521d\u59cb\u5316\u4e3a\u94fe\u8868\u7684\u5934\u90e8\u3002\u5728\u5f00\u59cb\u65f6\uff0c\u6211\u4eec\u8fd8\u6ca1\u6709\u8bbf\u95ee\u4efb\u4f55\u8282\u70b9\uff0c\u56e0\u6b64\u8ba1\u6570\u88ab\u8bbe\u7f6e\u4e3a 0\u3002\u7b2c 4 \u884c\u5230\u7b2c 6 \u884c\u5b9e\u9645\u5b9e\u73b0\u4e86\u904d\u5386\u64cd\u4f5c\u3002\u53ea\u8981\u5f53\u524d\u5f15\u7528\u6ca1\u6709\u5230\u8fbe\u94fe\u8868\u7684\u672b\u5c3e\uff08<code>None</code>\uff09\uff0c\u6211\u4eec\u5c31\u901a\u8fc7\u7b2c 6 \u884c\u7684\u8d4b\u503c\u8bed\u53e5\u5c06 <code>current</code> \u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u518d\u6b21\u5f3a\u8c03\uff0c\u5c06\u5f15\u7528\u4e0e <code>None</code> \u6bd4\u8f83\u975e\u5e38\u6709\u7528\u3002\u6bcf\u6b21 <code>current</code> \u79fb\u52a8\u5230\u4e00\u4e2a\u65b0\u8282\u70b9\u65f6\uff0c\u6211\u4eec\u5c31\u5c06 <code>count</code> \u52a0 1\u3002\u6700\u540e\uff0c\u5728\u8fed\u4ee3\u505c\u6b62\u540e\u8fd4\u56de <code>count</code>\u3002<code>Figure 9</code> \u663e\u793a\u4e86\u8fd9\u4e2a\u8fc7\u7a0b\u5982\u4f55\u6cbf\u94fe\u8868\u5411\u4e0b\u8fdb\u884c\u3002</p> Listing 5<pre><code>def size(self):\n    current = self.head\n    count = 0\n    while current is not None:\n        count = count + 1\n        current = current.next\n\n    return count\n</code></pre> <p> Figure 9: \u4ece\u5934\u5230\u5c3e\u904d\u5386\u94fe\u8868 </p> <p>\u5728\u94fe\u8868\u5b9e\u73b0\u7684\u65e0\u5e8f\u5217\u8868\u4e2d\u67e5\u627e\u4e00\u4e2a\u503c\u4e5f\u4f7f\u7528\u904d\u5386\u6280\u672f\u3002\u5728\u8bbf\u95ee\u94fe\u8868\u4e2d\u7684\u6bcf\u4e2a\u8282\u70b9\u65f6\uff0c\u6211\u4eec\u4f1a\u68c0\u67e5\u5b58\u50a8\u7684\u6570\u636e\u662f\u5426\u4e0e\u6211\u4eec\u8981\u67e5\u627e\u7684\u9879\u76ee\u5339\u914d\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u80fd\u4e0d\u9700\u8981\u904d\u5386\u5230\u94fe\u8868\u7684\u672b\u5c3e\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5982\u679c\u6211\u4eec\u5230\u8fbe\u94fe\u8868\u7684\u672b\u5c3e\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u627e\u7684\u9879\u4e00\u5b9a\u4e0d\u5728\u94fe\u8868\u4e2d\u3002\u53e6\u5916\uff0c\u5982\u679c\u627e\u5230\u9879\uff0c\u5c31\u6ca1\u6709\u5fc5\u8981\u7ee7\u7eed\u904d\u5386\u3002</p> <p><code>Listing 6</code> \u663e\u793a\u4e86 <code>search</code> \u65b9\u6cd5\u7684\u5b9e\u73b0\u3002\u4e0e <code>size</code> \u65b9\u6cd5\u4e00\u6837\uff0c\u904d\u5386\u521d\u59cb\u5316\u4e3a\u4ece\u94fe\u8868\u7684\u5934\u90e8\u5f00\u59cb\uff08\u7b2c 2 \u884c\uff09\u3002\u53ea\u8981\u8fd8\u6709\u66f4\u591a\u8282\u70b9\u9700\u8981\u8bbf\u95ee\uff0c\u6211\u4eec\u5c31\u7ee7\u7eed\u904d\u5386\u3002\u7b2c 4 \u884c\u7684\u95ee\u9898\u662f\u68c0\u67e5\u5f53\u524d\u8282\u70b9\u4e2d\u662f\u5426\u5b58\u5728\u6570\u636e\u9879\u3002\u5982\u679c\u5b58\u5728\uff0c\u6211\u4eec\u7acb\u5373\u8fd4\u56de <code>True</code>\u3002</p> Listing 6<pre><code>def search(self, item):\n    current = self.head\n    while current is not None:\n        if current.data == item:\n            return True\n        current = current.next\n\n    return False\n</code></pre> <p>\u4f8b\u5982\uff0c\u8003\u8651\u8c03\u7528 <code>search</code> \u65b9\u6cd5\u67e5\u627e\u9879 17\u3002</p> <pre><code>&gt;&gt;&gt; my_list.search(17)\nTrue\n</code></pre> <p>\u7531\u4e8e <code>17</code> \u5728\u5217\u8868\u4e2d\uff0c\u904d\u5386\u8fc7\u7a0b\u53ea\u9700\u8981\u79fb\u52a8\u5230\u5305\u542b <code>17</code> \u7684\u8282\u70b9\u3002\u5728\u90a3\u65f6\uff0c\u7b2c 4 \u884c\u7684\u6761\u4ef6\u4e3a <code>True</code>\uff0c\u6211\u4eec\u8fd4\u56de\u641c\u7d22\u7684\u7ed3\u679c\u3002<code>Figure 10</code> \u663e\u793a\u4e86\u6210\u529f\u67e5\u627e\u503c 17 \u7684\u8fc7\u7a0b\u3002</p> <p> Figure 10: \u6210\u529f\u67e5\u627e\u503c 17 </p> <p><code>remove</code> \u65b9\u6cd5\u9700\u8981\u4e24\u4e2a\u903b\u8f91\u6b65\u9aa4\u3002\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u904d\u5386\u94fe\u8868\u67e5\u627e\u8981\u5220\u9664\u7684\u9879\u3002\u4e00\u65e6\u627e\u5230\u9879\uff0c\u6211\u4eec\u5fc5\u987b\u5c06\u5176\u5220\u9664\u3002\u5982\u679c\u9879\u4e0d\u5728\u5217\u8868\u4e2d\uff0c\u6211\u4eec\u7684\u65b9\u6cd5\u5e94\u5f15\u53d1 <code>ValueError</code> \u5f02\u5e38\u3002</p> <p>\u7b2c\u4e00\u6b65\u4e0e <code>search</code> \u65b9\u6cd5\u975e\u5e38\u76f8\u4f3c\u3002\u4ece\u5916\u90e8\u5f15\u7528\u8bbe\u7f6e\u4e3a\u94fe\u8868\u7684\u5934\u90e8\u5f00\u59cb\uff0c\u6211\u4eec\u904d\u5386\u94fe\u8868\u76f4\u5230\u53d1\u73b0\u8981\u5220\u9664\u7684\u9879\u3002</p> <p>\u5f53\u9879\u88ab\u627e\u5230\u5e76\u8df3\u51fa\u5faa\u73af\u65f6\uff0c<code>current</code> \u5c06\u5f15\u7528\u5305\u542b\u8981\u5220\u9664\u9879\u7684\u8282\u70b9\u3002\u4f46\u6211\u4eec\u5982\u4f55\u5220\u9664\u5b83\u5462\uff1f\u4e00\u79cd\u53ef\u80fd\u6027\u662f\u5c06\u9879\u7684\u503c\u66ff\u6362\u4e3a\u67d0\u4e2a\u6807\u8bb0\uff0c\u8868\u793a\u8be5\u9879\u4e0d\u518d\u5b58\u5728\u3002\u8fd9\u4e2a\u65b9\u6cd5\u7684\u95ee\u9898\u662f\u8282\u70b9\u7684\u6570\u91cf\u5c06\u4e0d\u518d\u4e0e\u9879\u7684\u6570\u91cf\u5339\u914d\u3002\u66f4\u597d\u7684\u65b9\u6cd5\u662f\u901a\u8fc7\u5220\u9664\u6574\u4e2a\u8282\u70b9\u6765\u79fb\u9664\u9879\u3002</p> <p>\u4e3a\u4e86\u5220\u9664\u5305\u542b\u9879\u7684\u8282\u70b9\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539\u524d\u4e00\u4e2a\u8282\u70b9\u4e2d\u7684\u94fe\u63a5\uff0c\u4f7f\u5176\u6307\u5411 <code>current</code> \u8282\u70b9\u4e4b\u540e\u7684\u8282\u70b9\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u94fe\u8868\u6ca1\u6709\u5411\u540e\u904d\u5386\u7684\u529f\u80fd\u3002\u7531\u4e8e <code>current</code> \u5f15\u7528\u7684\u662f\u6211\u4eec\u60f3\u8981\u66f4\u6539\u7684\u8282\u70b9\u7684\u524d\u4e00\u4e2a\u8282\u70b9\uff0c\u56e0\u6b64\u73b0\u5728\u66f4\u6539\u5df2\u7ecf\u4e3a\u65f6\u5df2\u665a\u3002</p> <p>\u89e3\u51b3\u8fd9\u4e2a\u56f0\u5883\u7684\u65b9\u6cd5\u662f\u4f7f\u7528\u4e24\u4e2a\u5916\u90e8\u5f15\u7528\u8fdb\u884c\u904d\u5386\u3002<code>current</code> \u5c06\u50cf\u4e4b\u524d\u4e00\u6837\uff0c\u6807\u8bb0\u904d\u5386\u7684\u5f53\u524d\u4f4d\u7f6e\u3002\u65b0\u7684\u5f15\u7528\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a <code>previous</code>\uff0c\u5c06\u59cb\u7ec8\u6bd4 <code>current</code> \u9886\u5148\u4e00\u4e2a\u8282\u70b9\u3002\u8fd9\u6837\uff0c\u5f53 <code>current</code> \u505c\u5728\u8981\u5220\u9664\u7684\u8282\u70b9\u65f6\uff0c<code>previous</code> \u5c06\u5f15\u7528\u94fe\u8868\u4e2d\u9700\u8981\u4fee\u6539\u7684\u4f4d\u7f6e\u3002</p> <p><code>Listing 7</code> \u663e\u793a\u4e86\u5b8c\u6574\u7684 <code>remove</code> \u65b9\u6cd5\u3002\u7b2c 2 \u884c\u5230\u7b2c 3 \u884c\u4e3a\u4e24\u4e2a\u5f15\u7528\u8d4b\u4e88\u521d\u59cb\u503c\u3002\u8bf7\u6ce8\u610f\uff0c<code>current</code> \u4ece\u94fe\u8868\u5934\u5f00\u59cb\uff0c\u6b63\u5982\u5176\u4ed6\u904d\u5386\u793a\u4f8b\u4e00\u6837\u3002\u7136\u800c\uff0c<code>previous</code> \u88ab\u5047\u8bbe\u59cb\u7ec8\u5728 <code>current</code> \u4e4b\u524d\u4e00\u4e2a\u8282\u70b9\u3002\u56e0\u6b64\uff0c<code>previous</code> \u521d\u59cb\u503c\u4e3a <code>None</code>\uff0c\u56e0\u4e3a\u5934\u90e8\u4e4b\u524d\u6ca1\u6709\u8282\u70b9\uff08\u53c2\u89c1 <code>Figure 11</code>\uff09\u3002</p> <p>\u7b2c 6 \u884c\u5230\u7b2c 7 \u884c\u8be2\u95ee\u5f53\u524d\u8282\u70b9\u4e2d\u5b58\u50a8\u7684\u9879\u662f\u5426\u662f\u6211\u4eec\u5e0c\u671b\u5220\u9664\u7684\u9879\u3002\u5982\u679c\u662f\uff0c\u6211\u4eec\u5c31\u8df3\u51fa\u5faa\u73af\u3002\u5982\u679c\u672a\u627e\u5230\u9879\uff0c<code>previous</code> \u548c <code>current</code> \u5fc5\u987b\u90fd\u5411\u524d\u79fb\u52a8\u4e00\u4e2a\u8282\u70b9\u3002\u518d\u6b21\u5f3a\u8c03\uff0c\u8fd9\u4e24\u4e2a\u8bed\u53e5\u7684\u987a\u5e8f\u662f\u81f3\u5173\u91cd\u8981\u7684\u3002<code>previous</code> \u5fc5\u987b\u9996\u5148\u79fb\u52a8\u5230 <code>current</code> \u7684\u4f4d\u7f6e\uff0c\u7136\u540e <code>current</code> \u624d\u80fd\u79fb\u52a8\u3002\u8fd9\u79cd\u8fc7\u7a0b\u901a\u5e38\u88ab\u79f0\u4e3a inchworming\uff08\u722c\u866b\u5f0f\u79fb\u52a8\uff09\uff0c\u56e0\u4e3a <code>previous</code> \u5fc5\u987b\u8ffd\u8d76\u5230 <code>current</code> \u4e4b\u524d\uff0c\u624d\u80fd\u8ba9 <code>current</code> \u5411\u524d\u79fb\u52a8\u3002<code>Figure 12</code> \u663e\u793a\u4e86 <code>previous</code> \u548c <code>current</code> \u5728\u67e5\u627e\u5305\u542b\u503c 17 \u7684\u8282\u70b9\u65f6\u7684\u79fb\u52a8\u60c5\u51b5\u3002</p> Listing 7<pre><code>def remove(self, item):\n    current = self.head\n    previous = None\n\n    while current is not None:\n        if current.data == item:\n            break\n        previous = current\n        current = current.next\n\n    if current is None:\n        raise ValueError(\"{} is not in the list\".format(item))\n    if previous is None:\n        self.head = current.next\n    else:\n        previous.next = current.next\n</code></pre> <p> Figure 11: <code>previous</code> \u548c <code>current</code> \u7684\u521d\u59cb\u503c </p> <p> Figure 12: <code>previous</code> \u548c <code>current</code> \u5411\u4e0b\u79fb\u52a8\u94fe\u8868 </p> <p>\u5b8c\u6210 <code>remove</code> \u65b9\u6cd5\u7684\u67e5\u627e\u6b65\u9aa4\u540e\uff0c\u6211\u4eec\u9700\u8981\u4ece\u94fe\u8868\u4e2d\u5220\u9664\u8282\u70b9\u3002<code>Figure 13</code> \u663e\u793a\u4e86\u5fc5\u987b\u4fee\u6539\u7684\u94fe\u63a5\u3002\u4f46\u662f\uff0c\u6709\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u9700\u8981\u5904\u7406\u3002\u5982\u679c\u8981\u5220\u9664\u7684\u9879\u6070\u597d\u662f\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u9879\uff0c\u90a3\u4e48 <code>current</code> \u5c06\u5f15\u7528\u94fe\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002\u8fd9\u4e5f\u610f\u5473\u7740 <code>previous</code> \u5c06\u4e3a <code>None</code>\u3002\u6211\u4eec\u4e4b\u524d\u8bf4\u8fc7 <code>previous</code> \u5c06\u5f15\u7528\u9700\u8981\u4fee\u6539\u5176 <code>next</code> \u5f15\u7528\u7684\u8282\u70b9\uff0c\u4ee5\u5b8c\u6210\u5220\u9664\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u66f4\u6539\u7684\u4e0d\u662f <code>previous</code>\uff0c\u800c\u662f\u94fe\u8868\u7684\u5934\u90e8\uff08\u53c2\u89c1 <code>Figure 14</code>\uff09\u3002\u53e6\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u662f\u9879\u4e0d\u5728\u5217\u8868\u4e2d\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c<code>current is None</code> \u8bc4\u4f30\u4e3a <code>True</code>\uff0c\u5e76\u5f15\u53d1\u9519\u8bef\u3002</p> <p> Figure 13: \u4ece\u94fe\u8868\u4e2d\u5220\u9664\u4e2d\u95f4\u7684\u9879 </p> <p> Figure 14: \u4ece\u94fe\u8868\u4e2d\u5220\u9664\u7b2c\u4e00\u4e2a\u8282\u70b9 </p> <p>\u7b2c 13 \u884c\u5141\u8bb8\u6211\u4eec\u68c0\u67e5\u662f\u5426\u5904\u7406\u4e0a\u8ff0\u7279\u6b8a\u60c5\u51b5\u3002\u5982\u679c <code>previous</code> \u6ca1\u6709\u79fb\u52a8\uff0c\u5f53\u5faa\u73af\u8df3\u51fa\u65f6\uff0c\u5b83\u5c06\u4ecd\u7136\u5177\u6709\u503c <code>None</code>\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u94fe\u8868\u7684\u5934\u90e8\u88ab\u4fee\u6539\u4e3a\u5f15\u7528 <code>current</code> \u8282\u70b9\u4e4b\u540e\u7684\u8282\u70b9\uff08\u7b2c 14 \u884c\uff09\uff0c\u6709\u6548\u5730\u4ece\u94fe\u8868\u4e2d\u5220\u9664\u7b2c\u4e00\u4e2a\u8282\u70b9\u3002\u7136\u800c\uff0c\u5982\u679c <code>previous</code> \u4e0d\u662f <code>None</code>\uff0c\u8981\u5220\u9664\u7684\u8282\u70b9\u5728\u94fe\u8868\u7684\u67d0\u5904\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c<code>previous</code> \u5f15\u7528\u63d0\u4f9b\u4e86\u5fc5\u987b\u66f4\u6539\u7684 <code>next</code> \u5f15\u7528\u7684\u8282\u70b9\u3002\u7b2c 16 \u884c\u4fee\u6539 <code>previous</code> \u7684 <code>next</code> \u5c5e\u6027\u4ee5\u5b8c\u6210\u5220\u9664\u3002\u6ce8\u610f\uff0c\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u5f15\u7528\u66f4\u6539\u7684\u76ee\u6807\u90fd\u662f <code>current.next</code>\u3002\u4e00\u4e2a\u5e38\u89c1\u7684\u95ee\u9898\u662f\u8fd9\u4e24\u79cd\u60c5\u51b5\u662f\u5426\u4e5f\u5904\u7406\u4e86\u8981\u5220\u9664\u7684\u9879\u4f4d\u4e8e\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\u3002\u6211\u4eec\u7559\u7ed9\u4f60\u81ea\u5df1\u601d\u8003\u3002</p> <p>\u4f60\u53ef\u4ee5\u5728 ActiveCode 1 \u4e2d\u8bd5\u7528 <code>UnorderedList</code> \u7c7b\u3002</p> Activity: 3.21.2.1 \u5b8c\u6574\u7684 UnorderedList \u7c7b<pre><code>class Node:\n    \"\"\"\u94fe\u8868\u7684\u8282\u70b9\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"\u83b7\u53d6\u8282\u70b9\u6570\u636e\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"\u8bbe\u7f6e\u8282\u70b9\u6570\u636e\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"\u5b57\u7b26\u4e32\u8868\u793a\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n\nmy_list.add(31)\nmy_list.add(77)\nmy_list.add(17)\nmy_list.add(93)\nmy_list.add(26)\nmy_list.add(54)\n\nprint(my_list.size())\nprint(my_list.search(93))\nprint(my_list.search(100))\n\nmy_list.add(100)\nprint(my_list.search(100))\nprint(my_list.size())\n\nmy_list.remove(54)\nprint(my_list.size())\nmy_list.remove(93)\nprint(my_list.size())\nmy_list.remove(31)\nprint(my_list.size())\nprint(my_list.search(93))\n\ntry:\n    my_list.remove(27)\nexcept ValueError as ve:\n    print(ve)\n</code></pre> <p>\u5176\u4f59\u65b9\u6cd5 <code>append</code>\u3001<code>insert</code>\u3001<code>index</code> \u548c <code>pop</code> \u7559\u4f5c\u7ec3\u4e60\u3002\u8bf7\u8bb0\u4f4f\uff0c\u6bcf\u4e2a\u65b9\u6cd5\u90fd\u5fc5\u987b\u8003\u8651\u66f4\u6539\u662f\u5426\u53d1\u751f\u5728\u5217\u8868\u5934\u90e8\u6216\u5176\u4ed6\u5730\u65b9\u3002\u6b64\u5916\uff0c<code>insert</code>\u3001<code>index</code> \u548c <code>pop</code> \u9700\u8981\u6211\u4eec\u6307\u5b9a\u5217\u8868\u7684\u4f4d\u7f6e\u3002\u6211\u4eec\u5c06\u5047\u5b9a\u4f4d\u7f6e\u540d\u79f0\u662f\u4ece 0 \u5f00\u59cb\u7684\u6574\u6570\u3002</p> <p>\u81ea\u68c0</p> <p>\u7b2c\u4e00\u90e8\u5206\uff1a\u4e3a UnorderedList \u5b9e\u73b0 <code>append</code> \u65b9\u6cd5\u3002\u4f60\u521b\u5efa\u7684\u65b9\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u591a\u5c11\uff1f</p> self_check_list1<pre><code>class Node:\n    \"\"\"\u94fe\u8868\u7684\u8282\u70b9\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"\u83b7\u53d6\u8282\u70b9\u6570\u636e\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"\u8bbe\u7f6e\u8282\u70b9\u6570\u636e\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"\u5b57\u7b26\u4e32\u8868\u793a\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n</code></pre> <p>\u7b2c\u4e8c\u90e8\u5206\uff1a\u5728\u524d\u4e00\u4e2a\u95ee\u9898\u4e2d\uff0c\u4f60\u5f88\u53ef\u80fd\u521b\u5efa\u4e86\u4e00\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684 <code>append</code> \u65b9\u6cd5\u3002\u5982\u679c\u4f60\u5411 <code>UnorderedList</code> \u7c7b\u6dfb\u52a0\u4e00\u4e2a\u5b9e\u4f8b\u53d8\u91cf\uff0c\u4f60\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1) \u7684 <code>append</code> \u65b9\u6cd5\u3002\u4fee\u6539\u4f60\u7684 <code>append</code> \u65b9\u6cd5\uff0c\u4f7f\u5176\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(1)\u3002\u5c0f\u5fc3\uff01\u4e3a\u4e86\u6b63\u786e\u5b8c\u6210\u8fd9\u9879\u4efb\u52a1\uff0c\u4f60\u53ef\u80fd\u9700\u8981\u8003\u8651\u51e0\u4e2a\u7279\u6b8a\u60c5\u51b5\uff0c\u8fd9\u53ef\u80fd\u8fd8\u9700\u8981\u4f60\u4fee\u6539 <code>add</code> \u65b9\u6cd5\u3002</p> self_check_list2<pre><code>class Node:\n    \"\"\"\u94fe\u8868\u7684\u8282\u70b9\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"\u83b7\u53d6\u8282\u70b9\u6570\u636e\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"\u8bbe\u7f6e\u8282\u70b9\u6570\u636e\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"\u5b57\u7b26\u4e32\u8868\u793a\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n</code></pre> <p>As we suggested above, the unordered list will be built from a collection of nodes, each linked to the next by explicit references. As long as we know where to find the first node (containing the first item), each item after that can be found by successively following the next links. With this in mind, the <code>UnorderedList</code> class must maintain a reference to the first node. <code>Listing 2</code> shows the constructor. Note that each list object will maintain a single reference to the head of the list.</p> Listing 2<pre><code>class UnorderedList:\n\n    def __init__(self):\n        self.head = None\n</code></pre> <p>Initially when we construct a list, there are no items. The assignment statement</p> <pre><code>&gt;&gt;&gt; my_list = UnorderedList()\n</code></pre> <p>creates the linked list representation shown in <code>Figure 5</code>. As we discussed in the <code>Node</code> class, the special reference <code>None</code> will again be used to state that the head of the list does not refer to anything. Eventually, the example list given earlier will be represented by a linked list as shown in <code>Figure 6</code>. The head of the list refers to the first node which contains the first item of the list. In turn, that node holds a reference to the next node (the next item), and so on. It is very important to note that the list class itself does not contain any node objects. Instead it contains a single reference to only the first node in the linked structure.</p> <p> Figure 5: An Empty List </p> <p> Figure 6: A Linked List of Integers </p> <p>The <code>is_empty</code> method, shown in <code>Listing 3</code>, simply checks to see if the head of the list is a reference to <code>None</code>. The result of the boolean expression <code>self.head == None</code> will only be true if there are no nodes in the linked list. Since a new list is empty, the constructor and the check for empty must be consistent with one another. This shows the advantage to using the reference <code>None</code> to denote the end of the linked structure. In Python, <code>None</code> can be compared to any reference. Two references are equal if they both refer to the same object. We will use this often in our remaining methods.</p> Listing 3<pre><code>def is_empty(self):\n    return self.head == None\n</code></pre> <p>So how do we get items into our list? We need to implement the <code>add</code> method. However, before we can do that, we need to address the important question of where in the linked list to place the new item. Since this list is unordered, the specific location of the new item with respect to the other items already in the list is not important. The new item can go anywhere. With that in mind, it makes sense to place the new item in the easiest location possible.</p> <p>Recall that the linked list structure provides us with only one entry point, the head of the list. All of the other nodes can only be reached by accessing the first node and then following <code>next</code> links. This means that the easiest place to add the new node is right at the head, or beginning, of the list. In other words, we will make the new item the first item of the list and the existing items will need to be linked to this new first item so that they follow.</p> <p>The linked list shown in <code>Figure 6</code> was built by calling the <code>add</code> method a number of times.</p> <pre><code>&gt;&gt;&gt; my_list.add(31)\n&gt;&gt;&gt; my_list.add(77)\n&gt;&gt;&gt; my_list.add(17)\n&gt;&gt;&gt; my_list.add(93)\n&gt;&gt;&gt; my_list.add(26)\n&gt;&gt;&gt; my_list.add(54)\n</code></pre> <p>Note that since <code>31</code> is the first item added to the list, it will eventually be the last node on the linked list as every other item is added ahead of it. Also, since <code>54</code> is the last item added, it will become the data value in the first node of the linked list.</p> <p>The <code>add</code> method is shown in <code>Listing 4</code>. Each item of the list must reside in a node object. Line 2 creates a new node and places the item as its data. Now we must complete the process by linking the new node into the existing structure. This requires two steps as shown in <code>Figure 7</code>. Step 1 (line 3) changes the <code>next</code> reference of the new node to refer to the old first node of the list. Now that the rest of the list has been properly attached to the new node, we can modify the head of the list to refer to the new node. The assignment statement in line 4 sets the head of the list.</p> Listing 4<pre><code>def add(self, item):\n    temp = Node(item)\n    temp.set_next(self.head)\n    self.head = temp\n</code></pre> <p> Figure 7: Adding a New Node is a Two-Step Process </p> <p>The order of the two steps described above is very important. What happens if the order of line 3 and line 4 is reversed? If the modification of the head of the list happens first, the result can be seen in <code>Figure 8</code>. Since the head was the only external reference to the list nodes, all of the original nodes are lost and can no longer be accessed.</p> <p> Figure 8: Result of Reversing the Order of the Two Steps </p> <p>The next methods that we will implement\u2013<code>size</code>, <code>search</code>, and <code>remove</code>\u2013are all based on a technique known as linked list traversal. Traversal refers to the process of systematically visiting each node. To do this we use an external reference that starts at the first node in the list. As we visit each node, we move the reference to the next node by \u201ctraversing\u201d the next reference.</p> <p>To implement the <code>size</code> method, we need to traverse the linked list and keep a count of the number of nodes that occurred. <code>Listing 5</code> shows the Python code for counting the number of nodes in the list. The external reference is called <code>current</code> and is initialized to the head of the list in line 2. At the start of the process we have not seen any nodes so the count is set to :math:<code>0</code>. Lines 4\u20136 actually implement the traversal. As long as the current reference has not seen the end of the list (<code>None</code>), we move current along to the next node via the assignment statement in line 6. Again, the ability to compare a reference to <code>None</code> is very useful. Every time current moves to a new node, we add :math:<code>1</code> to <code>count</code>. Finally, <code>count</code> gets returned after the iteration stops. <code>Figure 9</code> shows this process as it proceeds down the list.</p> Listing 5<pre><code>def size(self):\n    current = self.head\n    count = 0\n    while current is not None:\n        count = count + 1\n        current = current.next\n\n    return count\n</code></pre> <p> Figure 9: Traversing the Linked List from the Head to the End </p> <p>Searching for a value in a linked list implementation of an unordered list also uses the traversal technique. As we visit each node in the linked list we will ask whether the data stored there matches the item we are looking for. In this case, however, we may not have to traverse all the way to the end of the list. In fact, if we do get to the end of the list, that means that the item we are looking for must not be present. Also, if we do find the item, there is no need to continue.</p> <p><code>Listing 6</code> shows the implementation for the <code>search</code> method. As in the <code>size</code> method, the traversal is initialized to start at the head of the list (line 2). We continue to iterate over the list as long as there are more nodes to visit. The question in line 4 asks whether the data item is present in the current node. If so, we return <code>True</code> immediately.</p> Listing 6<pre><code>def search(self, item):\n    current = self.head\n    while current is not None:\n        if current.data == item:\n            return True\n        current = current.next\n\n    return False\n</code></pre> <p>As an example, consider invoking the <code>search</code> method looking for the item 17.</p> <pre><code>&gt;&gt;&gt; my_list.search(17)\nTrue\n</code></pre> <p>Since <code>17</code> is in the list, the traversal process needs to move only to the node containing <code>17</code>. At that point, the condition in line 4 becomes <code>True</code> and we return the result of the search. This process can be seen in <code>Figure 10</code>.</p> <p> Figure 10: Successful Search for the Value 17 </p> <p>The <code>remove</code> method requires two logical steps. First, we need to traverse the list looking for the item we want to remove. Once we find the item, we must remove it. If the item is not in the list, our method should raise a <code>ValueError</code>.</p> <p>The first step is very similar to <code>search</code>. Starting with an external reference set to the head of the list, we traverse the links until we discover the item we are looking for.</p> <p>When the item is found and we break out of the loop, <code>current</code> will be a reference to the node containing the item to be removed. But how do we remove it? One possibility would be to replace the value of the item with some marker that suggests that the item is no longer present. The problem with this approach is the number of nodes will no longer match the number of items. It would be much better to remove the item by removing the entire node.</p> <p>In order to remove the node containing the item, we need to modify the link in the previous node so that it refers to the node that comes after <code>current</code>. Unfortunately, there is no way to go backward in the linked list. Since <code>current</code> refers to the node ahead of the node where we would like to make the change, it is too late to make the necessary modification.</p> <p>The solution to this dilemma is to use two external references as we traverse down the linked list. <code>current</code> will behave just as it did before, marking the current location of the traversal. The new reference, which we will call <code>previous</code>, will always travel one node behind <code>current</code>. That way, when <code>current</code> stops at the node to be removed, <code>previous</code> will refer to the proper place in the linked list for the modification.</p> <p><code>Listing 7</code> shows the complete <code>remove</code> method. Lines 2\u20133 assign initial values to the two references. Note that <code>current</code> starts out at the list head as in the other traversal examples. <code>previous</code>, however, is assumed to always travel one node behind <code>current</code>. For this reason, <code>previous</code> starts out with a value of <code>None</code> since there is no node before the head (see <code>Figure 11</code>).</p> <p>In lines 6\u20137 we ask whether the item stored in the current node is the item we wish to remove. If so, we break out of the loop. If we do not find the item, <code>previous</code> and <code>current</code> must both be moved one node ahead. Again, the order of these two statements is crucial. <code>previous</code> must first be moved one node ahead to the location of <code>current</code>. At that point, <code>current</code> can be moved. This process is often referred to as inchworming, as <code>previous</code> must catch up to <code>current</code> before <code>current</code> moves ahead. <code>Figure 12</code> shows the movement of <code>previous</code> and <code>current</code> as they progress down the list looking for the node containing the value 17.</p> Listing 7<pre><code>def remove(self, item):\n    current = self.head\n    previous = None\n\n    while current is not None:\n        if current.data == item:\n            break\n        previous = current\n        current = current.next\n\n    if current is None:\n        raise ValueError(\"{} is not in the list\".format(item))\n    if previous is None:\n        self.head = current.next\n    else:\n        previous.next = current.next\n</code></pre> <p> Figure 11: Initial Values for the <code>previous</code> and <code>current</code> References </p> <p> Figure 12: <code>previous</code> and <code>current</code> Move Down the List </p> <p>Once the searching step of the <code>remove</code> has been completed, we need to remove the node from the linked list. <code>Figure 13</code> shows the link that must be modified. However, there is a special case that needs to be addressed. If the item to be removed happens to be the first item in the list, then <code>current</code> will reference the first node in the linked list. This also means that <code>previous</code> will be <code>None</code>. We said earlier that <code>previous</code> would be referring to the node whose next reference needs to be modified in order to complete the removal. In this case, it is not <code>previous</code> but rather the head of the list that needs to be changed (see <code>Figure 14</code>). Another special case occurs if the item is not in the list. In that case <code>current is None</code> evaluates to <code>True</code> and an error is raised.</p> <p> Figure 13: Removing an Item from the Middle of the List </p> <p> Figure 14: Removing the First Node from the List </p> <p>Line 13 allows us to check whether we are dealing with the special case described above. If <code>previous</code> did not move, it will still have the value <code>None</code> when the loop breaks. In that case, the head of the list is modified to refer to the node after the current node (line 14), in effect removing the first node from the linked list. However, if <code>previous</code> is not <code>None</code>, the node to be removed is somewhere down the linked list structure. In this case the <code>previous</code> reference is providing us with the node whose next reference must be changed. Line 16 modifies the <code>next</code> property of the <code>previous</code> to accomplish the removal. Note that in both cases the destination of the reference change is <code>current.next</code>. One question that often arises is whether the two cases shown here will also handle the situation where the item to be removed is in the last node of the linked list. We leave that for you to consider.</p> <p>You can try out the <code>UnorderedList</code> class in ActiveCode 1.  </p> Activity: 3.21.2.1 The Complete UnorderedList Class<pre><code>class Node:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n\nmy_list.add(31)\nmy_list.add(77)\nmy_list.add(17)\nmy_list.add(93)\nmy_list.add(26)\nmy_list.add(54)\n\nprint(my_list.size())\nprint(my_list.search(93))\nprint(my_list.search(100))\n\nmy_list.add(100)\nprint(my_list.search(100))\nprint(my_list.size())\n\nmy_list.remove(54)\nprint(my_list.size())\nmy_list.remove(93)\nprint(my_list.size())\nmy_list.remove(31)\nprint(my_list.size())\nprint(my_list.search(93))\n\ntry:\n    my_list.remove(27)\nexcept ValueError as ve:\n    print(ve)\n</code></pre> <p>The remaining methods <code>append</code>, <code>insert</code>, <code>index</code>, and <code>pop</code> are left as exercises. Remember that each of these must take into account whether the change is taking place at the head of the list or someplace else. Also, <code>insert</code>, <code>index</code>, and <code>pop</code> require that we name the positions of the list. We will assume that position names are integers starting with 0.</p> <p>Self Check</p> <p>Part I:  Implement the append method for UnorderedList.  What is the time complexity of the method you created?</p> self_check_list1<pre><code>class Node:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n</code></pre> <p>Part II:  In the previous problem, you most likely created an append method that was :math:<code>O(n)</code>  If you add an instance variable to the UnorderedList class you can create an append method that is :math:<code>O(1)</code>.  Modify your append method to be :math:<code>O(1)</code>  Be Careful!  To really do this correctly you will need to consider a couple of special cases that may require you to make a modification to the add method as well.</p> self_check_list2<pre><code>class Node:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass UnorderedList:\n    def __init__(self):\n        self.head = None\n\n    def is_empty(self):\n        return self.head == None\n\n    def add(self, item):\n        temp = Node(item)\n        temp.set_next(self.head)\n        self.head = temp\n\n    def size(self):\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n    def search(self, item):\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            current = current.next\n\n        return False\n\n    def remove(self, item):\n        current = self.head\n        previous = None\n\n        while current is not None:\n            if current.data == item:\n                break\n            previous = current\n            current = current.next\n\n        if current is None:\n            raise ValueError(\"{} is not in the list\".format(item))\n        if previous is None:\n            self.head = current.next\n        else:\n            previous.next = current.next\n\n\nmy_list = UnorderedList()\n</code></pre>"},{"location":"c3/s22/","title":"3.22. \u6709\u5e8f\u5217\u8868\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>3.22. The Ordered List Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u73b0\u5728\u5c06\u8003\u8651\u4e00\u79cd\u79f0\u4e3a \u6709\u5e8f\u5217\u8868 \u7684\u5217\u8868\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4e0a\u9762\u7684\u6574\u6570\u5217\u8868\u662f\u4e00\u4e2a\u6709\u5e8f\u5217\u8868\uff08\u5347\u5e8f\u6392\u5217\uff09\uff0c\u90a3\u4e48\u5b83\u53ef\u4ee5\u5199\u6210 17, 26, 31, 54, 77 \u548c 93\u3002\u7531\u4e8e 17 \u662f\u6700\u5c0f\u7684\u9879\uff0c\u5b83\u5360\u636e\u4e86\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u3002\u540c\u6837\uff0c\u7531\u4e8e 93 \u662f\u6700\u5927\u7684\uff0c\u5b83\u5360\u636e\u4e86\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002</p> <p>\u6709\u5e8f\u5217\u8868\u7684\u7ed3\u6784\u662f\u4e00\u7ec4\u9879\uff0c\u5176\u4e2d\u6bcf\u9879\u90fd\u6839\u636e\u67d0\u4e9b\u57fa\u672c\u7279\u5f81\u5177\u6709\u76f8\u5bf9\u7684\u4f4d\u7f6e\u3002\u6392\u5e8f\u901a\u5e38\u662f\u5347\u5e8f\u6216\u964d\u5e8f\uff0c\u6211\u4eec\u5047\u8bbe\u5217\u8868\u9879\u5177\u6709\u5df2\u7ecf\u5b9a\u4e49\u7684\u6709\u610f\u4e49\u7684\u6bd4\u8f83\u64cd\u4f5c\u3002\u8bb8\u591a\u6709\u5e8f\u5217\u8868\u64cd\u4f5c\u4e0e\u65e0\u5e8f\u5217\u8868\u7684\u64cd\u4f5c\u76f8\u540c\u3002</p> <ul> <li> <p><code>OrderedList()</code> \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7a7a\u6709\u5e8f\u5217\u8868\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u5217\u8868\u3002</p> </li> <li> <p><code>add(item)</code> \u5c06\u4e00\u4e2a\u65b0\u9879\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\uff0c\u786e\u4fdd\u987a\u5e8f\u5f97\u4ee5\u4fdd\u6301\u3002\u5b83\u9700\u8981\u9879\uff0c\u5e76\u4e0d\u8fd4\u56de\u4efb\u4f55\u5185\u5bb9\u3002\u5047\u8bbe\u9879\u4e0d\u5728\u5217\u8868\u4e2d\u3002</p> </li> <li> <p><code>remove(item)</code> \u4ece\u5217\u8868\u4e2d\u5220\u9664\u8be5\u9879\u3002\u5b83\u9700\u8981\u9879\u5e76\u4fee\u6539\u5217\u8868\u3002\u5982\u679c\u8be5\u9879\u4e0d\u5728\u5217\u8868\u4e2d\uff0c\u5b83\u4f1a\u5f15\u53d1\u9519\u8bef\u3002</p> </li> <li> <p><code>search(item)</code> \u5728\u5217\u8868\u4e2d\u641c\u7d22\u8be5\u9879\u3002\u5b83\u9700\u8981\u9879\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>is_empty()</code> \u6d4b\u8bd5\u5217\u8868\u662f\u5426\u4e3a\u7a7a\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>size()</code> \u8fd4\u56de\u5217\u8868\u4e2d\u7684\u9879\u6570\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u3002</p> </li> <li> <p><code>index(item)</code> \u8fd4\u56de\u9879\u5728\u5217\u8868\u4e2d\u7684\u4f4d\u7f6e\u3002\u5b83\u9700\u8981\u9879\uff0c\u5e76\u8fd4\u56de\u7d22\u5f15\u3002\u5047\u8bbe\u8be5\u9879\u5728\u5217\u8868\u4e2d\u3002</p> </li> <li> <p><code>pop()</code> \u5220\u9664\u5e76\u8fd4\u56de\u5217\u8868\u4e2d\u7684\u6700\u540e\u4e00\u9879\u3002\u5b83\u4e0d\u9700\u8981\u4efb\u4f55\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u9879\u3002\u5047\u8bbe\u5217\u8868\u4e2d\u81f3\u5c11\u6709\u4e00\u9879\u3002</p> </li> <li> <p><code>pop(pos)</code> \u5220\u9664\u5e76\u8fd4\u56de\u4f4d\u7f6e <code>pos</code> \u5904\u7684\u9879\u3002\u5b83\u9700\u8981\u4f4d\u7f6e\uff0c\u5e76\u8fd4\u56de\u8be5\u9879\u3002\u5047\u8bbe\u8be5\u9879\u5728\u5217\u8868\u4e2d\u3002</p> </li> </ul> <p>We will now consider a type of list known as an ordered list. For example, if the list of integers shown above were an ordered list (ascending order), then it could be written as 17, 26, 31, 54, 77, and 1.  Since 17 is the smallest item, it occupies the first position in the list. Likewise, since 93 is the largest, it occupies the last position.</p> <p>The structure of an ordered list is a collection of items where each item holds a relative position that is based upon some underlying characteristic of the item. The ordering is typically either ascending or descending and we assume that list items have a meaningful comparison operation that is already defined. Many of the ordered list operations are the same as those of the unordered list.</p> <ul> <li> <p><code>OrderedList()</code> creates a new ordered list that is empty. It needs no parameters and returns an empty list.</p> </li> <li> <p><code>add(item)</code> adds a new item to the list making sure that the order is preserved. It needs the item and returns nothing. Assume the item is not already in the list.</p> </li> <li> <p><code>remove(item)</code> removes the item from the list. It needs the item and modifies the list. It will raise an error if the item is not present in the list.</p> </li> <li> <p><code>search(item)</code> searches for the item in the list. It needs the item and returns a Boolean value.</p> </li> <li> <p><code>is_empty()</code> tests to see whether the list is empty. It needs no parameters and returns a Boolean value.</p> </li> <li> <p><code>size()</code> returns the number of items in the list. It needs no parameters and returns an integer.</p> </li> <li> <p><code>index(item)</code> returns the position of an item in the list. It needs the item and returns the index. Assume the item is in the list.</p> </li> <li> <p><code>pop()</code> removes and returns the last item in the list. It needs nothing and returns an item. Assume the list has at least one item.</p> </li> <li> <p><code>pop(pos)</code> removes and returns the item at position <code>pos</code>. It needs the position and returns the item. Assume the item is in the list.</p> </li> </ul>"},{"location":"c3/s23/","title":"3.23. \u5b9e\u73b0\u6709\u5e8f\u5217\u8868","text":"<p>3.23. Implementing an Ordered List</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e3a\u4e86\u5b9e\u73b0\u6709\u5e8f\u5217\u8868\uff0c\u6211\u4eec\u5fc5\u987b\u8bb0\u4f4f\u9879\u7684\u76f8\u5bf9\u4f4d\u7f6e\u662f\u57fa\u4e8e\u67d0\u4e9b\u57fa\u672c\u7279\u5f81\u3002\u6709\u5e8f\u7684\u6574\u6570\u5217\u8868\uff08\u5982 17, 26, 31, 54, 77 \u548c 93\uff09\u53ef\u4ee5\u901a\u8fc7\u94fe\u63a5\u7ed3\u6784\u6765\u8868\u793a\uff0c\u5982 <code>\u56fe 15</code> \u6240\u793a\u3002\u540c\u6837\uff0c\u8282\u70b9\u548c\u94fe\u63a5\u7ed3\u6784\u975e\u5e38\u9002\u5408\u8868\u793a\u9879\u7684\u76f8\u5bf9\u4f4d\u7f6e\u3002</p> <p> \u56fe 15\uff1a\u6709\u5e8f\u94fe\u8868 </p> <p>\u8981\u5b9e\u73b0 <code>OrderedList</code> \u7c7b\uff0c\u6211\u4eec\u5c06\u4f7f\u7528\u4e0e\u4e4b\u524d\u65e0\u5e8f\u5217\u8868\u76f8\u540c\u7684\u6280\u672f\u3002\u518d\u6b21\uff0c\u7a7a\u5217\u8868\u5c06\u7531\u6307\u5411 <code>None</code> \u7684 <code>head</code> \u5f15\u7528\u8868\u793a\uff08\u53c2\u89c1 <code>Listing 8</code>\uff09\u3002</p> Listing 8<pre><code>class OrderedList:\n    def __init__(self):\n        self.head = None\n</code></pre> <p>\u8003\u8651\u5230\u6709\u5e8f\u5217\u8868\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u5e94\u8be5\u6ce8\u610f\u5230 <code>is_empty</code> \u548c <code>size</code> \u65b9\u6cd5\u53ef\u4ee5\u4e0e\u65e0\u5e8f\u5217\u8868\u4e00\u6837\u5b9e\u73b0\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ea\u5904\u7406\u5217\u8868\u4e2d\u8282\u70b9\u7684\u6570\u91cf\uff0c\u800c\u4e0d\u5173\u5fc3\u5b9e\u9645\u9879\u7684\u503c\u3002\u540c\u6837\uff0c<code>remove</code> \u65b9\u6cd5\u4e5f\u80fd\u6b63\u5e38\u5de5\u4f5c\uff0c\u56e0\u4e3a\u6211\u4eec\u4ecd\u7136\u9700\u8981\u627e\u5230\u9879\uff0c\u7136\u540e\u7ed5\u8fc7\u8282\u70b9\u8fdb\u884c\u5220\u9664\u3002\u5269\u4e0b\u7684\u4e24\u4e2a\u65b9\u6cd5\uff0c<code>search</code> \u548c <code>add</code>, \u5c06\u9700\u8981\u4e00\u4e9b\u4fee\u6539\u3002</p> <p>\u65e0\u5e8f\u94fe\u8868\u7684\u641c\u7d22\u8981\u6c42\u6211\u4eec\u9010\u4e2a\u904d\u5386\u8282\u70b9\uff0c\u76f4\u5230\u627e\u5230\u6240\u5bfb\u627e\u7684\u9879\u6216\u7528\u5c3d\u8282\u70b9\uff08<code>None</code>\uff09\u3002\u5b9e\u9645\u4e0a\uff0c\u5bf9\u4e8e\u6709\u5e8f\u5217\u8868\uff0c\u540c\u6837\u7684\u65b9\u6cd5\u4e5f\u9002\u7528\uff0c\u5982\u679c\u9879\u5728\u5217\u8868\u4e2d\uff0c\u6ca1\u6709\u5fc5\u8981\u505a\u4efb\u4f55\u66f4\u6539\u3002\u7136\u800c\uff0c\u5982\u679c\u9879\u4e0d\u5728\u5217\u8868\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6392\u5e8f\u6765\u5c3d\u53ef\u80fd\u65e9\u5730\u505c\u6b62\u641c\u7d22\u3002</p> <p>\u4f8b\u5982\uff0c<code>\u56fe 16</code> \u663e\u793a\u4e86\u6709\u5e8f\u94fe\u8868\u7684\u641c\u7d22\u8fc7\u7a0b\uff0c\u6b63\u5728\u5bfb\u627e\u503c 45\u3002\u5f53\u6211\u4eec\u4ece\u5217\u8868\u7684\u5934\u90e8\u5f00\u59cb\u904d\u5386\u65f6\uff0c\u9996\u5148\u4e0e 17 \u8fdb\u884c\u6bd4\u8f83\u3002\u7531\u4e8e 17 \u4e0d\u662f\u6211\u4eec\u8981\u627e\u7684\u9879\uff0c\u6211\u4eec\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u8fd9\u91cc\u662f 26\u3002\u540c\u6837\uff0c\u8fd9\u4e5f\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u7ee7\u7eed\u79fb\u52a8\u5230 31\uff0c\u7136\u540e\u5230 54\u3002\u6b64\u65f6\uff0c\u60c5\u51b5\u6709\u6240\u4e0d\u540c\u3002\u7531\u4e8e 54 \u4e0d\u662f\u6211\u4eec\u8981\u627e\u7684\u9879\uff0c\u6211\u4eec\u7684\u65e7\u7b56\u7565\u662f\u7ee7\u7eed\u5411\u524d\u79fb\u52a8\u3002\u7136\u800c\uff0c\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a\u6709\u5e8f\u5217\u8868\uff0c\u60c5\u51b5\u5e76\u975e\u5982\u6b64\u3002\u4e00\u65e6\u8282\u70b9\u4e2d\u7684\u503c\u5927\u4e8e\u6211\u4eec\u8981\u641c\u7d22\u7684\u9879\uff0c\u641c\u7d22\u53ef\u4ee5\u505c\u6b62\u5e76\u8fd4\u56de <code>False</code>\u3002\u56e0\u4e3a\u9879\u4e0d\u53ef\u80fd\u5728\u94fe\u8868\u7684\u540e\u9762\u5b58\u5728\u3002</p> <p> \u56fe 16\uff1a\u641c\u7d22\u6709\u5e8f\u94fe\u8868 </p> <p><code>Listing 9</code> \u663e\u793a\u4e86\u5b8c\u6574\u7684 <code>search</code> \u65b9\u6cd5\u3002\u901a\u8fc7\u6dfb\u52a0\u53e6\u4e00\u4e2a\u68c0\u67e5\uff08\u7b2c 6 \u884c\uff09\uff0c\u5f88\u5bb9\u6613\u5c06\u4e0a\u8ff0\u65b0\u6761\u4ef6\u7eb3\u5165\u5176\u4e2d\u3002\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u5411\u524d\u67e5\u770b\u5217\u8868\uff08\u7b2c 3 \u884c\uff09\u3002\u5982\u679c\u53d1\u73b0\u4efb\u4f55\u8282\u70b9\u5305\u542b\u7684\u6570\u636e\u5927\u4e8e\u6211\u4eec\u8981\u5bfb\u627e\u7684\u9879\uff0c\u6211\u4eec\u5c06\u7acb\u5373\u8fd4\u56de <code>False</code>\u3002\u5176\u4f59\u7684\u884c\u4e0e\u65e0\u5e8f\u5217\u8868\u7684\u641c\u7d22\u76f8\u540c\u3002</p> Listing 9<pre><code>def search(self, item):\n    current = self.head\n    while current is not None:\n        if current.data == item:\n            return True\n        if current.data &gt; item:\n            return False\n        current = current.next\n\n    return False\n</code></pre> <p>\u6700\u91cd\u8981\u7684\u65b9\u6cd5\u4fee\u6539\u5c06\u5728 <code>add</code> \u4e2d\u8fdb\u884c\u3002\u56de\u60f3\u4e00\u4e0b\uff0c\u5bf9\u4e8e\u65e0\u5e8f\u5217\u8868\uff0c<code>add</code> \u65b9\u6cd5\u53ef\u4ee5\u7b80\u5355\u5730\u5c06\u65b0\u8282\u70b9\u653e\u5728\u5217\u8868\u7684\u5934\u90e8\u3002\u8fd9\u662f\u6700\u5bb9\u6613\u8bbf\u95ee\u7684\u70b9\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u5728\u6709\u5e8f\u5217\u8868\u4e2d\u4e0d\u518d\u6709\u6548\u3002\u73b0\u5728\u6709\u5fc5\u8981\u627e\u5230\u65b0\u9879\u5728\u73b0\u6709\u6709\u5e8f\u5217\u8868\u4e2d\u7684\u786e\u5207\u4f4d\u7f6e\u3002</p> <p>\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u6709\u5e8f\u5217\u8868\uff0c\u5305\u542b 17, 26, 54, 77 \u548c 93\uff0c\u5e76\u4e14\u6211\u4eec\u60f3\u8981\u6dfb\u52a0\u503c 31\u3002<code>add</code> \u65b9\u6cd5\u5fc5\u987b\u51b3\u5b9a\u65b0\u9879\u5e94\u8be5\u653e\u5728 26 \u548c 54 \u4e4b\u95f4\u3002<code>\u56fe 17</code> \u663e\u793a\u4e86\u6211\u4eec\u9700\u8981\u7684\u8bbe\u7f6e\u3002\u5982\u524d\u6240\u8ff0\uff0c\u6211\u4eec\u9700\u8981\u904d\u5386\u94fe\u8868\uff0c\u5bfb\u627e\u65b0\u8282\u70b9\u5e94\u8be5\u63d2\u5165\u7684\u4f4d\u7f6e\u3002\u5f53\u6211\u4eec\u7528\u5c3d\u8282\u70b9\uff08<code>current</code> \u53d8\u4e3a <code>None</code>\uff09\u6216\u5f53\u524d\u8282\u70b9\u7684\u503c\u5927\u4e8e\u6211\u4eec\u60f3\u8981\u6dfb\u52a0\u7684\u9879\u65f6\uff0c\u6211\u4eec\u77e5\u9053\u5df2\u7ecf\u627e\u5230\u4e86\u4f4d\u7f6e\u3002\u5728\u6211\u4eec\u7684\u4f8b\u5b50\u4e2d\uff0c\u770b\u5230\u503c 54 \u5c31\u4f1a\u4f7f\u6211\u4eec\u505c\u6b62\u3002</p> <p> \u56fe 17\uff1a\u5411\u6709\u5e8f\u94fe\u8868\u4e2d\u6dfb\u52a0\u9879 </p> <p>\u6b63\u5982\u6211\u4eec\u5728\u65e0\u5e8f\u5217\u8868\u4e2d\u770b\u5230\u7684\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u989d\u5916\u7684\u5f15\u7528\uff0c\u8fd9\u91cc\u79f0\u4e3a <code>previous</code>, \u56e0\u4e3a <code>current</code> \u4e0d\u4f1a\u63d0\u4f9b\u8bbf\u95ee\u5fc5\u987b\u4fee\u6539\u7684\u8282\u70b9\u7684\u80fd\u529b\u3002<code>Listing 10</code> \u663e\u793a\u4e86\u5b8c\u6574\u7684 <code>add</code> \u65b9\u6cd5\u3002\u7b2c 3 \u884c\u548c\u7b2c 4 \u884c\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u5916\u90e8\u5f15\u7528\uff0c\u7b2c 8 \u884c\u548c\u7b2c 9 \u884c\u4f7f <code>previous</code> \u6bcf\u6b21\u8fed\u4ee3\u65f6\u90fd\u8ddf\u5728 <code>current</code> \u540e\u9762\u3002\u4e00\u65e6\u53d1\u73b0\u5f53\u524d\u8282\u70b9\u7684\u503c\u5927\u4e8e\u8981\u6dfb\u52a0\u7684\u9879\uff08\u7b2c 1 \u884c\u7684\u6761\u4ef6\uff09\uff0c\u8fed\u4ee3\u5c06\u7ee7\u7eed\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u5f53\u8fed\u4ee3\u7ed3\u675f\u65f6\uff0c\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u65b0\u8282\u70b9\u7684\u4f4d\u7f6e\u3002</p> <p>\u65b9\u6cd5\u7684\u5176\u4f59\u90e8\u5206\u5b8c\u6210\u4e86 <code>\u56fe 17</code> \u4e2d\u663e\u793a\u7684\u4e24\u6b65\u8fc7\u7a0b\u3002\u4e00\u65e6\u4e3a\u8be5\u9879\u521b\u5efa\u4e86\u65b0\u8282\u70b9\uff0c\u552f\u4e00\u5269\u4e0b\u7684\u95ee\u9898\u662f\u65b0\u8282\u70b9\u662f\u4f1a\u88ab\u6dfb\u52a0\u5230\u94fe\u8868\u7684\u5f00\u5934\uff0c\u8fd8\u662f\u6dfb\u52a0\u5230\u4e2d\u95f4\u67d0\u4e2a\u4f4d\u7f6e\u3002\u540c\u6837\uff0c<code>previous is None</code>\uff08\u7b2c 11 \u884c\uff09\u53ef\u4ee5\u7528\u6765\u63d0\u4f9b\u7b54\u6848\u3002</p> Listing 10<pre><code>def add(self, item):\n    \"\"\"\u6dfb\u52a0\u4e00\u4e2a\u65b0\u8282\u70b9\"\"\"\n    current = self.head\n    previous = None\n    temp = Node(item)\n\n    while current is not None and current.data &lt; item:\n        previous = current\n        current = current.next\n\n    if previous is None:\n        temp.next = self.head\n        self.head = temp\n    else:\n        temp.next = current\n        previous.next = temp\n</code></pre> <p>\u5230\u76ee\u524d\u4e3a\u6b62\u8ba8\u8bba\u7684 <code>OrderedList</code> \u7c7b\u53ef\u4ee5\u5728 ActiveCode 1 \u4e2d\u627e\u5230\u3002\u6211\u4eec\u5c06\u5269\u4f59\u7684\u65b9\u6cd5\u7559\u4f5c\u7ec3\u4e60\u3002\u4f60\u5e94\u8be5\u4ed4\u7ec6\u8003\u8651\u65e0\u5e8f\u5217\u8868\u7684\u5b9e\u73b0\u662f\u5426\u9002\u7528\u4e8e\u6709\u5e8f\u5217\u8868\u3002</p> Activity: 3.23.1 OrderedList \u7c7b<pre><code>class Node:\n    \"\"\"\u94fe\u8868\u7684\u8282\u70b9\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"\u83b7\u53d6\u8282\u70b9\u6570\u636e\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"\u8bbe\u7f6e\u8282\u70b9\u6570\u636e\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"\u83b7\u53d6\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"\u8bbe\u7f6e\u4e0b\u4e00\u4e2a\u8282\u70b9\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"\u5b57\u7b26\u4e32\u8868\u793a\"\"\"\n        return str(self._data)\n\n\nclass OrderedList:\n    \"\"\"\u6709\u5e8f\u94fe\u8868\u7684\u5b9e\u73b0\"\"\"\n    def __init__(self):\n        self.head = None\n\n    def search(self, item):\n        \"\"\"\u641c\u7d22\u5177\u6709\u7279\u5b9a\u503c\u7684\u8282\u70b9\"\"\"\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            if current.data &gt; item:\n                return False\n            current = current.next\n\n        return False\n\n    def add(self, item):\n        \"\"\"\u6dfb\u52a0\u4e00\u4e2a\u65b0\u8282\u70b9\"\"\"\n        current = self.head\n        previous = None\n        temp = Node(item)\n\n        while current is not None and current.data &lt; item:\n            previous = current\n            current = current.next\n\n        if previous is None:\n            temp.next = self.head\n            self.head = temp\n        else:\n            temp.next = current\n            previous.next = temp\n\n    def is_empty(self):\n        \"\"\"\u5217\u8868\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return self.head == None\n\n    def size(self):\n        \"\"\"\u5217\u8868\u7684\u5927\u5c0f\"\"\"\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n\nmy_list = OrderedList()\nmy_list.add(31)\nmy_list.add(77)\nmy_list.add(17)\nmy_list.add(93)\nmy_list.add(26)\nmy_list.add(54)\n\nprint(my_list.size())\nprint(my_list.search(93))\nprint(my_list.search(100))\n</code></pre> <p>In order to implement the ordered list, we must remember that the relative positions of the items are based on some underlying characteristic. The ordered list of integers given above (17, 26, 31, 54, 77, and 93) can be represented by a linked structure as shown in <code>Figure 15</code>. Again, the node and link structure is ideal for representing the relative positioning of the items.</p> <p> Figure 15: An Ordered Linked List </p> <p>To implement the <code>OrderedList</code> class, we will use the same technique as seen previously with unordered lists. Once again, an empty list will be denoted by a <code>head</code> reference to <code>None</code> (see <code>Listing 8</code>).</p> Listing 8<pre><code>class OrderedList:\n    def __init__(self):\n        self.head = None\n</code></pre> <p>As we consider the operations for the ordered list, we should note that the <code>is_empty</code> and <code>size</code> methods can be implemented the same as with unordered lists since they deal only with the number of nodes in the list without regard to the actual item values. Likewise, the <code>remove</code> method will work just fine since we still need to find the item and then link around the node to remove it. The two remaining methods, <code>search</code> and <code>add</code>, will require some modification.</p> <p>The search of an unordered linked list required that we traverse the nodes one at a time until we either find the item we are looking for or run out of nodes (<code>None</code>). It turns out that the same approach would work with the ordered list and no changes are necessary if the item is in the list. However, in the case where the item is not in the list, we can take advantage of the ordering to stop the search as soon as possible.</p> <p>For example, <code>Figure 16</code> shows the ordered linked list as a search is looking for the value 45. As we traverse, starting at the head of the list, we first compare against 17. Since 17 is not the item we are looking for, we move to the next node, in this case 26. Again, this is not what we want, so we move on to 31 and then on to 54. Now, at this point, something is different. Since 54 is not the item we are looking for, our former strategy would be to move forward. However, due to the fact that this is an ordered list, that will not be necessary. Once the value in the node becomes greater than the item we are searching for, the search can stop and return <code>False</code>. There is no way the item could exist further out in the linked list.</p> <p> Figure 16: Searching an Ordered Linked List </p> <p><code>Listing 9</code> shows the complete <code>search</code> method. It is easy to incorporate the new condition discussed above by adding another check (line 6). We can continue to look forward in the list (line 3). If any node is ever discovered that contains data greater than the item we are looking for, we will immediately return <code>False</code>. The remaining lines are identical to the unordered list search.</p> Listing 9<pre><code>def search(self,item):\n    current = self.head\n    while current is not None:\n        if current.data == item:\n            return True\n        if current.data &gt; item:\n            return False\n        current = current.next\n\n    return False\n</code></pre> <p>The most significant method modification will take place in <code>add</code>. Recall that for unordered lists, the <code>add</code> method could simply place a new node at the head of the list. It was the easiest point of access. Unfortunately, this will no longer work with ordered lists. It is now necessary that we discover the specific place where a new item belongs in the existing ordered list.</p> <p>Assume we have the ordered list consisting of 17, 26, 54, 77, and 93 and we want to add the value 31. The <code>add</code> method must decide that the new item belongs between 26 and 54. <code>Figure 17</code> shows the setup that we need. As we explained earlier, we need to traverse the linked list looking for the place where the new node will be added. We know we have found that place when either we run out of nodes (<code>current</code> becomes <code>None</code>) or the value of the current node becomes greater than the item we wish to add. In our example, seeing the value 54 causes us to stop.</p> <p> Figure 17: Adding an Item to an Ordered Linked List </p> <p>As we saw with unordered lists, it is necessary to have an additional reference, again called <code>previous</code>, since <code>current</code> will not provide access to the node that must be modified. <code>Listing 10</code> shows the complete <code>add</code> method. Lines 3\u20134 set up the two external references and lines 8\u20139 again allow <code>previous</code> to follow one node behind <code>current</code> every time through the iteration. The condition (line 1) allows the iteration to continue as long as there are more nodes and the value in the current node is not larger than the item. In either case, when the iteration fails, we have found the location for the new node.</p> <p>The remainder of the method completes the two-step process shown in <code>Figure 17</code>. Once a new node has been created for the item, the only remaining question is whether the new node will be added at the beginning of the linked list or some place in the middle. Again, <code>previous is None</code> (line 11) can be used to provide the answer.</p> Listing 10<pre><code>def add(self, item):\n    \"\"\"Add a new node\"\"\"\n    current = self.head\n    previous = None\n    temp = Node(item)\n\n    while current is not None and current.data &lt; item:\n        previous = current\n        current = current.next\n\n    if previous is None:\n        temp.next = self.head\n        self.head = temp\n    else:\n        temp.next = current\n        previous.next = temp\n</code></pre> <p>The <code>OrderedList</code> class with methods discussed thus far can be found in ActiveCode 1. We leave the remaining methods as exercises. You should carefully consider whether the unordered implementations will work given that the list is now ordered.</p> Activity: 3.23.1 OrderedList Class Thus Far<pre><code>class Node:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass OrderedList:\n    \"\"\"Ordered linked list implementation\"\"\"\n    def __init__(self):\n        self.head = None\n\n    def search(self, item):\n        \"\"\"Search for a node with a specific value\"\"\"\n        current = self.head\n        while current is not None:\n            if current.data == item:\n                return True\n            if current.data &gt; item:\n                return False\n            current = current.next\n\n        return False\n\n    def add(self, item):\n        \"\"\"Add a new node\"\"\"\n        current = self.head\n        previous = None\n        temp = Node(item)\n\n        while current is not None and current.data &lt; item:\n            previous = current\n            current = current.next\n\n        if previous is None:\n            temp.next = self.head\n            self.head = temp\n        else:\n            temp.next = current\n            previous.next = temp\n\n    def is_empty(self):\n        \"\"\"Is the list empty\"\"\"\n        return self.head == None\n\n    def size(self):\n        \"\"\"Size of the list\"\"\"\n        current = self.head\n        count = 0\n        while current is not None:\n            count = count + 1\n            current = current.next\n\n        return count\n\n\nmy_list = OrderedList()\nmy_list.add(31)\nmy_list.add(77)\nmy_list.add(17)\nmy_list.add(93)\nmy_list.add(26)\nmy_list.add(54)\n\nprint(my_list.size())\nprint(my_list.search(93))\nprint(my_list.search(100))\n</code></pre>"},{"location":"c3/s23/#3231-\u94fe\u8868\u5206\u6790","title":"3.23.1. \u94fe\u8868\u5206\u6790","text":"<p>3.23.1. Analysis of Linked Lists</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e3a\u4e86\u5206\u6790\u94fe\u8868\u64cd\u4f5c\u7684\u590d\u6742\u6027\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u8fd9\u4e9b\u64cd\u4f5c\u662f\u5426\u9700\u8981\u904d\u5386\u3002\u8003\u8651\u4e00\u4e2a\u6709 \\(n\\) \u4e2a\u8282\u70b9\u7684\u94fe\u8868\u3002<code>is_empty</code> \u65b9\u6cd5\u7684\u590d\u6742\u5ea6\u662f \\(O(1)\\)\uff0c\u56e0\u4e3a\u53ea\u9700\u8981\u4e00\u6b65\u68c0\u67e5\u5934\u5f15\u7528\u662f\u5426\u4e3a <code>None</code>\u3002\u53e6\u4e00\u65b9\u9762\uff0c<code>size</code> \u65b9\u6cd5\u603b\u662f\u9700\u8981 \\(n\\) \u6b65\uff0c\u56e0\u4e3a\u6ca1\u6709\u529e\u6cd5\u77e5\u9053\u94fe\u8868\u4e2d\u6709\u591a\u5c11\u4e2a\u8282\u70b9\u800c\u4e0d\u4ece\u5934\u5230\u5c3e\u904d\u5386\u3002\u56e0\u6b64\uff0c<code>size</code> \u7684\u590d\u6742\u5ea6\u662f \\(O(n)\\)\u3002\u5411\u65e0\u5e8f\u94fe\u8868\u6dfb\u52a0\u4e00\u4e2a\u9879\u76ee\u7684\u590d\u6742\u5ea6\u59cb\u7ec8\u662f \\(O(1)\\)\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u9700\u5c06\u65b0\u8282\u70b9\u653e\u7f6e\u5728\u94fe\u8868\u7684\u5934\u90e8\u3002\u7136\u800c\uff0c<code>search</code> \u548c <code>remove</code> \u4ee5\u53ca\u6709\u5e8f\u94fe\u8868\u4e2d\u7684 <code>add</code> \u90fd\u9700\u8981\u904d\u5386\u8fc7\u7a0b\u3002\u5c3d\u7ba1\u5e73\u5747\u60c5\u51b5\u4e0b\u5b83\u4eec\u53ef\u80fd\u53ea\u9700\u904d\u5386\u94fe\u8868\u7684\u4e00\u534a\u8282\u70b9\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u7684\u590d\u6742\u5ea6\u90fd\u662f \\(O(n)\\)\uff0c\u56e0\u4e3a\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e2a\u65b9\u6cd5\u90fd\u53ef\u80fd\u5904\u7406\u94fe\u8868\u4e2d\u7684\u6bcf\u4e2a\u8282\u70b9\u3002</p> <p>\u4f60\u53ef\u80fd\u8fd8\u6ce8\u610f\u5230\uff0c\u8fd9\u79cd\u5b9e\u73b0\u7684\u6027\u80fd\u4e0e\u4e4b\u524d\u63d0\u5230\u7684 Python \u5217\u8868\u7684\u5b9e\u9645\u6027\u80fd\u4e0d\u540c\u3002\u8fd9\u8868\u660e\u94fe\u8868\u5e76\u4e0d\u662f Python \u5217\u8868\u7684\u5b9e\u73b0\u65b9\u5f0f\u3002Python \u5217\u8868\u7684\u5b9e\u9645\u5b9e\u73b0\u57fa\u4e8e\u6570\u7ec4\u7684\u6982\u5ff5\u3002\u6211\u4eec\u5c06\u5728\u6700\u540e\u4e00\u7ae0\u4e2d\u8be6\u7ec6\u8ba8\u8bba\u8fd9\u4e00\u70b9\u3002</p> <p>To analyze the complexity of the linked list operations, we need to consider whether they require traversal. Consider a linked list that has \\(n\\) nodes. The <code>is_empty</code> method is \\(O(1)\\) since it requires one step to check the head reference for <code>None</code>. <code>size</code>, on the other hand, will always require \\(n\\) steps since there is no way to know how many nodes are in the linked list without traversing from head to end. Therefore, <code>size</code> is \\(O(n)\\). Adding an item to an unordered list will always be \\(O(1)\\) since we simply place the new node at the head of the linked list. However, <code>search</code> and <code>remove</code>, as well as <code>add</code> for an ordered list, all require the traversal process. Although on average they may need to traverse only half of the nodes, these methods are all \\(O(n)\\) since in the worst case each will process every node in the list.</p> <p>You may also have noticed that the performance of this implementation differs from the actual performance given earlier for Python lists. This suggests that linked lists are not the way Python lists are implemented. The actual implementation of a Python list is based on the notion of an array. We discuss this in more detail in the last chapter.</p>"},{"location":"c3/s24/","title":"3.24. \u603b\u7ed3","text":"<p>3.24. Summary</p> \u4e2d\u6587\u82f1\u6587 <ul> <li> <p>\u7ebf\u6027\u6570\u636e\u7ed3\u6784\u4ee5\u6709\u5e8f\u7684\u65b9\u5f0f\u7ef4\u62a4\u5176\u6570\u636e\u3002</p> </li> <li> <p>\u6808\u662f\u7b80\u5355\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7ef4\u6301 LIFO\uff08\u540e\u8fdb\u5148\u51fa\uff09\u987a\u5e8f\u3002</p> </li> <li> <p>\u6808\u7684\u57fa\u672c\u64cd\u4f5c\u662f <code>push</code>\u3001<code>pop</code> \u548c <code>is_empty</code>\u3002</p> </li> <li> <p>\u961f\u5217\u662f\u7b80\u5355\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7ef4\u6301 FIFO\uff08\u5148\u8fdb\u5148\u51fa\uff09\u987a\u5e8f\u3002</p> </li> <li> <p>\u961f\u5217\u7684\u57fa\u672c\u64cd\u4f5c\u662f <code>enqueue</code>\u3001<code>dequeue</code> \u548c <code>is_empty</code>\u3002</p> </li> <li> <p>\u524d\u7f00\u3001 infix\uff08\u4e2d\u7f00\uff09\u548c\u540e\u7f00\u662f\u8868\u8fbe\u5f0f\u7684\u4e09\u79cd\u5199\u6cd5\u3002</p> </li> <li> <p>\u6808\u5728\u8bbe\u8ba1\u7b97\u6cd5\u4ee5\u8bc4\u4f30\u548c\u8f6c\u6362\u8868\u8fbe\u5f0f\u65f6\u975e\u5e38\u6709\u7528\u3002</p> </li> <li> <p>\u6808\u53ef\u4ee5\u63d0\u4f9b\u53cd\u8f6c\u7279\u6027\u3002</p> </li> <li> <p>\u961f\u5217\u53ef\u4ee5\u5e2e\u52a9\u6784\u5efa\u65f6\u95f4\u6a21\u62df\u3002</p> </li> <li> <p>\u6a21\u62df\u4f7f\u7528\u968f\u673a\u6570\u751f\u6210\u5668\u521b\u5efa\u73b0\u5b9e\u60c5\u51b5\uff0c\u5e76\u5141\u8bb8\u6211\u4eec\u56de\u7b54\u201c\u5982\u679c\u201d\u7c7b\u578b\u7684\u95ee\u9898\u3002</p> </li> <li> <p>\u53cc\u7aef\u961f\u5217\uff08Deque\uff09\u662f\u5141\u8bb8\u6df7\u5408\u884c\u4e3a\uff08\u5982\u6808\u548c\u961f\u5217\uff09\u7684\u6570\u636e\u7ed3\u6784\u3002</p> </li> <li> <p>\u53cc\u7aef\u961f\u5217\u7684\u57fa\u672c\u64cd\u4f5c\u662f <code>add_front</code>\u3001<code>add_rear</code>\u3001<code>remove_front</code>\u3001<code>remove_rear</code> \u548c <code>is_empty</code>\u3002</p> </li> <li> <p>\u5217\u8868\u662f\u9879\u7684\u96c6\u5408\uff0c\u6bcf\u4e2a\u9879\u90fd\u6709\u4e00\u4e2a\u76f8\u5bf9\u4f4d\u7f6e\u3002</p> </li> <li> <p>\u94fe\u8868\u5b9e\u73b0\u7ef4\u62a4\u903b\u8f91\u987a\u5e8f\uff0c\u800c\u65e0\u9700\u7269\u7406\u5b58\u50a8\u8981\u6c42\u3002</p> </li> <li> <p>\u94fe\u8868\u5934\u90e8\u7684\u4fee\u6539\u662f\u4e00\u4e2a\u7279\u6b8a\u60c5\u51b5\u3002</p> </li> </ul> <ul> <li> <p>Linear data structures maintain their data in an ordered fashion.</p> </li> <li> <p>Stacks are simple data structures that maintain a LIFO (last in, first out) ordering.</p> </li> <li> <p>The fundamental operations for a stack are <code>push</code>, <code>pop</code>, and <code>is_empty</code>.</p> </li> <li> <p>Queues are simple data structures that maintain a FIFO (first in, first out) ordering.</p> </li> <li> <p>The fundamental operations for a queue are <code>enqueue</code>, <code>dequeue</code>, and <code>is_empty</code>.</p> </li> <li> <p>Prefix, infix, and postfix are all ways to write expressions.</p> </li> <li> <p>Stacks are very useful for designing algorithms to evaluate and translate expressions.</p> </li> <li> <p>Stacks can provide a reversal characteristic.</p> </li> <li> <p>Queues can assist in the construction of timing simulations.</p> </li> <li> <p>Simulations use random number generators to create a real-life situation and allow us to answer \u201cwhat if\u201d types of questions.</p> </li> <li> <p>Deques are data structures that allow hybrid behavior like that of stacks and queues.</p> </li> <li> <p>The fundamental operations for a deque are <code>add_front</code>, <code>add_rear</code>, <code>remove_front</code>, <code>remove_rear</code>, and <code>is_empty</code>.</p> </li> <li> <p>Lists are collections of items where each item holds a relative position.</p> </li> <li> <p>A linked list implementation maintains logical order without requiring physical storage requirements.</p> </li> <li> <p>Modification to the head of the linked list is a special case.</p> </li> </ul>"},{"location":"c3/s25/","title":"3.25. \u5173\u952e\u8bcd\u672f\u8bed","text":"<p>3.25. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - balanced parentheses last in, first out (LIFO) postfix data field linear data structure precedence deque linked list prefix first in, first out (FIFO) linked list traversal queue fully parenthesized list simulation head node stack infix palindrome - - - balanced parentheses last in, first out (LIFO) postfix data field linear data structure precedence deque linked list prefix first in, first out (FIFO) linked list traversal queue fully parenthesized list simulation head node stack infix palindrome"},{"location":"c3/s26/","title":"3.26. \u7ec3\u4e60","text":"<p>3.26. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>\u4f7f\u7528\u9664\u4ee5 2 \u7b97\u6cd5\u5c06\u4ee5\u4e0b\u503c\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u3002\u663e\u793a\u4f59\u6570\u7684\u5806\u6808\u3002</p> <ul> <li>17</li> <li>45</li> <li>96</li> </ul> </li> <li> <p>\u5c06\u4ee5\u4e0b\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u524d\u7f00\uff08\u4f7f\u7528\u5b8c\u6574\u7684\u62ec\u53f7\uff09\uff1a</p> <ul> <li> <p>(A + B) \u00b7 (C + D) \u00b7 (E + F)</p> </li> <li> <p>A + ((B + C) \u00b7 (D + E))</p> </li> <li> <p>A \u00b7 B \u00b7 C \u00b7 D + E + F</p> </li> </ul> </li> <li> <p>\u5c06\u4e0a\u8ff0\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u540e\u7f00\uff08\u4f7f\u7528\u5b8c\u6574\u7684\u62ec\u53f7\uff09\u3002</p> </li> <li> <p>\u4f7f\u7528\u76f4\u63a5\u8f6c\u6362\u7b97\u6cd5\u5c06\u4e0a\u8ff0\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u540e\u7f00\u3002\u663e\u793a\u8f6c\u6362\u8fc7\u7a0b\u4e2d\u5806\u6808\u7684\u72b6\u6001\u3002</p> </li> <li> <p>\u8bc4\u4f30\u4ee5\u4e0b\u540e\u7f00\u8868\u8fbe\u5f0f\u3002\u663e\u793a\u6bcf\u4e2a\u64cd\u4f5c\u6570\u548c\u64cd\u4f5c\u7b26\u5904\u7406\u65f6\u7684\u5806\u6808\u72b6\u6001\u3002</p> <ul> <li> <p>2 3 \u00b7 4 +</p> </li> <li> <p>1 2 + 3 + 4 + 5 +</p> </li> <li> <p>1 2 3 4 5 \u00b7 + \u00b7 +</p> </li> </ul> </li> <li> <p>\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u961f\u5217 ADT \u7684\u53e6\u4e00\u79cd\u65b9\u6cd5\u662f\u5c06\u961f\u5217\u7684\u5c3e\u90e8\u653e\u5728\u5217\u8868\u7684\u672b\u5c3e\u3002\u8fd9\u5bf9 Big-O \u6027\u80fd\u610f\u5473\u7740\u4ec0\u4e48\uff1f</p> </li> <li> <p>\u5982\u679c\u53cd\u5411\u6267\u884c\u94fe\u8868 <code>add</code> \u65b9\u6cd5\u7684\u4e24\u4e2a\u6b65\u9aa4\uff0c\u4f1a\u4ea7\u751f\u4ec0\u4e48\u7ed3\u679c\uff1f\u7ed3\u679c\u662f\u4ec0\u4e48\u7c7b\u578b\u7684\u5f15\u7528\uff1f\u53ef\u80fd\u4f1a\u51fa\u73b0\u54ea\u4e9b\u95ee\u9898\uff1f</p> </li> <li> <p>\u89e3\u91ca\u5f53\u8981\u5220\u9664\u7684\u9879\u5728\u94fe\u8868\u7684\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u94fe\u8868 <code>remove</code> \u65b9\u6cd5\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002</p> </li> <li> <p>\u89e3\u91ca\u5f53\u9879\u5728\u94fe\u8868\u4e2d\u552f\u4e00\u7684\u8282\u70b9\u65f6\uff0c<code>remove</code> \u65b9\u6cd5\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002</p> </li> <li> <p>\u4fee\u6539\u4e2d\u7f00\u5230\u540e\u7f00\u7684\u7b97\u6cd5\uff0c\u4f7f\u5176\u80fd\u591f\u5904\u7406\u9519\u8bef\u3002</p> </li> <li> <p>\u4fee\u6539\u540e\u7f00\u8bc4\u4f30\u7b97\u6cd5\uff0c\u4f7f\u5176\u80fd\u591f\u5904\u7406\u9519\u8bef\u3002</p> </li> <li> <p>\u5b9e\u73b0\u4e00\u4e2a\u76f4\u63a5\u7684\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8bc4\u4f30\u5668\uff0c\u7ed3\u5408\u4e2d\u7f00\u5230\u540e\u7f00\u8f6c\u6362\u548c\u540e\u7f00\u8bc4\u4f30\u7b97\u6cd5\u7684\u529f\u80fd\u3002\u4f60\u7684\u8bc4\u4f30\u5668\u5e94\u8be5\u4ece\u5de6\u5230\u53f3\u5904\u7406\u4e2d\u7f00\u6807\u8bb0\uff0c\u5e76\u4f7f\u7528\u4e24\u4e2a\u5806\u6808\uff0c\u4e00\u4e2a\u7528\u4e8e\u64cd\u4f5c\u7b26\uff0c\u4e00\u4e2a\u7528\u4e8e\u64cd\u4f5c\u6570\uff0c\u6765\u6267\u884c\u8bc4\u4f30\u3002</p> </li> <li> <p>\u5c06\u524d\u4e00\u4e2a\u95ee\u9898\u4e2d\u7684\u76f4\u63a5\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8bc4\u4f30\u5668\u8f6c\u6362\u4e3a\u8ba1\u7b97\u5668\u3002</p> </li> <li> <p>\u5b9e\u73b0\u961f\u5217 ADT\uff0c\u4f7f\u7528\u5217\u8868\u5c06\u961f\u5217\u7684\u5c3e\u90e8\u653e\u5728\u5217\u8868\u7684\u672b\u5c3e\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e00\u4e2a\u5b9e\u9a8c\uff0c\u4ee5\u5bf9\u6bd4\u4e24\u4e2a\u961f\u5217\u5b9e\u73b0\u7684\u6027\u80fd\u3002\u4f60\u80fd\u4ece\u8fd9\u6837\u7684\u5b9e\u9a8c\u4e2d\u5b66\u5230\u4ec0\u4e48\uff1f</p> </li> <li> <p>\u4fee\u6539\u70ed\u571f\u8c46\u6a21\u62df\u7a0b\u5e8f\uff0c\u5141\u8bb8\u968f\u673a\u9009\u62e9\u8ba1\u6570\u503c\uff0c\u4f7f\u6bcf\u6b21\u4f20\u9012\u4e0d\u518d\u4ece\u524d\u4e00\u6b21\u9884\u6d4b\u3002</p> </li> <li> <p>\u8003\u8651\u4e00\u4e2a\u73b0\u5b9e\u751f\u6d3b\u4e2d\u7684\u60c5\u51b5\u3002\u63d0\u51fa\u4e00\u4e2a\u95ee\u9898\uff0c\u7136\u540e\u8bbe\u8ba1\u4e00\u4e2a\u53ef\u4ee5\u5e2e\u52a9\u56de\u7b54\u5b83\u7684\u6a21\u62df\u3002\u53ef\u80fd\u7684\u60c5\u51b5\u5305\u62ec\uff1a</p> <ul> <li> <p>\u6392\u961f\u6d17\u8f66\u7684\u6c7d\u8f66</p> </li> <li> <p>\u8d85\u5e02\u7ed3\u8d26\u7684\u987e\u5ba2</p> </li> <li> <p>\u5728\u8dd1\u9053\u4e0a\u8d77\u98de\u548c\u964d\u843d\u7684\u98de\u673a</p> </li> <li> <p>\u94f6\u884c\u51fa\u7eb3\u5458</p> </li> </ul> <p>\u786e\u4fdd\u8bf4\u660e\u4f60\u505a\u51fa\u7684\u4efb\u4f55\u5047\u8bbe\uff0c\u5e76\u63d0\u4f9b\u5fc5\u987b\u8003\u8651\u7684\u4efb\u4f55\u6982\u7387\u6570\u636e\u3002</p> </li> <li> <p>\u5b9e\u73b0\u4e00\u4e2a\u57fa\u6570\u6392\u5e8f\u673a\u5668\u3002\u57fa\u6570\u6392\u5e8f\u5bf9\u4e8e\u5341\u8fdb\u5236\u6574\u6570\u662f\u4e00\u79cd\u673a\u68b0\u6392\u5e8f\u6280\u672f\uff0c\u4f7f\u7528\u4e00\u4e2a\u4e3b\u7bb1\u548c 10 \u4e2a\u6570\u5b57\u7bb1\u3002\u6bcf\u4e2a\u7bb1\u5b50\u50cf\u4e00\u4e2a\u961f\u5217\u4e00\u6837\u7ef4\u62a4\u5176\u503c\u7684\u5230\u8fbe\u987a\u5e8f\u3002\u7b97\u6cd5\u4ece\u5c06\u6bcf\u4e2a\u6570\u5b57\u653e\u5165\u4e3b\u7bb1\u5f00\u59cb\u3002\u7136\u540e\u6309\u4f4d\u8003\u8651\u6bcf\u4e2a\u503c\u3002\u5982\u679c\u8003\u8651\u7684\u662f\u4e2a\u4f4d\u6570\u5b57\uff0c534 \u88ab\u653e\u5165\u6570\u5b57\u7bb1 4 \u4e2d\uff0c667 \u88ab\u653e\u5165\u6570\u5b57\u7bb1 7 \u4e2d\u3002\u4e00\u65e6\u6240\u6709\u503c\u90fd\u653e\u5165\u4e86\u5bf9\u5e94\u7684\u6570\u5b57\u7bb1\u4e2d\uff0c\u4ece\u7bb1\u5b50 0 \u5230\u7bb1\u5b50 9 \u6536\u96c6\u503c\uff0c\u5e76\u5c06\u5b83\u4eec\u653e\u56de\u4e3b\u7bb1\u3002\u8be5\u8fc7\u7a0b\u7ee7\u7eed\u8fdb\u884c\u5230\u5341\u4f4d\u6570\u5b57\u3001\u767e\u4f4d\u6570\u5b57\u7b49\u3002\u5904\u7406\u5b8c\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u540e\uff0c\u4e3b\u7bb1\u4e2d\u7684\u503c\u5c06\u6309\u987a\u5e8f\u6392\u5217\u3002</p> </li> <li> <p>HTML \u6807\u7b7e\u7684\u5339\u914d\u95ee\u9898\u662f\u53e6\u4e00\u4e2a\u4f8b\u5b50\u3002\u5728 HTML \u4e2d\uff0c\u6807\u7b7e\u6709\u5f00\u6807\u7b7e\u548c\u95ed\u6807\u7b7e\u4e24\u79cd\u5f62\u5f0f\uff0c\u5fc5\u987b\u5e73\u8861\u4ee5\u6b63\u786e\u63cf\u8ff0\u7f51\u9875\u6587\u6863\u3002\u8fd9\u4e2a\u975e\u5e38\u7b80\u5355\u7684 HTML \u6587\u6863\uff1a</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;\n        Example\n        &lt;/title&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;h1&gt;Hello, world&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>\u65e8\u5728\u5c55\u793a HTML \u8bed\u8a00\u4e2d\u6807\u7b7e\u7684\u5339\u914d\u548c\u5d4c\u5957\u7ed3\u6784\u3002\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u68c0\u67e5 HTML \u6587\u6863\u4e2d\u7684\u5f00\u95ed\u6807\u7b7e\u662f\u5426\u6b63\u786e\u3002</p> </li> <li> <p>\u6269\u5c55 Listing 3.15 \u4e2d\u7684\u7a0b\u5e8f\uff0c\u4ee5\u5904\u7406\u5e26\u7a7a\u683c\u7684\u56de\u6587\u3002\u4f8b\u5982\uff0cI PREFER PI \u662f\u4e00\u4e2a\u56de\u6587\uff0c\u5982\u679c\u5ffd\u7565\u7a7a\u767d\u5b57\u7b26\uff0c\u5b83\u6b63\u5411\u548c\u53cd\u5411\u8bfb\u6cd5\u76f8\u540c\u3002</p> </li> <li> <p>\u5b9e\u73b0 <code>size</code> \u65b9\u6cd5\u65f6\uff0c\u6211\u4eec\u8ba1\u7b97\u4e86\u5217\u8868\u4e2d\u7684\u8282\u70b9\u6570\u91cf\u3002\u53e6\u4e00\u79cd\u7b56\u7565\u662f\u5728\u5217\u8868\u5934\u90e8\u5b58\u50a8\u8282\u70b9\u6570\u91cf\u4f5c\u4e3a\u9644\u52a0\u6570\u636e\u3002\u4fee\u6539 <code>UnorderedList</code> \u7c7b\u4ee5\u5305\u62ec\u8fd9\u4e9b\u4fe1\u606f\uff0c\u5e76\u91cd\u5199 <code>size</code> \u65b9\u6cd5\u3002</p> </li> <li> <p>\u5b9e\u73b0 <code>remove</code> \u65b9\u6cd5\uff0c\u4f7f\u5176\u5728\u9879\u4e0d\u5728\u5217\u8868\u4e2d\u65f6\u4e5f\u80fd\u6b63\u786e\u5de5\u4f5c\u3002</p> </li> <li> <p>\u4fee\u6539\u5217\u8868\u7c7b\u4ee5\u5141\u8bb8\u91cd\u590d\u9879\u3002\u8fd9\u79cd\u53d8\u5316\u5c06\u5f71\u54cd\u54ea\u4e9b\u65b9\u6cd5\uff1f</p> </li> <li> <p>\u5728 <code>UnorderedList</code> \u7c7b\u4e2d\u5b9e\u73b0 <code>__str__</code> \u65b9\u6cd5\u3002\u4ec0\u4e48\u662f\u5217\u8868\u7684\u826f\u597d\u5b57\u7b26\u4e32\u8868\u793a\uff1f</p> </li> <li> <p>\u5b9e\u73b0 <code>__str__</code> \u65b9\u6cd5\uff0c\u4f7f\u5217\u8868\u4ee5 Python \u7684\u65b9\u5f0f\u663e\u793a\uff08\u4f7f\u7528\u65b9\u62ec\u53f7\uff09\u3002</p> </li> <li> <p>\u5b9e\u73b0\u672a\u6392\u5e8f\u5217\u8868 ADT \u4e2d\u5b9a\u4e49\u7684\u5269\u4f59\u64cd\u4f5c\uff08<code>append</code>\u3001<code>index</code>\u3001<code>pop</code>\u3001<code>insert</code>\uff09\u3002</p> </li> <li> <p>\u4e3a <code>UnorderedList</code> \u7c7b\u5b9e\u73b0 <code>slice</code> \u65b9\u6cd5\u3002\u5b83\u5e94\u63a5\u53d7\u4e24\u4e2a\u53c2\u6570 <code>start</code> \u548c <code>stop</code>\uff0c\u5e76\u8fd4\u56de\u4ece <code>start</code> \u4f4d\u7f6e\u5f00\u59cb\u5230\u4f46\u4e0d\u5305\u62ec <code>stop</code> \u4f4d\u7f6e\u7684\u5217\u8868\u526f\u672c\u3002</p> </li> <li> <p>\u5b9e\u73b0\u6709\u5e8f\u5217\u8868 ADT \u4e2d\u5b9a\u4e49\u7684\u5269\u4f59\u64cd\u4f5c\u3002</p> </li> <li> <p>\u8003\u8651\u65e0\u5e8f\u5217\u8868\u548c\u6709\u5e8f\u5217\u8868\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u662f\u5426\u53ef\u4ee5\u4f7f\u7528\u7ee7\u627f\u6765\u6784\u5efa\u66f4\u9ad8\u6548\u7684\u5b9e\u73b0\uff1f\u5b9e\u73b0\u8fd9\u4e2a\u7ee7\u627f\u5c42\u6b21\u7ed3\u6784\u3002</p> </li> <li> <p>\u4f7f\u7528\u94fe\u8868\u5b9e\u73b0\u6808\u3002</p> </li> <li> <p>\u4f7f\u7528\u94fe\u8868\u5b9e\u73b0\u961f\u5217\u3002</p> </li> <li> <p>\u4f7f\u7528\u94fe\u8868\u5b9e\u73b0\u53cc\u7aef\u961f\u5217\uff08Deque\uff09\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e00\u4e2a\u5b9e\u9a8c\uff0c\u4ee5\u6bd4\u8f83 Python \u5217\u8868\u4e0e\u4f5c\u4e3a\u94fe\u8868\u5b9e\u73b0\u7684\u5217\u8868\u7684\u6027\u80fd\u3002</p> </li> <li> <p>\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u4e00\u4e2a\u5b9e\u9a8c\uff0c\u4ee5\u6bd4\u8f83\u57fa\u4e8e Python \u5217\u8868\u7684\u6808\u548c\u961f\u5217\u4e0e\u94fe\u8868\u5b9e\u73b0\u7684\u6027\u80fd\u3002</p> </li> <li> <p>\u4e0a\u8ff0\u94fe\u8868\u5b9e\u73b0\u79f0\u4e3a \u5355\u5411\u94fe\u8868\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u8282\u70b9\u53ea\u6709\u4e00\u4e2a\u5bf9\u5e8f\u5217\u4e2d\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528\u3002\u53e6\u4e00\u79cd\u5b9e\u73b0\u88ab\u79f0\u4e3a \u53cc\u5411\u94fe\u8868\u3002\u5728\u8fd9\u79cd\u5b9e\u73b0\u4e2d\uff0c\u6bcf\u4e2a\u8282\u70b9\u6709\u5bf9\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528\uff08\u901a\u5e38\u79f0\u4e3a next\uff09\u4ee5\u53ca\u5bf9\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u5f15\u7528\uff08\u901a\u5e38\u79f0\u4e3a back\uff09\u3002\u5934\u5f15\u7528\u8fd8\u5305\u542b\u4e24\u4e2a\u5f15\u7528\uff0c\u4e00\u4e2a\u6307\u5411\u94fe\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u4e00\u4e2a\u6307\u5411\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u3002\u7528 Python \u7f16\u5199\u8fd9\u79cd\u5b9e\u73b0\u3002</p> </li> <li> <p>\u521b\u5efa\u4e00\u4e2a\u961f\u5217\u7684\u5b9e\u73b0\uff0c\u4f7f <code>enqueue</code> \u548c <code>dequeue</code> \u64cd\u4f5c\u7684\u5e73\u5747\u6027\u80fd\u4e3a \\(O(1)\\)\u3002</p> </li> </ol> <ol> <li> <p>Convert the following values to binary using the Divide by 2 algorithm. Show the stack of remainders.</p> <ul> <li>17</li> <li>45</li> <li>96</li> </ul> </li> <li> <p>Convert the following infix expressions to prefix (use full parentheses):</p> <ul> <li> <p>(A + B) \u00b7 ( C + D) \u00b7 (E + F)</p> </li> <li> <p>A + ((B + C) \u00b7 (D + E))</p> </li> <li> <p>A \u00b7 B \u00b7 C \u00b7 D + E + F</p> </li> </ul> </li> <li> <p>Convert the above infix expressions to postfix (use full parentheses).</p> </li> <li>Convert the above infix expressions to postfix using the direct conversion algorithm. Show the stack as the conversion takes place.</li> <li> <p>Evaluate the following postfix expressions. Show the stack as each operand and operator is processed.</p> <ul> <li> <p>2 3 \u00b7 4 +</p> </li> <li> <p>1 2 + 3 + 4 + 5 +</p> </li> <li> <p>1 2 3 4 5 \u00b7 + \u00b7 +</p> </li> </ul> </li> <li> <p>The alternative implementation of the queue ADT is to use a list such that the rear of the queue is at the end of the list. What would this mean for Big-O performance?</p> </li> <li>What is the result of carrying out both steps of the linked list <code>add</code> method in reverse order? What kind of reference results? What types of problems may result?</li> <li>Explain how the linked list <code>remove</code> method works when the item to be removed is in the last node.</li> <li>Explain how the <code>remove</code> method works when the item is in the only node in the linked list.</li> <li>Modify the infix-to-postfix algorithm so that it can handle errors.</li> <li>Modify the postfix evaluation algorithm so that it can handle errors.</li> <li>Implement a direct infix evaluator that combines the functionality of infix-to-postfix conversion and the postfix evaluation algorithm. Your evaluator should process infix tokens from left to right and use two stacks, one for operators and one for operands, to perform the evaluation.</li> <li>Turn your direct infix evaluator from the previous problem into a calculator.</li> <li>Implement the queue ADT, using a list such that the rear of the queue is at the end of the list.</li> <li>Design and implement an experiment to do benchmark comparisons of the two queue implementations. What can you learn from such an experiment?</li> <li>Modify the hot potato simulation to allow for a randomly chosen counting value so that each pass is not predictable from the previous one.</li> <li> <p>Consider a real life situation. Formulate a question and then design a simulation that can help to answer it. Possible situations include:</p> <ul> <li> <p>Cars lined up at a car wash</p> </li> <li> <p>Customers at a grocery store check-out</p> </li> <li> <p>Airplanes taking off and landing on a runway</p> </li> <li> <p>A bank teller</p> </li> </ul> <p>Be sure to state any assumptions that you make and provide any probabilistic data that must be considered as part of the scenario.</p> </li> <li> <p>Implement a radix sorting machine. A radix sort for base 10 integers is a mechanical sorting technique that utilizes a collection of bins, one main bin and 10 digit bins. Each bin acts like a queue and maintains its values in the order that they arrive. The algorithm begins by placing each number in the main bin. Then it considers each value digit by digit. The first value is removed and placed in a digit bin corresponding to the digit being considered. For example, if the ones digit is being considered, 534 is placed in digit bin 4 and 667 is placed in digit bin 7. Once all the values are placed in the corresponding digit bins, the values are collected from bin 0 to bin 9 and placed back in the main bin. The process continues with the tens digit, the hundreds, and so on. After the last digit is processed, the main bin contains the values in order.</p> </li> <li> <p>Another example of the parentheses matching problem comes from Hypertext Markup Language (HTML). In HTML, tags exist in both opening and closing forms and must be balanced to properly describe a web document. This very simple HTML document:</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;\n        Example\n        &lt;/title&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;h1&gt;Hello, world&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>is intended only to show the matching and nesting structure for tags in the language. Write a program that can check an HTML document for proper opening and closing tags.</p> </li> <li> <p>Extend the program from Listing 3.15 to handle palindromes with spaces. For example, I PREFER PI is a palindrome that reads the same forward and backward if you ignore the blank characters.</p> </li> <li>To implement the <code>size</code> method, we counted the number of nodes in the list. An alternative strategy would be to store the number of nodes in the list as an additional piece of data in the head of the list. Modify the <code>UnorderedList</code> class to include this information and rewrite the <code>size</code> method.</li> <li>Implement the <code>remove</code> method so that it works correctly in the case where the item is not in the list.</li> <li>Modify the list classes to allow duplicates. Which methods will be impacted by this change?</li> <li>Implement the <code>__str__</code> method in the <code>UnorderedList</code> class. What would be a good string representation for a list?</li> <li>Implement the <code>__str__</code> method so that lists are displayed the Python way (with square brackets).</li> <li>Implement the remaining operations defined in the unordered list ADT (<code>append</code>, <code>index</code>, <code>pop</code>, <code>insert</code>).</li> <li>Implement a <code>slice</code> method for the <code>UnorderedList</code> class. It should take two parameters, <code>start</code> and <code>stop</code>, and return a copy of the list starting at the <code>start</code> position and going up to but not including the <code>stop</code> position.</li> <li>Implement the remaining operations defined in the ordered list ADT.</li> <li>Consider the relationship between unordered and ordered lists. Is it possible that inheritance could be used to build a more efficient implementation? Implement this inheritance hierarchy.</li> <li>Implement a stack using linked lists.</li> <li>Implement a queue using linked lists.</li> <li>Implement a deque using linked lists.</li> <li>Design and implement an experiment that will compare the performance of a Python list with a list implemented as a linked list.</li> <li>Design and implement an experiment that will compare the performance of the Python list-based stack and queue with the linked list implementation.</li> <li>The linked list implementation given above is called a singly linked list because each node has a single reference to the next node in the sequence. An alternative implementation is known as a doubly linked list. In this implementation, each node has a reference to the next node (commonly called next) as well as a reference to the preceding node (commonly called back). The head reference also contains two references, one to the first node in the linked list and one to the last. Code this implementation in Python.</li> <li>Create an implementation of a queue that would have an average performance of \\(O(1)\\) for <code>enqueue</code> and <code>dequeue</code> operations.</li> </ol>"},{"location":"c3/s3/","title":"3.3. \u6808","text":"<p>3.3. Stacks</p> \u4e2d\u6587\u82f1\u6587 <p>\u6808\uff08\u6709\u65f6\u79f0\u4e3a\u63a8\u6808\uff09\u662f\u4e00\u79cd\u6709\u5e8f\u7684\u9879\u76ee\u96c6\u5408\uff0c\u5176\u4e2d\u65b0\u9879\u76ee\u7684\u6dfb\u52a0\u548c\u73b0\u6709\u9879\u76ee\u7684\u79fb\u9664\u603b\u662f\u5728\u540c\u4e00\u7aef\u8fdb\u884c\u3002\u8fd9\u4e2a\u7aef\u901a\u5e38\u88ab\u79f0\u4e3a\u9876\u90e8\u3002\u4e0e\u9876\u90e8\u76f8\u5bf9\u7684\u7aef\u88ab\u79f0\u4e3a\u5e95\u90e8\u3002</p> <p>\u6808\u7684\u5e95\u90e8\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u5728\u6808\u4e2d\u5b58\u50a8\u7684\u9879\u76ee\u8d8a\u63a5\u8fd1\u5e95\u90e8\uff0c\u8868\u793a\u5b83\u4eec\u5728\u6808\u4e2d\u7684\u65f6\u95f4\u8d8a\u957f\u3002\u6700\u8fd1\u6dfb\u52a0\u7684\u9879\u76ee\u662f\u6700\u5148\u88ab\u79fb\u9664\u7684\u3002\u8fd9\u4e2a\u6392\u5e8f\u539f\u5219\u6709\u65f6\u88ab\u79f0\u4e3aLIFO\uff0c\u5373\u540e\u8fdb\u5148\u51fa\u3002\u5b83\u57fa\u4e8e\u5728\u96c6\u5408\u4e2d\u5b58\u5728\u7684\u65f6\u95f4\u957f\u5ea6\u8fdb\u884c\u6392\u5e8f\u3002\u8f83\u65b0\u7684\u9879\u76ee\u9760\u8fd1\u9876\u90e8\uff0c\u800c\u8f83\u65e7\u7684\u9879\u76ee\u9760\u8fd1\u5e95\u90e8\u3002</p> <p>\u8bb8\u591a\u6808\u7684\u4f8b\u5b50\u5728\u65e5\u5e38\u751f\u6d3b\u4e2d\u90fd\u53ef\u4ee5\u770b\u5230\u3002\u51e0\u4e4e\u4efb\u4f55\u81ea\u52a9\u9910\u5385\u90fd\u6709\u4e00\u5806\u6258\u76d8\u6216\u76d8\u5b50\uff0c\u4f60\u53d6\u7684\u662f\u6700\u4e0a\u9762\u7684\u4e00\u4e2a\uff0c\u4ece\u800c\u4e3a\u4e0b\u4e00\u4e2a\u987e\u5ba2\u9732\u51fa\u4e00\u4e2a\u65b0\u7684\u6258\u76d8\u6216\u76d8\u5b50\u3002\u60f3\u8c61\u4e00\u4e0b\u684c\u5b50\u4e0a\u7684\u4e00\u5806\u4e66\uff08<code>\u56fe 1</code>\uff09\u3002\u552f\u4e00\u80fd\u770b\u5230\u5c01\u9762\u7684\u4e66\u662f\u6700\u4e0a\u9762\u7684\u90a3\u4e00\u672c\u3002\u8981\u8bbf\u95ee\u6808\u4e2d\u7684\u5176\u4ed6\u4e66\uff0c\u6211\u4eec\u9700\u8981\u79fb\u9664\u5728\u5b83\u4eec\u4e0a\u9762\u7684\u4e66\u3002<code>\u56fe 2</code> \u663e\u793a\u4e86\u5305\u542b\u591a\u4e2a\u539f\u59cb Python \u6570\u636e\u5bf9\u8c61\u7684\u6808\u3002</p> <p> \u56fe 1: \u4e00\u672c\u4e66\u7684\u5806\u53e0 </p> <p> \u56fe 2: \u539f\u59cb Python \u6570\u636e\u5bf9\u8c61\u7684\u6808 </p> <p>\u6808\u7684\u4e00\u4e2a\u6700\u6709\u7528\u7684\u5c5e\u6027\u53ef\u4ee5\u5728\u6dfb\u52a0\u548c\u79fb\u9664\u9879\u76ee\u65f6\u89c2\u5bdf\u5230\u3002\u5047\u8bbe\u4f60\u5f00\u59cb\u65f6\u6709\u4e00\u4e2a\u5e72\u51c0\u7684\u684c\u9762\u3002\u73b0\u5728\uff0c\u5c06\u4e66\u4e00\u672c\u4e00\u672c\u5730\u5806\u53e0\u5728\u4e00\u8d77\u3002\u4f60\u6b63\u5728\u6784\u5efa\u4e00\u4e2a\u6808\u3002\u8003\u8651\u4e00\u4e0b\u5f53\u4f60\u5f00\u59cb\u79fb\u9664\u4e66\u7c4d\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002\u5b83\u4eec\u88ab\u79fb\u9664\u7684\u987a\u5e8f\u6b63\u597d\u4e0e\u5b83\u4eec\u88ab\u653e\u7f6e\u7684\u987a\u5e8f\u76f8\u53cd\u3002\u6808\u662f\u57fa\u672c\u7684\u91cd\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u4ee5\u7528\u6765\u53cd\u8f6c\u9879\u76ee\u7684\u987a\u5e8f\u3002\u63d2\u5165\u7684\u987a\u5e8f\u662f\u79fb\u9664\u987a\u5e8f\u7684\u53cd\u8f6c\u3002<code>\u56fe 3</code> \u663e\u793a\u4e86 Python \u6570\u636e\u5bf9\u8c61\u6808\u7684\u521b\u5efa\u8fc7\u7a0b\u548c\u9879\u76ee\u88ab\u79fb\u9664\u540e\u7684\u72b6\u6001\u3002\u6ce8\u610f\u5bf9\u8c61\u7684\u987a\u5e8f\u3002</p> <p> \u56fe 3: \u6808\u7684\u53cd\u8f6c\u5c5e\u6027 </p> <p>\u8003\u8651\u5230\u8fd9\u4e2a\u53cd\u8f6c\u5c5e\u6027\uff0c\u4f60\u53ef\u80fd\u4f1a\u60f3\u5230\u4f7f\u7528\u8ba1\u7b97\u673a\u65f6\u51fa\u73b0\u7684\u6808\u7684\u4f8b\u5b50\u3002\u4f8b\u5982\uff0c\u6bcf\u4e2a\u7f51\u9875\u6d4f\u89c8\u5668\u90fd\u6709\u4e00\u4e2a\u201c\u540e\u9000\u201d\u6309\u94ae\u3002\u5f53\u4f60\u5728\u7f51\u9875\u4e4b\u95f4\u5bfc\u822a\u65f6\uff0c\u8fd9\u4e9b\u9875\u9762\u88ab\u653e\u7f6e\u5728\u4e00\u4e2a\u6808\u4e0a\uff08\u5b9e\u9645\u4e0a\u662f URL \u88ab\u653e\u5728\u6808\u4e0a\uff09\u3002\u4f60\u5f53\u524d\u67e5\u770b\u7684\u9875\u9762\u5728\u9876\u90e8\uff0c\u800c\u4f60\u6700\u521d\u67e5\u770b\u7684\u9875\u9762\u5728\u5e95\u90e8\u3002\u5982\u679c\u4f60\u70b9\u51fb\u201c\u540e\u9000\u201d\u6309\u94ae\uff0c\u4f60\u5c06\u5f00\u59cb\u6309\u76f8\u53cd\u7684\u987a\u5e8f\u6d4f\u89c8\u9875\u9762\u3002</p> <p>A stack (sometimes called a push-down stack) is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. This end is commonly referred to as the top. The end opposite the top is known as the base.</p> <p>The base of the stack is significant since items stored in the stack that are closer to the base represent those that have been in the stack the longest. The most recently added item is the one that is in position to be removed first. This ordering principle is sometimes called LIFO, or last in, first out. It provides an ordering based on length of time in the collection. Newer items are near the top, while older items are near the base.</p> <p>Many examples of stacks occur in everyday situations. Almost any cafeteria has a stack of trays or plates where you take the one at the top, uncovering a new tray or plate for the next customer in line. Imagine a stack of books on a desk (<code>Figure 1</code>). The only book whose cover is visible is the one on top. To access others in the stack, we need to remove the ones that are sitting on top of them. <code>Figure 2</code> shows another stack that contains a number of primitive Python data objects.</p> <p> Figure 1: A Stack of Books </p> <p> Figure 2: A Stack of Primitive Python Data Objects </p> <p>One of the most useful properties of stacks can be observed  as items are added and then removed. Assume you start out with a clean desktop. Now place books one at a time on top of each other. You are constructing a stack. Consider what happens when you begin removing books. The order that they are removed is exactly the reverse of the order that they were placed. Stacks are fundamentally important, as they can be used to reverse the order of items. The order of insertion is the reverse of the order of removal. <code>Figure 3</code> shows the Python data object stack as it was created and then again as items are removed. Note the order of the objects.</p> <p> Figure 3: The Reversal Property of Stacks </p> <p>Considering this reversal property, you can perhaps think of examples of stacks that occur as you use your computer. For example, every web browser has a Back button. As you navigate from web page to web page, those pages are placed on a stack (actually it is the URLs that are going on the stack). The current page that you are viewing is on the top and the first page you looked at is at the base. If you click on the Back button, you begin to move in reverse order through the pages.</p>"},{"location":"c3/s4/","title":"3.4. \u6808\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>3.4. The Stack Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>\u6808\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7531\u4ee5\u4e0b\u7ed3\u6784\u548c\u64cd\u4f5c\u5b9a\u4e49\u3002\u6808\u5982\u524d\u6240\u8ff0\uff0c\u662f\u4e00\u4e2a\u6709\u5e8f\u7684\u9879\u76ee\u96c6\u5408\uff0c\u5176\u4e2d\u9879\u76ee\u88ab\u6dfb\u52a0\u5230\u5e76\u4ece\u79f0\u4e3a\u9876\u90e8\u7684\u7aef\u79fb\u9664\u3002\u6808\u7684\u987a\u5e8f\u662f\u540e\u8fdb\u5148\u51fa\uff08LIFO\uff09\u3002\u6808\u7684\u64cd\u4f5c\u5982\u4e0b\u6240\u793a\u3002</p> <ul> <li> <p><code>Stack()</code> \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7a7a\u6808\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6808\u3002</p> </li> <li> <p><code>push(item)</code> \u5c06\u4e00\u4e2a\u65b0\u9879\u76ee\u6dfb\u52a0\u5230\u6808\u7684\u9876\u90e8\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u9879\u76ee\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u4e14\u4e0d\u8fd4\u56de\u4efb\u4f55\u503c\u3002</p> </li> <li> <p><code>pop()</code> \u4ece\u6808\u4e2d\u79fb\u9664\u9876\u90e8\u7684\u9879\u76ee\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u88ab\u79fb\u9664\u7684\u9879\u76ee\u3002\u6808\u4f1a\u88ab\u4fee\u6539\u3002</p> </li> <li> <p><code>peek()</code> \u8fd4\u56de\u6808\u4e2d\u7684\u9876\u90e8\u9879\u76ee\uff0c\u4f46\u4e0d\u5c06\u5176\u79fb\u9664\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\u3002\u6808\u4e0d\u4f1a\u88ab\u4fee\u6539\u3002</p> </li> <li> <p><code>is_empty()</code> \u6d4b\u8bd5\u6808\u662f\u5426\u4e3a\u7a7a\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u3002</p> </li> <li> <p><code>size()</code> \u8fd4\u56de\u6808\u4e2d\u9879\u76ee\u7684\u6570\u91cf\u3002\u5b83\u4e0d\u9700\u8981\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6574\u6570\u3002</p> </li> </ul> <p>\u4f8b\u5982\uff0c\u5982\u679c<code>s</code>\u662f\u4e00\u4e2a\u5df2\u521b\u5efa\u5e76\u5f00\u59cb\u65f6\u4e3a\u7a7a\u7684\u6808\uff0c\u90a3\u4e48<code>\u8868 1</code>\u663e\u793a\u4e86\u4e00\u7cfb\u5217\u6808\u64cd\u4f5c\u7684\u7ed3\u679c\u3002\u5728\u6808\u5185\u5bb9\u4e0b\uff0c\u9876\u90e8\u9879\u76ee\u5728\u6700\u53f3\u4fa7\u5217\u51fa\u3002</p> <p>\u8868 1: \u793a\u4f8b\u6808\u64cd\u4f5c</p> \u6808\u64cd\u4f5c \u6808\u5185\u5bb9 \u8fd4\u56de\u503c <code>s.is_empty()</code> <code>[]</code> <code>True</code> <code>s.push(4)</code> <code>[4]</code> <code>s.push('dog')</code> <code>[4, 'dog']</code> <code>s.peek()</code> <code>[4, 'dog']</code> <code>'dog'</code> <code>s.push(True)</code> <code>[4, 'dog', True]</code> <code>s.size()</code> <code>[4, 'dog', True]</code> <code>3</code> <code>s.is_empty()</code> <code>[4, 'dog', True]</code> <code>False</code> <code>s.push(8.4)</code> <code>[4, 'dog', True, 8.4]</code> <code>s.pop()</code> <code>[4, 'dog', True]</code> <code>8.4</code> <code>s.pop()</code> <code>[4, 'dog']</code> <code>True</code> <code>s.size()</code> <code>[4, 'dog']</code> <code>2</code> <p>The stack abstract data type is defined by the following structure and operations. A stack is structured, as described above, as an ordered collection of items where items are added to and removed from the end called the top. Stacks are ordered LIFO. The stack operations are given below.</p> <ul> <li> <p><code>Stack()</code> creates a new stack that is empty. It needs no parameters and returns an empty stack.</p> </li> <li> <p><code>push(item)</code> adds a new item to the top of the stack. It needs the item and returns nothing.</p> </li> <li> <p><code>pop()</code> removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.</p> </li> <li> <p><code>peek()</code> returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.</p> </li> <li> <p><code>is_empty()</code> tests to see whether the stack is empty. It needs no parameters and returns a boolean value.</p> </li> <li> <p><code>size()</code> returns the number of items on the stack. It needs no parameters and returns an integer.</p> </li> </ul> <p>For example, if <code>s</code> is a stack that has been created and starts out empty, then <code>Table 1</code> shows the results of a sequence of stack operations. Under Stack Contents, the top item is listed at the far right.</p> <p>Table 1: Sample Stack Operations</p> Stack Operation Stack Contents Return Value <code>s.is_empty()</code> <code>[]</code> <code>True</code> <code>s.push(4)</code> <code>[4]</code> <code>s.push('dog')</code> <code>[4, 'dog']</code> <code>s.peek()</code> <code>[4, 'dog']</code> <code>'dog'</code> <code>s.push(True)</code> <code>[4, 'dog', True]</code> <code>s.size()</code> <code>[4, 'dog', True]</code> <code>3</code> <code>s.is_empty()</code> <code>[4, 'dog', True]</code> <code>False</code> <code>s.push(8.4)</code> <code>[4, 'dog', True, 8.4]</code> <code>s.pop()</code> <code>[4, 'dog', True]</code> <code>8.4</code> <code>s.pop()</code> <code>[4, 'dog']</code> <code>True</code> <code>s.size()</code> <code>[4, 'dog']</code> <code>2</code>"},{"location":"c3/s5/","title":"3.5. \u7528Python\u5b9e\u73b0\u6808","text":"<p>3.5. Implementing a Stack in Python</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/ImplementingaStackinPython.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u660e\u786e\u4e86\u6808\u4f5c\u4e3a\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u5c06\u5173\u6ce8\u4f7f\u7528 Python \u5b9e\u73b0\u6808\u3002\u56de\u987e\u4e00\u4e0b\uff0c\u5f53\u6211\u4eec\u7ed9\u4e00\u4e2a\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u4e00\u4e2a\u7269\u7406\u5b9e\u73b0\u65f6\uff0c\u6211\u4eec\u79f0\u8fd9\u79cd\u5b9e\u73b0\u4e3a\u6570\u636e\u7ed3\u6784\u3002</p> <p>\u6b63\u5982\u6211\u4eec\u5728\u7b2c\u4e00\u7ae0\u6240\u63cf\u8ff0\u7684\uff0c\u5728 Python \u4e2d\uff0c\u4e0e\u4efb\u4f55\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8bed\u8a00\u4e00\u6837\uff0c\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u5982\u6808\u7684\u5b9e\u73b0\u9009\u62e9\u662f\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u7c7b\u3002\u6808\u64cd\u4f5c\u88ab\u5b9e\u73b0\u4e3a\u65b9\u6cd5\u3002\u6b64\u5916\uff0c\u8981\u5b9e\u73b0\u6808\uff08\u8fd9\u662f\u4e00\u4e2a\u5143\u7d20\u96c6\u5408\uff09\uff0c\u5229\u7528 Python \u63d0\u4f9b\u7684\u539f\u59cb\u96c6\u5408\u7684\u529b\u91cf\u548c\u7b80\u5355\u6027\u662f\u6709\u610f\u4e49\u7684\u3002\u6211\u4eec\u5c06\u4f7f\u7528\u5217\u8868\u3002</p> <p>\u56de\u987e\u4e00\u4e0b\uff0cPython \u7684\u5217\u8868\u7c7b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6709\u5e8f\u7684\u96c6\u5408\u673a\u5236\u548c\u4e00\u7ec4\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a\u5217\u8868 [2, 5, 3, 6, 7, 4]\uff0c\u6211\u4eec\u53ea\u9700\u51b3\u5b9a\u54ea\u4e2a\u7aef\u88ab\u89c6\u4e3a\u6808\u7684\u9876\u90e8\uff0c\u54ea\u4e2a\u7aef\u662f\u5e95\u90e8\u3002\u4e00\u65e6\u505a\u51fa\u8fd9\u4e2a\u51b3\u5b9a\uff0c\u53ef\u4ee5\u4f7f\u7528\u5217\u8868\u65b9\u6cd5\u5982 <code>append</code> \u548c <code>pop</code> \u6765\u5b9e\u73b0\u64cd\u4f5c\u3002</p> <p>\u4ee5\u4e0b\u6808\u5b9e\u73b0\uff08<code>ActiveCode 1</code>\uff09\u5047\u8bbe\u5217\u8868\u7684\u672b\u7aef\u5c06\u4fdd\u5b58\u6808\u7684\u9876\u90e8\u5143\u7d20\u3002\u968f\u7740\u6808\u7684\u589e\u957f\uff08\u5f53 <code>push</code> \u64cd\u4f5c\u53d1\u751f\u65f6\uff09\uff0c\u65b0\u9879\u5c06\u88ab\u6dfb\u52a0\u5230\u5217\u8868\u7684\u672b\u7aef\u3002 <code>pop</code> \u64cd\u4f5c\u5c06\u64cd\u4f5c\u8be5\u672b\u7aef\u3002</p> Activity: 3.5.1 \u4f7f\u7528 Python \u5217\u8868\u5b9e\u73b0\u6808\u7c7b<pre><code>class Stack:\n    \"\"\"\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u6808\"\"\"\n\n    def __init__(self):\n        \"\"\"\u521b\u5efa\u65b0\u6808\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"\u68c0\u67e5\u6808\u662f\u5426\u4e3a\u7a7a\"\"\"\n        return not bool(self._items)\n\n    def push(self, item):\n        \"\"\"\u5c06\u9879\u6dfb\u52a0\u5230\u6808\u4e2d\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"\u4ece\u6808\u4e2d\u79fb\u9664\u9879\"\"\"\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"\u83b7\u53d6\u6808\u4e2d\u9876\u90e8\u9879\u7684\u503c\"\"\"\n        return self._items[-1]\n\n    def size(self):\n        \"\"\"\u83b7\u53d6\u6808\u4e2d\u9879\u7684\u6570\u91cf\"\"\"\n        return len(self._items)\n</code></pre> <p>\u8bf7\u8bb0\u4f4f\uff0c\u70b9\u51fb<code>run</code>\u6309\u94ae\u65f6\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u4e8b\u60c5\uff0c\u9664\u4e86\u5b9a\u4e49\u7c7b\u3002\u6211\u4eec\u5fc5\u987b\u521b\u5efa\u4e00\u4e2a <code>Stack</code> \u5bf9\u8c61\uff0c\u7136\u540e\u4f7f\u7528\u5b83\u3002<code>ActiveCode 2</code> \u663e\u793a\u4e86 <code>Stack</code> \u7c7b\u5728\u6211\u4eec\u6267\u884c <code>Table 1</code> \u4e2d\u7684\u64cd\u4f5c\u5e8f\u5217\u65f6\u7684\u5b9e\u9645\u60c5\u51b5\u3002\u6ce8\u610f <code>Stack</code> \u7c7b\u7684\u5b9a\u4e49\u4ece\u4e0e\u672c\u4e66\u6750\u6599\u4e00\u8d77\u63d0\u4f9b\u7684 <code>pythonds3</code> \u6a21\u5757\u4e2d\u5bfc\u5165\uff0c\u6216\u8005\u53ef\u4ee5\u4ece Python Package Index \u4e0b\u8f7d\u3002</p> <p>\u6ce8\u610f</p> <p><code>pythonds3</code> \u6a21\u5757\u5305\u542b\u672c\u4e66\u4e2d\u8ba8\u8bba\u7684\u6240\u6709\u6570\u636e\u7ed3\u6784\u7684\u5b9e\u73b0\u3002\u5b83\u6839\u636e\u4ee5\u4e0b\u90e8\u5206\u8fdb\u884c\u7ed3\u6784\u5316\uff1a\u57fa\u7840\u3001\u6811\u548c\u56fe\u3002\u8be5\u6a21\u5757\u53ef\u4ee5\u4ece GitHub \u4e0b\u8f7d\uff0c\u6216\u8005\u901a\u8fc7\u547d\u4ee4\u884c\u5b89\u88c5\uff0c\u5982\u4e0b\u6240\u793a\uff1a</p> <p><code>python3 -m pip install -U pythonds3</code></p> Activity: 3.5.2 ActiveCode<pre><code>from pythonds3.basic import Stack\n\ns = Stack()\n\nprint(s.is_empty())\ns.push(4)\ns.push(\"dog\")\nprint(s.peek())\ns.push(True)\nprint(s.size())\nprint(s.is_empty())\ns.push(8.4)\nprint(s.pop())\nprint(s.pop())\nprint(s.size())\n</code></pre> <p>\u91cd\u8981\u7684\u662f\u8981\u6ce8\u610f\uff0c\u6211\u4eec\u672c\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u5217\u8868\u5b9e\u73b0\u6808\uff0c\u5c06\u9876\u90e8\u8bbe\u7f6e\u5728\u5f00\u59cb\u5904\u800c\u4e0d\u662f\u672b\u5c3e\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4e4b\u524d\u7684 <code>pop</code> \u548c <code>append</code> \u65b9\u6cd5\u5c06\u4e0d\u518d\u6709\u6548\uff0c\u6211\u4eec\u5c06\u5fc5\u987b\u4f7f\u7528 <code>pop</code> \u548c <code>insert</code> \u660e\u786e\u7d22\u5f15\u4f4d\u7f6e 0\uff08\u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u9879\u76ee\uff09\u3002\u8be5\u5b9e\u73b0\u663e\u793a\u5728 <code>CodeLens 1</code> \u4e2d\u3002</p> Activity: CodeLens \u66ff\u4ee3\u5b9e\u73b0\u7684\u6808\u7c7b (stack_cl_1)<pre><code>class Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.insert(0, item)\n\n    def pop(self):\n        return self.items.pop(0)\n\n    def peek(self):\n        return self.items[0]\n\n    def size(self):\n        return len(self.items)\n\ns = Stack()\ns.push(\"hello\")\ns.push(\"true\")\nprint(s.pop())\n</code></pre> <p>\u8fd9\u79cd\u6539\u53d8\u62bd\u8c61\u6570\u636e\u7c7b\u578b\u7684\u7269\u7406\u5b9e\u73b0\u7684\u80fd\u529b\uff0c\u540c\u65f6\u4fdd\u6301\u5176\u903b\u8f91\u7279\u6027\uff0c\u662f\u62bd\u8c61\u5de5\u4f5c\u7684\u4e00\u4e2a\u4f8b\u5b50\u3002\u7136\u800c\uff0c\u5373\u4f7f\u6808\u53ef\u4ee5\u4ee5\u4efb\u610f\u65b9\u5f0f\u5de5\u4f5c\uff0c\u5982\u679c\u8003\u8651\u8fd9\u4e24\u79cd\u5b9e\u73b0\u7684\u6027\u80fd\uff0c\u786e\u5b9e\u5b58\u5728\u5dee\u5f02\u3002\u56de\u987e\u4e00\u4e0b\uff0c<code>append()</code> \u548c <code>pop()</code> \u64cd\u4f5c\u90fd\u662f \\(O(1)\\) \u7684\u3002\u8fd9\u610f\u5473\u7740\u7b2c\u4e00\u79cd\u5b9e\u73b0\u5c06\u4ee5\u5e38\u6570\u65f6\u95f4\u6267\u884c <code>push</code> \u548c <code>pop</code> \u64cd\u4f5c\uff0c\u65e0\u8bba\u6808\u4e2d\u6709\u591a\u5c11\u9879\u3002\u7b2c\u4e8c\u79cd\u5b9e\u73b0\u7684\u6027\u80fd\u8f83\u5dee\uff0c\u56e0\u4e3a <code>insert(0)</code> \u548c <code>pop(0)</code> \u64cd\u4f5c\u90fd\u9700\u8981 \\(O(n)\\)\uff0c\u5bf9\u4e8e\u5927\u5c0f\u4e3a <code>n</code> \u7684\u6808\u6765\u8bf4\u3002\u663e\u7136\uff0c\u5373\u4f7f\u5b9e\u73b0\u903b\u8f91\u4e0a\u7b49\u6548\uff0c\u5b83\u4eec\u5728\u8fdb\u884c\u57fa\u51c6\u6d4b\u8bd5\u65f6\u7684\u65f6\u95f4\u4f1a\u6709\u5f88\u5927\u4e0d\u540c\u3002</p> <p>\u81ea\u6211\u68c0\u67e5</p> Activity: 3.5.4 \u591a\u9879\u9009\u62e9\u9898Activity: 3.5.5 \u591a\u9879\u9009\u62e9\u9898 <p>\u7ed9\u5b9a\u4ee5\u4e0b\u6808\u64cd\u4f5c\u5e8f\u5217\uff0c\u5f53\u5e8f\u5217\u5b8c\u6210\u65f6\uff0c\u6808\u4e0a\u7684\u9876\u90e8\u9879\u662f\u4ec0\u4e48\uff1f</p> <p>:answer_a: \"x\" :answer_b: \"y\" :answer_c: \"z\" :answer_d: \u6808\u4e3a\u7a7a</p> <p>:correct: c</p> <p>:feedback_a: \u8bf7\u8bb0\u4f4f\uff0c\u6808\u662f\u4ece\u5e95\u90e8\u5411\u4e0a\u5efa\u7acb\u7684\u3002 :feedback_b: \u8bf7\u8bb0\u4f4f\uff0c\u6808\u662f\u4ece\u5e95\u90e8\u5411\u4e0a\u5efa\u7acb\u7684\u3002 :feedback_c: \u505a\u5f97\u597d\u3002 :feedback_d: \u8bf7\u8bb0\u4f4f\uff0c\u6808\u662f\u4ece\u5e95\u90e8\u5411\u4e0a\u5efa\u7acb\u7684\u3002</p> <p>\u7ed9\u5b9a\u4ee5\u4e0b\u6808\u64cd\u4f5c\u5e8f\u5217\uff0c\u5f53\u5e8f\u5217\u5b8c\u6210\u65f6\uff0c\u6808\u4e0a\u7684\u9876\u90e8\u9879\u662f\u4ec0\u4e48\uff1f</p> <pre><code>m = Stack()\nm.push(\"x\")\nm.push(\"y\")\nm.pop()\nm.push(\"z\")\nm.peek()\n</code></pre> <ul> <li> a: \"x\"</li> <li> b: \u6808\u4e3a\u7a7a</li> <li> c: \u5c06\u53d1\u751f\u9519\u8bef</li> <li> d: \"z\"</li> </ul> <p>correct: c</p> <ul> <li>feedback a: \u4f60\u53ef\u80fd\u9700\u8981\u67e5\u770b\u4e00\u4e0b <code>isEmpty</code> \u7684\u6587\u6863</li> <li>feedback b: \u6808\u4e2d\u6709\u5947\u6570\u4e2a\u9879\u76ee\uff0c\u4f46\u6bcf\u6b21\u5faa\u73af\u4e2d\u5f39\u51fa\u4e24\u4e2a\u9879\u76ee\u3002</li> <li>feedback c: \u505a\u5f97\u597d\u3002</li> <li>feedback d: \u4f60\u53ef\u80fd\u9700\u8981\u67e5\u770b\u4e00\u4e0b <code>isEmpty</code> \u7684\u6587\u6863</li> </ul> <pre><code>m = Stack()\nm.push(\"x\")\nm.push(\"y\")\nm.push(\"z\")\nwhile not m.is_empty():\n    m.pop()\n    m.pop()\n</code></pre> <p>\u7f16\u5199\u4e00\u4e2a\u51fd\u6570 <code>rev_string(my_str)</code>\uff0c\u8be5\u51fd\u6570\u4f7f\u7528\u6808\u6765\u53cd\u8f6c\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u3002</p> <pre><code>from test import testEqual\nfrom pythonds3.basic import Stack\n\ndef rev_string(my_str):\n    # \u4f60\u7684\u4ee3\u7801\u5728\u8fd9\u91cc\n\ntestEqual(rev_string(\"apple\"), \"elppa\")\ntestEqual(rev_string(\"x\"), \"x\")\ntestEqual(rev_string(\"1234567890\"), \"0987654321\")\n</code></pre> <p>Now that we have clearly defined the stack as an abstract data type, we will turn our attention to using Python to implement the stack. Recall that when we give an abstract data type a physical implementation, we refer to the implementation as a data structure.</p> <p>As we described in Chapter 1, in Python, as in any object-oriented programming language, the implementation of choice for an abstract data type such as a stack is the creation of a new class. The stack operations are implemented as methods. Further, to implement a stack, which is a collection of elements, it makes sense to utilize the power and simplicity of the primitive collections provided by Python. We will use a list.</p> <p>Recall that the list class in Python provides an ordered collection mechanism and a set of methods. For example, if we have the list [2, 5, 3, 6, 7, 4], we need only to decide which end of the list will be considered the top of the stack and which will be the base. Once that decision is made, the operations can be implemented using the list methods such as <code>append</code> and <code>pop</code>.</p> <p>The following stack implementation (<code>ActiveCode 1</code>) assumes that the end of the list will hold the top element of the stack. As the stack grows (as <code>push</code> operations occur), new items will be added on the end of the list. <code>pop</code> operations will manipulate that same end. </p> Activity: 3.5.1 Implementing a Stack class using Python lists<pre><code>class Stack:\n    \"\"\"Stack implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new stack\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty\"\"\"\n        return not bool(self._items)\n\n    def push(self, item):\n        \"\"\"Add an item to the stack\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove an item from the stack\"\"\"\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Get the value of the top item in the stack\"\"\"\n        return self._items[-1]\n\n    def size(self):\n        \"\"\"Get the number of items in the stack\"\"\"\n        return len(self._items)\n</code></pre> <p>Remember that nothing happens when we click the <code>run</code> button other than the definition of the class.  We must create a <code>Stack</code> object and then use it. <code>ActiveCode 2</code> shows the <code>Stack</code> class in action as we perform the sequence of operations from <code>Table 1</code>.  Notice that the definition of the <code>Stack</code> class is imported from the <code>pythonds3</code> module  that is included with the materials for this book or can be downloaded from the Python Package Index.</p> <p>Note</p> <p>The <code>pythonds3</code> module contains implementations of all data structures discussed in this book. It is structured according to the sections: basic, trees, and graphs. The module can be downloaded from GitHub or installed from the command line as follows:</p> <p><code>python3 -m pip install -U pythonds3</code></p> Activity: 3.5.2 ActiveCode<pre><code>from pythonds3.basic import Stack\n\ns = Stack()\n\nprint(s.is_empty())\ns.push(4)\ns.push(\"dog\")\nprint(s.peek())\ns.push(True)\nprint(s.size())\nprint(s.is_empty())\ns.push(8.4)\nprint(s.pop())\nprint(s.pop())\nprint(s.size())\n</code></pre> <p>It is important to note that we could have chosen to implement the stack using a list where the top is at the beginning instead of at the end. In this case, the previous <code>pop</code> and <code>append</code> methods would no longer work and we would have to index position 0 (the first item in the list) explicitly using <code>pop</code> and <code>insert</code>. The implementation is shown in <code>CodeLens 1</code>.</p> Activity: CodeLens Alternative Implementation of the Stack class (stack_cl_1)<pre><code>class Stack:\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.insert(0, item)\n\n    def pop(self):\n        return self.items.pop(0)\n\n    def peek(self):\n        return self.items[0]\n\n    def size(self):\n        return len(self.items)\n\ns = Stack()\ns.push(\"hello\")\ns.push(\"true\")\nprint(s.pop())\n</code></pre> <p>This ability to change the physical implementation of an abstract data type while maintaining the logical characteristics is an example of abstraction at work. However, even though the stack will work either way, if we consider the performance of the two implementations, there is definitely a difference. Recall that the <code>append()</code> and <code>pop()</code> operations were both \\(O(1)\\). This means that the first implementation will perform <code>push</code> and <code>pop</code> in constant time no matter how many items are on the stack. The performance of the second implementation suffers in that the <code>insert(0)</code> and <code>pop(0)</code> operations will both require \\(O(n)\\) for a stack of size <code>n</code>. Clearly, even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing.</p> <p>Self Check</p> Activity: 3.5.4 Multiple ChoiceActivity: 3.5.5 Multiple Choice <p>Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?</p> <p>:answer_a: \"x\" :answer_b: \"y\" :answer_c: \"z\" :answer_d: The stack is empty</p> <p>:correct: c</p> <p>:feedback_a: Remember that a stack is built from the bottom up. :feedback_b: Remember that a stack is built from the bottom up. :feedback_c: Good job. :feedback_d: Remember that a stack is built from the bottom up.</p> <p>Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?</p> <pre><code>m = Stack()\nm.push(\"x\")\nm.push(\"y\")\nm.pop()\nm.push(\"z\")\nm.peek()\n</code></pre> <ul> <li> a: \"x\"</li> <li> b: the stack is empty</li> <li> c: an error will occur</li> <li> d: \"z\"</li> </ul> <p>correct: c</p> <ul> <li>feedback a: You may want to check out the docs for isEmpty</li> <li>feedback b: There is an odd number of things on the stack but each time through the loop 2 things are popped.</li> <li>feedback c: Good Job.</li> <li>feedback d: You may want to check out the docs for isEmpty</li> </ul> <pre><code>m = Stack()\nm.push(\"x\")\nm.push(\"y\")\nm.push(\"z\")\nwhile not m.is_empty():\n    m.pop()\n    m.pop()\n</code></pre> <p>Write a function <code>rev_string(my_str)</code> that uses a stack to reverse the characters in a string.</p> <pre><code>from test import testEqual\nfrom pythonds3.basic import Stack\n\ndef rev_string(my_str):\n    # your code here\n\ntestEqual(rev_string(\"apple\"), \"elppa\")\ntestEqual(rev_string(\"x\"), \"x\")\ntestEqual(rev_string(\"1234567890\"), \"0987654321\")\n</code></pre>"},{"location":"c3/s6/","title":"3.6. \u7b80\u5355\u7684\u62ec\u53f7\u5339\u914d","text":"<p>3.6. Simple Balanced Parentheses</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/SimpleBalancedParentheses.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u73b0\u5728\u6211\u4eec\u5c06\u5173\u6ce8\u4e8e\u4f7f\u7528\u6808\u6765\u89e3\u51b3\u5b9e\u9645\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u95ee\u9898\u3002\u4f60\u53ef\u80fd\u5df2\u7ecf\u5199\u8fc7\u7c7b\u4f3c\u8fd9\u6837\u7684\u7b97\u672f\u8868\u8fbe\u5f0f\uff1a</p> \\[(5 + 6) * (7 + 8) / (4 + 3)\\] <p>\u5728\u8fd9\u4e9b\u8868\u8fbe\u5f0f\u4e2d\uff0c\u62ec\u53f7\u7528\u4e8e\u6392\u5e8f\u64cd\u4f5c\u7684\u6267\u884c\u3002\u4f60\u4e5f\u53ef\u80fd\u5728\u7f16\u7a0b\u8bed\u8a00\u5982 Lisp \u4e2d\u6709\u8fc7\u4e00\u4e9b\u7f16\u7a0b\u7ecf\u9a8c\uff0c\u6bd4\u5982\u6709\u5982\u4e0b\u6784\u9020\uff1a</p> <pre><code>(defun square(n)\n        (* n n))\n</code></pre> <p>\u8fd9\u5b9a\u4e49\u4e86\u4e00\u4e2a\u540d\u4e3a <code>square</code> \u7684\u51fd\u6570\uff0c\u5b83\u4f1a\u8fd4\u56de\u5176\u53c2\u6570 <code>n</code> \u7684\u5e73\u65b9\u3002Lisp \u4ee5\u4f7f\u7528\u5927\u91cf\u62ec\u53f7\u800c\u95fb\u540d\u3002</p> <p>\u5728\u8fd9\u4e24\u4e2a\u793a\u4f8b\u4e2d\uff0c\u62ec\u53f7\u5fc5\u987b\u4ee5\u5e73\u8861\u7684\u65b9\u5f0f\u51fa\u73b0\u3002\u5e73\u8861\u7684\u62ec\u53f7 \u610f\u5473\u7740\u6bcf\u4e2a\u5f00\u62ec\u53f7\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u95ed\u62ec\u53f7\uff0c\u5e76\u4e14\u62ec\u53f7\u5bf9\u662f\u6b63\u786e\u5d4c\u5957\u7684\u3002\u8003\u8651\u4ee5\u4e0b\u6b63\u786e\u5e73\u8861\u7684\u62ec\u53f7\u5b57\u7b26\u4e32\uff1a</p> <pre><code>(()()()())\n\n(((())))\n\n(()((())()))\n</code></pre> <p>\u5c06\u8fd9\u4e9b\u4e0e\u4ee5\u4e0b\u4e0d\u5e73\u8861\u7684\u62ec\u53f7\u5b57\u7b26\u4e32\u8fdb\u884c\u6bd4\u8f83\uff1a</p> <pre><code>    ((((((())\n\n    ()))\n\n    (()()(()\n</code></pre> <p>\u533a\u5206\u6b63\u786e\u5e73\u8861\u7684\u62ec\u53f7\u548c\u4e0d\u5e73\u8861\u7684\u62ec\u53f7\u662f\u8bc6\u522b\u8bb8\u591a\u7f16\u7a0b\u8bed\u8a00\u7ed3\u6784\u7684\u91cd\u8981\u90e8\u5206\u3002</p> <p>\u6311\u6218\u5728\u4e8e\u7f16\u5199\u4e00\u4e2a\u7b97\u6cd5\uff0c\u4ece\u5de6\u5230\u53f3\u8bfb\u53d6\u62ec\u53f7\u5b57\u7b26\u4e32\uff0c\u5e76\u51b3\u5b9a\u8fd9\u4e9b\u7b26\u53f7\u662f\u5426\u5e73\u8861\u3002\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e2a\u91cd\u8981\u7684\u89c2\u5bdf\u3002\u5f53\u4f60\u4ece\u5de6\u5230\u53f3\u5904\u7406\u7b26\u53f7\u65f6\uff0c\u6700\u65b0\u7684\u5f00\u62ec\u53f7\u5fc5\u987b\u4e0e\u4e0b\u4e00\u4e2a\u95ed\u62ec\u53f7\u5339\u914d\uff08\u89c1 <code>Figure 4</code>\uff09\u3002\u6b64\u5916\uff0c\u7b2c\u4e00\u4e2a\u5904\u7406\u7684\u5f00\u7b26\u53f7\u53ef\u80fd\u9700\u8981\u7b49\u5230\u6700\u540e\u4e00\u4e2a\u7b26\u53f7\u624d\u4f1a\u6709\u5339\u914d\u3002\u95ed\u7b26\u53f7\u4e0e\u5f00\u7b26\u53f7\u7684\u5339\u914d\u662f\u6309\u51fa\u73b0\u7684\u76f8\u53cd\u987a\u5e8f\u8fdb\u884c\u7684\uff1b\u5b83\u4eec\u662f\u4ece\u5185\u90e8\u5411\u5916\u5339\u914d\u7684\u3002\u8fd9\u662f\u6808\u53ef\u4ee5\u7528\u6765\u89e3\u51b3\u95ee\u9898\u7684\u7ebf\u7d22\u3002</p> <p> Figure 4: \u5339\u914d\u62ec\u53f7 </p> <p>\u4e00\u65e6\u4f60\u540c\u610f\u6808\u662f\u4fdd\u6301\u62ec\u53f7\u7684\u9002\u5f53\u6570\u636e\u7ed3\u6784\uff0c\u7b97\u6cd5\u7684\u63cf\u8ff0\u5c31\u662f\u76f4\u63a5\u7684\u3002\u4ece\u4e00\u4e2a\u7a7a\u6808\u5f00\u59cb\uff0c\u4ece\u5de6\u5230\u53f3\u5904\u7406\u62ec\u53f7\u5b57\u7b26\u4e32\u3002\u5982\u679c\u7b26\u53f7\u662f\u5f00\u62ec\u53f7\uff0c\u5219\u5c06\u5176\u63a8\u5165\u6808\u4e2d\uff0c\u8868\u793a\u7a0d\u540e\u9700\u8981\u51fa\u73b0\u4e00\u4e2a\u76f8\u5e94\u7684\u95ed\u7b26\u53f7\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u5982\u679c\u7b26\u53f7\u662f\u95ed\u62ec\u53f7\uff0c\u5219\u5f39\u51fa\u6808\u3002\u53ea\u8981\u53ef\u4ee5\u5f39\u51fa\u6808\u4ee5\u5339\u914d\u6bcf\u4e2a\u95ed\u7b26\u53f7\uff0c\u62ec\u53f7\u5c31\u4fdd\u6301\u5e73\u8861\u3002\u5982\u679c\u5728\u4efb\u4f55\u65f6\u5019\u6808\u4e2d\u6ca1\u6709\u5f00\u7b26\u53f7\u6765\u5339\u914d\u4e00\u4e2a\u95ed\u7b26\u53f7\uff0c\u5219\u5b57\u7b26\u4e32\u4e0d\u5e73\u8861\u3002\u5728\u5b57\u7b26\u4e32\u7ed3\u675f\u65f6\uff0c\u5f53\u6240\u6709\u7b26\u53f7\u90fd\u88ab\u5904\u7406\u5b8c\u540e\uff0c\u6808\u5e94\u8be5\u662f\u7a7a\u7684\u3002\u5b9e\u73b0\u8fd9\u4e2a\u7b97\u6cd5\u7684 Python \u4ee3\u7801\u5982\u4e0b\u6240\u793a\uff08<code>ActiveCode 1</code>\uff09\u3002</p> Activity: 3.6.1 \u89e3\u51b3\u5e73\u8861\u62ec\u53f7\u95ee\u9898<pre><code>from pythonds3.basic import Stack\n\n\ndef par_checker(symbol_string):\n    s = Stack()\n    for symbol in symbol_string:\n        if symbol == \"(\":\n            s.push(symbol)\n        else:\n            if s.is_empty():\n                return False\n            else:\n                s.pop()\n\n    return s.is_empty()\n\n\nprint(par_checker(\"((()))\"))  # \u9884\u671f\u8f93\u51fa True\nprint(par_checker(\"((()()))\"))  # \u9884\u671f\u8f93\u51fa True\nprint(par_checker(\"(()\"))  # \u9884\u671f\u8f93\u51fa False\nprint(par_checker(\")(\"))  # \u9884\u671f\u8f93\u51fa False\n</code></pre> <p>\u8fd9\u4e2a\u51fd\u6570 <code>par_checker</code> \u5047\u8bbe <code>Stack</code> \u7c7b\u662f\u53ef\u7528\u7684\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\uff0c\u8868\u793a\u62ec\u53f7\u5b57\u7b26\u4e32\u662f\u5426\u5e73\u8861\u3002\u5982\u679c\u5f53\u524d\u7b26\u53f7\u662f <code>(</code>\uff0c\u5219\u5c06\u5176\u63a8\u5165\u6808\u4e2d\uff08\u7b2c 7 \u5230 8 \u884c\uff09\u3002\u53e6\u5916\u6ce8\u610f\u7b2c 13 \u884c\u7684 <code>pop</code> \u53ea\u662f\u4ece\u6808\u4e2d\u79fb\u9664\u4e00\u4e2a\u7b26\u53f7\u3002\u8fd4\u56de\u7684\u503c\u6ca1\u6709\u4f7f\u7528\uff0c\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u5b83\u5fc5\u987b\u662f\u4e4b\u524d\u770b\u5230\u7684\u5f00\u7b26\u53f7\u3002\u5982\u679c\u5728\u5904\u7406\u5b8c <code>symbol_string</code> \u4e4b\u524d\u6808\u53d8\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u6709\u592a\u591a\u7684\u95ed\u62ec\u53f7\uff0c\u5b57\u7b26\u4e32\u4e0d\u5e73\u8861\uff0c\u56e0\u6b64\u6211\u4eec\u7acb\u5373\u8fd4\u56de <code>False</code>\uff08\u7b2c 11 \u884c\uff09\u3002\u5728\u7ed3\u675f\u65f6\uff08\u7b2c 15 \u884c\uff09\uff0c\u53ea\u8981\u6808\u5df2\u5b8c\u5168\u6e05\u7a7a\uff0c\u5b57\u7b26\u4e32\u5c31\u4ee3\u8868\u4e00\u4e2a\u6b63\u786e\u5e73\u8861\u7684\u62ec\u53f7\u5e8f\u5217\u3002</p> <p>We now turn our attention to using stacks to solve real computer science problems. You have no doubt written arithmetic expressions such as</p> \\[(5 + 6) * (7 + 8) / (4 + 3)\\] <p>where parentheses are used to order the performance of operations. You may also have some experience programming in a language such as Lisp with constructs like</p> <pre><code>(defun square(n)\n        (* n n))\n</code></pre> <p>This defines a function called <code>square</code> that will return the square of its argument <code>n</code>. Lisp is notorious for using lots and lots of parentheses.</p> <p>In both of these examples, parentheses must appear in a balanced fashion. Balanced parentheses means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. Consider the following correctly balanced strings of parentheses:</p> <pre><code>(()()()())\n\n(((())))\n\n(()((())()))\n</code></pre> <p>Compare those with the following, which are not balanced:</p> <pre><code>    ((((((())\n\n    ()))\n\n    (()()(()\n</code></pre> <p>The ability to differentiate between parentheses that are correctly balanced and those that are unbalanced is an important part of recognizing many programming language structures.</p> <p>The challenge then is to write an algorithm that will read a string of parentheses from left to right and decide whether the symbols are balanced. To solve this problem we need to make an important observation. As you process symbols from left to right, the most recent opening parenthesis must match the next closing symbol (see <code>Figure 4</code>). Also, the first opening symbol processed may have to wait until the very last symbol for its match. Closing symbols match opening symbols in the reverse order of their appearance; they match from the inside out. This is a clue that stacks can be used to solve the problem.</p> <p> Figure 4: Matching Parentheses </p> <p>Once you agree that a stack is the appropriate data structure for keeping the parentheses, the statement of the algorithm is straightforward. Starting with an empty stack, process the parenthesis strings from left to right. If a symbol is an opening parenthesis, push it on the stack as a signal that a corresponding closing symbol needs to appear later. If, on the other hand, a symbol is a closing parenthesis, pop the stack. As long as it is possible to pop the stack to match every closing symbol, the parentheses remain balanced. If at any time there is no opening symbol on the stack to match a closing symbol, the string is not balanced properly. At the end of the string, when all symbols have been processed, the stack should be empty. The Python code to implement this algorithm is shown in <code>ActiveCode 1</code>.</p> Activity: 3.6.1 Solving the Balanced Parentheses Problem<pre><code>from pythonds3.basic import Stack\n\n\ndef par_checker(symbol_string):\n    s = Stack()\n    for symbol in symbol_string:\n        if symbol == \"(\":\n            s.push(symbol)\n        else:\n            if s.is_empty():\n                return False\n            else:\n                s.pop()\n\n    return s.is_empty()\n\n\nprint(par_checker(\"((()))\"))  # expected True\nprint(par_checker(\"((()()))\"))  # expected True\nprint(par_checker(\"(()\"))  # expected False\nprint(par_checker(\")(\"))  # expected False\n</code></pre> <p>This function, <code>par_checker</code>, assumes that a <code>Stack</code> class is available and returns a Boolean result as to whether the string of parentheses is balanced. If the current symbol is <code>(</code>, then it is pushed on the stack (lines 7--8). Note also in line 13 that <code>pop</code> simply removes a symbol from the stack. The returned value is not used since we know it must be an opening symbol seen earlier. If the stack becomes empty before we reach the end of the <code>symbol_string</code>, then there are too many closing parentheses and the string is not balanced, so we immediately return <code>False</code> (line 11). At the end (line 15), the string represents a correctly balanced sequence of parentheses as long as the stack has been completely cleaned off.</p>"},{"location":"c3/s7/","title":"3.7. \u7b26\u53f7\u5339\u914d\uff08\u4e00\u822c\u60c5\u51b5\uff09","text":"<p>3.7. Balanced Symbols (A General Case)</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/BalancedSymbolsAGeneralCase.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u4e0a\u9762\u8ba8\u8bba\u7684\u5e73\u8861\u62ec\u53f7\u95ee\u9898\u662f\u8bb8\u591a\u7f16\u7a0b\u8bed\u8a00\u4e2d\u51fa\u73b0\u7684\u66f4\u4e00\u822c\u60c5\u51b5\u7684\u7279\u4f8b\u3002\u5e73\u8861\u548c\u5d4c\u5957\u4e0d\u540c\u7c7b\u578b\u7684\u5f00\u95ed\u7b26\u53f7\u7684\u666e\u904d\u95ee\u9898\u5728\u7f16\u7a0b\u4e2d\u7ecf\u5e38\u51fa\u73b0\u3002\u4f8b\u5982\uff0c\u5728 Python \u4e2d\uff0c\u65b9\u62ec\u53f7 <code>[</code> \u548c <code>]</code> \u7528\u4e8e\u5217\u8868\uff1b\u5927\u62ec\u53f7 <code>{</code> \u548c <code>}</code> \u7528\u4e8e\u96c6\u5408\u548c\u5b57\u5178\uff1b\u800c\u5706\u62ec\u53f7 <code>(</code> \u548c <code>)</code> \u7528\u4e8e\u5143\u7ec4\u548c\u7b97\u672f\u8868\u8fbe\u5f0f\u3002\u53ea\u8981\u6bcf\u79cd\u7b26\u53f7\u4fdd\u6301\u5176\u81ea\u8eab\u7684\u5f00\u95ed\u5173\u7cfb\uff0c\u5c31\u53ef\u4ee5\u6df7\u5408\u4f7f\u7528\u8fd9\u4e9b\u7b26\u53f7\u3002\u50cf\u4ee5\u4e0b\u8fd9\u6837\u7684\u7b26\u53f7\u4e32\uff1a</p> <pre><code>{ { ( [ ] [ ] ) } ( ) }\n\n[ [ { { ( ( ) ) } } ] ]\n\n[ ] [ ] [ ] ( ) { }\n</code></pre> <p>\u662f\u6b63\u786e\u5e73\u8861\u7684\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u5f00\u7b26\u53f7\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u95ed\u7b26\u53f7\uff0c\u5e76\u4e14\u7b26\u53f7\u7c7b\u578b\u4e5f\u5339\u914d\u3002</p> <p>\u5c06\u8fd9\u4e9b\u4e0e\u4ee5\u4e0b\u4e0d\u5e73\u8861\u7684\u7b26\u53f7\u4e32\u8fdb\u884c\u6bd4\u8f83\uff1a</p> <pre><code>( [ ) ]\n\n( ( ( ) ] ) )\n\n[ { ( ) ]\n</code></pre> <p>\u524d\u4e00\u8282\u4e2d\u7b80\u5355\u7684\u62ec\u53f7\u68c0\u67e5\u5668\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6269\u5c55\u4ee5\u5904\u7406\u8fd9\u4e9b\u65b0\u7684\u7b26\u53f7\u7c7b\u578b\u3002\u56de\u987e\u4e00\u4e0b\uff0c\u6bcf\u4e2a\u5f00\u7b26\u53f7\u90fd\u7b80\u5355\u5730\u63a8\u5165\u6808\u4e2d\uff0c\u4ee5\u7b49\u5f85\u540e\u7eed\u51fa\u73b0\u7684\u5339\u914d\u95ed\u7b26\u53f7\u3002\u5f53\u95ed\u7b26\u53f7\u51fa\u73b0\u65f6\uff0c\u552f\u4e00\u7684\u533a\u522b\u662f\u6211\u4eec\u5fc5\u987b\u68c0\u67e5\u5b83\u662f\u5426\u6b63\u786e\u5339\u914d\u6808\u9876\u7684\u5f00\u7b26\u53f7\u3002\u5982\u679c\u4e24\u4e2a\u7b26\u53f7\u4e0d\u5339\u914d\uff0c\u5219\u5b57\u7b26\u4e32\u4e0d\u5e73\u8861\u3002\u518d\u6b21\u5f3a\u8c03\uff0c\u5982\u679c\u5904\u7406\u5b8c\u6574\u4e2a\u5b57\u7b26\u4e32\u540e\u6808\u4e2d\u6ca1\u6709\u5269\u4f59\u7b26\u53f7\uff0c\u5219\u5b57\u7b26\u4e32\u662f\u6b63\u786e\u5e73\u8861\u7684\u3002</p> <p>\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u7684 Python \u7a0b\u5e8f\u5982\u4e0b\u6240\u793a\uff08<code>ActiveCode 1</code>\uff09\u3002\u552f\u4e00\u7684\u53d8\u5316\u51fa\u73b0\u5728\u7b2c 13 \u884c\uff0c\u6211\u4eec\u8c03\u7528\u4e86\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570 <code>matches</code> \u6765\u5e2e\u52a9\u7b26\u53f7\u5339\u914d\u3002\u6bcf\u4e2a\u4ece\u6808\u4e2d\u79fb\u9664\u7684\u7b26\u53f7\u5fc5\u987b\u68c0\u67e5\u662f\u5426\u4e0e\u5f53\u524d\u7684\u95ed\u7b26\u53f7\u5339\u914d\u3002\u5982\u679c\u53d1\u751f\u4e0d\u5339\u914d\uff0c\u5e73\u8861\u68c0\u67e5\u5668\u5c06\u7acb\u5373\u8fd4\u56de <code>False</code>\u3002</p> Activity: 3.7.1 \u89e3\u51b3\u4e00\u822c\u7684\u7b26\u53f7\u5e73\u8861\u95ee\u9898<pre><code>from pythonds3.basic import Stack\n\n\ndef balance_checker(symbol_string):\n    s = Stack()\n    for symbol in symbol_string:\n        if symbol in \"([{\":\n            s.push(symbol)\n        else:\n            if s.is_empty():\n                return False\n            else:\n                if not matches(s.pop(), symbol):\n                    return False\n\n    return s.is_empty()\n\ndef matches(sym_left, sym_right):\n    all_lefts = \"([{\"\n    all_rights = \")]}\"\n    return all_lefts.index(sym_left) == all_rights.index(sym_right)\n\n\nprint(balance_checker('{({([][])}())}'))\nprint(balance_checker('[{()]'))\n</code></pre> <p>\u8fd9\u4e24\u4e2a\u793a\u4f8b\u8868\u660e\uff0c\u6808\u662f\u5904\u7406\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u8bed\u8a00\u6784\u9020\u7684\u91cd\u8981\u6570\u636e\u7ed3\u6784\u3002\u51e0\u4e4e\u6240\u6709\u4f60\u80fd\u60f3\u5230\u7684\u8bb0\u6cd5\u90fd\u6709\u4e00\u4e9b\u9700\u8981\u6309\u5e73\u8861\u987a\u5e8f\u5339\u914d\u7684\u5d4c\u5957\u7b26\u53f7\u3002\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\uff0c\u6808\u8fd8\u6709\u8bb8\u591a\u5176\u4ed6\u91cd\u8981\u7684\u7528\u9014\u3002\u6211\u4eec\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u90e8\u5206\u7ee7\u7eed\u63a2\u8ba8\u8fd9\u4e9b\u7528\u9014\u3002</p> <p>The balanced parentheses problem shown above is a specific case of a more general situation that arises in many programming languages. The general problem of balancing and nesting different kinds of opening and closing symbols occurs frequently. For example, in Python square brackets, <code>[</code> and <code>]</code>, are used for lists; curly braces, <code>{</code> and <code>}</code>, are used for sets and dictionaries; and parentheses, <code>(</code> and <code>)</code>, are used for tuples and arithmetic expressions. It is possible to mix symbols as long as each maintains its own open and close relationship. Strings of symbols such as</p> <pre><code>{ { ( [ ] [ ] ) } ( ) }\n\n[ [ { { ( ( ) ) } } ] ]\n\n[ ] [ ] [ ] ( ) { }\n</code></pre> <p>are properly balanced in that not only does each opening symbol have a corresponding closing symbol, but the types of symbols match as well.</p> <p>Compare those with the following strings that are not balanced:</p> <pre><code>( [ ) ]\n\n( ( ( ) ] ) )\n\n[ { ( ) ]\n</code></pre> <p>The simple parentheses checker from the previous section can easily be extended to handle these new types of symbols. Recall that each opening symbol is simply pushed on the stack to wait for the matching closing symbol to appear later in the sequence. When a closing symbol does appear, the only difference is that we must check to be sure that it correctly matches the type of the opening symbol on top of the stack. If the two symbols do not match, the string is not balanced. Once again, if the entire string is processed and nothing is left on the stack, the string is correctly balanced.</p> <p>The Python program to implement this is shown in <code>ActiveCode 1</code>. The only change appears in line 13 where we call a helper function, <code>matches</code>, to assist with symbol-matching. Each symbol that is removed from the stack must be checked to see that it matches the current closing symbol. If a mismatch occurs, the balance checker returns <code>False</code> immediately.</p> Activity: 3.7.1 Solving the General Balanced Symbol Problem<pre><code>from pythonds3.basic import Stack\n\n\ndef balance_checker(symbol_string):\n    s = Stack()\n    for symbol in symbol_string:\n        if symbol in \"([{\":\n            s.push(symbol)\n        else:\n            if s.is_empty():\n                return False\n            else:\n                if not matches(s.pop(), symbol):\n                    return False\n\n    return s.is_empty()\n\ndef matches(sym_left, sym_right):\n    all_lefts = \"([{\"\n    all_rights = \")]}\"\n    return all_lefts.index(sym_left) == all_rights.index(sym_right)\n\n\nprint(balance_checker('{({([][])}())}'))\nprint(balance_checker('[{()]'))\n</code></pre> <p>These two examples show that stacks are very important data structures for the processing of language constructs in computer science. Almost any notation you can think of has some type of nested symbol that must be matched in a balanced order. There are a number of other important uses for stacks in computer science. We will continue to explore them in the next sections.</p>"},{"location":"c3/s8/","title":"3.8. \u5c06\u5341\u8fdb\u5236\u6570\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u6570","text":"<p>3.8. Converting Decimal Numbers to Binary Numbers</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/ConvertingDecimalNumberstoBinaryNumbers.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u4f60\u7684\u8ba1\u7b97\u673a\u79d1\u5b66\u5b66\u4e60\u4e2d\uff0c\u4f60\u53ef\u80fd\u5df2\u7ecf\u4ee5\u67d0\u79cd\u65b9\u5f0f\u63a5\u89e6\u8fc7\u4e8c\u8fdb\u5236\u6570\u5b57\u7684\u6982\u5ff5\u3002\u4e8c\u8fdb\u5236\u8868\u793a\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u8ba1\u7b97\u673a\u5185\u90e8\u5b58\u50a8\u7684\u6240\u6709\u503c\u90fd\u662f\u4ee5\u4e8c\u8fdb\u5236\u6570\u5b57\u4e32\u7684\u5f62\u5f0f\u5b58\u5728\uff0c\u5373\u7531 0 \u548c 1 \u7ec4\u6210\u7684\u4e32\u3002\u5982\u679c\u6211\u4eec\u4e0d\u80fd\u5728\u5e38\u89c1\u8868\u793a\u548c\u4e8c\u8fdb\u5236\u6570\u5b57\u4e4b\u95f4\u8fdb\u884c\u8f6c\u6362\uff0c\u6211\u4eec\u5c06\u4e0d\u5f97\u4e0d\u4ee5\u975e\u5e38\u4e0d\u4fbf\u7684\u65b9\u5f0f\u4e0e\u8ba1\u7b97\u673a\u4ea4\u4e92\u3002</p> <p>\u6574\u6570\u503c\u662f\u5e38\u89c1\u7684\u6570\u636e\u9879\u3002\u5728\u8ba1\u7b97\u673a\u7a0b\u5e8f\u548c\u8ba1\u7b97\u4e2d\uff0c\u5b83\u4eec\u7ecf\u5e38\u88ab\u4f7f\u7528\u3002\u6211\u4eec\u5728\u6570\u5b66\u8bfe\u4e0a\u5b66\u4e60\u5b83\u4eec\uff0c\u5f53\u7136\uff0c\u6211\u4eec\u4f7f\u7528\u5341\u8fdb\u5236\u6570\u5b57\u7cfb\u7edf\u6216\u57fa\u6570 10 \u6765\u8868\u793a\u5b83\u4eec\u3002\u5341\u8fdb\u5236\u6570\u5b57 \\(233_{10}\\) \u53ca\u5176\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u7b49\u4ef7 \\(11101001_{2}\\) \u53ef\u4ee5\u5206\u522b\u89e3\u91ca\u4e3a</p> \\[2\\times10^{2} + 3\\times10^{1} + 3\\times10^{0}\\] <p>\u548c</p> \\[1\\times2^{7} + 1\\times2^{6} + 1\\times2^{5} + 0\\times2^{4} + 1\\times2^{3} + 0\\times2^{2} + 0\\times2^{1} + 1\\times2^{0}\\] <p>\u4f46\u6211\u4eec\u5982\u4f55\u8f7b\u677e\u5730\u5c06\u6574\u6570\u503c\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u6570\u5b57\u5462\uff1f\u7b54\u6848\u662f\u4e00\u4e2a\u79f0\u4e3a\u201c\u9664\u4ee5 2\u201d\u7684\u7b97\u6cd5\uff0c\u8be5\u7b97\u6cd5\u4f7f\u7528\u6808\u6765\u8ddf\u8e2a\u4e8c\u8fdb\u5236\u7ed3\u679c\u7684\u6570\u5b57\u3002</p> <p>\u201c\u9664\u4ee5 2\u201d\u7b97\u6cd5\u5047\u8bbe\u6211\u4eec\u4ece\u4e00\u4e2a\u5927\u4e8e 0 \u7684\u6574\u6570\u5f00\u59cb\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u8fed\u4ee3\u8fc7\u7a0b\u4e0d\u65ad\u5c06\u5341\u8fdb\u5236\u6570\u5b57\u9664\u4ee5 2\uff0c\u5e76\u8ddf\u8e2a\u4f59\u6570\u3002\u7b2c\u4e00\u6b21\u9664\u4ee5 2 \u53ef\u4ee5\u786e\u5b9a\u503c\u662f\u5076\u6570\u8fd8\u662f\u5947\u6570\u3002\u5076\u6570\u7684\u4f59\u6570\u4e3a 0\uff0c\u5e76\u4e14\u5728\u4e2a\u4f4d\u4e0a\u4f1a\u6709 0\u3002\u5947\u6570\u7684\u4f59\u6570\u4e3a 1\uff0c\u5e76\u4e14\u5728\u4e2a\u4f4d\u4e0a\u4f1a\u6709 1\u3002\u6211\u4eec\u5c06\u4e8c\u8fdb\u5236\u6570\u5b57\u89c6\u4e3a\u4e00\u4e32\u6570\u5b57\uff1b\u6211\u4eec\u8ba1\u7b97\u7684\u7b2c\u4e00\u4e2a\u4f59\u6570\u5b9e\u9645\u4e0a\u662f\u5e8f\u5217\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002\u5982 <code>Figure 5</code> \u6240\u793a\uff0c\u6211\u4eec\u518d\u6b21\u770b\u5230\u8fd9\u79cd\u9006\u5e8f\u7684\u5c5e\u6027\uff0c\u8fd9\u8868\u660e\u6808\u5f88\u53ef\u80fd\u662f\u89e3\u51b3\u95ee\u9898\u7684\u5408\u9002\u6570\u636e\u7ed3\u6784\u3002</p> <p> Figure 5: \u5341\u8fdb\u5236\u5230\u4e8c\u8fdb\u5236\u8f6c\u6362 </p> <p><code>ActiveCode 1</code> \u4e2d\u7684 Python \u4ee3\u7801\u5b9e\u73b0\u4e86\u201c\u9664\u4ee5 2\u201d\u7b97\u6cd5\u3002\u51fd\u6570 <code>divide_by_2</code> \u63a5\u53d7\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u5b57\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u91cd\u590d\u5c06\u5176\u9664\u4ee5 2\u3002\u7b2c 8 \u884c\u4f7f\u7528\u5185\u7f6e\u7684\u53d6\u6a21\u8fd0\u7b97\u7b26 <code>%</code> \u6765\u63d0\u53d6\u4f59\u6570\uff0c\u7b2c 9 \u884c\u5c06\u5176\u63a8\u5165\u6808\u4e2d\u3002\u5728\u9664\u6cd5\u8fc7\u7a0b\u8fbe\u5230 0 \u540e\uff0c\u5728\u7b2c 12-14 \u884c\u6784\u5efa\u4e00\u4e2a\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u3002\u7b2c 12 \u884c\u521b\u5efa\u4e00\u4e2a\u7a7a\u5b57\u7b26\u4e32\u3002\u4e8c\u8fdb\u5236\u6570\u5b57\u4ece\u6808\u4e2d\u4e00\u4e2a\u4e00\u4e2a\u5f39\u51fa\uff0c\u5e76\u9644\u52a0\u5230\u5b57\u7b26\u4e32\u7684\u53f3\u7aef\u3002\u7136\u540e\u8fd4\u56de\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u3002</p> Activity: 3.8.1 \u4ece\u5341\u8fdb\u5236\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236<pre><code>from pythonds3.basic import Stack\n\n\ndef divide_by_2(decimal_num):\n    rem_stack = Stack()\n\n    while decimal_num &gt; 0:\n        rem = decimal_num % 2\n        rem_stack.push(rem)\n        decimal_num = decimal_num // 2\n\n    bin_string = \"\"\n    while not rem_stack.is_empty():\n        bin_string = bin_string + str(rem_stack.pop())\n\n    return bin_string\n\nprint(divide_by_2(42))\nprint(divide_by_2(31))\n</code></pre> <p>\u4e8c\u8fdb\u5236\u8f6c\u6362\u7684\u7b97\u6cd5\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6269\u5c55\u5230\u6267\u884c\u4efb\u4f55\u8fdb\u5236\u7684\u8f6c\u6362\u3002\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\uff0c\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u7684\u7f16\u7801\u65b9\u5f0f\u662f\u5f88\u5e38\u89c1\u7684\u3002\u5176\u4e2d\u6700\u5e38\u89c1\u7684\u6709\u4e8c\u8fdb\u5236\u3001\u516b\u8fdb\u5236\uff08\u57fa\u6570 8\uff09\u548c\u5341\u516d\u8fdb\u5236\uff08\u57fa\u6570 16\uff09\u3002</p> <p>\u5341\u8fdb\u5236\u6570\u5b57 \\(233\\) \u53ca\u5176\u5bf9\u5e94\u7684\u516b\u8fdb\u5236\u548c\u5341\u516d\u8fdb\u5236\u7b49\u4ef7 \\(351_{8}\\) \u548c \\(E9_{16}\\) \u53ef\u4ee5\u89e3\u91ca\u4e3a</p> <p>\\(3 \\times 8^{2} + 5 \\times 8^{1} + 1 \\times 8^{0}\\)</p> <p>\u548c</p> <p>\\(14 \\times 16^{1} + 9 \\times 16^{0}\\)</p> <p>\u51fd\u6570 <code>divide_by_2</code> \u53ef\u4ee5\u4fee\u6539\u4e3a\u63a5\u53d7\u4e0d\u4ec5\u662f\u5341\u8fdb\u5236\u503c\uff0c\u8fd8\u53ef\u4ee5\u63a5\u53d7\u7528\u4e8e\u8f6c\u6362\u7684\u8fdb\u5236\u3002\u201c\u9664\u4ee5 2\u201d \u7684\u601d\u60f3\u88ab\u66f4\u4e00\u822c\u7684\u201c\u9664\u4ee5\u57fa\u6570\u201d\u6240\u66ff\u4ee3\u3002\u65b0\u7684\u51fd\u6570 <code>base_converter</code> \u5982 <code>ActiveCode 2</code> \u6240\u793a\uff0c\u63a5\u53d7\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u5b57\u548c 2 \u5230 16 \u4e4b\u95f4\u7684\u4efb\u4f55\u57fa\u6570\u4f5c\u4e3a\u53c2\u6570\u3002\u4f59\u6570\u4ecd\u7136\u88ab\u63a8\u5165\u6808\u4e2d\uff0c\u76f4\u5230\u88ab\u8f6c\u6362\u7684\u503c\u53d8\u4e3a 0\u3002\u76f8\u540c\u7684\u4ece\u5de6\u5230\u53f3\u7684\u5b57\u7b26\u4e32\u6784\u5efa\u6280\u672f\u53ef\u4ee5\u4f7f\u7528\uff0c\u53ea\u9700\u505a\u4e00\u4e2a\u5c0f\u7684\u6539\u53d8\u3002\u57fa\u6570 2 \u5230\u57fa\u6570 10 \u7684\u6570\u5b57\u6700\u591a\u9700\u8981 10 \u4e2a\u6570\u5b57\uff0c\u56e0\u6b64\u5178\u578b\u7684\u6570\u5b57\u5b57\u7b26 0 \u5230 9 \u8db3\u591f\u7528\u3002\u5f53\u6211\u4eec\u8d85\u8fc7\u57fa\u6570 10 \u65f6\uff0c\u4f1a\u51fa\u73b0\u95ee\u9898\u3002\u6211\u4eec\u4e0d\u80fd\u7b80\u5355\u5730\u4f7f\u7528\u4f59\u6570\uff0c\u56e0\u4e3a\u5b83\u4eec\u672c\u8eab\u8868\u793a\u4e3a\u4e24\u4f4d\u5341\u8fdb\u5236\u6570\u5b57\u3002\u6211\u4eec\u9700\u8981\u521b\u5efa\u4e00\u7ec4\u53ef\u4ee5\u8868\u793a\u8fd9\u4e9b\u4f59\u6570\u7684\u6570\u5b57\u5b57\u7b26\u3002</p> Activity: 3.8.2 \u4ece\u5341\u8fdb\u5236\u8f6c\u6362\u4e3a\u4efb\u610f\u8fdb\u5236<pre><code>from pythonds3.basic import Stack\n\n\ndef base_converter(decimal_num, base):\n    digits = \"0123456789ABCDEF\"\n    rem_stack = Stack()\n\n    while decimal_num &gt; 0:\n        rem = decimal_num % base\n        rem_stack.push(rem)\n        decimal_num = decimal_num // base\n\n    new_string = \"\"\n    while not rem_stack.is_empty():\n        new_string = new_string + digits[rem_stack.pop()]\n\n    return new_string\n\nprint(base_converter(25, 2))\nprint(base_converter(25, 16))\n</code></pre> <p>\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u7684\u65b9\u6cd5\u662f\u6269\u5c55\u6570\u5b57\u96c6\u4ee5\u5305\u542b\u4e00\u4e9b\u5b57\u6bcd\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5341\u516d\u8fdb\u5236\u4f7f\u7528\u5341\u4e2a\u5341\u8fdb\u5236\u6570\u5b57\u4ee5\u53ca\u524d\u516d\u4e2a\u5b57\u6bcd\u5b57\u7b26\u6765\u8868\u793a 16 \u4e2a\u6570\u5b57\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u521b\u5efa\u4e86\u4e00\u4e2a\u6570\u5b57\u5b57\u7b26\u4e32\uff08\u5728 <code>Listing 6</code> \u7684\u7b2c 5 \u884c\uff09\u6765\u5b58\u50a8\u76f8\u5e94\u4f4d\u7f6e\u7684\u6570\u5b57\u30020 \u4f4d\u4e8e\u4f4d\u7f6e 0\uff0c1 \u4f4d\u4e8e\u4f4d\u7f6e 1\uff0cA \u4f4d\u4e8e\u4f4d\u7f6e 10\uff0cB \u4f4d\u4e8e\u4f4d\u7f6e 11\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\u5f53\u4ece\u6808\u4e2d\u79fb\u9664\u4f59\u6570\u65f6\uff0c\u5b83\u53ef\u4ee5\u7528\u6765\u7d22\u5f15\u6570\u5b57\u5b57\u7b26\u4e32\uff0c\u5e76\u5c06\u6b63\u786e\u7684\u7ed3\u679c\u6570\u5b57\u9644\u52a0\u5230\u7b54\u6848\u4e2d\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f59\u6570 13 \u4ece\u6808\u4e2d\u79fb\u9664\uff0c\u5219\u5c06\u6570\u5b57 D \u9644\u52a0\u5230\u7ed3\u679c\u5b57\u7b26\u4e32\u4e2d\u3002</p> <p>\u81ea\u6211\u68c0\u6d4b</p> Activity: 3.8.3 \u586b\u7a7a\u9898Activity: 3.8.4 \u586b\u7a7a\u9898Activity: 3.8.5 \u586b\u7a7a\u9898 <p>25 \u8868\u793a\u4e3a\u516b\u8fdb\u5236\u6570\u5b57\u7684\u503c\u662f\u591a\u5c11\uff1f</p> <p>|blank|</p> <ul> <li>:31: \u6b63\u786e\u3002</li> <li> \u9519\u8bef\u3002</li> </ul> <p>256 \u8868\u793a\u4e3a\u5341\u516d\u8fdb\u5236\u6570\u5b57\u7684\u503c\u662f\u591a\u5c11\uff1f</p> <p>|blank|</p> <ul> <li> \u6b63\u786e\u3002</li> <li> \u9519\u8bef\u3002</li> </ul> <p>26 \u8868\u793a\u4e3a\u57fa\u6570 26 \u7684\u503c\u662f\u591a\u5c11\uff1f</p> <p>|blank|</p> <ul> <li>:10: \u6b63\u786e\u3002</li> <li> \u4f60\u53ef\u80fd\u9700\u8981\u4fee\u6539 baseConverter \u51fd\u6570\uff0c\u6216\u8005\u4ec5\u4ec5\u627e\u51fa\u57fa\u6570\u8f6c\u6362\u4e2d\u7684\u89c4\u5f8b\u3002</li> </ul> <p>In your study of computer science, you have probably been exposed in one way or another to the idea of a binary number. Binary representation is important in computer science since all values stored within a computer exist as a string of binary digits, a string of 0s and 1s. Without the ability to convert back and forth between common representations and binary numbers, we would need to interact with computers in very awkward ways.</p> <p>Integer values are common data items. They are used in computer programs and computation all the time. We learn about them in math class and of course represent them using the decimal number system, or base 10. The decimal number \\(233_{10}\\) and its corresponding binary equivalent \\(11101001_{2}\\) are interpreted respectively as</p> \\[2\\times10^{2} + 3\\times10^{1} + 3\\times10^{0}\\] <p>and</p> \\[1\\times2^{7} + 1\\times2^{6} + 1\\times2^{5} + 0\\times2^{4} + 1\\times2^{3} + 0\\times2^{2} + 0\\times2^{1} + 1\\times2^{0}\\] <p>But how can we easily convert integer values into binary numbers? The answer is an algorithm called Divide by 2 that uses a stack to keep track of the digits for the binary result.</p> <p>The Divide by 2 algorithm assumes that we start with an integer greater than 0. A simple iteration then continually divides the decimal number by 2 and keeps track of the remainder. The first division by 2 gives information as to whether the value is even or odd. An even value will  have a remainder of 0 and will have the digit 0 in the ones place. An odd value will have a remainder of 1 and will have the digit 1 in the ones place. We think about building our binary number as a sequence of digits; the first remainder we compute will actually be the last digit in the sequence. As shown in <code>Figure 5</code>, we again see the reversal property that signals that a stack is likely to be the appropriate data structure for solving the problem.</p> <p> Figure 5: Decimal-to-Binary Conversion </p> <p>The Python code in <code>ActiveCode 1</code> implements the Divide by 2 algorithm. The function <code>divide_by_2</code> takes an argument that is a decimal number and repeatedly divides it by 2. Line 8 uses the built-in modulo operator, <code>%</code>, to extract the remainder and line 9 then pushes it on the stack. After the division process reaches 0, a binary string is constructed in lines 12-14. Line 12 creates an empty string. The binary digits are popped from the stack one at a time and appended to the right-hand end of the string. The binary string is then returned.</p> Activity: 3.8.1 Converting from Decimal to Binary<pre><code>from pythonds3.basic import Stack\n\n\ndef divide_by_2(decimal_num):\n    rem_stack = Stack()\n\n    while decimal_num &gt; 0:\n        rem = decimal_num % 2\n        rem_stack.push(rem)\n        decimal_num = decimal_num // 2\n\n    bin_string = \"\"\n    while not rem_stack.is_empty():\n        bin_string = bin_string + str(rem_stack.pop())\n\n    return bin_string\n\nprint(divide_by_2(42))\nprint(divide_by_2(31))\n</code></pre> <p>The algorithm for binary conversion can easily be extended to perform the conversion for any base. In computer science it is common to use a number of different encodings. The most common of these are binary, octal (base 8), and hexadecimal (base 16).</p> <p>The decimal number \\(233\\) and its corresponding octal and hexadecimal equivalents \\(351_{8}\\) and \\(E9_{16}\\) are interpreted as</p> <p>\\(3 \\times 8^{2} + 5 \\times 8^{1} + 1 \\times 8^{0}\\)</p> <p>and</p> <p>\\(14 \\times 16^{1} + 9 \\times 16^{0}\\)</p> <p>The function <code>divide_by_2</code> can be modified to accept not only a decimal value but also a base for the intended conversion. The \u201cDivide by 2\u201d idea is simply replaced with a more general \u201cDivide by base.\u201d A new function called <code>base_converter</code>, shown in <code>ActiveCode 2</code>, takes a decimal number and any base between 2 and 16 as parameters. The remainders are still pushed onto the stack until the value being converted becomes 0. The same left-to-right string construction technique can be used with one slight change. Base 2 through base 10 numbers need a maximum of 10 digits, so the typical digit characters 0  through 9 work fine. The problem comes when we go beyond base 10. We can no longer simply use the remainders, as they are themselves represented as two-digit decimal numbers. Instead we need to create a set of digits that can be used to represent those remainders beyond 9.</p> Activity: 3.8.2 Converting from Decimal to any Base<pre><code>from pythonds3.basic import Stack\n\n\ndef base_converter(decimal_num, base):\n    digits = \"0123456789ABCDEF\"\n    rem_stack = Stack()\n\n    while decimal_num &gt; 0:\n        rem = decimal_num % base\n        rem_stack.push(rem)\n        decimal_num = decimal_num // base\n\n    new_string = \"\"\n    while not rem_stack.is_empty():\n        new_string = new_string + digits[rem_stack.pop()]\n\n    return new_string\n\nprint(base_converter(25, 2))\nprint(base_converter(25, 16))\n</code></pre> <p>A solution to this problem is to extend the digit set to include some alphabet characters. For example, hexadecimal uses the ten decimal digits along with the first six alphabet characters for the 16 digits. To implement this, a digit string is created (line 5 in <code>Listing 6</code>) that stores the digits in their corresponding positions. 0 is at position 0, 1 is at position 1, A is at position 10, B is at position 11, and so on. When a remainder is removed from the stack, it can be used to index into the digit string and the correct resulting digit can be appended to the answer. For example, if the remainder 13 is removed from the stack, the digit D is appended to the resulting string.</p> <p>Self Check</p> Activity: 3.8.3 Fill in the BlankActivity: 3.8.4 Fill in the BlankActivity: 3.8.5 Fill in the Blank <p>What is value of 25 expressed as an octal number?</p> <p>|blank|</p> <ul> <li>:31: Correct.</li> <li> Incorrect</li> </ul> <p>What is value of 256 expressed as a hexidecimal number?</p> <p>|blank|</p> <ul> <li> Correct.</li> <li> Incorrect.</li> </ul> <p>What is value of 26 expressed in base 26?</p> <p>|blank|</p> <ul> <li>:10: Correct.</li> <li> You may need to modify the baseConverter function, or simply find a pattern in the conversion of bases.</li> </ul>"},{"location":"c3/s9/","title":"3.9. \u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f","text":"<p>3.9. Infix, Prefix, and Postfix Expressions</p> <p>\u539f\u6587: https://runestone.academy/ns/books/published/pythonds3/BasicDS/InfixPrefixandPostfixExpressions.html?mode=browsing</p> \u4e2d\u6587\u82f1\u6587 <p>\u5f53\u4f60\u5199\u4e0b\u4e00\u4e2a\u7b97\u672f\u8868\u8fbe\u5f0f\uff0c\u5982 B \u00b7 C \u65f6\uff0c\u8868\u8fbe\u5f0f\u7684\u5f62\u5f0f\u4f1a\u63d0\u4f9b\u4fe1\u606f\uff0c\u4ee5\u4fbf\u4f60\u53ef\u4ee5\u6b63\u786e\u89e3\u91ca\u5b83\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u77e5\u9053\u53d8\u91cf B \u6b63\u5728\u88ab\u53d8\u91cf C \u4e58\uff0c\u56e0\u4e3a\u4e58\u6cd5\u8fd0\u7b97\u7b26 \u00b7 \u51fa\u73b0\u5728\u5b83\u4eec\u4e4b\u95f4\u3002\u8fd9\u79cd\u7b26\u53f7\u8868\u793a\u6cd5\u79f0\u4e3a \u4e2d\u7f00\uff0c\u56e0\u4e3a\u8fd0\u7b97\u7b26 \u5728 \u4e24\u4e2a\u64cd\u4f5c\u6570\u4e4b\u95f4\u3002</p> <p>\u8003\u8651\u53e6\u4e00\u4e2a\u4e2d\u7f00\u793a\u4f8b A + B \u00b7 C\u3002\u8fd0\u7b97\u7b26 + \u548c \u00b7 \u4ecd\u7136\u51fa\u73b0\u5728\u64cd\u4f5c\u6570\u4e4b\u95f4\uff0c\u4f46\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\u3002\u8fd9\u4e9b\u8fd0\u7b97\u7b26\u4f5c\u7528\u4e8e\u54ea\u4e2a\u64cd\u4f5c\u6570\uff1f+ \u8fd0\u7b97\u7b26\u4f5c\u7528\u4e8e A \u548c B\uff0c\u8fd8\u662f \u00b7 \u8fd0\u7b97\u7b26\u4f5c\u7528\u4e8e B \u548c C\uff1f\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u4f3c\u4e4e\u542b\u7cca\u4e0d\u6e05\u3002</p> <p>\u5b9e\u9645\u4e0a\uff0c\u4f60\u5df2\u7ecf\u5f88\u957f\u65f6\u95f4\u5728\u9605\u8bfb\u548c\u7f16\u5199\u8fd9\u79cd\u7c7b\u578b\u7684\u8868\u8fbe\u5f0f\uff0c\u8fd9\u4e9b\u5e76\u4e0d\u4f1a\u5bf9\u4f60\u9020\u6210\u56f0\u6270\u3002\u539f\u56e0\u5728\u4e8e\u4f60\u4e86\u89e3 + \u548c \u00b7 \u8fd0\u7b97\u7b26\u7684\u4e00\u4e9b\u89c4\u5219\u3002\u6bcf\u4e2a\u8fd0\u7b97\u7b26\u90fd\u6709\u4e00\u4e2a \u4f18\u5148\u7ea7 \u7ea7\u522b\u3002\u4f18\u5148\u7ea7\u66f4\u9ad8\u7684\u8fd0\u7b97\u7b26\u4f1a\u5728\u4f18\u5148\u7ea7\u8f83\u4f4e\u7684\u8fd0\u7b97\u7b26\u4e4b\u524d\u4f7f\u7528\u3002\u552f\u4e00\u53ef\u4ee5\u6539\u53d8\u8fd9\u79cd\u987a\u5e8f\u7684\u60c5\u51b5\u662f\u5b58\u5728\u62ec\u53f7\u3002\u7b97\u672f\u8fd0\u7b97\u7b26\u7684\u4f18\u5148\u7ea7\u987a\u5e8f\u662f\u5c06\u4e58\u6cd5\u548c\u9664\u6cd5\u7f6e\u4e8e\u52a0\u6cd5\u548c\u51cf\u6cd5\u4e4b\u4e0a\u3002\u5982\u679c\u4e24\u4e2a\u8fd0\u7b97\u7b26\u5177\u6709\u76f8\u540c\u7684\u4f18\u5148\u7ea7\uff0c\u5219\u4f7f\u7528\u4ece\u5de6\u5230\u53f3\u7684\u987a\u5e8f\u6216\u7ed3\u5408\u6027\u3002</p> <p>\u6211\u4eec\u7528\u8fd0\u7b97\u7b26\u4f18\u5148\u7ea7\u6765\u89e3\u91ca\u6709\u95ee\u9898\u7684\u8868\u8fbe\u5f0f A + B \u00b7 C\u3002\u9996\u5148\u8fdb\u884c B \u548c C \u7684\u4e58\u6cd5\uff0c\u7136\u540e\u5c06\u7ed3\u679c\u52a0\u4e0a A\u3002 (A + B) \u00b7 C \u4f1a\u5f3a\u5236\u5148\u8fdb\u884c A \u548c B \u7684\u52a0\u6cd5\uff0c\u7136\u540e\u8fdb\u884c\u4e58\u6cd5\u3002\u5728\u8868\u8fbe\u5f0f A + B + C \u4e2d\uff0c\u6309\u7167\u4f18\u5148\u7ea7\uff08\u901a\u8fc7\u7ed3\u5408\u6027\uff09\uff0c\u6700\u5de6\u8fb9\u7684 + \u4f1a\u5148\u8fdb\u884c\u3002</p> <p>\u867d\u7136\u8fd9\u4e00\u5207\u5bf9\u4f60\u6765\u8bf4\u53ef\u80fd\u5f88\u660e\u663e\uff0c\u4f46\u8981\u8bb0\u4f4f\u8ba1\u7b97\u673a\u9700\u8981\u786e\u5207\u77e5\u9053\u8981\u6267\u884c\u54ea\u4e9b\u64cd\u4f5c\u4ee5\u53ca\u6267\u884c\u7684\u987a\u5e8f\u3002\u786e\u4fdd\u64cd\u4f5c\u987a\u5e8f\u6ca1\u6709\u6df7\u6dc6\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u521b\u5efa\u4e00\u4e2a\u79f0\u4e3a \u5b8c\u5168\u62ec\u53f7\u5316 \u7684\u8868\u8fbe\u5f0f\u3002\u8fd9\u79cd\u7c7b\u578b\u7684\u8868\u8fbe\u5f0f\u4e3a\u6bcf\u4e2a\u8fd0\u7b97\u7b26\u4f7f\u7528\u4e00\u5bf9\u62ec\u53f7\u3002\u62ec\u53f7\u51b3\u5b9a\u4e86\u64cd\u4f5c\u7684\u987a\u5e8f\uff1b\u6ca1\u6709\u6b67\u4e49\u3002\u4e5f\u4e0d\u9700\u8981\u8bb0\u4f4f\u4efb\u4f55\u4f18\u5148\u7ea7\u89c4\u5219\u3002</p> <p>\u8868\u8fbe\u5f0f A + B \u00b7 C + D \u53ef\u4ee5\u91cd\u5199\u4e3a ((A + (B \u00b7 C)) + D) \u6765\u663e\u793a\u4e58\u6cd5\u5148\u8fdb\u884c\uff0c\u7136\u540e\u662f\u6700\u5de6\u8fb9\u7684\u52a0\u6cd5\u3002 A + B + C + D \u53ef\u4ee5\u5199\u4f5c (((A + B) + C) + D)\uff0c\u56e0\u4e3a\u52a0\u6cd5\u64cd\u4f5c\u4ece\u5de6\u5230\u53f3\u7ed3\u5408\u3002</p> <p>\u8fd8\u6709\u4e24\u79cd\u5176\u4ed6\u975e\u5e38\u91cd\u8981\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f\uff0c\u5f00\u59cb\u65f6\u53ef\u80fd\u5bf9\u4f60\u4e0d\u592a\u660e\u663e\u3002\u8003\u8651\u4e2d\u7f00\u8868\u8fbe\u5f0f A + B\u3002\u5982\u679c\u6211\u4eec\u5c06\u8fd0\u7b97\u7b26\u79fb\u5230\u4e24\u4e2a\u64cd\u4f5c\u6570\u4e4b\u524d\uff0c\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f\u5f97\u5230\u7684\u8868\u8fbe\u5f0f\u662f + A B\u3002\u540c\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd0\u7b97\u7b26\u79fb\u5230\u672b\u5c3e\uff0c\u5f97\u5230 A B +\u3002\u8fd9\u4e9b\u770b\u8d77\u6765\u6709\u70b9\u5947\u602a\u3002</p> <p>\u8fd9\u4e9b\u5bf9\u8fd0\u7b97\u7b26\u76f8\u5bf9\u4e8e\u64cd\u4f5c\u6570\u7684\u4f4d\u7f6e\u7684\u6539\u53d8\u521b\u5efa\u4e86\u4e24\u79cd\u65b0\u7684\u8868\u8fbe\u5f0f\u683c\u5f0f\uff0c\u524d\u7f00 \u548c \u540e\u7f00\u3002\u524d\u7f00\u8868\u8fbe\u5f0f\u8868\u793a\u6cd5\u8981\u6c42\u6240\u6709\u8fd0\u7b97\u7b26\u51fa\u73b0\u5728\u5b83\u4eec\u64cd\u4f5c\u7684\u4e24\u4e2a\u64cd\u4f5c\u6570\u4e4b\u524d\u3002\u800c\u540e\u7f00\u5219\u8981\u6c42\u8fd0\u7b97\u7b26\u51fa\u73b0\u5728\u76f8\u5e94\u7684\u64cd\u4f5c\u6570\u4e4b\u540e\u3002\u66f4\u591a\u7684\u793a\u4f8b\u5e94\u8be5\u6709\u52a9\u4e8e\u4f7f\u8fd9\u4e00\u70b9\u66f4\u6e05\u6670\uff08\u89c1 <code>Table 2</code>\uff09\u3002</p> <p>A + B \u00b7 C \u5728\u524d\u7f00\u8868\u8fbe\u5f0f\u4e2d\u5199\u4f5c + A \u00b7 B C\u3002\u4e58\u6cd5\u8fd0\u7b97\u7b26\u7d27\u63a5\u5728\u64cd\u4f5c\u6570 B \u548c C \u4e4b\u524d\uff0c\u8868\u793a \u00b7 \u4f18\u5148\u4e8e +\u3002\u7136\u540e\u52a0\u6cd5\u8fd0\u7b97\u7b26\u51fa\u73b0\u5728 A \u548c\u4e58\u6cd5\u7ed3\u679c\u4e4b\u524d\u3002</p> <p>\u5728\u540e\u7f00\u8868\u8fbe\u5f0f\u4e2d\uff0c\u8868\u8fbe\u5f0f\u4e3a A B C \u00b7 +\u3002\u540c\u6837\uff0c\u64cd\u4f5c\u987a\u5e8f\u88ab\u4fdd\u6301\uff0c\u56e0\u4e3a \u00b7 \u7d27\u63a5\u5728 B \u548c C \u4e4b\u540e\uff0c\u8868\u793a \u00b7 \u4f18\u5148\u4e8e +\uff0c\u52a0\u6cd5\u8fd0\u7b97\u7b26\u968f\u540e\u51fa\u73b0\u3002\u867d\u7136\u8fd0\u7b97\u7b26\u79fb\u52a8\u4e86\uff0c\u73b0\u5728\u51fa\u73b0\u5728\u5b83\u4eec\u5404\u81ea\u7684\u64cd\u4f5c\u6570\u4e4b\u524d\u6216\u4e4b\u540e\uff0c\u4f46\u64cd\u4f5c\u6570\u4e4b\u95f4\u7684\u987a\u5e8f\u4fdd\u6301\u5b8c\u5168\u4e0d\u53d8\u3002</p> <p>Table 2: \u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u793a\u4f8b</p> \u4e2d\u7f00\u8868\u8fbe\u5f0f \u524d\u7f00\u8868\u8fbe\u5f0f \u540e\u7f00\u8868\u8fbe\u5f0f A + B + A B A B + A + B \u00b7 C + A \u00b7 B C A B C \u00b7 + <p>\u73b0\u5728\u8003\u8651\u4e2d\u7f00\u8868\u8fbe\u5f0f (A + B) \u00b7 C\u3002\u56de\u60f3\u4e00\u4e0b\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4e2d\u7f00\u8868\u793a\u6cd5\u8981\u6c42\u62ec\u53f7\u5f3a\u5236\u5148\u8fdb\u884c\u52a0\u6cd5\uff0c\u7136\u540e\u518d\u8fdb\u884c\u4e58\u6cd5\u3002\u7136\u800c\uff0c\u5f53 A + B \u5199\u6210\u524d\u7f00\u65f6\uff0c\u52a0\u6cd5\u8fd0\u7b97\u7b26\u88ab\u7b80\u5355\u5730\u79fb\u5230\u64cd\u4f5c\u6570\u4e4b\u524d\uff0c+ A B\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7684\u7ed3\u679c\u6210\u4e3a\u4e58\u6cd5\u7684\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u6570\u3002\u4e58\u6cd5\u8fd0\u7b97\u7b26\u79fb\u5230\u6574\u4e2a\u8868\u8fbe\u5f0f\u4e4b\u524d\uff0c\u5f97\u5230 \u00b7 + A B C\u3002\u540c\u6837\uff0c\u5728\u540e\u7f00\u8868\u8fbe\u5f0f\u4e2d A B + \u5f3a\u5236\u5148\u8fdb\u884c\u52a0\u6cd5\uff0c\u7136\u540e\u5bf9\u7ed3\u679c\u548c\u5269\u4f59\u7684\u64cd\u4f5c\u6570 C \u8fdb\u884c\u4e58\u6cd5\u3002\u6b63\u786e\u7684\u540e\u7f00\u8868\u8fbe\u5f0f\u662f A B + C \u00b7\u3002</p> <p>\u518d\u6b21\u8003\u8651\u8fd9\u4e09\u79cd\u8868\u8fbe\u5f0f\uff08\u89c1 <code>Table 3</code>\uff09\u3002\u53d1\u751f\u4e86\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u4e8b\u60c5\u3002\u62ec\u53f7\u53bb\u4e86\u54ea\u91cc\uff1f\u4e3a\u4ec0\u4e48\u5728\u524d\u7f00\u548c\u540e\u7f00\u8868\u793a\u6cd5\u4e2d\u6211\u4eec\u4e0d\u9700\u8981\u5b83\u4eec\uff1f\u7b54\u6848\u662f\u8fd0\u7b97\u7b26\u5bf9\u4e8e\u5b83\u4eec\u64cd\u4f5c\u7684\u64cd\u4f5c\u6570\u4e0d\u518d\u6a21\u7cca\u3002\u53ea\u6709\u4e2d\u7f00\u8868\u793a\u6cd5\u9700\u8981\u989d\u5916\u7684\u7b26\u53f7\u3002\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u4e2d\u7684\u64cd\u4f5c\u987a\u5e8f\u5b8c\u5168\u7531\u8fd0\u7b97\u7b26\u7684\u4f4d\u7f6e\u51b3\u5b9a\uff0c\u522b\u65e0\u5176\u4ed6\u3002\u5728\u5f88\u591a\u65b9\u9762\uff0c\u8fd9\u4f7f\u5f97\u4e2d\u7f00\u8868\u793a\u6cd5\u6210\u4e3a\u6700\u4e0d\u7406\u60f3\u7684\u8868\u793a\u6cd5\u3002</p> <p>Table 3: \u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u7684\u6bd4\u8f83</p> \u4e2d\u7f00\u8868\u8fbe\u5f0f \u524d\u7f00\u8868\u8fbe\u5f0f \u540e\u7f00\u8868\u8fbe\u5f0f (A + B) \u00b7 C \u00b7 + A B C A B + C \u00b7 <p><code>Table 4</code> \u5c55\u793a\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u4e2d\u7f00\u8868\u8fbe\u5f0f\u53ca\u5176\u7b49\u6548\u7684\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u3002\u786e\u4fdd\u4f60\u7406\u89e3\u5b83\u4eec\u5728\u64cd\u4f5c\u987a\u5e8f\u4e0a\u7684\u7b49\u4ef7\u6027\u3002</p> <p>Table 4: \u989d\u5916\u7684\u4e2d\u7f00\u3001\u524d\u7f00\u548c\u540e\u7f00\u8868\u8fbe\u5f0f\u793a\u4f8b</p> \u4e2d\u7f00\u8868\u8fbe\u5f0f \u524d\u7f00\u8868\u8fbe\u5f0f \u540e\u7f00\u8868\u8fbe\u5f0f A + B \u00b7 C + D + + A \u00b7 B C D A B C \u00b7 + D + (A + B) \u00b7 (C + D) \u00b7 + A B + C D A B + C D + \u00b7 A \u00b7 B + C \u00b7 D + \u00b7 A B \u00b7 C D A B \u00b7 C D \u00b7 + A + B + C + D + + + A B C D A B + C + D + <p>When you write an arithmetic expression such as B \u00b7 C, the form of the expression provides you with information so that you can interpret it correctly. In this case we know that the variable B is being multiplied by the variable C since the multiplication operator \u00b7 appears between them in the expression. This type of notation is referred to as infix since the operator is in between the two operands that it is working on.</p> <p>Consider another infix example, A + B \u00b7 C. The operators + and \u00b7 still appear between the operands, but there is a problem. Which operands do they work on? Does the + work on A and B, or does the \u00b7 take B and C? The expression seems ambiguous.</p> <p>In fact, you have been reading and writing these types of expressions for a long time and they do not cause you any problem. The reason for this is that you know something about the operators + and \u00b7. Each operator has a precedence level. Operators of higher precedence are used before operators of lower precedence. The only thing that can change that order is the presence of parentheses. The precedence order for arithmetic operators places multiplication and division above addition and subtraction. If two operators of equal precedence appear, then a left-to-right ordering or associativity is used.</p> <p>Let\u2019s interpret the troublesome expression A + B \u00b7 C using operator precedence. B and C are multiplied first, and A is then added to that result. (A + B) \u00b7 C would force the addition of A and B to be done first before the multiplication. In the expression A + B + C, by precedence (via associativity), the leftmost + would be done first.</p> <p>Although all this may be obvious to you, remember that computers need to know exactly what operations to perform and in what order. One way to write an expression that guarantees there will be no confusion with respect to the order of operations is to create what is called a fully parenthesized expression. This type of expression uses one pair of parentheses for each operator. The parentheses dictate the order of operations; there is no ambiguity. There is also no need to remember any precedence rules.</p> <p>The expression A + B \u00b7 C + D can be rewritten as ((A + (B \u00b7 C)) + D) to show that the multiplication happens first, followed by the leftmost addition. A + B + C + D can be written as (((A + B) + C) + D) since the addition operations associate from left to right.</p> <p>There are two other very important expression formats that may not seem obvious to you at first. Consider the infix expression A + B. What would happen if we moved the operator before the two operands? The resulting expression would be + A B. Likewise, we could move the operator to the end, resulting in A B +. These look a bit strange.</p> <p>These changes to the position of the operator with respect to the operands create two new expression formats, prefix and postfix. Prefix expression notation requires that all operators precede the two operands that they work on. Postfix, on the other hand, requires that its operators come after the corresponding operands. A few more examples should help to make this a bit clearer (see <code>Table 2</code>).</p> <p>A + B \u00b7 C would be written as + A \u00b7 B C in prefix. The multiplication operator comes immediately before the operands B and C, denoting that \u00b7 has precedence over +. The addition operator then appears before the A and the result of the multiplication.</p> <p>In postfix, the expression would be A B C \u00b7 +. Again, the order of operations is preserved since the \u00b7 appears immediately after the B and the C, denoting that \u00b7 has precedence, with + coming after. Although the operators moved and now appear either before or after their respective operands, the order of the operands stayed exactly the same relative to one another.</p> <p>Table 2: Examples of Infix, Prefix, and Postfix Expressions</p> Infix Expression Prefix Expression Postfix Expression A + B + A B A B + A + B \u00b7 C + A \u00b7 B C A B C \u00b7 + <p>Now consider the infix expression (A + B) \u00b7 C. Recall that in this case, infix requires the parentheses to force the performance of the addition before the multiplication. However, when A + B was written in prefix, the addition operator was simply moved before the operands, + A B. The result of this operation becomes the first operand for the multiplication. The multiplication operator is moved in front of the entire expression, giving us \u00b7 + A B C. Likewise, in postfix A B + forces the addition to happen first. The multiplication can be done to that result and the remaining operand C. The proper postfix expression is then A B + C \u00b7.</p> <p>Consider these three expressions again (see <code>Table 3</code>). Something very important has happened. Where did the parentheses go? Why don\u2019t we need them in prefix and postfix? The answer is that the operators are no longer ambiguous with respect to the operands that they work on. Only infix notation requires the additional symbols. The order of operations within prefix and postfix expressions is completely determined by the position of the operator and nothing else. In many ways, this makes infix the least desirable notation to use.</p> <p>Table 3: Comparison of Infix, Prefix, and Postfix Expressions</p> Infix Expression Prefix Expression Postfix Expression (A + B) \u00b7 C \u00b7 + A B C A B + C \u00b7 <p><code>Table 4</code> shows some additional examples of infix expressions and the equivalent prefix and postfix expressions. Be sure that you understand how they are equivalent in terms of the order of the operations being performed.</p> <p>Table 4: Additional Examples of Infix, Prefix, and Postfix Expressions</p> Infix Expression Prefix Expression Postfix Expression A + B \u00b7 C + D + + A \u00b7 B C D A B C \u00b7 + D + (A + B) \u00b7 (C + D) \u00b7 + A B + C D A B + C D + \u00b7 A \u00b7 B + C \u00b7 D + \u00b7 A B \u00b7 C D A B \u00b7 C D \u00b7 + A + B + C + D + + + A B C D A B + C + D +"},{"location":"c3/s9/#391-\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u524d\u7f00\u548c\u540e\u7f00","title":"3.9.1. \u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u6362\u4e3a\u524d\u7f00\u548c\u540e\u7f00","text":"<p>3.9.1. Conversion of Infix Expressions to Prefix and Postfix</p> \u4e2d\u6587\u82f1\u6587 <p>So far, we have used ad hoc methods to convert between infix expressions and the equivalent prefix and postfix expression notations. As you might expect, there are algorithmic ways to perform the conversion that allow any expression of any complexity to be correctly transformed.</p> <p>The first technique that we will consider uses the notion of a fully parenthesized expression that was discussed earlier. Recall that A + B \u00b7 C can be written as (A + (B \u00b7 C)) to show explicitly that the multiplication has precedence over the addition. On closer observation, however, you can see that each parenthesis pair also denotes the beginning and the end of an operand pair with the corresponding operator in the middle.</p> <p>Look at the right parenthesis in the subexpression (B \u00b7 C) above. If we were to move the multiplication symbol to that position and remove the matching left parenthesis, giving us B C \u00b7, we would in effect have converted the subexpression to postfix notation. If the addition operator were also moved to its corresponding right parenthesis position and the matching left parenthesis were removed, the complete postfix expression would result (see <code>Figure 6</code>).</p> <p> Figure 6: Moving Operators to the Right for Postfix Notation </p> <p>If we do the same thing but instead of moving the symbol to the position of the right parenthesis, we move it to the left, we get prefix notation (see <code>Figure 7</code>). The position of the parenthesis pair is actually a clue to the final position of the enclosed operator.</p> <p> Figure 7: Moving Operators to the Left for Prefix Notation </p> <p>So in order to convert an expression, no matter how complex, to either prefix or postfix notation, fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation.</p> <p>Here is a more complex expression: (A + B) \u00b7 C - (D - E) \u00b7 (F + G). <code>Figure 8</code> shows the conversion to prefix and postfix notations.</p> <p> Figure 8: Converting a Complex Expression to Prefix and Postfix Notations </p> <p>So far, we have used ad hoc methods to convert between infix expressions and the equivalent prefix and postfix expression notations. As you might expect, there are algorithmic ways to perform the conversion that allow any expression of any complexity to be correctly transformed.</p> <p>The first technique that we will consider uses the notion of a fully parenthesized expression that was discussed earlier. Recall that A + B \u00b7 C can be written as (A + (B \u00b7 C)) to show explicitly that the multiplication has precedence over the addition. On closer observation, however, you can see that each parenthesis pair also denotes the beginning and the end of an operand pair with the corresponding operator in the middle.</p> <p>Look at the right parenthesis in the subexpression (B \u00b7 C) above. If we were to move the multiplication symbol to that position and remove the matching left parenthesis, giving us B C \u00b7, we would in effect have converted the subexpression to postfix notation. If the addition operator were also moved to its corresponding right parenthesis position and the matching left parenthesis were removed, the complete postfix expression would result (see <code>Figure 6</code>).</p> <p> Figure 6: Moving Operators to the Right for Postfix Notation </p> <p>If we do the same thing but instead of moving the symbol to the position of the right parenthesis, we move it to the left, we get prefix notation (see <code>Figure 7</code>). The position of the parenthesis pair is actually a clue to the final position of the enclosed operator.</p> <p> Figure 7: Moving Operators to the Left for Prefix Notation </p> <p>So in order to convert an expression, no matter how complex, to either prefix or postfix notation, fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation.</p> <p>Here is a more complex expression: (A + B) \u00b7 C - (D - E) \u00b7 (F + G). <code>Figure 8</code> shows the conversion to prefix and postfix notations.</p> <p> Figure 8: Converting a Complex Expression to Prefix and Postfix Notations </p>"},{"location":"c3/s9/#392-\u4e00\u822c\u7684\u4e2d\u7f00\u8f6c\u540e\u7f00\u8f6c\u6362","title":"3.9.2. \u4e00\u822c\u7684\u4e2d\u7f00\u8f6c\u540e\u7f00\u8f6c\u6362","text":"<p>3.9.2. General Infix-to-Postfix Conversion</p> \u4e2d\u6587\u82f1\u6587 <p>We need to develop an algorithm to convert any infix expression to a postfix expression. To do this we will look closer at the conversion process.</p> <p>Consider once again the expression A + B \u00b7 C. As shown above, A B C \u00b7 + is the postfix equivalent. We have already noted that the operands A, B, and C stay in their relative positions. It is only the operators that change position. Let\u2019s look again at the operators in the infix expression. The first operator that appears from left to right is +. However, in the postfix expression, + is at the end since the next operator, \u00b7, has precedence over addition. The order of the operators in the original expression is reversed in the resulting postfix expression.</p> <p>As we process the expression, the operators have to be saved somewhere since their corresponding right operands are not seen yet. Also, the order of these saved operators may need to be reversed due to their precedence. This is the case with the addition and the multiplication in this example. Since the addition operator comes before the multiplication operator and has lower precedence, it needs to appear after the multiplication operator is used. Because of this reversal of order, it makes sense to consider using a stack to keep the operators until they are needed.</p> <p>What about (A + B) \u00b7 C? Recall that A B + C \u00b7 is the postfix equivalent. Again, processing this infix expression from left to right, we see + first. In this case, when we see \u00b7, + has already been placed in the result expression because it has precedence over \u00b7 by virtue of the parentheses. We can now start to see how the conversion algorithm will work. When we see a left parenthesis, we will save it to denote that another operator of high precedence will be coming. That operator will need to wait until the corresponding right parenthesis appears to denote its position (recall the fully parenthesized technique). When that right parenthesis does appear, the operator can be popped from the stack.</p> <p>As we scan the infix expression from left to right, we will use a stack to keep the operators. This will provide the reversal that we noted in the first example. The top of the stack will always be the most recently saved operator. Whenever we read a new operator, we will need to consider how that operator compares in precedence with the operators, if any, already on the stack.</p> <p>Assume the infix expression is a string of tokens delimited by spaces. The operator tokens are \u00b7, /, +, and -, along with the left and right parentheses, ( and ). The operand tokens are the single-character identifiers A, B, C, and so on. The following steps will produce a string of tokens in postfix order.</p> <ol> <li>Create an empty stack called <code>op_stack</code> for keeping operators. Create an empty list for output.</li> <li>Convert the input infix string to a list by using the string method <code>split</code>.</li> <li> <p>Scan the token list from left to right.</p> </li> <li> <p>If the token is an operand, append it to the end of the output list.</p> </li> <li> <p>If the token is a left parenthesis, push it on the <code>op_stack</code>.</p> </li> <li> <p>If the token is a right parenthesis, pop the <code>op_stack</code> until the corresponding left parenthesis is removed. Append each operator to the end of the output list.</p> </li> <li> <p>If the token is an operator, \u00b7, /, +, or -, push it on the <code>op_stack</code>. However, first remove any operators already on the <code>op_stack</code> that have higher or equal precedence and append them to the output list.</p> </li> <li> <p>When the input expression has been completely processed, check the <code>op_stack</code>. Any operators still on the stack can be removed and appended to the end of the output list.</p> </li> </ol> <p><code>Figure 9</code> shows the conversion algorithm working on the expression A \u00b7 B + C \u00b7 D. Note that the first \u00b7 operator is removed upon seeing the + operator. Also, + stays on the stack when the second \u00b7 occurs, since multiplication has precedence over addition. At the end of the infix expression the stack is popped twice, removing both operators and placing + as the last operator in the postfix expression.</p> <p> Figure 9: Converting A \u00b7 B + C \u00b7 D to Postfix Notation </p> <p>In order to code the algorithm in Python, we will use a dictionary called <code>prec</code> to hold the precedence values for the operators, as seen in in <code>ActiveCode 1</code>. This dictionary will map each operator to an integer that can be compared against the precedence levels of other operators (we have arbitrarily used the integers 3, 2, and 1). The left parenthesis will receive the lowest value possible. This way any operator that is compared against it will have higher precedence and will be placed on top of it. Line 15 defines the operands to be any upper-case character or digit.</p> Activity: 3.9.2.1 Converting Infix Expressions to Postfix Expressions<pre><code>from pythonds3.basic import Stack\n\ndef infix_to_postfix(infix_expr):\n    prec = {}\n    prec[\"*\"] = 3\n    prec[\"/\"] = 3\n    prec[\"+\"] = 2\n    prec[\"-\"] = 2\n    prec[\"(\"] = 1\n    op_stack = Stack()\n    postfix_list = []\n    token_list = infix_expr.split()\n\n    for token in token_list:\n        if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\":\n            postfix_list.append(token)\n        elif token == \"(\":\n            op_stack.push(token)\n        elif token == \")\":\n            top_token = op_stack.pop()\n            while top_token != \"(\":\n                postfix_list.append(top_token)\n                top_token = op_stack.pop()\n        else:\n            while (not op_stack.is_empty()) and (prec[op_stack.peek()] &gt;= prec[token]):\n                postfix_list.append(op_stack.pop())\n            op_stack.push(token)\n\n    while not op_stack.is_empty():\n        postfix_list.append(op_stack.pop())\n\n    return \" \".join(postfix_list)\n\nprint(infix_to_postfix(\"A * B + C * D\"))\nprint(infix_to_postfix(\"( A + B ) * C - ( D - E ) * ( F + G )\"))\n</code></pre> <p>A few more examples of execution in the Python shell are shown below.</p> <pre><code>&gt;&gt;&gt; infix_to_postfix(\"( A + B ) * ( C + D )\")\n'A B + C D + *'\n&gt;&gt;&gt; infix_to_postfix(\"( A + B ) * C\")\n'A B + C *'\n&gt;&gt;&gt; infix_to_postfix(\"A + B * C\")\n'A B C * +'\n&gt;&gt;&gt;\n</code></pre> <p>We need to develop an algorithm to convert any infix expression to a postfix expression. To do this we will look closer at the conversion process.</p> <p>Consider once again the expression A + B \u00b7 C. As shown above, A B C \u00b7 + is the postfix equivalent. We have already noted that the operands A, B, and C stay in their relative positions. It is only the operators that change position. Let\u2019s look again at the operators in the infix expression. The first operator that appears from left to right is +. However, in the postfix expression, + is at the end since the next operator, \u00b7, has precedence over addition. The order of the operators in the original expression is reversed in the resulting postfix expression.</p> <p>As we process the expression, the operators have to be saved somewhere since their corresponding right operands are not seen yet. Also, the order of these saved operators may need to be reversed due to their precedence. This is the case with the addition and the multiplication in this example. Since the addition operator comes before the multiplication operator and has lower precedence, it needs to appear after the multiplication operator is used. Because of this reversal of order, it makes sense to consider using a stack to keep the operators until they are needed.</p> <p>What about (A + B) \u00b7 C? Recall that A B + C \u00b7 is the postfix equivalent. Again, processing this infix expression from left to right, we see + first. In this case, when we see \u00b7, + has already been placed in the result expression because it has precedence over \u00b7 by virtue of the parentheses. We can now start to see how the conversion algorithm will work. When we see a left parenthesis, we will save it to denote that another operator of high precedence will be coming. That operator will need to wait until the corresponding right parenthesis appears to denote its position (recall the fully parenthesized technique). When that right parenthesis does appear, the operator can be popped from the stack.</p> <p>As we scan the infix expression from left to right, we will use a stack to keep the operators. This will provide the reversal that we noted in the first example. The top of the stack will always be the most recently saved operator. Whenever we read a new operator, we will need to consider how that operator compares in precedence with the operators, if any, already on the stack.</p> <p>Assume the infix expression is a string of tokens delimited by spaces. The operator tokens are \u00b7, /, +, and -, along with the left and right parentheses, ( and ). The operand tokens are the single-character identifiers A, B, C, and so on. The following steps will produce a string of tokens in postfix order.</p> <ol> <li>Create an empty stack called <code>op_stack</code> for keeping operators. Create an empty list for output.</li> <li>Convert the input infix string to a list by using the string method <code>split</code>.</li> <li> <p>Scan the token list from left to right.</p> </li> <li> <p>If the token is an operand, append it to the end of the output list.</p> </li> <li> <p>If the token is a left parenthesis, push it on the <code>op_stack</code>.</p> </li> <li> <p>If the token is a right parenthesis, pop the <code>op_stack</code> until the corresponding left parenthesis is removed. Append each operator to the end of the output list.</p> </li> <li> <p>If the token is an operator, \u00b7, /, +, or -, push it on the <code>op_stack</code>. However, first remove any operators already on the <code>op_stack</code> that have higher or equal precedence and append them to the output list.</p> </li> <li> <p>When the input expression has been completely processed, check the <code>op_stack</code>. Any operators still on the stack can be removed and appended to the end of the output list.</p> </li> </ol> <p><code>Figure 9</code> shows the conversion algorithm working on the expression A \u00b7 B + C \u00b7 D. Note that the first \u00b7 operator is removed upon seeing the + operator. Also, + stays on the stack when the second \u00b7 occurs, since multiplication has precedence over addition. At the end of the infix expression the stack is popped twice, removing both operators and placing + as the last operator in the postfix expression.</p> <p> Figure 9: Converting A \u00b7 B + C \u00b7 D to Postfix Notation </p> <p>In order to code the algorithm in Python, we will use a dictionary called <code>prec</code> to hold the precedence values for the operators, as seen in in <code>ActiveCode 1</code>. This dictionary will map each operator to an integer that can be compared against the precedence levels of other operators (we have arbitrarily used the integers 3, 2, and 1). The left parenthesis will receive the lowest value possible. This way any operator that is compared against it will have higher precedence and will be placed on top of it. Line 15 defines the operands to be any upper-case character or digit.</p> Activity: 3.9.2.1 Converting Infix Expressions to Postfix Expressions<pre><code>from pythonds3.basic import Stack\n\ndef infix_to_postfix(infix_expr):\n    prec = {}\n    prec[\"*\"] = 3\n    prec[\"/\"] = 3\n    prec[\"+\"] = 2\n    prec[\"-\"] = 2\n    prec[\"(\"] = 1\n    op_stack = Stack()\n    postfix_list = []\n    token_list = infix_expr.split()\n\n    for token in token_list:\n        if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\":\n            postfix_list.append(token)\n        elif token == \"(\":\n            op_stack.push(token)\n        elif token == \")\":\n            top_token = op_stack.pop()\n            while top_token != \"(\":\n                postfix_list.append(top_token)\n                top_token = op_stack.pop()\n        else:\n            while (not op_stack.is_empty()) and (prec[op_stack.peek()] &gt;= prec[token]):\n                postfix_list.append(op_stack.pop())\n            op_stack.push(token)\n\n    while not op_stack.is_empty():\n        postfix_list.append(op_stack.pop())\n\n    return \" \".join(postfix_list)\n\nprint(infix_to_postfix(\"A * B + C * D\"))\nprint(infix_to_postfix(\"( A + B ) * C - ( D - E ) * ( F + G )\"))\n</code></pre> <p>A few more examples of execution in the Python shell are shown below.</p> <pre><code>&gt;&gt;&gt; infix_to_postfix(\"( A + B ) * ( C + D )\")\n'A B + C D + *'\n&gt;&gt;&gt; infix_to_postfix(\"( A + B ) * C\")\n'A B + C *'\n&gt;&gt;&gt; infix_to_postfix(\"A + B * C\")\n'A B C * +'\n&gt;&gt;&gt;\n</code></pre>"},{"location":"c3/s9/#393-\u540e\u7f00\u8868\u8fbe\u5f0f\u6c42\u503c","title":"3.9.3. \u540e\u7f00\u8868\u8fbe\u5f0f\u6c42\u503c","text":"<p>3.9.3. Postfix Evaluation</p> \u4e2d\u6587\u82f1\u6587 <p>As a final stack example, we will consider the evaluation of an expression that is already in postfix notation. In this case, a stack is again the data structure of choice. However, as you scan the postfix expression, it is the operands that must wait, not the operators as in the conversion algorithm above. Another way to think about the solution is that whenever an operator is seen on the input, the two most recent operands will be used in the evaluation.</p> <p>To see this in more detail, consider the postfix expression 4 5 6 \u00b7 +. As you scan the expression from left to right, you first encounter the operands 4 and 5. At this point, you are still unsure what to do with them until you see the next symbol. Placing each on the stack ensures that they are available if an operator comes next.</p> <p>In this case, the next symbol is another operand. So, as before, push it and check the next symbol. Now we see an operator, \u00b7. This means that the two most recent operands need to be used in a multiplication operation. By popping the stack twice, we can get the proper operands and then perform the multiplication (in this case getting the result 30).</p> <p>We can now handle this result by placing it back on the stack so that it can be used as an operand for the later operators in the expression. When the final operator is processed, there will be only one value left on the stack. Pop and return it as the result of the expression. <code>Figure 10</code> shows the stack contents as this entire example expression is being processed.</p> <p> Figure 10: Stack Contents During Evaluation </p> <p><code>Figure 11</code> shows a slightly more complex example, 7 8 + 3 2 + /. There are two things to note in this example. First, the stack size grows, shrinks, and then grows again as the subexpressions are evaluated. Second, the division operation needs to be handled carefully. Recall that the operands in the postfix expression are in their original order since postfix changes only the placement of operators. When the operands for the division are popped from the stack, they are reversed. Since division is not a commutative operator, in other words \\(15/5\\) is not the same as \\(5/15\\), we must be sure that the order of the operands is not switched.</p> <p> Figure 11: A More Complex Example of Evaluation </p> <p>Assume the postfix expression is a string of tokens delimited by spaces. The operators are \u00b7, /, +, and - and the operands are assumed to be single-digit integer values. The output will be an integer result.</p> <ol> <li>Create an empty stack called <code>operand_stack</code>.</li> <li>Convert the string to a list by using the string method <code>split</code>.</li> <li> <p>Scan the token list from left to right.</p> </li> <li> <p>If the token is an operand, convert it from a string to an integer and push the value onto the <code>operand_stack</code>.</p> </li> <li> <p>If the token is an operator, \u00b7, /, +, or -, it will need two operands. Pop the <code>operand_stack</code> twice. The first pop is the second operand and the second pop is the first operand. Perform the arithmetic operation. Push the result back on the <code>operand_stack</code>.</p> </li> <li> <p>When the input expression has been completely processed, the result is on the stack. Pop the <code>operand_stack</code> and return the value.</p> </li> </ol> <p>The complete function for the evaluation of postfix expressions is shown in <code>ActiveCode 2</code>. To assist with the arithmetic, a helper function <code>do_math</code> is defined. It will take two operands and an operator and then perform the proper arithmetic operation.</p> Activity: 3.9.3.1 Postfix Evaluation<pre><code>from pythonds3.basic import Stack\n\ndef postfix_eval(postfix_expr):\n    operand_stack = Stack()\n    token_list = postfix_expr.split()\n\n    for token in token_list:\n        if token in \"0123456789\":\n            operand_stack.push(int(token))\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = do_math(token, operand1, operand2)\n            operand_stack.push(result)\n    return operand_stack.pop()\n\n\ndef do_math(op, op1, op2):\n    if op == \"*\":\n        return op1 * op2\n    elif op == \"/\":\n        return op1 / op2\n    elif op == \"+\":\n        return op1 + op2\n    else:\n        return op1 - op2\n\n\nprint(postfix_eval(\"7 8 + 3 2 + /\"))\n</code></pre> <p>It is important to note that in both the postfix conversion and the postfix evaluation programs we assumed that there were no errors in the input expression. Using these programs as a starting point, you can easily see how error detection and reporting can be included. We leave this as an exercise at the end of the chapter.</p> <p>Self Check</p> Activity: 3.9.3.2 Fill in the BlankActivity: 3.9.3.3 Fill in the BlankActivity: 3.9.3.4 Fill in the Blank <p>Without using the activecode <code>infix_to_postfix</code> function, convert the following expression to postfix  <code>10 + 3 * 5 / (16 - 4)</code> .</p> <p>|blank|</p> <ul> <li>:10\\s+3\\s+5\\s*\\s16\\s+4\\s-\\s/\\s*+: Correct.</li> <li>:10.3.5.16.4\\s+[ /+-]: The numbers appear to be in the correct order check your operators</li> <li> Remember the numbers will be in the same order as the original equation</li> </ul> <p>What is the result of evaluating the following: <code>17 10 + 3 * 9 / ==</code> ?</p> <p>|blank|</p> <ul> <li>:9: Correct.</li> <li> Remember to push each intermediate result back on the stack</li> </ul> <p>Modify the <code>infix_to_postfix</code> function so that it can convert the following expression:  <code>5 * 3 ^ (4 - 2)</code>. Run the function on the expression and paste the answer here:</p> <p>|blank|</p> <ul> <li>:5\\s+3\\s+4\\s+2\\s-\\s**\\s**: Correct.</li> <li> Hint: You only need to add one line to the function!!</li> </ul> <p>As a final stack example, we will consider the evaluation of an expression that is already in postfix notation. In this case, a stack is again the data structure of choice. However, as you scan the postfix expression, it is the operands that must wait, not the operators as in the conversion algorithm above. Another way to think about the solution is that whenever an operator is seen on the input, the two most recent operands will be used in the evaluation.</p> <p>To see this in more detail, consider the postfix expression 4 5 6 \u00b7 +. As you scan the expression from left to right, you first encounter the operands 4 and 5. At this point, you are still unsure what to do with them until you see the next symbol. Placing each on the stack ensures that they are available if an operator comes next.</p> <p>In this case, the next symbol is another operand. So, as before, push it and check the next symbol. Now we see an operator, \u00b7. This means that the two most recent operands need to be used in a multiplication operation. By popping the stack twice, we can get the proper operands and then perform the multiplication (in this case getting the result 30).</p> <p>We can now handle this result by placing it back on the stack so that it can be used as an operand for the later operators in the expression. When the final operator is processed, there will be only one value left on the stack. Pop and return it as the result of the expression. <code>Figure 10</code> shows the stack contents as this entire example expression is being processed.</p> <p> Figure 10: Stack Contents During Evaluation </p> <p><code>Figure 11</code> shows a slightly more complex example, 7 8 + 3 2 + /. There are two things to note in this example. First, the stack size grows, shrinks, and then grows again as the subexpressions are evaluated. Second, the division operation needs to be handled carefully. Recall that the operands in the postfix expression are in their original order since postfix changes only the placement of operators. When the operands for the division are popped from the stack, they are reversed. Since division is not a commutative operator, in other words \\(15/5\\) is not the same as \\(5/15\\), we must be sure that the order of the operands is not switched.</p> <p> Figure 11: A More Complex Example of Evaluation </p> <p>Assume the postfix expression is a string of tokens delimited by spaces. The operators are \u00b7, /, +, and - and the operands are assumed to be single-digit integer values. The output will be an integer result.</p> <ol> <li>Create an empty stack called <code>operand_stack</code>.</li> <li>Convert the string to a list by using the string method <code>split</code>.</li> <li> <p>Scan the token list from left to right.</p> </li> <li> <p>If the token is an operand, convert it from a string to an integer and push the value onto the <code>operand_stack</code>.</p> </li> <li> <p>If the token is an operator, \u00b7, /, +, or -, it will need two operands. Pop the <code>operand_stack</code> twice. The first pop is the second operand and the second pop is the first operand. Perform the arithmetic operation. Push the result back on the <code>operand_stack</code>.</p> </li> <li> <p>When the input expression has been completely processed, the result is on the stack. Pop the <code>operand_stack</code> and return the value.</p> </li> </ol> <p>The complete function for the evaluation of postfix expressions is shown in <code>ActiveCode 2</code>. To assist with the arithmetic, a helper function <code>do_math</code> is defined. It will take two operands and an operator and then perform the proper arithmetic operation.</p> Activity: 3.9.3.1 Postfix Evaluation<pre><code>from pythonds3.basic import Stack\n\ndef postfix_eval(postfix_expr):\n    operand_stack = Stack()\n    token_list = postfix_expr.split()\n\n    for token in token_list:\n        if token in \"0123456789\":\n            operand_stack.push(int(token))\n        else:\n            operand2 = operand_stack.pop()\n            operand1 = operand_stack.pop()\n            result = do_math(token, operand1, operand2)\n            operand_stack.push(result)\n    return operand_stack.pop()\n\n\ndef do_math(op, op1, op2):\n    if op == \"*\":\n        return op1 * op2\n    elif op == \"/\":\n        return op1 / op2\n    elif op == \"+\":\n        return op1 + op2\n    else:\n        return op1 - op2\n\n\nprint(postfix_eval(\"7 8 + 3 2 + /\"))\n</code></pre> <p>It is important to note that in both the postfix conversion and the postfix evaluation programs we assumed that there were no errors in the input expression. Using these programs as a starting point, you can easily see how error detection and reporting can be included. We leave this as an exercise at the end of the chapter.</p> <p>Self Check</p> Activity: 3.9.3.2 Fill in the BlankActivity: 3.9.3.3 Fill in the BlankActivity: 3.9.3.4 Fill in the Blank <p>Without using the activecode <code>infix_to_postfix</code> function, convert the following expression to postfix  <code>10 + 3 * 5 / (16 - 4)</code> .</p> <p>|blank|</p> <ul> <li>:10\\s+3\\s+5\\s*\\s16\\s+4\\s-\\s/\\s*+: Correct.</li> <li>:10.3.5.16.4\\s+[ /+-]: The numbers appear to be in the correct order check your operators</li> <li> Remember the numbers will be in the same order as the original equation</li> </ul> <p>What is the result of evaluating the following: <code>17 10 + 3 * 9 / ==</code> ?</p> <p>|blank|</p> <ul> <li>:9: Correct.</li> <li> Remember to push each intermediate result back on the stack</li> </ul> <p>Modify the <code>infix_to_postfix</code> function so that it can convert the following expression:  <code>5 * 3 ^ (4 - 2)</code>. Run the function on the expression and paste the answer here:</p> <p>|blank|</p> <ul> <li>:5\\s+3\\s+4\\s+2\\s-\\s**\\s**: Correct.</li> <li> Hint: You only need to add one line to the function!!</li> </ul>"},{"location":"c4/","title":"4. \u9012\u5f52","text":"<p>4. Recursion</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>4.1. \u76ee\u6807 </li> <li>4.2. \u4ec0\u4e48\u662f\u9012\u5f52\uff1f </li> <li>4.3. \u8ba1\u7b97\u4e00\u4e2a\u6570\u5217\u7684\u548c </li> <li>4.4. \u9012\u5f52\u7684\u4e09\u6761\u6cd5\u5219 </li> <li>4.5. \u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u4efb\u610f\u8fdb\u5236\u7684\u5b57\u7b26\u4e32 </li> <li>4.6. \u6808\u5e27\uff1a\u5b9e\u73b0\u9012\u5f52 </li> <li>4.7. \u9012\u5f52\u7684\u53ef\u89c6\u5316 </li> <li>4.8. \u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62 </li> <li>4.9. \u590d\u6742\u7684\u9012\u5f52\u95ee\u9898 </li> <li>4.10. \u6c49\u8bfa\u5854\u95ee\u9898 </li> <li>4.11. \u8ff7\u5bab\u63a2\u7d22 </li> <li>4.12. \u52a8\u6001\u89c4\u5212 </li> <li>4.13. \u603b\u7ed3 </li> <li>4.14. \u5173\u952e\u672f\u8bed </li> <li>4.15. \u7ec3\u4e60</li> </ul> <ul> <li>4.1. Objectives</li> <li>4.2. What Is Recursion?</li> <li>4.3. Calculating the Sum of a List of Numbers</li> <li>4.4. The Three Laws of Recursion</li> <li>4.5. Converting an Integer to a String in Any Base</li> <li>4.6. Stack Frames: Implementing Recursion</li> <li>4.7. Visualizing Recursion</li> <li>4.8. Sierpinski Triangle</li> <li>4.9. Complex Recursive Problems</li> <li>4.10. Tower of Hanoi</li> <li>4.11. Exploring a Maze</li> <li>4.12. Dynamic Programming</li> <li>4.13. Summary</li> <li>4.14. Key Terms</li> <li>4.15. Exercises</li> </ul>"},{"location":"c4/s1/","title":"4.1. \u76ee\u6807","text":"<p>4.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <p>\u672c\u7ae0\u7684\u76ee\u6807\u5982\u4e0b\uff1a</p> <ul> <li>\u7406\u89e3\u590d\u6742\u95ee\u9898\u53ef\u80fd\u6709\u7b80\u5355\u7684\u9012\u5f52\u89e3\u51b3\u65b9\u6848\uff0c\u8fd9\u4e9b\u95ee\u9898\u53ef\u80fd\u5426\u5219\u5f88\u96be\u89e3\u51b3\u3002</li> <li>\u5b66\u4e60\u5982\u4f55\u9012\u5f52\u5730\u5236\u5b9a\u7a0b\u5e8f\u3002</li> <li>\u7406\u89e3\u5e76\u5e94\u7528\u9012\u5f52\u7684\u4e09\u6761\u6cd5\u5219\u3002</li> <li>\u5c06\u9012\u5f52\u7406\u89e3\u4e3a\u4e00\u79cd\u8fed\u4ee3\u5f62\u5f0f\u3002</li> <li>\u5b9e\u73b0\u95ee\u9898\u7684\u9012\u5f52\u516c\u5f0f\u5316\u3002</li> <li>\u7406\u89e3\u8ba1\u7b97\u673a\u7cfb\u7edf\u5982\u4f55\u5b9e\u73b0\u9012\u5f52\u3002</li> </ul> <p>The goals for this chapter are as follows:</p> <ul> <li>To understand that complex problems that may otherwise be difficult to solve may have a simple recursive solution.</li> <li>To learn how to formulate programs recursively.</li> <li>To understand and apply the three laws of recursion.</li> <li>To understand recursion as a form of iteration.</li> <li>To implement the recursive formulation of a problem.</li> <li>To understand how recursion is implemented by a computer system.</li> </ul>"},{"location":"c4/s10/","title":"4.10. \u6c49\u8bfa\u5854\u95ee\u9898","text":"<p>4.10. Tower of Hanoi</p> \u4e2d\u6587\u82f1\u6587 <p>\u6c49\u8bfa\u5854\u96be\u9898\u7531\u6cd5\u56fd\u6570\u5b66\u5bb6\u7231\u5fb7\u534e\u00b7\u5362\u5361\u65af\uff08Edouard Lucas\uff09\u4e8e1883\u5e74\u53d1\u660e\u3002\u4ed6\u53d7\u5230\u4e00\u4e2a\u4f20\u8bf4\u7684\u542f\u53d1\uff0c\u8be5\u4f20\u8bf4\u8bb2\u8ff0\u4e86\u4e00\u4e2a\u5370\u5ea6\u5bfa\u5e99\u7684\u6545\u4e8b\uff0c\u5bfa\u5e99\u91cc\u5c06\u8fd9\u4e2a\u96be\u9898\u5448\u73b0\u7ed9\u5e74\u8f7b\u7684\u50e7\u4fa3\u3002\u5728\u65f6\u95f4\u7684\u5f00\u7aef\uff0c\u50e7\u4fa3\u4eec\u88ab\u7ed9\u4e88\u4e86\u4e09\u6839\u6746\u5b50\u548c64\u4e2a\u91d1\u76d8\uff0c\u6bcf\u4e2a\u76d8\u5b50\u6bd4\u4e0b\u4e00\u4e2a\u76d8\u5b50\u7565\u5c0f\u3002\u4ed6\u4eec\u7684\u4efb\u52a1\u662f\u5c06\u6240\u670964\u4e2a\u76d8\u5b50\u4ece\u4e00\u6839\u6746\u5b50\u79fb\u52a8\u5230\u53e6\u4e00\u6839\u6746\u5b50\uff0c\u5e76\u4e14\u6709\u4e24\u4e2a\u91cd\u8981\u7684\u9650\u5236\u3002\u4ed6\u4eec\u6bcf\u6b21\u53ea\u80fd\u79fb\u52a8\u4e00\u4e2a\u76d8\u5b50\uff0c\u5e76\u4e14\u4e0d\u80fd\u5c06\u8f83\u5927\u7684\u76d8\u5b50\u653e\u5728\u8f83\u5c0f\u7684\u76d8\u5b50\u4e0a\u9762\u3002\u50e7\u4fa3\u4eec\u65e5\u591c\u9ad8\u6548\u5730\u5de5\u4f5c\uff0c\u6bcf\u79d2\u79fb\u52a8\u4e00\u4e2a\u76d8\u5b50\u3002\u4f20\u8bf4\u4e2d\u8bf4\uff0c\u5f53\u4ed6\u4eec\u5b8c\u6210\u5de5\u4f5c\u65f6\uff0c\u5bfa\u5e99\u5c06\u5d29\u6e83\u6210\u5c18\u571f\uff0c\u4e16\u754c\u4e5f\u5c06\u6d88\u5931\u3002</p> <p>\u5c3d\u7ba1\u8fd9\u4e2a\u4f20\u8bf4\u5f88\u6709\u8da3\uff0c\u4f60\u4e0d\u5fc5\u62c5\u5fc3\u4e16\u754c\u5f88\u5feb\u5c31\u4f1a\u7ed3\u675f\u3002\u5c0664\u4e2a\u76d8\u5b50\u7684\u5854\u6b63\u786e\u79fb\u52a8\u6240\u9700\u7684\u6b65\u6570\u662f \\(2^{64}-1 = 18,446,744,073,709,551,615\\)\u3002\u4ee5\u6bcf\u79d2\u4e00\u4e2a\u6b65\u9aa4\u7684\u901f\u5ea6\uff0c\u8fd9\u5c06\u662f \\(584,942,417,355\\) \u5e74\uff01\u663e\u7136\uff0c\u8fd9\u4e2a\u96be\u9898\u8fdc\u4e0d\u6b62\u8868\u9762\u770b\u8d77\u6765\u90a3\u4e48\u7b80\u5355\u3002</p> <p><code>Figure 4.11</code> \u5c55\u793a\u4e86\u4e00\u4e2a\u5728\u5c06\u76d8\u5b50\u4ece\u7b2c\u4e00\u4e2a\u6746\u5b50\u79fb\u52a8\u5230\u7b2c\u4e09\u4e2a\u6746\u5b50\u8fc7\u7a0b\u4e2d\u95f4\u7684\u914d\u7f6e\u3002\u6ce8\u610f\uff0c\u5982\u89c4\u5219\u6240\u89c4\u5b9a\u7684\u90a3\u6837\uff0c\u6bcf\u6839\u6746\u5b50\u4e0a\u7684\u76d8\u5b50\u90fd\u88ab\u5806\u53e0\u5728\u4e00\u8d77\uff0c\u786e\u4fdd\u8f83\u5c0f\u7684\u76d8\u5b50\u603b\u662f\u5728\u8f83\u5927\u7684\u76d8\u5b50\u4e0a\u9762\u3002\u5982\u679c\u4f60\u4e4b\u524d\u6ca1\u6709\u5c1d\u8bd5\u8fc7\u89e3\u51b3\u8fd9\u4e2a\u96be\u9898\uff0c\u73b0\u5728\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u3002\u4f60\u4e0d\u9700\u8981\u534e\u4e3d\u7684\u76d8\u5b50\u548c\u6746\u5b50\u2014\u2014\u4e00\u672c\u4e66\u6216\u51e0\u5f20\u7eb8\u7247\u5c31\u80fd\u6d3e\u4e0a\u7528\u573a\u3002</p> <p> Figure 4.11: \u6c49\u8bfa\u5854\u76d8\u5b50\u7684\u793a\u4f8b\u6392\u5217 </p> <p>\u6211\u4eec\u5982\u4f55\u9012\u5f52\u5730\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff1f\u4f60\u4f1a\u5982\u4f55\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff1f\u6211\u4eec\u7684\u57fa\u672c\u60c5\u51b5\u662f\u4ec0\u4e48\uff1f\u8ba9\u6211\u4eec\u4ece\u5e95\u90e8\u5f00\u59cb\u601d\u8003\u8fd9\u4e2a\u95ee\u9898\u3002\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e94\u7684\u5854\uff0c\u6700\u521d\u5728\u6746\u5b50\u4e00\u4e0a\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u5c06\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u56db\u7684\u5854\u79fb\u52a8\u5230\u6746\u5b50\u4e8c\uff0c\u4f60\u53ef\u4ee5\u8f7b\u677e\u5730\u5c06\u5e95\u90e8\u76d8\u5b50\u79fb\u52a8\u5230\u6746\u5b50\u4e09\uff0c\u7136\u540e\u5c06\u9ad8\u5ea6\u4e3a\u56db\u7684\u5854\u4ece\u6746\u5b50\u4e8c\u79fb\u52a8\u5230\u6746\u5b50\u4e09\u3002\u4f46\u662f\uff0c\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u5982\u4f55\u5c06\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u56db\u7684\u5854\u79fb\u52a8\u600e\u4e48\u529e\uff1f\u5047\u8bbe\u4f60\u77e5\u9053\u5982\u4f55\u5c06\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e09\u7684\u5854\u79fb\u52a8\u5230\u6746\u5b50\u4e09\uff1b\u90a3\u4e48\uff0c\u4f60\u53ef\u4ee5\u8f7b\u677e\u5730\u5c06\u7b2c\u56db\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6746\u5b50\u4e8c\uff0c\u5e76\u5c06\u4e09\u4e2a\u76d8\u5b50\u4ece\u6746\u5b50\u4e09\u79fb\u52a8\u5230\u5b83\u4e0a\u9762\u3002\u4f46\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u5982\u4f55\u79fb\u52a8\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e09\u7684\u5854\u600e\u4e48\u529e\uff1f\u5982\u4f55\u5c06\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e8c\u7684\u5854\u79fb\u52a8\u5230\u6746\u5b50\u4e8c\uff0c\u7136\u540e\u5c06\u7b2c\u4e09\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6746\u5b50\u4e09\uff0c\u7136\u540e\u5c06\u9ad8\u5ea6\u4e3a\u4e8c\u7684\u5854\u79fb\u52a8\u5230\u4e0a\u9762\uff1f\u4f46\u5982\u679c\u4f60\u4ecd\u7136\u4e0d\u77e5\u9053\u5982\u4f55\u505a\u5462\uff1f\u663e\u7136\uff0c\u5c06\u4e00\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6746\u5b50\u4e09\u662f\u5f88\u7b80\u5355\u7684\uff0c\u4f60\u751a\u81f3\u53ef\u4ee5\u8bf4\u662f\u5fae\u4e0d\u8db3\u9053\u7684\u3002\u8fd9\u542c\u8d77\u6765\u50cf\u662f\u4e00\u4e2a\u5373\u5c06\u6210\u4e3a\u57fa\u672c\u60c5\u51b5\u7684\u4f8b\u5b50\u3002</p> <p>\u4e0b\u9762\u662f\u4e00\u4e2a\u9ad8\u5c42\u6b21\u7684\u6982\u8ff0\uff0c\u63cf\u8ff0\u5982\u4f55\u5c06\u4e00\u4e2a\u9ad8\u5ea6\u4e3a \\(h\\) \u7684\u5854\u4ece\u8d77\u59cb\u6746\u79fb\u52a8\u5230\u76ee\u6807\u6746\uff0c\u4f7f\u7528\u4e00\u4e2a\u4e2d\u95f4\u6746\uff1a</p> <ol> <li>\u5c06\u9ad8\u5ea6\u4e3a \\(h-1\\) \u7684\u5854\u4ece\u8d77\u59cb\u6746\u79fb\u52a8\u5230\u4e2d\u95f4\u6746\uff0c\u901a\u8fc7\u76ee\u6807\u6746\u3002</li> <li>\u5c06\u5269\u4e0b\u7684\u76d8\u5b50\u4ece\u8d77\u59cb\u6746\u79fb\u52a8\u5230\u76ee\u6807\u6746\u3002</li> <li>\u5c06\u9ad8\u5ea6\u4e3a \\(h-1\\) \u7684\u5854\u4ece\u4e2d\u95f4\u6746\u79fb\u52a8\u5230\u76ee\u6807\u6746\uff0c\u901a\u8fc7\u8d77\u59cb\u6746\u3002</li> </ol> <p>\u53ea\u8981\u6211\u4eec\u59cb\u7ec8\u9075\u5b88\u8f83\u5927\u7684\u76d8\u5b50\u4fdd\u6301\u5728\u5806\u5e95\u7684\u89c4\u5219\uff0c\u6211\u4eec\u53ef\u4ee5\u9012\u5f52\u5730\u4f7f\u7528\u4e0a\u8ff0\u4e09\u4e2a\u6b65\u9aa4\uff0c\u5c06\u4efb\u4f55\u8f83\u5927\u7684\u76d8\u5b50\u89c6\u4e3a\u4e0d\u5b58\u5728\u3002\u4e0a\u8ff0\u6982\u8ff0\u4e2d\u552f\u4e00\u7f3a\u5c11\u7684\u662f\u57fa\u672c\u60c5\u51b5\u7684\u8bc6\u522b\u3002\u6700\u7b80\u5355\u7684\u6c49\u8bfa\u5854\u95ee\u9898\u662f\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e00\u7684\u5854\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u5c06\u4e00\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6700\u7ec8\u76ee\u6807\u3002\u4e00\u4e2a\u9ad8\u5ea6\u4e3a\u4e00\u7684\u5854\u5c06\u662f\u6211\u4eec\u7684\u57fa\u672c\u60c5\u51b5\u3002\u6b64\u5916\uff0c\u4e0a\u8ff0\u6b65\u9aa4\u901a\u8fc7\u5728\u6b65\u9aa4 1 \u548c 3 \u4e2d\u9010\u6b65\u964d\u4f4e\u5854\u7684\u9ad8\u5ea6\uff0c\u5c06\u6211\u4eec\u5f15\u5bfc\u5230\u57fa\u672c\u60c5\u51b5\u3002<code>Listing 1</code> \u663e\u793a\u4e86\u7528\u4e8e\u89e3\u51b3\u6c49\u8bfa\u5854\u96be\u9898\u7684 Python \u4ee3\u7801\u3002</p> **Listing 4.9:** \u6c49\u8bfa\u5854\u7684 Python \u4ee3\u7801<pre><code>def move_tower(height, from_pole, to_pole, with_pole):\n    if height &lt; 1:\n        return\n    move_tower(height - 1, from_pole, with_pole, to_pole)\n    move_disk(from_pole, to_pole)\n    move_tower(height - 1, with_pole, to_pole, from_pole)\n</code></pre> <p>\u6ce8\u610f\uff0c<code>Listing 1</code> \u4e2d\u7684\u4ee3\u7801\u51e0\u4e4e\u4e0e\u82f1\u6587\u63cf\u8ff0\u5b8c\u5168\u4e00\u81f4\u3002\u7b97\u6cd5\u7684\u7b80\u6d01\u6027\u5173\u952e\u5728\u4e8e\u6211\u4eec\u8fdb\u884c\u4e24\u4e2a\u4e0d\u540c\u7684\u9012\u5f52\u8c03\u7528\uff0c\u4e00\u4e2a\u5728\u7b2c 4 \u884c\uff0c\u53e6\u4e00\u4e2a\u5728\u7b2c 6 \u884c\u3002\u5728\u7b2c 4 \u884c\uff0c\u6211\u4eec\u5c06\u521d\u59cb\u5854\u7684\u6240\u6709\u76d8\u5b50\uff08\u9664\u4e86\u5e95\u90e8\u76d8\u5b50\uff09\u79fb\u52a8\u5230\u4e2d\u95f4\u6746\u3002\u4e0b\u4e00\u884c\u5c06\u5e95\u90e8\u76d8\u5b50\u79fb\u52a8\u5230\u6700\u7ec8\u4f4d\u7f6e\u3002\u7136\u540e\u5728\u7b2c 6 \u884c\uff0c\u6211\u4eec\u5c06\u5854\u4ece\u4e2d\u95f4\u6746\u79fb\u52a8\u5230\u6700\u5927\u76d8\u5b50\u7684\u4e0a\u9762\u3002\u57fa\u672c\u60c5\u51b5\u662f\u9ad8\u5ea6\u4e3a 0 \u7684\u5854\uff1b\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6ca1\u6709\u4efb\u4f55\u64cd\u4f5c\u9700\u8981\u505a\uff0c\u6240\u4ee5 <code>move_tower</code> \u51fd\u6570\u8fd4\u56de\u3002\u5904\u7406\u57fa\u672c\u60c5\u51b5\u65f6\u91cd\u8981\u7684\u4e00\u70b9\u662f\uff0c\u7b80\u5355\u5730\u4ece <code>move_tower</code> \u8fd4\u56de\u6700\u7ec8\u5141\u8bb8\u8c03\u7528 <code>move_disk</code> \u51fd\u6570\u3002</p> <p><code>move_disk</code> \u51fd\u6570\u5728 <code>Listing 4.10</code> \u4e2d\u5c55\u793a\uff0c\u975e\u5e38\u7b80\u5355\u3002\u5b83\u7684\u529f\u80fd\u53ea\u662f\u6253\u5370\u51fa\u5b83\u6b63\u5728\u5c06\u4e00\u4e2a\u76d8\u5b50\u4ece\u4e00\u4e2a\u6746\u5b50\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a\u6746\u5b50\u3002\u5982\u679c\u4f60\u8f93\u5165\u5e76\u8fd0\u884c <code>move_tower</code> \u7a0b\u5e8f\uff0c\u4f60\u4f1a\u53d1\u73b0\u5b83\u4e3a\u89e3\u51b3\u96be\u9898\u63d0\u4f9b\u4e86\u4e00\u4e2a\u975e\u5e38\u9ad8\u6548\u7684\u65b9\u6848\u3002</p> **Listing 4.10:** \u79fb\u52a8\u4e00\u4e2a\u76d8\u5b50\u7684 Python \u4ee3\u7801<pre><code>def move_disk(from_pole, to_pole):\n    print(f\"moving disk from {from_pole} to {to_pole}\")\n</code></pre> <p><code>ActiveCode 4.10.1</code> \u63d0\u4f9b\u4e86\u4e09\u4e2a\u76d8\u5b50\u7684\u5b8c\u6574\u89e3\u51b3\u65b9\u6848\u3002</p> Activity: 4.10.1 \u9012\u5f52\u89e3\u51b3\u6c49\u8bfa\u5854<pre><code>def move_tower(height, from_pole, to_pole, with_pole):\n    if height &gt;= 1:\n        move_tower(height - 1, from_pole, with_pole, to_pole)\n        move_disk(from_pole, to_pole)\n        move_tower(height - 1, with_pole, to_pole, from_pole)\n\ndef move_disk(from_p, to_p):\n    print(\"moving disk from\", from_p, \"to\", to_p)\n\nmove_tower(3, \"A\", \"B\", \"C\")\n</code></pre> <p>\u73b0\u5728\u4f60\u5df2\u7ecf\u770b\u5230\u4e86 <code>move_tower</code> \u548c <code>move_disk</code> \u7684\u4ee3\u7801\uff0c\u4f60\u53ef\u80fd\u4f1a\u60f3\u4e3a\u4ec0\u4e48\u6211\u4eec\u6ca1\u6709\u4e00\u4e2a\u660e\u786e\u8ddf\u8e2a\u76d8\u5b50\u5728\u6746\u5b50\u4e0a\u7684\u6570\u636e\u7ed3\u6784\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u63d0\u793a\uff1a\u5982\u679c\u4f60\u8981\u663e\u5f0f\u8ddf\u8e2a\u76d8\u5b50\uff0c\u4f60\u53ef\u80fd\u4f1a\u4f7f\u7528\u4e09\u4e2a <code>Stack</code> \u5bf9\u8c61\uff0c\u6bcf\u4e2a\u6746\u5b50\u4e00\u4e2a\u3002\u7b54\u6848\u662f Python \u901a\u8fc7\u8c03\u7528\u6808\u9690\u5f0f\u5730\u63d0\u4f9b\u4e86\u6211\u4eec\u6240\u9700\u7684\u5806\u6808\u3002</p> <p>The Tower of Hanoi puzzle was invented by the French mathematician Edouard Lucas in 1883. He was inspired by a legend that tells of a Hindu temple where the puzzle was presented to young priests. At the beginning of time, the priests were given three poles and a stack of 64 gold disks, each disk a little smaller than the one beneath it. Their assignment was to transfer all 64 disks from one of the three poles to another, with two important constraints. They could only move one disk at a time, and they could never place a larger disk on top of a smaller one. The priests worked very efficiently, day and night, moving one disk every second. When they finished their work, the legend said, the temple would crumble into dust and the world would vanish.</p> <p>Although the legend is interesting, you need not worry about the world ending any time soon. The number of moves required to correctly move a tower of 64 disks is \\(2^{64}-1 = 18,446,744,073,709,551,615\\). At a rate of one move per second, that is \\(584,942,417,355\\) years! Clearly there is more to this puzzle than meets the eye.</p> <p><code>Figure 4.11</code> shows an example of a configuration of disks in the middle of a move from the first peg to the third. Notice that, as the rules specify, the disks on each peg are stacked so that smaller disks are always on top of the larger disks. If you have not tried to solve this puzzle before, you should try it now. You do not need fancy disks and poles\u2014a pile of books or pieces of paper will work.</p> <p> Figure 4.11: An Example Arrangement of Disks for the Tower of Hanoi </p> <p>How do we go about solving this problem recursively? How would you go about solving this problem at all? What is our base case? Let\u2019s think about this problem from the bottom up. Suppose you have a tower of five disks, originally on peg one. If you already knew how to move a tower of four disks to peg two, you could then easily move the bottom disk to peg three, and then move the tower of four from peg two to peg three. But what if you do not know how to move a tower of height four? Suppose that you knew how to move a tower of height three to peg three; then it would be easy to move the fourth disk to peg two and move the three from peg three on top of it. But what if you do not know how to move a tower of three? How about moving a tower of two disks to peg two and then moving the third disk to peg three, and then moving the tower of height two on top of it? But what if you still do not know how to do this? Surely you would agree that moving a single disk to peg three is easy enough, trivial you might even say. This sounds like a base case in the making.</p> <p>Here is a high-level outline of how to move a tower of height \\(h\\) from the starting pole to the goal pole, using an intermediate pole:</p> <ol> <li>Move a tower of height \\(h-1\\) from the starting pole to an intermediate pole via the goal pole.</li> <li>Move the remaining disk from the starting pole to the final pole.</li> <li>Move the tower of height \\(h-1\\) from the intermediate pole to the goal pole via the starting pole.</li> </ol> <p>As long as we always obey the rule that the larger disks remain on the bottom of the stack, we can use the three steps above recursively, treating any larger disks as though they were not even there. The only thing missing from the outline above is the identification of a base case. The simplest Tower of Hanoi problem is a tower of one disk. In this case, we need move only a single disk to its final destination. A tower of one disk will be our base case. In addition, the steps outlined above move us toward the base case by reducing the height of the tower in steps 1 and 3. <code>Listing 1</code> shows the Python code to solve the Tower of Hanoi puzzle.</p> **Listing 4.9:** Python Code for the Tower of Hanoi<pre><code>def move_tower(height, from_pole, to_pole, with_pole):\n    if height &lt; 1:\n        return\n    move_tower(height - 1, from_pole, with_pole, to_pole)\n    move_disk(from_pole, to_pole)\n    move_tower(height - 1, with_pole, to_pole, from_pole)\n</code></pre> <p>Notice that the code in <code>Listing 1</code> is almost identical to the English description. The key to the simplicity of the algorithm is that we make two different recursive calls, one on line 4 and a second on line 6. On line 4 we move all but the bottom disk on the initial tower to an intermediate pole. The next line moves the bottom disk to its final resting place. Then on line 6 we move the tower from the intermediate pole to the top of the largest disk. The base case is the tower of height 0; in this case there is nothing to do, so the <code>move_tower</code> function returns. The important thing to remember about handling the base case this way is that simply returning from <code>move_tower</code> is what finally allows the <code>move_disk</code> function to be called.</p> <p>The function <code>move_disk</code>, shown in <code>Listing 4.10</code>, is very simple. All it does is print out that it is moving a disk from one pole to another. If you type in and run the <code>move_tower</code> program you can see that it gives you a very efficient solution to the puzzle.</p> **Listing 4.10:** Python Code to Move One Disk<pre><code>def move_disk(from_pole, to_pole):\n    print(f\"moving disk from {from_pole} to {to_pole}\")\n</code></pre> <p>The program in <code>ActiveCode 4.10.1</code> provides the entire solution for three disks.</p> Activity: 4.10.1 Solving Tower of Hanoi Recursively<pre><code>def move_tower(height, from_pole, to_pole, with_pole):\n    if height &gt;= 1:\n        move_tower(height - 1, from_pole, with_pole, to_pole)\n        move_disk(from_pole, to_pole)\n        move_tower(height - 1, with_pole, to_pole, from_pole)\n\n\ndef move_disk(from_p, to_p):\n    print(\"moving disk from\", from_p, \"to\", to_p)\n\n\nmove_tower(3, \"A\", \"B\", \"C\")\n</code></pre> <p>Now that you have seen the code for both <code>move_tower</code> and <code>move_disk</code>, you may be wondering why we do not have a data structure that explicitly keeps track of what disks are on what poles. Here is a hint: if you were going to explicitly keep track of the disks, you would probably use three <code>Stack</code> objects, one for each pole. The answer is that Python provides the stacks that we need implicitly through the call stack.</p>"},{"location":"c4/s11/","title":"4.11. \u8ff7\u5bab\u63a2\u7d22","text":"<p>4.11. Exploring a Maze</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u8fd9\u4e00\u90e8\u5206\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u4e00\u4e2a\u4e0e\u4e0d\u65ad\u6269\u5c55\u7684\u673a\u5668\u4eba\u4e16\u754c\u76f8\u5173\u7684\u95ee\u9898\uff1a\u5982\u4f55\u627e\u5230\u8ff7\u5bab\u7684\u51fa\u53e3\uff1f\u5982\u679c\u4f60\u6709\u4e00\u4e2a Roomba \u5438\u5c18\u5668\u5728\u4f60\u7684\u5bbf\u820d\uff08\u96be\u9053\u6240\u6709\u5927\u5b66\u751f\u90fd\u6709\u5417\uff1f\uff09\uff0c\u4f60\u4f1a\u5e0c\u671b\u80fd\u4f7f\u7528\u4f60\u5728\u8fd9\u4e00\u90e8\u5206\u5b66\u5230\u7684\u77e5\u8bc6\u91cd\u65b0\u7f16\u7a0b\u5b83\u3002\u6211\u4eec\u8981\u89e3\u51b3\u7684\u95ee\u9898\u662f\u5e2e\u52a9\u6211\u4eec\u7684\u6d77\u9f9f\u627e\u5230\u8ff7\u5bab\u4e2d\u7684\u51fa\u53e3\u3002\u8ff7\u5bab\u95ee\u9898\u7684\u6839\u6e90\u53ef\u4ee5\u8ffd\u6eaf\u5230\u5e0c\u814a\u795e\u8bdd\u4e2d\u7684\u5fd2\u4fee\u65af\uff0c\u5fd2\u4fee\u65af\u88ab\u9001\u5165\u8ff7\u5bab\u53bb\u6740\u6b7b\u5f25\u8bfa\u9676\u6d1b\u65af\u3002\u5fd2\u4fee\u65af\u4f7f\u7528\u4e86\u4e00\u7403\u7ebf\u56e2\u6765\u5e2e\u52a9\u4ed6\u5728\u5b8c\u6210\u4efb\u52a1\u540e\u627e\u5230\u51fa\u8def\u3002\u5728\u6211\u4eec\u7684\u95ee\u9898\u4e2d\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u7684\u6d77\u9f9f\u88ab\u4e22\u5728\u8ff7\u5bab\u7684\u67d0\u4e2a\u5730\u65b9\uff0c\u5fc5\u987b\u627e\u5230\u51fa\u53e3\u3002\u8bf7\u67e5\u770b <code>Figure 4.12</code> \u4ee5\u4e86\u89e3\u6211\u4eec\u5728\u8fd9\u4e00\u90e8\u5206\u8981\u89e3\u51b3\u7684\u95ee\u9898\u3002</p> <p> Figure 4.12: \u5b8c\u6210\u7684\u8ff7\u5bab\u641c\u7d22\u7a0b\u5e8f </p> <p>\u4e3a\u4e86\u7b80\u5316\u95ee\u9898\uff0c\u6211\u4eec\u5c06\u5047\u8bbe\u8ff7\u5bab\u88ab\u5212\u5206\u4e3a\u65b9\u683c\u3002\u6bcf\u4e2a\u65b9\u683c\u8981\u4e48\u662f\u5f00\u653e\u7684\uff0c\u8981\u4e48\u88ab\u5899\u58c1\u5360\u636e\u3002\u6d77\u9f9f\u53ea\u80fd\u901a\u8fc7\u5f00\u653e\u7684\u65b9\u683c\u3002\u5982\u679c\u6d77\u9f9f\u78b0\u5230\u5899\u58c1\uff0c\u5b83\u5fc5\u987b\u5c1d\u8bd5\u4e0d\u540c\u7684\u65b9\u5411\u3002\u6d77\u9f9f\u9700\u8981\u4e00\u4e2a\u7cfb\u7edf\u7684\u7a0b\u5e8f\u6765\u627e\u5230\u8ff7\u5bab\u7684\u51fa\u53e3\u3002\u7a0b\u5e8f\u5982\u4e0b\uff1a</p> <ol> <li>\u4ece\u8d77\u59cb\u4f4d\u7f6e\u5f00\u59cb\uff0c\u6211\u4eec\u9996\u5148\u5c1d\u8bd5\u5411\u5317\u8d70\u4e00\u4e2a\u65b9\u683c\uff0c\u7136\u540e\u4ece\u90a3\u91cc\u9012\u5f52\u5730\u5c1d\u8bd5\u6211\u4eec\u7684\u7a0b\u5e8f\u3002</li> <li>\u5982\u679c\u6211\u4eec\u5728\u7b2c\u4e00\u6b65\u5c1d\u8bd5\u5317\u65b9\u8def\u5f84\u6ca1\u6709\u6210\u529f\uff0c\u90a3\u4e48\u6211\u4eec\u5c06\u5411\u5357\u8d70\u4e00\u6b65\uff0c\u5e76\u9012\u5f52\u5730\u91cd\u590d\u6211\u4eec\u7684\u7a0b\u5e8f\u3002</li> <li>\u5982\u679c\u5357\u65b9\u4e5f\u6ca1\u6709\u6210\u529f\uff0c\u6211\u4eec\u5c06\u5c1d\u8bd5\u5411\u897f\u8d70\u4e00\u6b65\uff0c\u5e76\u9012\u5f52\u5e94\u7528\u6211\u4eec\u7684\u7a0b\u5e8f\u3002</li> <li>\u5982\u679c\u5317\u65b9\u3001\u5357\u65b9\u548c\u897f\u65b9\u90fd\u6ca1\u6709\u6210\u529f\uff0c\u90a3\u4e48\u6211\u4eec\u5c06\u4ece\u4e1c\u8fb9\u7684\u4e00\u6b65\u4f4d\u7f6e\u9012\u5f52\u5730\u5e94\u7528\u7a0b\u5e8f\u3002</li> <li>\u5982\u679c\u8fd9\u4e9b\u65b9\u5411\u90fd\u4e0d\u884c\uff0c\u90a3\u4e48\u8ff7\u5bab\u4e2d\u6ca1\u6709\u51fa\u8def\uff0c\u6211\u4eec\u5c31\u5931\u8d25\u4e86\u3002</li> </ol> <p>\u8fd9\u542c\u8d77\u6765\u5f88\u7b80\u5355\uff0c\u4f46\u9996\u5148\u6709\u51e0\u4e2a\u7ec6\u8282\u9700\u8981\u8ba8\u8bba\u3002\u5047\u8bbe\u6211\u4eec\u7b2c\u4e00\u6b21\u9012\u5f52\u6b65\u9aa4\u662f\u5411\u5317\u8d70\u3002\u6309\u7167\u6211\u4eec\u7684\u7a0b\u5e8f\uff0c\u4e0b\u4e00\u6b65\u4e5f\u4f1a\u5411\u5317\u3002\u4f46\u662f\uff0c\u5982\u679c\u5317\u65b9\u88ab\u5899\u58c1\u6321\u4f4f\uff0c\u6211\u4eec\u5fc5\u987b\u67e5\u770b\u7a0b\u5e8f\u7684\u4e0b\u4e00\u6b65\u5e76\u5c1d\u8bd5\u5411\u5357\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u4e00\u6b65\u5411\u5357\u5c06\u6211\u4eec\u5e26\u56de\u5230\u6700\u521d\u7684\u4f4d\u7f6e\u3002\u5982\u679c\u6211\u4eec\u4ece\u90a3\u91cc\u5e94\u7528\u9012\u5f52\u7a0b\u5e8f\uff0c\u6211\u4eec\u5c06\u8fd4\u56de\u4e00\u6b65\u5230\u5317\u65b9\uff0c\u5f62\u6210\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5fc5\u987b\u6709\u4e00\u4e2a\u7b56\u7565\u6765\u8bb0\u4f4f\u6211\u4eec\u5df2\u7ecf\u53bb\u8fc7\u7684\u5730\u65b9\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u888b\u9762\u5305\u5c51\u53ef\u4ee5\u6cbf\u9014\u4e22\u5f03\u3002\u5982\u679c\u6211\u4eec\u5728\u67d0\u4e2a\u65b9\u5411\u4e0a\u8d70\u4e86\u4e00\u6b65\uff0c\u53d1\u73b0\u90a3\u4e2a\u65b9\u683c\u4e0a\u5df2\u7ecf\u6709\u4e86\u9762\u5305\u5c51\uff0c\u6211\u4eec\u77e5\u9053\u6211\u4eec\u5e94\u8be5\u7acb\u5373\u9000\u56de\u5e76\u5c1d\u8bd5\u7a0b\u5e8f\u4e2d\u7684\u4e0b\u4e00\u4e2a\u65b9\u5411\u3002\u6b63\u5982\u6211\u4eec\u5c06\u770b\u5230\u7684\uff0c\u56de\u9000\u5c31\u50cf\u4ece\u9012\u5f52\u51fd\u6570\u8c03\u7528\u4e2d\u8fd4\u56de\u4e00\u6837\u7b80\u5355\u3002</p> <p>\u5c31\u50cf\u6211\u4eec\u5bf9\u6240\u6709\u9012\u5f52\u7b97\u6cd5\u6240\u505a\u7684\u90a3\u6837\uff0c\u8ba9\u6211\u4eec\u56de\u987e\u57fa\u672c\u60c5\u51b5\u3002\u6839\u636e\u524d\u9762\u7684\u63cf\u8ff0\uff0c\u4f60\u53ef\u80fd\u5df2\u7ecf\u731c\u5230\u4e86\u5176\u4e2d\u7684\u4e00\u4e9b\u3002\u5728\u8fd9\u4e2a\u7b97\u6cd5\u4e2d\uff0c\u6709\u56db\u4e2a\u57fa\u672c\u60c5\u51b5\u9700\u8981\u8003\u8651\uff1a</p> <ol> <li>\u6d77\u9f9f\u78b0\u5230\u5899\u58c1\u3002\u7531\u4e8e\u65b9\u683c\u88ab\u5899\u58c1\u5360\u636e\uff0c\u4e0d\u80fd\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u63a2\u7d22\u3002</li> <li>\u6d77\u9f9f\u53d1\u73b0\u4e86\u4e00\u4e2a\u5df2\u7ecf\u88ab\u63a2\u7d22\u8fc7\u7684\u65b9\u683c\u3002\u6211\u4eec\u4e0d\u60f3\u7ee7\u7eed\u4ece\u8fd9\u4e2a\u4f4d\u7f6e\u8fdb\u884c\u63a2\u7d22\uff0c\u4ee5\u514d\u8fdb\u5165\u5faa\u73af\u3002</li> <li>\u6211\u4eec\u53d1\u73b0\u4e86\u4e00\u4e2a\u672a\u88ab\u5899\u58c1\u5360\u636e\u7684\u5916\u8fb9\u754c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u627e\u5230\u4e86\u8ff7\u5bab\u7684\u51fa\u53e3\u3002</li> <li>\u6211\u4eec\u5728\u56db\u4e2a\u65b9\u5411\u4e0a\u90fd\u672a\u80fd\u6210\u529f\u63a2\u7d22\u67d0\u4e2a\u65b9\u683c\u3002</li> </ol> <p>\u4e3a\u4e86\u4f7f\u7a0b\u5e8f\u6b63\u5e38\u5de5\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u4e00\u79cd\u8868\u793a\u8ff7\u5bab\u7684\u65b9\u5f0f\u3002<code>Figure 4.13</code> \u662f\u4e00\u4e2a\u8ff7\u5bab\u6570\u636e\u6587\u4ef6\u7684\u793a\u4f8b\u3002</p> **Figure 4.13:** \u8ff7\u5bab\u6570\u636e\u6587\u4ef6\u793a\u4f8b<pre><code>++++++++++++++++++++++\n+   +   ++ ++     +   \n+ +   +       +++ + ++\n+ + +  ++  ++++   + ++\n+++ ++++++    +++ +  +\n+          ++  ++    +\n+++++ ++++++   +++++ +\n+     +   +++++++  + +\n+ +++++++      S +   +\n+                + +++\n++++++++++++++++++ +++\n</code></pre> <p>\u4e3a\u4e86\u8ba9\u8fd9\u66f4\u52a0\u6709\u8da3\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 <code>turtle</code> \u6a21\u5757\u6765\u7ed8\u5236\u548c\u63a2\u7d22\u6211\u4eec\u7684\u8ff7\u5bab\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u8fd9\u4e2a\u7b97\u6cd5\u7684\u5b9e\u9645\u6548\u679c\u3002<code>Maze</code> \u5bf9\u8c61\u5c06\u63d0\u4f9b\u4ee5\u4e0b\u65b9\u6cd5\u4f9b\u6211\u4eec\u5728\u7f16\u5199\u641c\u7d22\u7b97\u6cd5\u65f6\u4f7f\u7528\uff1a</p> <ul> <li><code>__init__</code> \u8bfb\u53d6\u8868\u793a\u8ff7\u5bab\u7684\u6570\u636e\u663e\u793a\u6587\u4ef6\uff0c\u521d\u59cb\u5316\u8ff7\u5bab\u7684\u5185\u90e8\u8868\u793a\uff0c\u5e76\u627e\u5230\u6d77\u9f9f\u7684\u8d77\u59cb\u4f4d\u7f6e\u3002</li> <li><code>draw_maze</code> \u5728\u5c4f\u5e55\u7a97\u53e3\u4e2d\u7ed8\u5236\u8ff7\u5bab\u3002</li> <li><code>update_position</code> \u66f4\u65b0\u8ff7\u5bab\u7684\u5185\u90e8\u8868\u793a\uff0c\u5e76\u5728\u7a97\u53e3\u4e2d\u66f4\u6539\u6d77\u9f9f\u7684\u4f4d\u7f6e\u3002</li> <li><code>is_exit</code> \u68c0\u67e5\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u662f\u8ff7\u5bab\u7684\u51fa\u53e3\u3002</li> </ul> <p><code>Maze</code> \u7c7b\u8fd8\u91cd\u8f7d\u4e86\u7d22\u5f15\u64cd\u4f5c\u7b26 <code>[]</code>\uff0c\u4ee5\u4fbf\u6211\u4eec\u7684\u7b97\u6cd5\u53ef\u4ee5\u8f7b\u677e\u8bbf\u95ee\u4efb\u4f55\u7279\u5b9a\u65b9\u683c\u7684\u72b6\u6001\u3002</p> <p><code>Listing 4.11</code> \u5305\u62ec\u4e86 <code>Maze</code> \u7c7b\u65b9\u6cd5\uff08<code>Listings 4.12</code>--<code>4.15</code>\uff09\u548c <code>search_from</code> \u51fd\u6570\uff08<code>Listing 4.16</code>\uff09\u4f7f\u7528\u7684\u5168\u5c40\u5e38\u91cf\u3002</p> **Listing 4.11:** \u8ff7\u5bab\u7a0b\u5e8f\u5168\u5c40\u5e38\u91cf<pre><code>START = \"S\"\nOBSTACLE = \"+\"\nTRIED = \".\"\nDEAD_END = \"-\"\nPART_OF_PATH = \"O\"\n</code></pre> <p><code>__init__</code> \u65b9\u6cd5\u4ee5\u6587\u4ef6\u540d\u4f5c\u4e3a\u552f\u4e00\u53c2\u6570\u3002\u8be5\u6587\u4ef6\u662f\u4e00\u4e2a\u6587\u672c\u6587\u4ef6\uff0c\u901a\u8fc7\u4f7f\u7528 \u201c+\u201d \u5b57\u7b26\u8868\u793a\u5899\u58c1\uff0c\u7a7a\u683c\u8868\u793a\u5f00\u653e\u65b9\u683c\uff0c\u5b57\u6bcd \u201cS\u201d \u8868\u793a\u8d77\u59cb\u4f4d\u7f6e\u3002</p> **Listing 4.12:** \u8ff7\u5bab\u7c7b\u6784\u9020\u51fd\u6570<pre><code>class Maze:\n    def __init__(self, maze_filename):\n        with open(maze_filename, \"r\") as maze_file:\n            self.maze_list = [\n                [ch for ch in line.rstrip(\"\\n\")]\n                for line in maze_file.readlines()\n            ]\n        self.rows_in_maze = len(self.maze_list)\n        self.columns_in_maze = len(self.maze_list[0])\n        for row_idx, row in enumerate(self.maze_list):\n            if START in row:\n                self.start_row = row_idx\n                self.start_col = row.index(START)\n                break\n\n        self.x_translate = -self.columns_in_maze / 2\n        self.y_translate = self.rows_in_maze / 2\n        self.t = turtle.Turtle()\n        self.t.shape(\"turtle\")\n        self.wn = turtle.Screen()\n        self.wn.setworldcoordinates(\n            -(self.columns_in_maze - 1) / 2 - 0.5,\n            -(self.rows_in_maze - 1) / 2 - 0.5,\n            (self.columns_in_maze - 1) / 2 + 0.5,\n            (self.rows_in_maze - 1) / 2 + 0.5,\n        )\n</code></pre> <p>\u8ff7\u5bab\u7684\u5185\u90e8\u8868\u793a\u662f\u4e00\u4e2a\u5217\u8868\u7684\u5217\u8868\u3002<code>maze_list</code> \u5b9e\u4f8b\u53d8\u91cf\u7684\u6bcf\u4e00\u884c\u4e5f\u662f\u4e00\u4e2a\u5217\u8868\u3002\u8fd9\u4e2a\u4e8c\u7ea7\u5217\u8868\u5305\u542b\u6bcf\u4e2a\u65b9\u683c\u7684\u4e00\u4e2a\u5b57\u7b26\uff0c\u4f7f\u7528\u4e0a\u8ff0\u63cf\u8ff0\u7684\u5b57\u7b26\u3002\u5bf9\u4e8e <code>Figure 13</code> \u4e2d\u7684\u6570\u636e\u6587\u4ef6\uff0c\u5185\u90e8\u8868\u793a\u770b\u8d77\u6765\u5982\u4e0b\uff1a</p> <pre><code>    [  ['+', '+', '+', '+', '+', ..., '+', '+', '+', '+', '+']\n        ['+', ' ', ' ', ' ', '+', ..., ' ', '+', ' ', ' ', ' ']\n        ['+', ' ', '+', ' ', ' ', ..., ' ', '+', ' ', '+', '+']\n        ['+', ' ', '+', ' ', '+', ..., ' ', '+', ' ', '+', '+']\n        ['+', '+', '+', ' ', '+', ..., ' ', '+', ' ', ' ', '+']\n        ['+', ' ', ' ', ' ', ' ', ..., ' ', ' ', ' ', ' ', '+']\n        ['+', '+', '+', '+', '+', ..., '+', '+', '+', ' ', '+']\n        ['+', ' ', ' ', ' ', ' ', ..., ' ', ' ', '+', ' ', '+']\n        ['+', ' ', '+', '+', '+', ..., '+', ' ', ' ', ' ', '+']\n        ['+', ' ', ' ', ' ', ' ', ..., '+', ' ', '+', '+', '+']\n        ['+', '+', '+', '+', '+', ..., '+', ' ', '+', '+', '+'] ]\n</code></pre> <p><code>draw_maze</code> \u65b9\u6cd5\u4f7f\u7528\u8fd9\u79cd\u5185\u90e8\u8868\u793a\u6765\u7ed8\u5236\u8ff7\u5bab\u7684\u521d\u59cb\u89c6\u56fe\u5728\u5c4f\u5e55\u4e0a\uff08<code>Figure 4.12</code>\uff09\u3002</p> **Listing 4.13:** \u8ff7\u5bab\u7c7b\u7ed8\u56fe\u65b9\u6cd5<pre><code>def draw_maze(self):\n    self.t.speed(10)\n    self.wn.tracer(0)\n    for y in range(self.rows_in_maze):\n        for x in range(self.columns_in_maze):\n            if self.maze_list[y][x] == OBSTACLE:\n                self.draw_centered_box(\n                    x + self.x_translate, -y + self.y_translate, \"orange\"\n                )\n    self.t.color(\"black\")\n    self.t.fillcolor(\"blue\")\n    self.wn.update()\n    self.wn.tracer(1)\n\ndef draw_centered_box(self, x, y, color):\n    self.t.up()\n    self.t.goto(x - 0.5, y - 0.5)\n    self.t.color\n\n(color)\n    self.t.fillcolor(color)\n    self.t.setheading(90)\n    self.t.down()\n    self.t.begin_fill()\n    for i in range(4):\n        self.t.forward(1)\n        self.t.right(90)\n    self.t.end_fill()\n</code></pre> <p><code>update_position</code> \u65b9\u6cd5\u5982 <code>Listing 4.14</code> \u6240\u793a\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5185\u90e8\u8868\u793a\u6765\u67e5\u770b\u6d77\u9f9f\u662f\u5426\u78b0\u5230\u5899\u58c1\u3002\u5b83\u8fd8\u7528 \u201c.\u201d \u6216 \u201c-\u201d \u66f4\u65b0\u5185\u90e8\u8868\u793a\uff0c\u4ee5\u8868\u793a\u6d77\u9f9f\u662f\u5426\u8bbf\u95ee\u8fc7\u67d0\u4e2a\u65b9\u683c\u6216\u8be5\u65b9\u683c\u662f\u5426\u662f\u6b7b\u80e1\u540c\u3002\u6b64\u5916\uff0c<code>update_position</code> \u65b9\u6cd5\u4f7f\u7528\u4e24\u4e2a\u8f85\u52a9\u65b9\u6cd5\uff0c<code>move_turtle</code> \u548c <code>drop_bread_crumb</code>\uff0c\u6765\u66f4\u65b0\u5c4f\u5e55\u4e0a\u7684\u89c6\u56fe\u3002</p> **Listing 4.14:** \u8ff7\u5bab\u7c7b\u79fb\u52a8\u65b9\u6cd5<pre><code>def update_position(self, row, col, val=None):\n    if val:\n        self.maze_list[row][col] = val\n    self.move_turtle(col, row)\n\n    if val == PART_OF_PATH:\n        color = \"green\"\n    elif val == OBSTACLE:\n        color = \"red\"\n    elif val == TRIED:\n        color = \"black\"\n    elif val == DEAD_END:\n        color = \"red\"\n    else:\n        color = None\n\n    if color:\n        self.drop_bread_crumb(color)\n\ndef move_turtle(self, x, y):\n    self.t.up()\n    self.t.setheading(self.t.towards(x + self.x_translate, -y + self.y_translate))\n    self.t.goto(x + self.x_translate, -y + self.y_translate)\n\ndef drop_bread_crumb(self, color):\n    self.t.dot(10, color)\n</code></pre> <p>\u6700\u540e\uff0c<code>is_exit</code> \u65b9\u6cd5\u4f7f\u7528\u6d77\u9f9f\u7684\u5f53\u524d\u4f4d\u7f6e\u6765\u6d4b\u8bd5\u662f\u5426\u5230\u8fbe\u4e86\u51fa\u53e3\u3002\u51fa\u53e3\u6761\u4ef6\u53d1\u751f\u5728\u6d77\u9f9f\u5230\u8fbe\u8ff7\u5bab\u7684\u8fb9\u7f18\u65f6\uff0c\u5373\u7b2c\u96f6\u884c\u3001\u7b2c\u96f6\u5217\u3001\u6700\u53f3\u5217\u6216\u6700\u5e95\u884c\u3002</p> **Listing 4.15:** \u8ff7\u5bab\u7c7b\u8f85\u52a9\u65b9\u6cd5<pre><code>def is_exit(self, row, col):\n    return (\n        row == 0\n        or row == self.rows_in_maze - 1\n        or col == 0\n        or col == self.columns_in_maze - 1\n    )\n\ndef __getitem__(self, idx):\n    return self.maze_list[idx]\n</code></pre> <p>\u8ba9\u6211\u4eec\u67e5\u770b <code>search_from</code> \u51fd\u6570\u7684\u4ee3\u7801\u3002\u8be5\u51fd\u6570\u7684\u4ee3\u7801\u663e\u793a\u5728 <code>Listing 4.16</code> \u4e2d\u3002\u6ce8\u610f\uff0c\u8fd9\u4e2a\u51fd\u6570\u63a5\u53d7\u4e09\u4e2a\u53c2\u6570\uff1a\u4e00\u4e2a <code>Maze</code> \u5bf9\u8c61\u3001\u8d77\u59cb\u884c\u548c\u8d77\u59cb\u5217\u3002\u8fd9\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u4f5c\u4e3a\u9012\u5f52\u51fd\u6570\uff0c\u641c\u7d22\u903b\u8f91\u4e0a\u4ece\u6bcf\u6b21\u9012\u5f52\u8c03\u7528\u4e2d\u91cd\u65b0\u5f00\u59cb\u3002</p> **Listing 4.16:** search_from \u51fd\u6570<pre><code>def search_from(maze, row, column):\n    # \u5c1d\u8bd5\u4ece\u8fd9\u4e2a\u70b9\u7684\u56db\u4e2a\u65b9\u5411\u4e2d\u627e\u5230\u51fa\u53e3\n    maze.update_position(row, column)\n    # \u57fa\u672c\u60c5\u51b5\u8fd4\u56de\u503c\uff1a\n    #  1. \u78b0\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de False\n    if maze[row][column] == OBSTACLE:\n        return False\n    #  2. \u627e\u5230\u5df2\u88ab\u63a2\u7d22\u8fc7\u7684\u65b9\u683c\n    if maze[row][column] in [TRIED, DEAD_END]:\n        return False\n    # 3. \u627e\u5230\u4e00\u4e2a\u672a\u88ab\u969c\u788d\u7269\u5360\u636e\u7684\u5916\u8fb9\u754c\n    if maze.is_exit(row, column):\n        maze.update_position(row, column, PART_OF_PATH)\n        return True\n    maze.update_position(row, column, TRIED)\n    # \u5426\u5219\uff0c\u4f7f\u7528\u903b\u8f91\u77ed\u8def\u4f9d\u6b21\u5c1d\u8bd5\u6bcf\u4e2a\u65b9\u5411\n    found = (\n        search_from(maze, row - 1, column)\n        or search_from(maze, row + 1, column)\n        or search_from(maze, row, column - 1)\n        or search_from(maze, row, column + 1)\n    )\n    if found:\n        maze.update_position(row, column, PART_OF_PATH)\n    else:\n        maze.update_position(row, column, DEAD_END)\n    return found\n</code></pre> <p>\u5728\u67e5\u770b\u7b97\u6cd5\u65f6\uff0c\u4f60\u4f1a\u53d1\u73b0\u4ee3\u7801\u7684\u7b2c\u4e00\u6b65\uff08\u7b2c3\u884c\uff09\u662f\u8c03\u7528 <code>update_position</code>\u3002\u8fd9\u53ea\u662f\u4e3a\u4e86\u5e2e\u52a9\u4f60\u53ef\u89c6\u5316\u7b97\u6cd5\uff0c\u4ee5\u4fbf\u4f60\u53ef\u4ee5\u51c6\u786e\u5730\u770b\u5230\u6d77\u9f9f\u5982\u4f55\u63a2\u7d22\u8ff7\u5bab\u3002\u63a5\u4e0b\u6765\uff0c\u7b97\u6cd5\u68c0\u67e5\u56db\u4e2a\u57fa\u672c\u60c5\u51b5\u4e2d\u7684\u524d\u4e09\u4e2a\uff1a\u6d77\u9f9f\u662f\u5426\u78b0\u5230\u5899\u58c1\uff08\u7b2c6\u884c\uff09\uff1f\u6d77\u9f9f\u662f\u5426\u56de\u5230\u4e86\u5df2\u63a2\u7d22\u7684\u65b9\u683c\uff08\u7b2c9\u884c\uff09\uff1f\u6d77\u9f9f\u662f\u5426\u627e\u5230\u4e86\u51fa\u53e3\uff08\u7b2c12\u884c\uff09\uff1f\u5982\u679c\u8fd9\u4e9b\u6761\u4ef6\u90fd\u4e0d\u6210\u7acb\uff0c\u6211\u4eec\u5c06\u7ee7\u7eed\u9012\u5f52\u641c\u7d22\u3002</p> <p>\u4f60\u4f1a\u6ce8\u610f\u5230\u5728\u9012\u5f52\u6b65\u9aa4\u4e2d\uff0c\u6709\u56db\u4e2a\u9012\u5f52\u8c03\u7528\u5230 <code>search_from</code>\u3002\u7531\u4e8e\u8fd9\u4e9b\u8c03\u7528\u901a\u8fc7 <code>or</code> \u8bed\u53e5\u8fde\u63a5\u5728\u4e00\u8d77\uff0c\u5f88\u96be\u9884\u6d4b\u4f1a\u4f7f\u7528\u591a\u5c11\u4e2a\u9012\u5f52\u8c03\u7528\u3002\u5982\u679c\u7b2c\u4e00\u4e2a\u8c03\u7528 <code>search_from</code> \u8fd4\u56de <code>True</code>\uff0c\u90a3\u4e48\u5176\u4f59\u7684\u4e09\u4e2a\u8c03\u7528\u5c06\u4e0d\u4f1a\u88ab\u9700\u8981\u3002\u8fd9\u610f\u5473\u7740\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u6709\u6548\u7684\u8def\u5f84\u5411 <code>(row - 1, column)</code>\uff08\u6216\u5317\u65b9\uff0c\u5982\u679c\u4f60\u60f3\u4ee5\u5730\u7406\u65b9\u4f4d\u601d\u8003\uff09\u53ef\u4ee5\u901a\u5411\u8ff7\u5bab\u7684\u51fa\u53e3\u3002\u5982\u679c\u5317\u65b9\u6ca1\u6709\u597d\u7684\u8def\u5f84\uff0c\u63a5\u4e0b\u6765\u4f1a\u5c1d\u8bd5\u5411\u5357\u3002\u5982\u679c\u5357\u65b9\u5931\u8d25\uff0c\u5219\u5c1d\u8bd5\u897f\u65b9\uff0c\u6700\u540e\u5c1d\u8bd5\u4e1c\u65b9\u3002\u5982\u679c\u6240\u6709\u56db\u4e2a\u9012\u5f52\u8c03\u7528\u90fd\u8fd4\u56de <code>False</code>\uff0c\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u4e86\u4e00\u4e2a\u6b7b\u80e1\u540c\u3002\u4f60\u5e94\u8be5\u4e0b\u8f7d\u6216\u8f93\u5165\u6574\u4e2a\u7a0b\u5e8f\u5e76\u5c1d\u8bd5\u901a\u8fc7\u66f4\u6539\u8fd9\u4e9b\u8c03\u7528\u7684\u987a\u5e8f\u6765\u8fdb\u884c\u5b9e\u9a8c\u3002</p> <p>\u5b8c\u6574\u7684\u7a0b\u5e8f\u663e\u793a\u5728 <code>ActiveCode 4.11.1 &lt;completemaze&gt;</code> \u4e2d\u3002\u8be5\u7a0b\u5e8f\u4f7f\u7528\u6570\u636e\u6587\u4ef6 <code>maze2.txt</code>\uff0c\u5982\u4e0b\u6240\u793a\u3002\u6ce8\u610f\uff0c\u5b83\u662f\u4e00\u4e2a\u66f4\u7b80\u5355\u7684\u793a\u4f8b\u6587\u4ef6\uff0c\u56e0\u4e3a\u51fa\u53e3\u79bb\u6d77\u9f9f\u7684\u8d77\u59cb\u4f4d\u7f6e\u975e\u5e38\u8fd1\u3002</p> <pre><code>++++++++++++++++++++++\n+   +   ++ ++        +\n    +     ++++++++++\n+ +    ++  ++++ +++ ++\n+ +   + + ++    +++  +\n+          ++  ++  + +\n+++++ + +      ++  + +\n+++++ +++  + +  ++   +\n+          + + S+ +  +\n+++++ +  + + +     + +\n++++++++++++++++++++++\n</code></pre> \u6d3b\u52a8: 4.11.1 \u5b8c\u6574\u7684\u8ff7\u5bab\u89e3\u51b3\u5668<pre><code>import turtle\n\nSTART = \"S\"\nOBSTACLE = \"+\"\nTRIED = \".\"\nDEAD_END = \"-\"\nPART_OF_PATH = \"O\"\n\n\nclass Maze:\n    def __init__(self, maze_filename):\n        with open(maze_filename, \"r\") as maze_file:\n            self.maze_list = [\n                [ch for ch in line.rstrip(\"\\n\")]\n                for line in maze_file.readlines()\n            ]\n        self.rows_in_maze = len(self.maze_list)\n        self.columns_in_maze = len(self.maze_list[0])\n        for row_idx, row in enumerate(self.maze_list):\n            if START in row:\n                self.start_row = row_idx\n                self.start_col = row.index(START)\n                break\n\n        self.x_translate = -self.columns_in_maze / 2\n        self.y_translate = self.rows_in_maze / 2\n        self.t = turtle.Turtle()\n        self.t.shape(\"turtle\")\n        self.wn = turtle.Screen()\n        self.wn.setworldcoordinates(\n            -(self.columns_in_maze - 1) / 2 - 0.5,\n            -(self.rows_in_maze - 1) / 2 - 0.5,\n            (self.columns_in_maze - 1) / 2 + 0.5,\n            (self.rows_in_maze - 1) / 2 + 0.5,\n        )\n\n    def draw_maze(self):\n        self.t.speed(10)\n        self.wn.tracer(0)\n        for y in range(self.rows_in_maze):\n            for x in range(self.columns_in_maze):\n                if self.maze_list[y][x] == OBSTACLE:\n                    self.draw_centered_box(\n                        x + self.x_translate, -y + self.y_translate, \"orange\"\n                    )\n        self.t.color(\"black\")\n        self.t.fillcolor(\"blue\")\n        self.wn.update()\n        self.wn.tracer(1)\n\n    def draw_centered_box(self, x, y, color):\n        self.t.up()\n        self.t.goto(x - 0.5, y - 0.5)\n        self.t.color(color)\n        self.t.fillcolor(color)\n        self.t.setheading(90)\n        self.t.down()\n        self.t.begin_fill()\n        for i in range(4):\n            self.t.forward(1)\n            self.t.right(90)\n        self.t.end_fill()\n\n    def move_turtle(self, x, y):\n        self.t.up()\n        self.t.setheading(self.t.towards(x + self.x_translate, -y + self.y_translate))\n        self.t.goto(x + self.x_translate, -y + self.y_translate)\n\n    def drop_bread_crumb(self, color):\n        self.t.dot(10, color)\n\n    def update_position(self, row, col, val=None):\n        if val:\n            self.maze_list[row][col] = val\n        self.move_turtle(col, row)\n\n        if val == PART_OF_PATH:\n            color = \"green\"\n        elif val == OBSTACLE:\n            color = \"red\"\n        elif val == TRIED:\n            color = \"black\"\n        elif val == DEAD_END:\n            color = \"red\"\n        else:\n            color = None\n\n        if color:\n            self.drop_bread_crumb(color)\n\n    def is_exit(self, row, col):\n        return (\n            row == 0\n            or row == self.rows_in_maze - 1\n            or col == 0\n            or col == self.columns_in_maze - 1\n        )\n\n    def __getitem__(self, idx):\n        return self.maze_list[idx]\n\n\ndef search_from(maze, start_row, start_column):\n    # \u5c1d\u8bd5\u4ece\u8fd9\u4e2a\u70b9\u7684\u56db\u4e2a\u65b9\u5411\u4e2d\u627e\u5230\u51fa\u53e3\n    # \u57fa\u672c\u60c5\u51b5\u8fd4\u56de\u503c\uff1a\n    #  1. \u78b0\u5230\u969c\u788d\u7269\uff0c\u8fd4\u56de False\n    maze.update_position(start_row, start_column)\n    if maze[start_row][start_column] == OBSTACLE:\n        return False\n    #  2.\n\n \u627e\u5230\u5df2\u63a2\u7d22\u7684\u65b9\u683c\n    if (\n        maze[start_row][start_column] == TRIED\n        or maze[start_row][start_column] == DEAD_END\n    ):\n        return False\n    # 3. \u627e\u5230\u4e00\u4e2a\u672a\u88ab\u969c\u788d\u7269\u5360\u636e\u7684\u5916\u8fb9\u754c\n    if maze.is_exit(start_row, start_column):\n        maze.update_position(start_row, start_column, PART_OF_PATH)\n        return True\n    maze.update_position(start_row, start_column, TRIED)\n    # \u5426\u5219\uff0c\u4f7f\u7528\u903b\u8f91\u77ed\u8def\u4f9d\u6b21\u5c1d\u8bd5\u6bcf\u4e2a\u65b9\u5411\n    found = (\n        search_from(maze, start_row - 1, start_column)\n        or search_from(maze, start_row + 1, start_column)\n        or search_from(maze, start_row, start_column - 1)\n        or search_from(maze, start_row, start_column + 1)\n    )\n    if found:\n        maze.update_position(start_row, start_column, PART_OF_PATH)\n    else:\n        maze.update_position(start_row, start_column, DEAD_END)\n    return found\n\n\nmy_maze = Maze(\"maze2.txt\")\nmy_maze.draw_maze()\nmy_maze.update_position(my_maze.start_row, my_maze.start_col)\n\nsearch_from(my_maze, my_maze.start_row, my_maze.start_col)\n</code></pre> <p>\u81ea\u6211\u68c0\u67e5</p> <p>\u4fee\u6539\u8ff7\u5bab\u641c\u7d22\u7a0b\u5e8f\uff0c\u4f7f\u5f97\u5bf9 <code>search_from</code> \u7684\u8c03\u7528\u987a\u5e8f\u4e0d\u540c\u3002\u89c2\u5bdf\u7a0b\u5e8f\u7684\u8fd0\u884c\u60c5\u51b5\u3002\u4f60\u80fd\u89e3\u91ca\u4e3a\u4ec0\u4e48\u884c\u4e3a\u4e0d\u540c\u5417\uff1f\u4f60\u80fd\u9884\u6d4b\u5728\u7ed9\u5b9a\u7684\u8c03\u7528\u987a\u5e8f\u66f4\u6539\u4e0b\u6d77\u9f9f\u5c06\u9075\u5faa\u4ec0\u4e48\u8def\u5f84\u5417\uff1f</p> <p>In this section we will look at a problem that has relevance to the expanding world of robotics: how do you find your way out of a maze? If you have a Roomba vacuum cleaner for your dorm room (don\u2019t all college students?) you will wish that you could reprogram it using what you have learned in this section. The problem we want to solve is to help our turtle find its way out of a virtual maze. The maze problem has roots as deep as the Greek myth about Theseus, who was sent into a maze to kill the Minotaur. Theseus used a ball of thread to help him find his way back out again once he had finished off the beast. In our problem we will assume that our turtle is dropped down somewhere into the middle of the maze and must find its way out. Look at `Figure 4.12 to get an idea of where we are going in this section.</p> <p> Figure 4.12: The Finished Maze Search Program </p> <p>To make it easier for us we will assume that our maze is divided up into squares. Each square of the maze is either open or occupied by a section of wall. The turtle can only pass through the open squares of the maze. If the turtle bumps into a wall, it must try a different direction. The turtle will require a systematic procedure to find its way out of the maze. Here is the procedure:</p> <ol> <li>From our starting position we will first try going north one square and then recursively try our procedure from there.</li> <li>If we are not successful by trying a northern path as the first step then we will take a step to the south and recursively repeat our procedure.</li> <li>If south does not work then we will try a step to the West as our first step and recursively apply our procedure.</li> <li>If north, south, and west have not been successful then we will apply the procedure recursively from a position one step to our east.</li> <li>If none of these directions works then there is no way to get out of the maze and we fail.</li> </ol> <p>Now that sounds pretty easy, but there are a couple of details to talk about first. Suppose we take our first recursive step by going north. By following our procedure, our next step would also be to the north. But if the north is blocked by a wall, we must look at the next step of the procedure and try going to the south. Unfortunately, that step to the south brings us right back to our original starting place. If we apply the recursive procedure from there, we will just go back one step to the North and be in an infinite loop. So we must have a strategy to remember where we have been. In this case we will assume that we have a bag of bread crumbs we can drop along our way. If we take a step in a certain direction and find that there is a bread crumb already on that square, we know that we should immediately back up and try the next direction in our procedure. As we will see when we look at the code for this algorithm, backing up is as simple as returning from a recursive function call.</p> <p>As we do for all recursive algorithms, let us review the base cases. Some of them you may already have guessed based on the description in the previous paragraph. In this algorithm, there are four base cases to consider:</p> <ol> <li>The turtle has run into a wall. Since the square is occupied by a wall, no further exploration can take place.</li> <li>The turtle has found a square that has already been explored. We do not want to continue exploring from this position so we don't get into a loop.</li> <li>We have found an outside edge, not occupied by a wall. In other words, we have found an exit from the maze.</li> <li>We have explored a square unsuccessfully in all four directions.</li> </ol> <p>For our program to work we will need to have a way to represent the maze. <code>Figure 4.13</code> is an example of a maze data file.</p> **Figure 4.13:** An Example Maze Data File<pre><code>++++++++++++++++++++++\n+   +   ++ ++     +   \n+ +   +       +++ + ++\n+ + +  ++  ++++   + ++\n+++ ++++++    +++ +  +\n+          ++  ++    +\n+++++ ++++++   +++++ +\n+     +   +++++++  + +\n+ +++++++      S +   +\n+                + +++\n++++++++++++++++++ +++\n</code></pre> <p>To make this even more interesting we are going to use the <code>turtle</code> module to draw and explore our maze so we can watch this algorithm in action. The <code>Maze</code> object will provide the following methods for us to use in writing our search algorithm:</p> <ul> <li><code>__init__</code> Reads in a data file representing a maze, initializes the internal representation of the maze, and finds the starting position for the turtle.</li> <li><code>draw_maze</code> Draws the maze in a window on the screen.</li> <li><code>update_position</code> Updates the internal representation of the maze and changes the position of the turtle in the window.</li> <li><code>is_exit</code> Checks to see if the current position is an exit from the maze.</li> </ul> <p>The <code>Maze</code> class also overloads the index operator <code>[]</code> so that our algorithm can easily access the status of any particular square.</p> <p><code>Listing 4.11 &lt;lst_maze_globals&gt;</code> includes the global constants used by the <code>Maze</code> class methods (Listings <code>4.12 &lt;lst_maze_init&gt;</code>--<code>4.15 &lt;lst_maze_aux&gt;</code>) and the <code>search_from</code> function (<code>Listing 4.16 &lt;lst_maze_search&gt;</code>).</p> **Listing 4.11:** The Maze Program Global Constants<pre><code>START = \"S\"\nOBSTACLE = \"+\"\nTRIED = \".\"\nDEAD_END = \"-\"\nPART_OF_PATH = \"O\"\n</code></pre> <p>The <code>__init__</code> method takes the name of a file as its only parameter. This file is a text file that represents a maze by using \u201c+\u201d characters for walls, spaces for open squares, and the letter \u201cS\u201d to indicate the starting position.</p> **Listing 4.12:** The Maze Class Constructor<pre><code>class Maze:\n    def __init__(self, maze_filename):\n        with open(maze_filename, \"r\") as maze_file:\n            self.maze_list = [\n                [ch for ch in line.rstrip(\"\\n\")]\n                for line in maze_file.readlines()\n            ]\n        self.rows_in_maze = len(self.maze_list)\n        self.columns_in_maze = len(self.maze_list[0])\n        for row_idx, row in enumerate(self.maze_list):\n            if START in row:\n                self.start_row = row_idx\n                self.start_col = row.index(START)\n                break\n\n        self.x_translate = -self.columns_in_maze / 2\n        self.y_translate = self.rows_in_maze / 2\n        self.t = turtle.Turtle()\n        self.t.shape(\"turtle\")\n        self.wn = turtle.Screen()\n        self.wn.setworldcoordinates(\n            -(self.columns_in_maze - 1) / 2 - 0.5,\n            -(self.rows_in_maze - 1) / 2 - 0.5,\n            (self.columns_in_maze - 1) / 2 + 0.5,\n            (self.rows_in_maze - 1) / 2 + 0.5,\n        )\n</code></pre> <p>The internal representation of the maze is a list of lists. Each row of the <code>maze_list</code> instance variable is also a list. This secondary list contains one character per square using the characters described above. For the data file in <code>Figure 13</code> the internal representation looks like the following:</p> <pre><code>    [  ['+', '+', '+', '+', '+', ..., '+', '+', '+', '+', '+']\n       ['+', ' ', ' ', ' ', '+', ..., ' ', '+', ' ', ' ', ' ']\n       ['+', ' ', '+', ' ', ' ', ..., ' ', '+', ' ', '+', '+']\n       ['+', ' ', '+', ' ', '+', ..., ' ', '+', ' ', '+', '+']\n       ['+', '+', '+', ' ', '+', ..., ' ', '+', ' ', ' ', '+']\n       ['+', ' ', ' ', ' ', ' ', ..., ' ', ' ', ' ', ' ', '+']\n       ['+', '+', '+', '+', '+', ..., '+', '+', '+', ' ', '+']\n       ['+', ' ', ' ', ' ', ' ', ..., ' ', ' ', '+', ' ', '+']\n       ['+', ' ', '+', '+', '+', ..., '+', ' ', ' ', ' ', '+']\n       ['+', ' ', ' ', ' ', ' ', ..., '+', ' ', '+', '+', '+']\n       ['+', '+', '+', '+', '+', ..., '+', ' ', '+', '+', '+'] ]\n</code></pre> <p>The <code>draw_maze</code> method uses this internal representation to draw the initial view of the maze on the screen (<code>Figure 4.12</code>).</p> **Listing 4.13:** The Maze Class Drawing Methods<pre><code>def draw_maze(self):\n    self.t.speed(10)\n    self.wn.tracer(0)\n    for y in range(self.rows_in_maze):\n        for x in range(self.columns_in_maze):\n            if self.maze_list[y][x] == OBSTACLE:\n                self.draw_centered_box(\n                    x + self.x_translate, -y + self.y_translate, \"orange\"\n                )\n    self.t.color(\"black\")\n    self.t.fillcolor(\"blue\")\n    self.wn.update()\n    self.wn.tracer(1)\n\ndef draw_centered_box(self, x, y, color):\n    self.t.up()\n    self.t.goto(x - 0.5, y - 0.5)\n    self.t.color(color)\n    self.t.fillcolor(color)\n    self.t.setheading(90)\n    self.t.down()\n    self.t.begin_fill()\n    for i in range(4):\n        self.t.forward(1)\n        self.t.right(90)\n    self.t.end_fill()\n</code></pre> <p>The <code>update_position</code> method, as shown in <code>Listing 4.14</code> uses the same internal representation to see if the turtle has run into a wall. It also updates the internal representation with a \u201c.\u201d or \u201c-\u201d to indicate that the turtle has visited a particular square or if the square is part of a dead end. In addition, the <code>update_position</code> method uses two helper methods, <code>move_turtle</code> and <code>drop_bread_crumb</code>, to update the view on the screen.</p> **Listing 4.14:** The Maze Class Moving Methods<pre><code>def update_position(self, row, col, val=None):\n    if val:\n        self.maze_list[row][col] = val\n    self.move_turtle(col, row)\n\n    if val == PART_OF_PATH:\n        color = \"green\"\n    elif val == OBSTACLE:\n        color = \"red\"\n    elif val == TRIED:\n        color = \"black\"\n    elif val == DEAD_END:\n        color = \"red\"\n    else:\n        color = None\n\n    if color:\n        self.drop_bread_crumb(color)\n\ndef move_turtle(self, x, y):\n    self.t.up()\n    self.t.setheading(self.t.towards(x + self.x_translate, -y + self.y_translate))\n    self.t.goto(x + self.x_translate, -y + self.y_translate)\n\ndef drop_bread_crumb(self, color):\n    self.t.dot(10, color)\n</code></pre> <p>Finally, the <code>is_exit</code> method uses the current position of the turtle to test for an exit condition. An exit condition occurs whenever the turtle has navigated to the edge of the maze, either row zero or column zero, or the far-right column or the bottom row.</p> **Listing 4.15:** The Maze Class Auxiliary Methods<pre><code>def is_exit(self, row, col):\n    return (\n        row == 0\n        or row == self.rows_in_maze - 1\n        or col == 0\n        or col == self.columns_in_maze - 1\n    )\n\ndef __getitem__(self, idx):\n    return self.maze_list[idx]\n</code></pre> <p>Let\u2019s examine the code for the search function which we call <code>search_from</code>. The code is shown in <code>Listing 4.16</code>. Notice that this function takes three parameters: a <code>Maze</code> object, the starting row, and the starting column. This is important because as a recursive function the search logically starts again with each recursive call.</p> **Listing 4.15:** The Maze Class Auxiliary Methods<pre><code>def search_from(maze, row, column):\n    # Try each of four directions from this point until we find a way out.\n    maze.update_position(row, column)\n    # Base Case return values:\n    #  1. We have run into an obstacle, return false\n    if maze[row][column] == OBSTACLE:\n        return False\n    #  2. We have found an already explored square\n    if maze[row][column] in [TRIED, DEAD_END]:\n        return False\n    # 3. We have found an exit\n    if maze.is_exit(row, column):\n        maze.update_position(row, column, PART_OF_PATH)\n        return True\n    maze.update_position(row, column, TRIED)\n    # Otherwise, use logical short circuiting to try each direction\n    # in turn (if needed)\n    found = (\n        search_from(maze, row - 1, column)\n        or search_from(maze, row + 1, column)\n        or search_from(maze, row, column - 1)\n        or search_from(maze, row, column + 1)\n    )\n    if found:\n        maze.update_position(row, column, PART_OF_PATH)\n    else:\n        maze.update_position(row, column, DEAD_END)\n    return found\n</code></pre> <p>As you look through the algorithm you will see that the first thing the code does (line 3) is call <code>update_position</code>. This is simply to help you visualize the algorithm so that you can watch exactly how the turtle explores its way through the maze. Next the algorithm checks for the first three of the four base cases: Has the turtle run into a wall (lines 6)? Has the turtle circled back to a square already explored (line 9)? Has the turtle found an exit (line 12)? If none of these conditions is true then we continue the search recursively.</p> <p>You will notice that in the recursive step there are four recursive calls to <code>search_from</code>. It is hard to predict how many of these recursive calls will be used since they are all connected by <code>or</code> statements. If the first call to <code>search_from</code> returns <code>True</code> then none of the last three calls would be needed. You can interpret this as meaning that a step to <code>(row - 1, column)</code> (or north if you want to think geographically) is on the path leading out of the maze. If there is not a good path leading out of the maze to the north then the next recursive call is tried, this one to the south. If south fails then try west, and finally east. If all four recursive calls return <code>False</code> then we have found a dead end. You should download or type in the whole program and experiment with it by changing the order of these calls.</p> <p>The complete program is shown in <code>ActiveCode 4.11.1 &lt;completemaze&gt;</code>.  This program uses the data file <code>maze2.txt</code> shown below. Note that it is a much more simple example file in that the exit is very close to the starting position of the turtle.</p> <pre><code>++++++++++++++++++++++\n+   +   ++ ++        +\n    +     ++++++++++\n+ +    ++  ++++ +++ ++\n+ +   + + ++    +++  +\n+          ++  ++  + +\n+++++ + +      ++  + +\n+++++ +++  + +  ++   +\n+          + + S+ +  +\n+++++ +  + + +     + +\n++++++++++++++++++++++\n</code></pre> Activity: 4.11.1 Complete Maze Solver<pre><code>import turtle\n\nSTART = \"S\"\nOBSTACLE = \"+\"\nTRIED = \".\"\nDEAD_END = \"-\"\nPART_OF_PATH = \"O\"\n\n\nclass Maze:\n    def __init__(self, maze_filename):\n        with open(maze_filename, \"r\") as maze_file:\n            self.maze_list = [\n                [ch for ch in line.rstrip(\"\\n\")]\n                for line in maze_file.readlines()\n            ]\n        self.rows_in_maze = len(self.maze_list)\n        self.columns_in_maze = len(self.maze_list[0])\n        for row_idx, row in enumerate(self.maze_list):\n            if START in row:\n                self.start_row = row_idx\n                self.start_col = row.index(START)\n                break\n\n        self.x_translate = -self.columns_in_maze / 2\n        self.y_translate = self.rows_in_maze / 2\n        self.t = turtle.Turtle()\n        self.t.shape(\"turtle\")\n        self.wn = turtle.Screen()\n        self.wn.setworldcoordinates(\n            -(self.columns_in_maze - 1) / 2 - 0.5,\n            -(self.rows_in_maze - 1) / 2 - 0.5,\n            (self.columns_in_maze - 1) / 2 + 0.5,\n            (self.rows_in_maze - 1) / 2 + 0.5,\n        )\n\n    def draw_maze(self):\n        self.t.speed(10)\n        self.wn.tracer(0)\n        for y in range(self.rows_in_maze):\n            for x in range(self.columns_in_maze):\n                if self.maze_list[y][x] == OBSTACLE:\n                    self.draw_centered_box(\n                        x + self.x_translate, -y + self.y_translate, \"orange\"\n                    )\n        self.t.color(\"black\")\n        self.t.fillcolor(\"blue\")\n        self.wn.update()\n        self.wn.tracer(1)\n\n    def draw_centered_box(self, x, y, color):\n        self.t.up()\n        self.t.goto(x - 0.5, y - 0.5)\n        self.t.color(color)\n        self.t.fillcolor(color)\n        self.t.setheading(90)\n        self.t.down()\n        self.t.begin_fill()\n        for i in range(4):\n            self.t.forward(1)\n            self.t.right(90)\n        self.t.end_fill()\n\n    def move_turtle(self, x, y):\n        self.t.up()\n        self.t.setheading(self.t.towards(x + self.x_translate, -y + self.y_translate))\n        self.t.goto(x + self.x_translate, -y + self.y_translate)\n\n    def drop_bread_crumb(self, color):\n        self.t.dot(10, color)\n\n    def update_position(self, row, col, val=None):\n        if val:\n            self.maze_list[row][col] = val\n        self.move_turtle(col, row)\n\n        if val == PART_OF_PATH:\n            color = \"green\"\n        elif val == OBSTACLE:\n            color = \"red\"\n        elif val == TRIED:\n            color = \"black\"\n        elif val == DEAD_END:\n            color = \"red\"\n        else:\n            color = None\n\n        if color:\n            self.drop_bread_crumb(color)\n\n    def is_exit(self, row, col):\n        return (\n            row == 0\n            or row == self.rows_in_maze - 1\n            or col == 0\n            or col == self.columns_in_maze - 1\n        )\n\n    def __getitem__(self, idx):\n        return self.maze_list[idx]\n\n\ndef search_from(maze, start_row, start_column):\n    # try each of four directions from this point until we find a way out.\n    # base Case return values:\n    #  1. We have run into an obstacle, return false\n    maze.update_position(start_row, start_column)\n    if maze[start_row][start_column] == OBSTACLE:\n        return False\n    #  2. We have found a square that has already been explored\n    if (\n        maze[start_row][start_column] == TRIED\n        or maze[start_row][start_column] == DEAD_END\n    ):\n        return False\n    # 3. We have found an outside edge not occupied by an obstacle\n    if maze.is_exit(start_row, start_column):\n        maze.update_position(start_row, start_column, PART_OF_PATH)\n        return True\n    maze.update_position(start_row, start_column, TRIED)\n    # Otherwise, use logical short circuiting to try each direction\n    # in turn (if needed)\n    found = (\n        search_from(maze, start_row - 1, start_column)\n        or search_from(maze, start_row + 1, start_column)\n        or search_from(maze, start_row, start_column - 1)\n        or search_from(maze, start_row, start_column + 1)\n    )\n    if found:\n        maze.update_position(start_row, start_column, PART_OF_PATH)\n    else:\n        maze.update_position(start_row, start_column, DEAD_END)\n    return found\n\n\nmy_maze = Maze(\"maze2.txt\")\nmy_maze.draw_maze()\nmy_maze.update_position(my_maze.start_row, my_maze.start_col)\n\nsearch_from(my_maze, my_maze.start_row, my_maze.start_col)\n</code></pre> <p>Self Check</p> <p>Modify the maze search program so that the calls to <code>search_from</code> are in a different order. Watch the program run. Can you explain why the behavior is different? Can you predict what path the turtle will follow for a given change in order?</p>"},{"location":"c4/s12/","title":"4.12. \u52a8\u6001\u89c4\u5212","text":"<p>4.12. Dynamic Programming</p> \u4e2d\u6587\u82f1\u6587 <p>\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u7684\u8bb8\u591a\u7a0b\u5e8f\u90fd\u662f\u4e3a\u4e86\u4f18\u5316\u67d0\u4e9b\u503c\u800c\u7f16\u5199\u7684\uff0c\u4f8b\u5982\uff1a\u5728\u4e24\u4e2a\u70b9\u4e4b\u95f4\u627e\u5230\u6700\u77ed\u8def\u5f84\uff0c\u627e\u5230\u6700\u9002\u5408\u4e00\u7ec4\u70b9\u7684\u76f4\u7ebf\uff0c\u6216\u627e\u5230\u6ee1\u8db3\u67d0\u4e9b\u6761\u4ef6\u7684\u6700\u5c0f\u5bf9\u8c61\u96c6\u5408\u3002\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6\u4eec\u4f7f\u7528\u4e86\u591a\u79cd\u7b56\u7565\u6765\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u3002\u672c\u4e66\u7684\u76ee\u6807\u4e4b\u4e00\u662f\u5411\u4f60\u5c55\u793a\u51e0\u79cd\u4e0d\u540c\u7684\u89e3\u51b3\u95ee\u9898\u7684\u7b56\u7565\u3002\u52a8\u6001\u89c4\u5212\u662f\u4e00\u79cd\u7528\u4e8e\u8fd9\u4e9b\u7c7b\u578b\u4f18\u5316\u95ee\u9898\u7684\u7b56\u7565\u3002</p> <p>\u4e00\u4e2a\u7ecf\u5178\u7684\u4f18\u5316\u95ee\u9898\u6d89\u53ca\u4f7f\u7528\u6700\u5c11\u6570\u91cf\u7684\u786c\u5e01\u627e\u96f6\u3002\u5047\u8bbe\u4f60\u662f\u4e00\u4e2a\u81ea\u52a8\u552e\u8d27\u673a\u5236\u9020\u5546\u7684\u7a0b\u5e8f\u5458\u3002\u4f60\u7684\u516c\u53f8\u5e0c\u671b\u901a\u8fc7\u4e3a\u6bcf\u7b14\u4ea4\u6613\u63d0\u4f9b\u5c3d\u53ef\u80fd\u5c11\u7684\u786c\u5e01\u6765\u7b80\u5316\u5de5\u4f5c\u3002\u5047\u8bbe\u987e\u5ba2\u6295\u4e861\u7f8e\u5143\u8d2d\u4e70\u4e86\u4e00\u4ef6\u5546\u54c1\uff0c\u4ef7\u683c\u4e3a37\u7f8e\u5206\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528\u7684\u6700\u5c11\u786c\u5e01\u6570\u662f\u591a\u5c11\uff1f\u7b54\u6848\u662f\u516d\u679a\u786c\u5e01\uff1a\u4e24\u679a25\u7f8e\u5206\u7684\u786c\u5e01\u3001\u4e00\u679a10\u7f8e\u5206\u7684\u786c\u5e01\u548c\u4e09\u679a1\u7f8e\u5206\u7684\u786c\u5e01\u3002\u6211\u4eec\u662f\u5982\u4f55\u5f97\u51fa\u516d\u679a\u786c\u5e01\u7684\u7b54\u6848\u7684\uff1f\u6211\u4eec\u4ece\u6211\u4eec\u5e93\u4e2d\u7684\u6700\u5927\u786c\u5e01\uff08\u537325\u7f8e\u5206\uff09\u5f00\u59cb\uff0c\u5c3d\u53ef\u80fd\u591a\u5730\u4f7f\u7528\u8fd9\u4e9b\u786c\u5e01\uff0c\u7136\u540e\u8f6c\u5230\u4e0b\u4e00\u4e2a\u8f83\u5c0f\u7684\u786c\u5e01\u503c\uff0c\u5c3d\u53ef\u80fd\u591a\u5730\u4f7f\u7528\u8fd9\u4e9b\u786c\u5e01\u3002\u8fd9\u79cd\u65b9\u6cd5\u79f0\u4e3a\u8d2a\u5fc3\u7b97\u6cd5\uff0c\u56e0\u4e3a\u6211\u4eec\u5c3d\u53ef\u80fd\u5730\u89e3\u51b3\u95ee\u9898\u7684\u8f83\u5927\u90e8\u5206\u3002</p> <p>\u8d2a\u5fc3\u7b97\u6cd5\u5728\u4f7f\u7528\u7f8e\u56fd\u786c\u5e01\u65f6\u6548\u679c\u5f88\u597d\uff0c\u4f46\u5047\u8bbe\u4f60\u7684\u516c\u53f8\u51b3\u5b9a\u5728\u4e0b\u57c3\u5c14\u535a\u5c3c\u4e9a\u90e8\u7f72\u5176\u81ea\u52a8\u552e\u8d27\u673a\uff0c\u5728\u90a3\u91cc\uff0c\u9664\u4e86\u5e38\u89c1\u76841\u30015\u300110\u548c25\u7f8e\u5206\u786c\u5e01\u4e4b\u5916\uff0c\u8fd8\u5b58\u572821\u7f8e\u5206\u7684\u786c\u5e01\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u7684\u8d2a\u5fc3\u7b97\u6cd5\u65e0\u6cd5\u627e\u523063\u7f8e\u5206\u627e\u96f6\u7684\u6700\u4f18\u89e3\u3002\u7531\u4e8e21\u7f8e\u5206\u786c\u5e01\u7684\u52a0\u5165\uff0c\u8d2a\u5fc3\u7b97\u6cd5\u4ecd\u7136\u4f1a\u53d1\u73b0\u89e3\u51b3\u65b9\u6848\u662f\u516d\u679a\u786c\u5e01\u3002\u7136\u800c\uff0c\u6700\u4f18\u7b54\u6848\u662f\u4e09\u679a21\u7f8e\u5206\u7684\u786c\u5e01\u3002</p> <p>\u8ba9\u6211\u4eec\u770b\u770b\u4e00\u79cd\u53ef\u4ee5\u786e\u4fdd\u627e\u5230\u95ee\u9898\u6700\u4f18\u89e3\u7684\u65b9\u6cd5\u3002\u7531\u4e8e\u672c\u8282\u8ba8\u8bba\u7684\u662f\u9012\u5f52\uff0c\u4f60\u53ef\u80fd\u731c\u5230\u4e86\u6211\u4eec\u5c06\u4f7f\u7528\u9012\u5f52\u89e3\u51b3\u65b9\u6848\u3002\u6211\u4eec\u4ece\u8bc6\u522b\u57fa\u672c\u60c5\u51b5\u5f00\u59cb\u3002\u5982\u679c\u6211\u4eec\u8bd5\u56fe\u627e\u96f6\u7684\u91d1\u989d\u7b49\u4e8e\u67d0\u79cd\u786c\u5e01\u7684\u9762\u503c\uff0c\u90a3\u4e48\u7b54\u6848\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u4e00\u679a\u786c\u5e01\u3002</p> <p>\u5982\u679c\u91d1\u989d\u4e0d\u5339\u914d\uff0c\u6211\u4eec\u6709\u51e0\u79cd\u9009\u62e9\u3002\u6211\u4eec\u60f3\u8981\u7684\u662f\u786c\u5e01\u6570\u7684\u6700\u5c0f\u503c\uff0c\u8fd9\u4e2a\u786c\u5e01\u6570\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u51e0\u79cd\u65b9\u5f0f\u8ba1\u7b97\uff1a\u7528\u4e00\u679a1\u7f8e\u5206\u7684\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d\u51cf\u53bb1\u7f8e\u5206\u6240\u9700\u7684\u786c\u5e01\u6570\uff0c\u6216\u7528\u4e00\u679a5\u7f8e\u5206\u7684\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d\u51cf\u53bb5\u7f8e\u5206\u6240\u9700\u7684\u786c\u5e01\u6570\uff0c\u6216\u7528\u4e00\u679a10\u7f8e\u5206\u7684\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d\u51cf\u53bb10\u7f8e\u5206\u6240\u9700\u7684\u786c\u5e01\u6570\uff0c\u7b49\u7b49\u3002\u56e0\u6b64\uff0c\u8ba1\u7b97\u627e\u96f6\u91d1\u989d\u6240\u9700\u7684\u786c\u5e01\u6570\u53ef\u4ee5\u6839\u636e\u4ee5\u4e0b\u516c\u5f0f\u8ba1\u7b97\uff1a</p> <pre><code>$num\\_coins = \\min \\begin{cases} \n1 + num\\_coins(original\\ amount - 1) \\\\ \n1 + num\\_coins(original\\ amount - 5) \\\\ \n1 + num\\_coins(original\\ amount - 10) \\\\ \n1 + num\\_coins(original\\ amount - 25) \n\\end{cases}\n</code></pre> <p><code>Listing 17</code> \u663e\u793a\u4e86\u4e0a\u8ff0\u63cf\u8ff0\u7684\u7b97\u6cd5\u3002\u5728\u7b2c3\u884c\uff0c\u6211\u4eec\u68c0\u67e5\u57fa\u672c\u60c5\u51b5\uff1b\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u8bd5\u56fe\u627e\u96f6\u7684\u91d1\u989d\u662f\u5426\u7b49\u4e8e\u67d0\u79cd\u786c\u5e01\u7684\u9762\u503c\u3002\u5982\u679c\u6211\u4eec\u6ca1\u6709\u7b49\u4e8e\u627e\u96f6\u91d1\u989d\u7684\u786c\u5e01\uff0c\u6211\u4eec\u5c06\u5bf9\u6240\u6709\u5c0f\u4e8e\u627e\u96f6\u91d1\u989d\u7684\u786c\u5e01\u503c\u8fdb\u884c\u9012\u5f52\u8c03\u7528\u3002\u7b2c6\u884c\u663e\u793a\u4e86\u5982\u4f55\u901a\u8fc7\u5217\u8868\u63a8\u5bfc\u5f0f\u8fc7\u6ee4\u51fa\u5c0f\u4e8e\u5f53\u524d\u627e\u96f6\u91d1\u989d\u7684\u786c\u5e01\u5217\u8868\u3002\u9012\u5f52\u8c03\u7528\u8fd8\u4f1a\u5c06\u6211\u4eec\u9700\u8981\u627e\u96f6\u7684\u603b\u91d1\u989d\u51cf\u5c11\u5230\u6240\u9009\u786c\u5e01\u7684\u503c\u3002\u9012\u5f52\u8c03\u7528\u5728\u7b2c7\u884c\u8fdb\u884c\u3002\u8bf7\u6ce8\u610f\uff0c\u5728\u540c\u4e00\u884c\uff0c\u6211\u4eec\u5c06\u786c\u5e01\u6570\u52a01\uff0c\u4ee5\u8003\u8651\u6211\u4eec\u4f7f\u7528\u4e86\u4e00\u679a\u786c\u5e01\u3002\u4ec5\u4ec5\u52a01\u5c31\u7b49\u540c\u4e8e\u6211\u4eec\u8fdb\u884c\u4e86\u4e00\u4e2a\u9012\u5f52\u8c03\u7528\uff0c\u5e76\u7acb\u5373\u6ee1\u8db3\u57fa\u672c\u60c5\u51b5\u6761\u4ef6\u3002</p> **Listing 17:** \u786c\u5e01\u4f18\u5316\u95ee\u9898\u7684\u9012\u5f52\u7248\u672c<pre><code>def make_change_1(coin_denoms, change):\n    if change in coin_denoms:\n        return 1\n    min_coins = float(\"inf\")\n    for i in [c for c in coin_denoms if c &lt;= change]:\n        num_coins = 1 + make_change_1(\n            coin_denoms, change - i\n        )\n        min_coins = min(num_coins, min_coins)\n    return min_coins\n\n\nprint(make_change_1([1, 5, 10, 25], 63))\n</code></pre> <p><code>Listing 17</code> \u4e2d\u7684\u7b97\u6cd5\u7684\u95ee\u9898\u662f\u6548\u7387\u6781\u4f4e\u3002\u5b9e\u9645\u4e0a\uff0c\u89e3\u51b34\u79cd\u786c\u5e01\u300163\u7f8e\u5206\u95ee\u9898\u7684\u6700\u4f18\u89e3\u9700\u898167,716,925\u6b21\u9012\u5f52\u8c03\u7528\uff01\u4e3a\u4e86\u7406\u89e3\u6211\u4eec\u65b9\u6cd5\u7684\u81f4\u547d\u7f3a\u9677\uff0c\u770b\u770b<code>Figure 14</code>\uff0c\u5b83\u5c55\u793a\u4e86\u4e3a26\u7f8e\u5206\u627e\u96f6\u6240\u9700\u7684377\u4e2a\u51fd\u6570\u8c03\u7528\u4e2d\u7684\u4e00\u5c0f\u90e8\u5206\u3002</p> <p>\u56fe\u4e2d\u7684\u6bcf\u4e2a\u8282\u70b9\u5bf9\u5e94\u4e00\u6b21 <code>make_change_1</code> \u7684\u8c03\u7528\u3002\u8282\u70b9\u4e0a\u7684\u6807\u7b7e\u8868\u793a\u6211\u4eec\u8ba1\u7b97\u786c\u5e01\u6570\u91cf\u7684\u627e\u96f6\u91d1\u989d\u3002\u7bad\u5934\u4e0a\u7684\u6807\u7b7e\u8868\u793a\u6211\u4eec\u521a\u521a\u4f7f\u7528\u7684\u786c\u5e01\u3002\u901a\u8fc7\u8ddf\u8e2a\u56fe\u5f62\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7ec4\u5408\u786c\u5e01\u7684\u65b9\u5f0f\u3002\u4e3b\u8981\u95ee\u9898\u5728\u4e8e\u6211\u4eec\u91cd\u590d\u8ba1\u7b97\u4e86\u592a\u591a\u6b21\u3002\u4f8b\u5982\uff0c\u56fe\u8868\u663e\u793a\u7b97\u6cd5\u4f1a\u91cd\u65b0\u8ba1\u7b9715\u7f8e\u5206\u627e\u96f6\u7684\u6700\u4f18\u786c\u5e01\u6570\u91cf\u81f3\u5c11\u4e09\u6b21\u3002\u6bcf\u6b21\u8ba1\u7b9715\u7f8e\u5206\u7684\u6700\u4f18\u786c\u5e01\u6570\u91cf\u672c\u8eab\u9700\u898152\u6b21\u51fd\u6570\u8c03\u7528\u3002\u663e\u7136\uff0c\u6211\u4eec\u5728\u91cd\u590d\u8ba1\u7b97\u65e7\u7ed3\u679c\u65f6\u6d6a\u8d39\u4e86\u5927\u91cf\u65f6\u95f4\u548c\u7cbe\u529b\u3002</p> <p><code>Figure 14: Call Tree for Listing 17</code></p> <p>\u51cf\u5c11\u5de5\u4f5c\u91cf\u7684\u5173\u952e\u662f\u8bb0\u4f4f\u4e00\u4e9b\u8fc7\u53bb\u7684\u7ed3\u679c\uff0c\u4ee5\u907f\u514d\u91cd\u65b0\u8ba1\u7b97\u5df2\u7ecf\u77e5\u9053\u7684\u7ed3\u679c\u3002\u4e00\u79cd\u7b80\u5355\u7684\u89e3\u51b3\u65b9\u6848\u662f\u5c06\u627e\u5230\u7684\u6700\u5c0f\u786c\u5e01\u6570\u5b58\u50a8\u5728\u8868\u4e2d\u3002\u7136\u540e\uff0c\u5728\u8ba1\u7b97\u65b0\u7684\u6700\u5c0f\u65f6\uff0c\u6211\u4eec\u9996\u5148\u68c0\u67e5\u8868\u4e2d\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u7ed3\u679c\u3002\u5982\u679c\u8868\u4e2d\u5df2\u7ecf\u6709\u7ed3\u679c\uff0c\u6211\u4eec\u4f7f\u7528\u8868\u4e2d\u7684\u503c\uff0c\u800c\u4e0d\u662f\u91cd\u65b0\u8ba1\u7b97\u3002<code>ActiveCode 1</code> \u663e\u793a\u4e86\u4e00\u4e2a\u4fee\u6539\u8fc7\u7684\u7b97\u6cd5\uff0c\u91c7\u7528\u4e86\u8868\u67e5\u627e\u65b9\u6848\u3002</p> Activity: 4.12.1 \u4f7f\u7528\u8868\u67e5\u627e\u9012\u5f52\u8ba1\u7b97\u786c\u5e01<pre><code>def make_change_2(coin_value_list, change, known_results):\n    min_coins = change\n    if change in coin_value_list:\n        known_results[change] = 1\n        return 1\n    elif known_results[change] &gt; 0:\n        return known_results[change]\n    else:\n        for i in [c for c in coin_value_list if c &lt;= change]:\n            num_coins = 1 + make_change_2(coin_value_list, change - i, known_results)\n            if num_coins &lt; min_coins:\n                min_coins = num_coins\n            known_results[change] = min_coins\n    return min_coins\n\nprint(make_change_2([1, 5, 10, 25], 63, [0] * 64))\n</code></pre> <p>\u6ce8\u610f\u5728\u7b2c6\u884c\u6211\u4eec\u6dfb\u52a0\u4e86\u4e00\u4e2a\u6d4b\u8bd5\uff0c\u4ee5\u67e5\u770b\u6211\u4eec\u7684\u8868\u4e2d\u662f\u5426\u5305\u542b\u67d0\u4e2a\u91d1\u989d\u7684\u6700\u5c0f\u786c\u5e01\u6570\u3002\u5982\u679c\u8868\u4e2d\u6ca1\u6709\uff0c\u6211\u4eec\u9012\u5f52\u8ba1\u7b97\u6700\u5c0f\u503c\u5e76\u5c06\u8ba1\u7b97\u7ed3\u679c\u5b58\u50a8\u5728\u8868\u4e2d\u3002\u4f7f\u7528\u8fd9\u4e2a\u4fee\u6539\u540e\u7684\u7b97\u6cd5\uff0c\u5c064\u79cd\u786c\u5e01\u300163\u7f8e\u5206\u95ee\u9898\u7684\u9012\u5f52\u8c03\u7528\u6b21\u6570\u51cf\u5c11\u5230221\u6b21\uff01</p> <p>\u5c3d\u7ba1 <code>ActiveCode 1</code> \u4e2d\u7684\u7b97\u6cd5\u662f\u6b63\u786e\u7684\uff0c\u4f46\u5b83\u770b\u8d77\u6765\u6709\u70b9\u50cf\u4e00\u79cd\u6743\u5b9c\u4e4b\u8ba1\u3002\u6b64\u5916\uff0c\u5982\u679c\u6211\u4eec\u67e5\u770b <code>known_results</code> \u5217\u8868\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u8868\u4e2d\u5b58\u5728\u4e00\u4e9b\u7a7a\u7f3a\u3002\u5b9e\u9645\u4e0a\uff0c\u6211\u4eec\u6240\u505a\u7684\u5e76\u4e0d\u662f\u52a8\u6001\u89c4\u5212\uff0c\u800c\u662f\u901a\u8fc7\u4e00\u79cd\u79f0\u4e3a\u8bb0\u5fc6\u5316\uff08\u6216\u66f4\u5e38\u89c1\u7684\u53eb\u6cd5\u662f\u7f13\u5b58\uff09\u7684\u6280\u672f\u63d0\u9ad8\u4e86\u7a0b\u5e8f\u7684\u6027\u80fd\u3002</p> <p>\u771f\u6b63\u7684\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u5c06\u91c7\u7528\u4e00\u79cd\u66f4\u7cfb\u7edf\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u95ee\u9898\u3002\u6211\u4eec\u7684\u52a8\u6001\u89c4\u5212\u89e3\u51b3\u65b9\u6848\u5c06\u4ece1\u7f8e\u5206\u5f00\u59cb\uff0c\u7cfb\u7edf\u5730\u5de5\u4f5c\u5230\u6211\u4eec\u9700\u8981\u7684\u91d1\u989d\u3002\u8fd9\u53ef\u4ee5\u786e\u4fdd\u5728\u7b97\u6cd5\u7684\u6bcf\u4e00\u6b65\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u627e\u96f6\u6240\u9700\u7684\u6700\u5c0f\u786c\u5e01\u6570\u3002</p> <p>\u8ba9\u6211\u4eec\u770b\u770b\u5982\u4f55\u586b\u5145\u4e00\u4e2a\u6700\u5c0f\u786c\u5e01\u6570\u8868\u6765\u627e\u96f611\u7f8e\u5206\u3002<code>Figure 15</code> \u8bf4\u660e\u4e86\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u6211\u4eec\u4ece1\u7f8e\u5206\u5f00\u59cb\u3002\u552f\u4e00\u7684\u89e3\u51b3\u65b9\u6848\u662f\u4e00\u4e2a\u786c\u5e01\uff081\u7f8e\u5206\uff09\u3002\u4e0b\u4e00\u884c\u663e\u793a\u4e861\u7f8e\u5206\u548c2\u7f8e\u5206\u7684\u6700\u5c0f\u786c\u5e01\u6570\u3002\u518d\u6b21\uff0c\u552f\u4e00\u7684\u89e3\u51b3\u65b9\u6848\u662f\u4e24\u4e2a1\u7f8e\u5206\u786c\u5e01\u3002\u7b2c\u4e94\u884c\u662f\u6709\u8da3\u7684\u5730\u65b9\u3002\u73b0\u5728\u6211\u4eec\u6709\u4e24\u4e2a\u9009\u9879\u53ef\u4ee5\u8003\u8651\uff0c\u4e94\u4e2a1\u7f8e\u5206\u786c\u5e01\u6216\u4e00\u4e2a5\u7f8e\u5206\u786c\u5e01\u3002\u6211\u4eec\u5982\u4f55\u51b3\u5b9a\u54ea\u4e2a\u66f4\u597d\uff1f\u6211\u4eec\u67e5\u770b\u8868\u683c\uff0c\u53d1\u73b0\u4e3a\u4e86\u627e\u96f64\u7f8e\u5206\uff0c\u6211\u4eec\u9700\u89814\u4e2a\u786c\u5e01\uff0c\u52a0\u4e0a\u4e00\u4e2a1\u7f8e\u5206\u786c\u5e01\u5c31\u662f5\u4e2a\u786c\u5e01\u3002\u6216\u8005\uff0c\u6211\u4eec\u53ef\u4ee5\u67e5\u770b0\u7f8e\u5206\uff0c\u52a0\u4e0a\u4e00\u4e2a5\u7f8e\u5206\u786c\u5e01\u5c31\u662f1\u4e2a\u786c\u5e01\u3002\u56e0\u4e3a1\u548c5\u4e2d\u7684\u6700\u5c0f\u503c\u662f1\uff0c\u6211\u4eec\u5728\u8868\u683c\u4e2d\u5b58\u50a81\u3002\u518d\u770b\u8868\u683c\u672b\u5c3e\uff0c\u8003\u865111\u7f8e\u5206\u3002<code>Figure 16</code> \u663e\u793a\u4e86\u6211\u4eec\u9700\u8981\u8003\u8651\u7684\u4e09\u79cd\u9009\u9879\uff1a</p> <ol> <li>\u4e00\u679a1\u7f8e\u5206\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d \\(11-1 = 10\\) \u7f8e\u5206\u7684\u6700\u5c0f\u786c\u5e01\u6570\uff081\uff09</li> <li>\u4e00\u679a5\u7f8e\u5206\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d \\(11 - 5 = 6\\) \u7f8e\u5206\u7684\u6700\u5c0f\u786c\u5e01\u6570\uff082\uff09</li> <li>\u4e00\u679a10\u7f8e\u5206\u786c\u5e01\u52a0\u4e0a\u627e\u96f6\u91d1\u989d $11 - 10 = </li> </ol> <p>1$ \u7f8e\u5206\u7684\u6700\u5c0f\u786c\u5e01\u6570\uff081\uff09</p> <p>\u9009\u62e91\u62163\u90fd\u80fd\u5f97\u5230\u603b\u5171\u4e24\u679a\u786c\u5e01\uff0c\u8fd9\u5c31\u662f11\u7f8e\u5206\u7684\u6700\u5c0f\u786c\u5e01\u6570\u3002</p> <p><code>Listing 19</code> \u662f\u4e00\u4e2a\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u6765\u89e3\u51b3\u6211\u4eec\u7684\u627e\u96f6\u95ee\u9898\u3002<code>make_change_3</code> \u63a5\u53d7\u4e09\u4e2a\u53c2\u6570\uff1a\u6709\u6548\u786c\u5e01\u503c\u7684\u5217\u8868\u3001\u6211\u4eec\u60f3\u8981\u627e\u96f6\u7684\u91d1\u989d\uff0c\u4ee5\u53ca\u6bcf\u4e2a\u503c\u6240\u9700\u7684\u6700\u5c0f\u786c\u5e01\u6570\u7684\u5217\u8868\u3002\u5f53\u51fd\u6570\u5b8c\u6210\u65f6\uff0c<code>min_coins</code> \u5c06\u5305\u542b\u4ece0\u5230<code>change</code>\u7684\u6240\u6709\u503c\u7684\u89e3\u51b3\u65b9\u6848\u3002</p> **Listing 19:** \u52a8\u6001\u89c4\u5212\u89e3\u51b3\u65b9\u6848<pre><code>def make_change_3(coin_value_list, change, min_coins):\n    for cents in range(change + 1):\n        coin_count = cents\n        for j in [c for c in coin_value_list if c &lt;= cents]:\n            if min_coins[cents - j] + 1 &lt; coin_count:\n                coin_count = min_coins[cents - j] + 1\n        min_coins[cents] = coin_count\n    return min_coins[change]\n</code></pre> <p>\u6ce8\u610f <code>make_change_3</code> \u4e0d\u662f\u9012\u5f52\u51fd\u6570\uff0c\u5c3d\u7ba1\u6211\u4eec\u4ece\u9012\u5f52\u89e3\u51b3\u65b9\u6848\u5f00\u59cb\u3002\u91cd\u8981\u7684\u662f\u8981\u610f\u8bc6\u5230\uff0c\u9012\u5f52\u89e3\u51b3\u65b9\u6848\u5e76\u4e0d\u4e00\u5b9a\u662f\u6700\u6709\u6548\u7684\u89e3\u51b3\u65b9\u6848\u3002\u8fd9\u4e2a\u51fd\u6570\u7684\u5927\u90e8\u5206\u5de5\u4f5c\u90fd\u7531\u7b2c4\u884c\u5f00\u59cb\u7684\u5faa\u73af\u5b8c\u6210\u3002\u5728\u8fd9\u4e2a\u5faa\u73af\u4e2d\uff0c\u6211\u4eec\u8003\u8651\u4f7f\u7528\u6240\u6709\u53ef\u80fd\u7684\u786c\u5e01\u6765\u627e\u96f6\u6307\u5b9a\u7684\u91d1\u989d <code>cents</code>\u3002\u5c31\u50cf\u6211\u4eec\u4e3a11\u7f8e\u5206\u627e\u96f6\u7684\u4f8b\u5b50\u4e00\u6837\uff0c\u6211\u4eec\u8bb0\u4f4f\u6700\u5c0f\u503c\u5e76\u5c06\u5176\u5b58\u50a8\u5728 <code>min_coins</code> \u5217\u8868\u4e2d\u3002</p> <p>\u5c3d\u7ba1\u6211\u4eec\u7684\u627e\u96f6\u7b97\u6cd5\u5f88\u597d\u5730\u627e\u51fa\u4e86\u6700\u5c0f\u786c\u5e01\u6570\uff0c\u4f46\u5b83\u6ca1\u6709\u5e2e\u52a9\u6211\u4eec\u5b9e\u9645\u627e\u96f6\uff0c\u56e0\u4e3a\u6211\u4eec\u6ca1\u6709\u8bb0\u5f55\u4f7f\u7528\u7684\u786c\u5e01\u3002\u6211\u4eec\u53ef\u4ee5\u8f7b\u677e\u5730\u6269\u5c55 <code>make_change_3</code> \u6765\u8ddf\u8e2a\u6240\u4f7f\u7528\u7684\u786c\u5e01\uff0c\u53ea\u9700\u8bb0\u4f4f\u6bcf\u4e2a <code>min_coins</code> \u8868\u4e2d\u7684\u6700\u540e\u4e00\u679a\u786c\u5e01\u3002\u5982\u679c\u6211\u4eec\u77e5\u9053\u6700\u540e\u6dfb\u52a0\u7684\u786c\u5e01\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u51cf\u53bb\u786c\u5e01\u7684\u503c\u6765\u627e\u5230\u8868\u4e2d\u524d\u4e00\u4e2a\u6761\u76ee\uff0c\u8be5\u6761\u76ee\u544a\u8bc9\u6211\u4eec\u4e3a\u4f7f\u8be5\u91d1\u989d\u6dfb\u52a0\u7684\u6700\u540e\u4e00\u679a\u786c\u5e01\u3002\u6211\u4eec\u53ef\u4ee5\u4e00\u76f4\u8ffd\u6eaf\u5230\u5f00\u59cb\u3002</p> <p><code>ActiveCode 2</code> \u663e\u793a\u4e86 <code>make_change_4</code>\uff0c\u5b83\u57fa\u4e8e <code>make_change_3</code> \u7b97\u6cd5\uff0c\u4f46\u4fee\u6539\u4e3a\u8ddf\u8e2a\u6240\u4f7f\u7528\u7684\u786c\u5e01\uff0c\u4ee5\u53ca\u4e00\u4e2a <code>print_coins</code> \u51fd\u6570\uff0c\u5b83\u901a\u8fc7\u8868\u683c\u5411\u540e\u8ddf\u8e2a\u4ee5\u6253\u5370\u51fa\u6240\u7528\u7684\u6bcf\u4e2a\u786c\u5e01\u7684\u503c\u3002\u8fd9\u5c55\u793a\u4e86\u8be5\u7b97\u6cd5\u5728\u4e3a\u4e0b\u57c3\u5c14\u535a\u5c3c\u4e9a\u7684\u670b\u53cb\u89e3\u51b3\u95ee\u9898\u65f6\u7684\u4f5c\u7528\u3002<code>main</code> \u7684\u524d\u4e24\u884c\u8bbe\u7f6e\u4e86\u8981\u8f6c\u6362\u7684\u91d1\u989d\uff0c\u5e76\u521b\u5efa\u4e86\u4f7f\u7528\u7684\u786c\u5e01\u5217\u8868\u3002\u63a5\u4e0b\u6765\u7684\u4e24\u884c\u521b\u5efa\u4e86\u6211\u4eec\u9700\u8981\u5b58\u50a8\u7ed3\u679c\u7684\u5217\u8868\u3002<code>coins_used</code> \u662f\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u7528\u4e8e\u627e\u96f6\u7684\u786c\u5e01\uff0c<code>coin_count</code> \u662f\u7528\u4e8e\u627e\u96f6\u76f8\u5e94\u91d1\u989d\u6240\u9700\u7684\u6700\u5c0f\u786c\u5e01\u6570\u3002</p> <p>\u6ce8\u610f\u6211\u4eec\u6253\u5370\u51fa\u7684\u786c\u5e01\u76f4\u63a5\u6765\u81ea <code>coins_used</code> \u6570\u7ec4\u3002\u5bf9\u4e8e\u7b2c\u4e00\u6b21\u8c03\u7528\uff0c\u6211\u4eec\u4ece\u6570\u7ec4\u4f4d\u7f6e63\u5f00\u59cb\u6253\u537021\u3002\u7136\u540e\u6211\u4eec\u8ba1\u7b97 \\(63 - 21 = 42\\)\uff0c\u5e76\u67e5\u770b\u5217\u8868\u4e2d\u7b2c42\u4e2a\u5143\u7d20\u3002\u6211\u4eec\u53d1\u73b0\u90a3\u91cc\u4e5f\u5b58\u50a8\u4e8621\u3002\u6700\u540e\uff0c\u6570\u7ec4\u7684\u7b2c21\u4e2a\u5143\u7d20\u4e5f\u5305\u542b21\uff0c\u7ed9\u6211\u4eec\u4e09\u679a21\u7f8e\u5206\u786c\u5e01\u3002</p> Activity: 4.12.2 \u5b8c\u6574\u7684\u627e\u96f6\u95ee\u9898\u89e3\u51b3\u65b9\u6848<pre><code>def make_change_4(coin_value_list, change, min_coins, coins_used):\n    for cents in range(change + 1):\n        coin_count = cents\n        new_coin = 1\n        for j in [c for c in coin_value_list if c &lt;= cents]:\n            if min_coins[cents - j] + 1 &lt; coin_count:\n                coin_count = min_coins[cents - j] + 1\n                new_coin = j\n        min_coins[cents] = coin_count\n        coins_used[cents] = new_coin\n    return min_coins[change]\n\n\ndef print_coins(coins_used, change):\n    coin = change\n    while coin &gt; 0:\n        this_coin = coins_used[coin]\n        print(this_coin, end=\" \")\n        coin = coin - this_coin\n    print()\n\n\ndef main():\n    amnt = 63\n    clist = [1, 5, 10, 21, 25]\n    coins_used = [0] * (amnt + 1)\n    coin_count = [0] * (amnt + 1)\n\n    print(\n        \"Making change for {} requires the following {} coins: \".format(\n                amnt, make_change_4(clist, amnt, coin_count, coins_used)\n        ),\n        end=\"\",\n    )\n    print_coins(coins_used, amnt)\n    print(\"The used list is as follows:\")\n    print(coins_used)\n\n\nmain()\n</code></pre> <p>Many programs in computer science are written to optimize some value; for example, find the shortest path between two points, find the line that best fits a set of points, or find the smallest set of objects that satisfies some criteria. There are many strategies that computer scientists use to solve these problems. One of the goals of this book is to expose you to several different problem-solving strategies. Dynamic programming is one strategy for these types of optimization problems.</p> <p>A classic example of an optimization problem involves making change using the fewest coins. Suppose you are a programmer for a vending machine manufacturer. Your company wants to streamline effort by giving out the fewest possible coins in change for each transaction. Suppose a customer puts in a dollar bill and purchases an item for 37 cents. What is the smallest number of coins you can use to make change? The answer is six coins: two quarters, one dime, and three pennies. How did we arrive at the answer of six coins? We start with the largest coin in our arsenal (a quarter) and use as many of those as possible, then we go to the next lowest coin value and use as many of those as possible. This first approach is called a greedy method because we try to solve as big a piece of the problem as possible right away.</p> <p>The greedy method works fine when we are using U.S. coins, but suppose that your company decides to deploy its vending machines in Lower Elbonia where, in addition to the usual 1, 5, 10, and 25 cent coins they also have a 21 cent coin. In this instance our greedy method fails to find the optimal solution for 63 cents in change. With the addition of the 21 cent coin the greedy method would still find the solution to be six coins. However, the optimal answer is three 21 cent pieces.</p> <p>Let\u2019s look at a method where we could be sure that we would find the optimal answer to the problem. Since this section is about recursion, you may have guessed that we will use a recursive solution. Let\u2019s start with identifying the base case. If we are trying to make change for the same amount as the value of one of our coins, the answer is easy, one coin.</p> <p>If the amount does not match we have several options. What we want is the minimum of a penny plus the number of coins needed to make change for the original amount minus a penny, or a nickel plus the number of coins needed to make change for the original amount minus five cents, or a dime plus the number of coins needed to make change for the original amount minus ten cents, and so on. So the number of coins needed to make change for the original amount can be computed according to the following:</p> <p>\\(num\\_coins = min \\begin{cases} 1 + num\\_coins(original\\ amount - 1) \\\\ 1 + num\\_coins(original\\ amount - 5) \\\\ 1 + num\\_coins(original\\ amount - 10) \\\\ 1 + num\\_coins(original\\ amount - 25) \\end{cases} \\label{eqn_change}\\)</p> <p>The algorithm for doing what we have just described is shown in <code>Listing 17</code>. In line\u00a03 we are checking our base case; that is, we are trying to make change in the exact amount of one of our coins. If we do not have a coin equal to the amount of change, we make recursive calls for each different coin value less than the amount of change we are trying to make. Line\u00a06 shows how we filter the list of coins to those less than the current value of change using a list comprehension. The recursive call also reduces the total amount of change we need to make by the value of the coin selected. The recursive call is made in line\u00a07. Notice that on that same line we add 1 to our number of coins to account for the fact that we are using a coin. Just adding 1 is the same as if we had made a recursive call asking where we satisfy the base case condition immediately.</p> **Listing 17:** Recursive Version of Coin Optimization Problem<pre><code>def make_change_1(coin_denoms, change):\n    if change in coin_denoms:\n        return 1\n    min_coins = float(\"inf\")\n    for i in [c for c in coin_denoms if c &lt;= change]:\n        num_coins = 1 + make_change_1(\n            coin_denoms, change - i\n        )\n        min_coins = min(num_coins, min_coins)\n    return min_coins\n\n\nprint(make_change_1([1, 5, 10, 25], 63))\n</code></pre> <p>The trouble with the algorithm in <code>Listing 17</code> is that it is extremely inefficient. In fact, it takes 67,716,925 recursive calls to find the optimal solution to the 4 coins, 63 cents problem! To understand the fatal flaw in our approach look at <code>Figure 14</code>, which illustrates a small fraction of the 377 function calls needed to find the optimal set of coins to make change for 26 cents.</p> <p>Each node in the graph corresponds to a call to <code>make_change_1</code>. The label on the node indicates the amount of change for which we are computing the number of coins. The label on the arrow indicates the coin that we just used. By following the graph we can see the combination of coins that got us to any point in the graph. The main problem is that we are redoing too many calculations. For example, the graph shows that the algorithm would recalculate the optimal number of coins to make change for 15 cents at least three times. Each of these computations to find the optimal number of coins for 15 cents itself takes 52 function calls. Clearly we are wasting a lot of time and effort recalculating old results.</p> <p> Figure 14: Call Tree for Listing 17 </p> <p>The key to cutting down on the amount of work we do is to remember some of the past results so we can avoid recomputing results we already know. A simple solution is to store the results for the minimum number of coins in a table when we find them. Then before we compute a new minimum, we first check the table to see if a result is already known. If there is already a result in the table, we use the value from the table rather than recomputing. <code>ActiveCode 1</code> shows a modified algorithm to incorporate our table lookup scheme.</p> Activity: 4.12.1 Recursively Counting Coins with Table Lookup<pre><code>def make_change_2(coin_value_list, change, known_results):\n    min_coins = change\n    if change in coin_value_list:\n        known_results[change] = 1\n        return 1\n    elif known_results[change] &gt; 0:\n        return known_results[change]\n    else:\n        for i in [c for c in coin_value_list if c &lt;= change]:\n            num_coins = 1 + make_change_2(coin_value_list, change - i, known_results)\n            if num_coins &lt; min_coins:\n                min_coins = num_coins\n            known_results[change] = min_coins\n    return min_coins\n\nprint(make_change_2([1, 5, 10, 25], 63, [0] * 64))\n</code></pre> <p>Notice that in line\u00a06 we have added a test to see if our table contains the minimum number of coins for a certain amount of change. If it does not, we compute the minimum recursively and store the computed minimum in the table. Using this modified algorithm reduces the number of recursive calls we need to make for the four coin, 63 cent problem to 221 calls!</p> <p>Although the algorithm in <code>AcitveCode 1</code> is correct, it looks and feels like a bit of a hack.  Also, if we look at the <code>known_results</code> lists we can see that there are some holes in the table. In fact the term for what we have done is not dynamic programming but rather we have improved the performance of our program by using a technique known as memoization, or more commonly called caching.</p> <p>A truly dynamic programming algorithm will take a more systematic approach to the problem. Our dynamic programming solution is going to start with making change for one cent and systematically work its way up to the amount of change we require. This guarantees that at each step of the algorithm we already know the minimum number of coins needed to make change for any smaller amount.</p> <p>Let\u2019s look at how we would fill in a table of minimum coins to use in making change for 11 cents. <code>Figure 15</code> illustrates the process. We start with one cent. The only solution possible is one coin (a penny). The next row shows the minimum for one cent and two cents. Again, the only solution is two pennies. The fifth row is where things get interesting. Now we have two options to consider, five pennies or one nickel. How do we decide which is best? We consult the table and see that the number of coins needed to make change for four cents is four, plus one more penny to make five, equals five coins. Or we can look at zero cents plus one more nickel to make five cents equals one coin. Since the minimum of one and five is one we store 1 in the table. Fast forward again to the end of the table and consider 11 cents. <code>Figure 16</code> shows the three options that we have to consider:</p> <ol> <li>A penny plus the minimum number of coins to make change for \\(11-1 = 10\\) cents (1)</li> <li>A nickel plus the minimum number of coins to make change for \\(11 - 5 = 6\\) cents (2)</li> <li>A dime plus the minimum number of coins to make change for \\(11 - 10 = 1\\) cent (1)</li> </ol> <p>Either option 1 or 3 will give us a total of two coins which is the minimum number of coins for 11 cents.</p> <p> Figure 15: Minimum Number of Coins Needed to Make Change </p> <p> Figure 16: Three Options to Consider for the Minimum Number of Coins for Eleven Cents </p> <p><code>Listing 19</code> is a dynamic programming algorithm to solve our change-making problem. <code>make_change_3</code> takes three parameters: a list of valid coin values, the amount of change we want to make, and a list of the minimum number of coins needed to make each value. When the function is done, <code>min_coins</code> will contain the solution for all values from 0 to the value of <code>change</code>.</p> **Listing 19:** Dynamic Programming Solution<pre><code>def make_change_3(coin_value_list, change, min_coins):\n    for cents in range(change + 1):\n        coin_count = cents\n        for j in [c for c in coin_value_list if c &lt;= cents]:\n            if min_coins[cents - j] + 1 &lt; coin_count:\n                coin_count = min_coins[cents - j] + 1\n        min_coins[cents] = coin_count\n    return min_coins[change]\n</code></pre> <p>Note that <code>make_change_3</code> is not a recursive function, even though we started with a recursive solution to this problem. It is  important to realize that a recursive solution to a problem will not  necessarily be the most efficient solution. The bulk of the work in this function is done by the loop that starts on line\u00a04. In this loop we consider using all possible coins to make change for the amount specified by <code>cents</code>. Like we did for the 11 cent example above, we remember the minimum value and store it in our <code>min_coins</code> list.</p> <p>Although our making change algorithm does a good job of figuring out the minimum number of coins, it does not help us make change since we do not keep track of the coins we use. We can easily extend <code>make_change_3</code> to keep track of the coins used by simply remembering the last coin we add for each entry in the <code>min_coins</code> table. If we know the last coin added, we can simply subtract the value of the coin to find a previous entry in the table that tells us the last coin we added to make that amount. We can keep tracing back through the table until we get to the beginning.</p> <p><code>ActiveCode 2</code> shows <code>make_change_4</code>, based on the <code>make_change_3</code> algorithm but modified to keep track of the coins used, along with a function <code>print_coins</code> that walks backward through the table to print out the value of each coin used. This shows the algorithm in action solving the problem for our friends in Lower Elbonia. The first two lines of <code>main</code> set the amount to be converted and create the list of coins used. The next two lines create the lists we need to store the results. <code>coins_used</code> is a list of the coins used to make change, and <code>coin_count</code> is the minimum number of coins used to make change for the amount corresponding to the position in the list.</p> <p>Notice that the coins we print out come directly from the <code>coins_used</code> array. For the first call we start at array position 63 and print 21. Then we take \\(63 - 21 = 42\\) and look at the 42<sup>nd</sup> element of the list. Once again we find a 21 stored there. Finally, element 21 of the array also contains 21, giving us the three 21 cent pieces.</p> Activity: 4.12.2 Complete Solution to the Change Problem<pre><code>def make_change_4(coin_value_list, change, min_coins, coins_used):\n    for cents in range(change + 1):\n        coin_count = cents\n        new_coin = 1\n        for j in [c for c in coin_value_list if c &lt;= cents]:\n            if min_coins[cents - j] + 1 &lt; coin_count:\n                coin_count = min_coins[cents - j] + 1\n                new_coin = j\n        min_coins[cents] = coin_count\n        coins_used[cents] = new_coin\n    return min_coins[change]\n\n\ndef print_coins(coins_used, change):\n    coin = change\n    while coin &gt; 0:\n        this_coin = coins_used[coin]\n        print(this_coin, end=\" \")\n        coin = coin - this_coin\n    print()\n\n\ndef main():\n    amnt = 63\n    clist = [1, 5, 10, 21, 25]\n    coins_used = [0] * (amnt + 1)\n    coin_count = [0] * (amnt + 1)\n\n    print(\n        \"Making change for {} requires the following {} coins: \".format(\n                amnt, make_change_4(clist, amnt, coin_count, coins_used)\n        ),\n        end=\"\",\n    )\n    print_coins(coins_used, amnt)\n    print(\"The used list is as follows:\")\n    print(coins_used)\n\n\nmain()\n</code></pre>"},{"location":"c4/s13/","title":"4.13. \u603b\u7ed3","text":"<p>4.13. Summary</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u51e0\u4e2a\u9012\u5f52\u7b97\u6cd5\u7684\u4f8b\u5b50\u3002\u8fd9\u4e9b\u7b97\u6cd5\u7684\u9009\u62e9\u662f\u4e3a\u4e86\u8ba9\u4f60\u63a5\u89e6\u5230\u4e00\u4e9b\u9012\u5f52\u4f5c\u4e3a\u6709\u6548\u95ee\u9898\u89e3\u51b3\u6280\u672f\u7684\u4e0d\u540c\u95ee\u9898\u3002\u9700\u8981\u8bb0\u4f4f\u7684\u5173\u952e\u70b9\u5982\u4e0b\uff1a</p> <ul> <li>\u6240\u6709\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u6709\u4e00\u4e2a\u57fa\u672c\u60c5\u51b5\u3002</li> <li>\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u6539\u53d8\u5176\u72b6\u6001\u5e76\u5411\u57fa\u672c\u60c5\u51b5\u8fc8\u8fdb\u3002</li> <li>\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u8c03\u7528\u81ea\u8eab\uff08\u9012\u5f52\u5730\uff09\u3002</li> <li>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u9012\u5f52\u53ef\u4ee5\u4ee3\u66ff\u8fed\u4ee3\u3002</li> <li>\u9012\u5f52\u7b97\u6cd5\u5f80\u5f80\u975e\u5e38\u81ea\u7136\u5730\u6620\u5c04\u5230\u4f60\u8bd5\u56fe\u89e3\u51b3\u7684\u95ee\u9898\u7684\u6b63\u5f0f\u8868\u8fbe\u5f0f\u4e0a\u3002</li> <li>\u9012\u5f52\u5e76\u4e0d\u603b\u662f\u7b54\u6848\u3002\u6709\u65f6\uff0c\u9012\u5f52\u89e3\u51b3\u65b9\u6848\u53ef\u80fd\u6bd4\u5176\u4ed6\u7b97\u6cd5\u66f4\u8017\u8d39\u8ba1\u7b97\u8d44\u6e90\u3002</li> </ul> <p>In this chapter we have looked at examples of several recursive algorithms. These algorithms were chosen to expose you to several different problems where recursion is an effective problem-solving technique. The key points to remember from this chapter are as follows:</p> <ul> <li>All recursive algorithms must have a base case.</li> <li>A recursive algorithm must change its state and make progress toward the base case.</li> <li>A recursive algorithm must call itself (recursively).</li> <li>Recursion can take the place of iteration in some cases.</li> <li>Recursive algorithms often map very naturally to a formal expression of the problem you are trying to solve.</li> <li>Recursion is not always the answer. Sometimes a recursive solution may be more computationally expensive than an alternative algorithm.</li> </ul>"},{"location":"c4/s14/","title":"4.14. \u5173\u952e\u672f\u8bed","text":"<p>4.14. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - base case greedy method stack frame dynamic programming recursion fractal recursive call - - - base case greedy method stack frame dynamic programming recursion fractal recursive call"},{"location":"c4/s15/","title":"4.15. \u7ec3\u4e60","text":"<p>4.15. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>\u7ed8\u5236\u6c49\u8bfa\u5854\u95ee\u9898\u7684\u8c03\u7528\u6808\u3002 \u5047\u8bbe\u4f60\u4ece\u4e00\u4e2a\u5305\u542b\u4e09\u5f20\u76d8\u5b50\u7684\u5806\u6808\u5f00\u59cb\u3002</p> </li> <li> <p>\u4f7f\u7528\u9012\u5f52\u89c4\u5219\u7ed8\u5236\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u3002 \u4f7f\u7528\u7eb8\u548c\u94c5\u7b14\u5b8c\u6210\u3002</p> </li> <li> <p>\u4f7f\u7528\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u8ba1\u7b97\u627e\u96f6\u95ee\u9898\uff0c\u627e\u51fa\u7528\u6700\u5c11\u6570\u91cf\u7684\u786c\u5e01\u6765\u627e33\u7f8e\u5206\u7684\u96f6\u94b1\u3002 \u9664\u4e86\u901a\u5e38\u7684\u786c\u5e01\uff0c\u8fd8\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a8\u7f8e\u5206\u7684\u786c\u5e01\u3002</p> </li> <li> <p>\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u51fd\u6570\u6765\u8ba1\u7b97\u4e00\u4e2a\u6570\u5b57\u7684\u9636\u4e58\u3002</p> </li> <li> <p>\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u51fd\u6570\u6765\u53cd\u8f6c\u4e00\u4e2a\u5217\u8868\u3002</p> </li> <li> <p>\u4fee\u6539\u9012\u5f52\u6811\u7a0b\u5e8f\uff0c\u4f7f\u7528\u4ee5\u4e0b\u4e00\u4e2a\u6216\u591a\u4e2a\u60f3\u6cd5\uff1a</p> <ul> <li>\u4fee\u6539\u5206\u652f\u7684\u7c97\u7ec6\uff0c\u4f7f\u5f97\u968f\u7740 <code>branch_len</code> \u7684\u51cf\u5c0f\uff0c\u7ebf\u6761\u53d8\u5f97\u66f4\u7ec6\u3002</li> <li>\u4fee\u6539\u5206\u652f\u7684\u989c\u8272\uff0c\u4f7f\u5f97 <code>branch_len</code> \u975e\u5e38\u77ed\u65f6\uff0c\u5b83\u88ab\u7740\u8272\u4e3a\u53f6\u5b50\u3002</li> <li>\u4fee\u6539\u8f6c\u5f2f\u89d2\u5ea6\uff0c\u4f7f\u5f97\u5728\u6bcf\u4e2a\u5206\u652f\u70b9\uff0c\u89d2\u5ea6\u5728\u67d0\u4e2a\u8303\u56f4\u5185\u968f\u673a\u9009\u62e9\u3002\u4f8b\u5982\uff0c\u9009\u62e915\u523045\u5ea6\u4e4b\u95f4\u7684\u89d2\u5ea6\u3002\u8fdb\u884c\u5b9e\u9a8c\uff0c\u770b\u770b\u6548\u679c\u5982\u4f55\u3002</li> <li>\u9012\u5f52\u5730\u4fee\u6539 <code>branch_len</code>\uff0c\u4f7f\u5f97\u6bcf\u6b21\u9012\u51cf\u7684\u91cf\u5728\u67d0\u4e2a\u8303\u56f4\u5185\u968f\u673a\u9009\u62e9\u3002</li> </ul> <p>\u5982\u679c\u5b9e\u73b0\u4ee5\u4e0a\u6240\u6709\u60f3\u6cd5\uff0c\u4f60\u5c06\u5f97\u5230\u4e00\u4e2a\u975e\u5e38\u903c\u771f\u7684\u6811\u5f62\u56fe\u50cf\u3002</p> </li> <li> <p>\u627e\u5230\u6216\u53d1\u660e\u4e00\u4e2a\u7ed8\u5236\u5206\u5f62\u5c71\u8109\u7684\u7b97\u6cd5\u3002 \u63d0\u793a\uff1a\u4e00\u79cd\u65b9\u6cd5\u662f\u518d\u6b21\u4f7f\u7528\u4e09\u89d2\u5f62\u3002</p> </li> <li> <p>\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u51fd\u6570\u6765\u8ba1\u7b97\u6590\u6ce2\u90a3\u5951\u6570\u5217\u3002 \u9012\u5f52\u51fd\u6570\u7684\u6027\u80fd\u4e0e\u8fed\u4ee3\u7248\u672c\u76f8\u6bd4\u5982\u4f55\uff1f</p> </li> <li> <p>\u4f7f\u7528\u4e09\u4e2a\u5806\u6808\u6765\u89e3\u51b3\u6c49\u8bfa\u5854\u95ee\u9898\u3002</p> </li> <li> <p>\u4f7f\u7528 <code>turtle</code> \u56fe\u5f62\u6a21\u5757\uff0c\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u7a0b\u5e8f\u6765\u663e\u793a\u5e0c\u5c14\u4f2f\u7279\u66f2\u7ebf\u3002</p> </li> <li> <p>\u4f7f\u7528 <code>turtle</code> \u56fe\u5f62\u6a21\u5757\uff0c\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u7a0b\u5e8f\u6765\u663e\u793a\u79d1\u8d6b\u96ea\u82b1\u3002</p> </li> <li> <p>\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u89e3\u51b3\u4ee5\u4e0b\u95ee\u9898\uff1a \u4f60\u6709\u4e24\u4e2a\u6c34\u58f6\uff1a\u4e00\u4e2a4\u52a0\u4ed1\u7684\u6c34\u58f6\u548c\u4e00\u4e2a3\u52a0\u4ed1\u7684\u6c34\u58f6\u3002\u4e24\u4e2a\u6c34\u58f6\u4e0a\u90fd\u6ca1\u6709\u523b\u5ea6\u3002\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u6cf5\u6765\u586b\u5145\u6c34\u58f6\u3002\u5982\u4f55\u57284\u52a0\u4ed1\u7684\u6c34\u58f6\u4e2d\u51c6\u786e\u5730\u83b7\u5f972\u52a0\u4ed1\u7684\u6c34\uff1f</p> </li> <li> <p>\u5c06\u4e0a\u8ff0\u95ee\u9898\u8fdb\u884c\u63a8\u5e7f\uff0c\u4f7f\u5f97\u89e3\u51b3\u65b9\u6848\u7684\u53c2\u6570\u5305\u62ec\u6bcf\u4e2a\u6c34\u58f6\u7684\u5927\u5c0f\u548c\u5927\u6c34\u58f6\u4e2d\u5269\u4f59\u7684\u6700\u7ec8\u6c34\u91cf\u3002</p> </li> <li> <p>\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u89e3\u51b3\u4ee5\u4e0b\u95ee\u9898\uff1a \u4e09\u4e2a\u4f20\u6559\u58eb\u548c\u4e09\u4e2a\u98df\u4eba\u65cf\u6765\u5230\u4e00\u6761\u6cb3\u8fb9\uff0c\u53d1\u73b0\u4e00\u53ea\u53ef\u4ee5\u5bb9\u7eb3\u4e24\u4e2a\u4eba\u7684\u8239\u3002\u6240\u6709\u4eba\u5fc5\u987b\u8fc7\u6cb3\u624d\u80fd\u7ee7\u7eed\u65c5\u7a0b\u3002\u7136\u800c\uff0c\u5982\u679c\u98df\u4eba\u65cf\u5728\u4efb\u4f55\u4e00\u5cb8\u4e0a\u6570\u91cf\u8d85\u8fc7\u4f20\u6559\u58eb\uff0c\u4f20\u6559\u58eb\u5c31\u4f1a\u88ab\u5403\u6389\u3002\u627e\u5230\u4e00\u4e2a\u8fc7\u6cb3\u7684\u7cfb\u5217\uff0c\u4f7f\u6240\u6709\u4eba\u5b89\u5168\u5230\u8fbe\u5bf9\u5cb8\u3002</p> </li> <li> <p>\u4f7f\u7528 <code>turtle</code> \u56fe\u5f62\u6a21\u5757\u4fee\u6539\u6c49\u8bfa\u5854\u7a0b\u5e8f\uff0c\u4f7f\u5f97\u76d8\u5b50\u7684\u79fb\u52a8\u6709\u52a8\u753b\u6548\u679c\u3002 \u63d0\u793a\uff1a\u4f60\u53ef\u4ee5\u521b\u5efa\u591a\u4e2a <code>turtle</code> \u5e76\u5c06\u5b83\u4eec\u8bbe\u7f6e\u6210\u77e9\u5f62\u5f62\u72b6\u3002</p> </li> <li> <p>\u5e15\u65af\u5361\u5c14\u4e09\u89d2\u5f62\u662f\u4e00\u4e2a\u6570\u5b57\u4e09\u89d2\u5f62\uff0c\u6570\u5b57\u6309\u9519\u5f00\u884c\u7684\u65b9\u5f0f\u6392\u5217\uff0c\u6ee1\u8db3\uff1a</p> <p>\\(a_{nr} = \\frac{n!}{r!(n-r)!}\\)</p> <p>\u8fd9\u662f\u4e8c\u9879\u5f0f\u7cfb\u6570\u7684\u65b9\u7a0b\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u5c06\u4e09\u89d2\u5f62\u4e2d\u5bf9\u89d2\u7ebf\u4e0a\u7684\u4e24\u4e2a\u6570\u5b57\u76f8\u52a0\u6765\u6784\u5efa\u5e15\u65af\u5361\u5c14\u4e09\u89d2\u5f62\u3002\u4e0b\u9762\u662f\u5e15\u65af\u5361\u5c14\u4e09\u89d2\u5f62\u7684\u793a\u4f8b\uff1a</p> <pre><code>        1\n    1   1\n    1   2   1\n1   3   3   1\n1   4   6   4   1\n</code></pre> <p>\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6253\u5370\u51fa\u5e15\u65af\u5361\u5c14\u4e09\u89d2\u5f62\u3002\u4f60\u7684\u7a0b\u5e8f\u5e94\u63a5\u53d7\u4e00\u4e2a\u53c2\u6570\uff0c\u6307\u5b9a\u8981\u6253\u5370\u591a\u5c11\u884c\u4e09\u89d2\u5f62\u3002</p> </li> <li> <p>\u4f60\u662f\u4e00\u4e2a\u8ba1\u7b97\u673a\u79d1\u5b66\u5bb6/\u827a\u672f\u5c0f\u5077\uff0c\u95ef\u5165\u4e86\u4e00\u4e2a\u4e3b\u8981\u7684\u827a\u672f\u753b\u5eca\u3002 \u4f60\u552f\u4e00\u80fd\u7528\u6765\u642c\u8fd0\u5077\u6765\u7684\u827a\u672f\u54c1\u7684\u662f\u4e00\u4e2a\u53ea\u80fd\u88c5 \\(W\\) \u78c5\u827a\u672f\u54c1\u7684\u80cc\u5305\uff0c\u4f46\u5bf9\u4e8e\u6bcf\u4ef6\u827a\u672f\u54c1\u4f60\u77e5\u9053\u5b83\u7684\u4ef7\u503c\u548c\u91cd\u91cf\u3002\u7f16\u5199\u4e00\u4e2a\u52a8\u6001\u89c4\u5212\u51fd\u6570\u6765\u5e2e\u52a9\u4f60\u6700\u5927\u5316\u5229\u6da6\u3002\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\u95ee\u9898\uff1a\u5047\u8bbe\u4f60\u7684\u80cc\u5305\u80fd\u5bb9\u7eb3\u603b\u91cd\u91cf\u4e3a20\u78c5\u7684\u7269\u54c1\u3002\u4f60\u67095\u4ef6\u7269\u54c1\uff0c\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>item     weight      value\n1        2           3\n2        3           4\n3        4           8\n4        5           8\n5        9          10\n</code></pre> </li> <li> <p>\u8fd9\u4e2a\u95ee\u9898\u88ab\u79f0\u4e3a\u5b57\u7b26\u4e32\u7f16\u8f91\u8ddd\u79bb\u95ee\u9898\uff0c\u5e76\u5728\u8bb8\u591a\u7814\u7a76\u9886\u57df\u4e2d\u975e\u5e38\u6709\u7528\u3002 \u5047\u8bbe\u4f60\u8981\u5c06\u5355\u8bcd algorithm \u8f6c\u6362\u4e3a alligator\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u5b57\u6bcd\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u4ee55\u7684\u6210\u672c\u5c06\u5b57\u6bcd\u4ece\u4e00\u4e2a\u5355\u8bcd\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5355\u8bcd\uff0c\u5220\u9664\u4e00\u4e2a\u5b57\u6bcd\u7684\u6210\u672c\u4e3a20\uff0c\u63d2\u5165\u4e00\u4e2a\u5b57\u6bcd\u7684\u6210\u672c\u4e3a20\u3002\u5c06\u4e00\u4e2a\u5355\u8bcd\u8f6c\u6362\u4e3a\u53e6\u4e00\u4e2a\u5355\u8bcd\u7684\u603b\u6210\u672c\u662f\u62fc\u5199\u68c0\u67e5\u7a0b\u5e8f\u7528\u4e8e\u63d0\u4f9b\u7c7b\u4f3c\u5355\u8bcd\u5efa\u8bae\u7684\u4f9d\u636e\u3002\u4f7f\u7528\u52a8\u6001\u89c4\u5212\u6280\u672f\u5f00\u53d1\u4e00\u4e2a\u7b97\u6cd5\uff0c\u4ee5\u83b7\u5f97\u4efb\u4f55\u4e24\u4e2a\u5355\u8bcd\u4e4b\u95f4\u7684\u6700\u5c0f\u7f16\u8f91\u8ddd\u79bb\u3002</p> </li> </ol> <ol> <li>Draw a call stack for the Tower of Hanoi problem. Assume that you start with a stack of three disks.</li> <li>Using the recursive rules as described, draw a Sierpinski triangle using paper and pencil.</li> <li>Using the dynamic programming algorithm for making change, find the smallest number of coins that you can use to make 33 cents in change. In addition to the usual coins assume that you have an 8 cent coin.</li> <li>Write a recursive function to compute the factorial of a number.</li> <li>Write a recursive function to reverse a list.</li> <li> <p>Modify the recursive tree program using one or all of the following ideas:</p> <ul> <li>Modify the thickness of the branches so that as the <code>branch_len</code> gets smaller, the line gets thinner.</li> <li>Modify the color of the branches so that as the <code>branch_len</code> gets very short it is colored like a leaf.</li> <li>Modify the angle used in turning the turtle so that at each branch point the angle is selected at random in some range. For example, choose an angle between 15 and 45 degrees. Play around to see what looks good.</li> <li>Modify the <code>branch_len</code> recursively so that instead of always subtracting the same amount you subtract a random amount in some range.</li> </ul> <p>If you implement all of the above ideas you will have a very realistic looking tree.</p> </li> <li> <p>Find or invent an algorithm for drawing a fractal mountain. Hint: one approach to this uses triangles again</p> </li> <li>Write a recursive function to compute the Fibonacci sequence. How does the performance of the recursive function compare to that of an iterative version?</li> <li>Implement a solution to the Tower of Hanoi using three stacks to keep track of the disks.</li> <li>Using the <code>turtle</code> graphics module, write a recursive program to display a Hilbert curve.</li> <li>Using the <code>turtle</code> graphics module, write a recursive program to display a Koch snowflake.</li> <li>Write a program to solve the following problem. You have two jugs: a 4-gallon jug and a 3-gallon jug. Neither of the jugs have markings on them. There is a pump that can be used to fill the jugs with water. How can you get exactly two gallons of water in the 4-gallon jug?</li> <li>Generalize the problem above so that the parameters to your solution include the sizes of each jug and the final amount of water to be left in the larger jug.</li> <li>Write a program that solves the following problem. Three missionaries and three cannibals come to a river and find a boat that holds two people. Everyone must get across the river to continue on the journey. However, if the cannibals ever outnumber the missionaries on either bank, the missionaries will be eaten. Find a series of crossings that will get everyone safely to the other side of the river.</li> <li>Modify the Tower of Hanoi program using <code>turtle</code> graphics to animate the movement of the disks. Hint: you can make multiple turtles and have them shaped like rectangles.</li> <li> <p>Pascal\u2019s triangle is a number triangle with numbers arranged in staggered rows such that</p> <p>\\(a_{nr} = {n! \\over{r! (n-r)!}}\\)</p> <p>This is the equation for a binomial coefficient. You can build Pascal\u2019s triangle by adding the two numbers that are diagonally above a number in the triangle. An example of Pascal\u2019s triangle is shown below.</p> <pre><code>        1\n    1   1\n    1   2   1\n1   3   3   1\n1   4   6   4   1\n</code></pre> <p>Write a program that prints out Pascal\u2019s triangle. Your program should accept a parameter that tells how many rows of the triangle to print.</p> </li> <li> <p>Suppose you are a computer scientist/art thief who has broken into a major art gallery. All you have with you to haul out your stolen art is your knapsack which only holds \\(W\\) pounds of art, but for every piece of art you know its value and its weight. Write a dynamic programming function to help you maximize your profit. Here is a sample problem for you to get started: suppose your knapsack can hold a total weight of 20 pounds. You have 5 items as follows:</p> <pre><code>item     weight      value\n1        2           3\n2        3           4\n3        4           8\n4        5           8\n5        9          10\n</code></pre> </li> <li> <p>This problem is called the string edit distance problem, and is quite useful in many areas of research. Suppose that you want to transform the word algorithm into the word alligator. For each letter you can either copy the letter from one word to another at a cost of 5, you can delete a letter at cost of 20, or insert a letter at a cost of 20. The total cost to transform one word into another is used by spell-check programs to provide suggestions for words that are close to one another. Use dynamic programming techniques to develop an algorithm that gives you the smallest edit distance between any two words.</p> </li> </ol>"},{"location":"c4/s2/","title":"4.2. \u4ec0\u4e48\u662f\u9012\u5f52\uff1f","text":"<p>4.2. What Is Recursion?</p> \u4e2d\u6587\u82f1\u6587 <p>\u9012\u5f52 \u662f\u4e00\u79cd\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\uff0c\u6d89\u53ca\u5c06\u95ee\u9898\u62c6\u89e3\u6210\u8d8a\u6765\u8d8a\u5c0f\u7684\u5b50\u95ee\u9898\uff0c\u76f4\u5230\u5f97\u5230\u4e00\u4e2a\u8db3\u591f\u5c0f\u7684\u95ee\u9898\uff0c\u4ee5\u4fbf\u53ef\u4ee5\u7b80\u5355\u5730\u89e3\u51b3\u3002\u901a\u5e38\uff0c\u9012\u5f52\u6d89\u53ca\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u81ea\u8eab\u3002\u5c3d\u7ba1\u8868\u9762\u4e0a\u770b\u8d77\u6765\u5e76\u4e0d\u590d\u6742\uff0c\u4f46\u9012\u5f52\u4f7f\u6211\u4eec\u80fd\u591f\u4e3a\u53ef\u80fd\u975e\u5e38\u96be\u4ee5\u7f16\u7a0b\u7684\u95ee\u9898\u7f16\u5199\u4f18\u96c5\u7684\u89e3\u51b3\u65b9\u6848\u3002</p> <p>Recursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself. While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program.</p>"},{"location":"c4/s3/","title":"4.3. \u8ba1\u7b97\u4e00\u4e2a\u6570\u5217\u7684\u548c","text":"<p>4.3. Calculating the Sum of a List of Numbers</p> \u4e2d\u6587\u82f1\u6587 <p>\u6211\u4eec\u5c06\u4ece\u4e00\u4e2a\u7b80\u5355\u7684\u95ee\u9898\u5f00\u59cb\uff0c\u8fd9\u4e2a\u95ee\u9898\u4f60\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u89e3\u51b3\uff0c\u800c\u65e0\u9700\u4f7f\u7528\u9012\u5f52\u3002\u5047\u8bbe\u4f60\u60f3\u8ba1\u7b97\u4e00\u4e2a\u6570\u5b57\u5217\u8868\u7684\u603b\u548c\uff0c\u6bd4\u5982\uff1a[1, 3, 5, 7, 9]\u3002\u4e00\u4e2a\u8ba1\u7b97\u603b\u548c\u7684\u8fed\u4ee3\u51fd\u6570\u5982 <code>ActiveCode 4.3.1</code> \u6240\u793a\u3002\u8fd9\u4e2a\u51fd\u6570\u4f7f\u7528\u4e00\u4e2a\u7d2f\u52a0\u5668\u53d8\u91cf\uff08<code>the_sum</code>\uff09\u6765\u8ba1\u7b97\u5217\u8868\u4e2d\u6240\u6709\u6570\u5b57\u7684\u8fd0\u884c\u603b\u548c\uff0c\u5f00\u59cb\u65f6\u4e3a0\uff0c\u7136\u540e\u5c06\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u6570\u5b57\u76f8\u52a0\u3002</p> Activity: 4.3.1 Iterative Summation<pre><code>def list_sum(num_list):\n    the_sum = 0\n    for i in num_list:\n        the_sum = the_sum + i\n    return the_sum\n\nprint(list_sum([1, 3, 5, 7, 9]))\n</code></pre> <p>\u5047\u8bbe\u4f60\u6ca1\u6709 <code>while</code> \u5faa\u73af\u6216 <code>for</code> \u5faa\u73af\u3002\u4f60\u5c06\u5982\u4f55\u8ba1\u7b97\u4e00\u4e2a\u6570\u5b57\u5217\u8868\u7684\u603b\u548c\uff1f\u5982\u679c\u4f60\u662f\u4e00\u4e2a\u6570\u5b66\u5bb6\uff0c\u4f60\u53ef\u80fd\u4f1a\u4ece\u52a0\u6cd5\u662f\u4e00\u4e2a\u4e3a\u4e24\u4e2a\u53c2\u6570\u5b9a\u4e49\u7684\u51fd\u6570\uff08\u5373\u4e00\u5bf9\u6570\u5b57\uff09\u5f00\u59cb\u3002\u4e3a\u4e86\u5c06\u95ee\u9898\u4ece\u52a0\u6cd5\u5217\u8868\u91cd\u65b0\u5b9a\u4e49\u4e3a\u52a0\u6cd5\u5bf9\u6570\u5b57\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5217\u8868\u91cd\u65b0\u5199\u6210\u4e00\u4e2a\u5b8c\u5168\u62ec\u8d77\u6765\u7684\u8868\u8fbe\u5f0f\u3002\u8fd9\u6837\u7684\u8868\u8fbe\u5f0f\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a</p> <p>\\(((((1 + 3) + 5) + 7) + 9)\\)</p> <p>\u6211\u4eec\u4e5f\u53ef\u4ee5\u5c06\u8868\u8fbe\u5f0f\u4ee5\u53e6\u4e00\u79cd\u65b9\u5f0f\u62ec\u8d77\u6765\uff0c</p> <p>\\((1 + (3 + (5 + (7 + 9))))\\)</p> <p>\u6ce8\u610f\u5230\u6700\u5185\u5c42\u7684\u62ec\u53f7 \\((7 + 9)\\) \u662f\u4e00\u4e2a\u53ef\u4ee5\u5728\u6ca1\u6709\u5faa\u73af\u6216\u4efb\u4f55\u7279\u6b8a\u7ed3\u6784\u7684\u60c5\u51b5\u4e0b\u89e3\u51b3\u7684\u95ee\u9898\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u7b80\u5316\u5e8f\u5217\u6765\u8ba1\u7b97\u6700\u7ec8\u7684\u603b\u548c\u3002</p> <p>\\(\\begin{align}  total &amp;= \\  (1 + (3 + (5 + (7 + 9)))) \\\\ total &amp;= \\  (1 + (3 + (5 + 16))) \\\\ total &amp;= \\  (1 + (3 + 21)) \\\\ total &amp;= \\  (1 + 24) \\\\ total &amp;= \\  25 \\end{align}\\)</p> <p>\u6211\u4eec\u5982\u4f55\u5c06\u8fd9\u4e2a\u60f3\u6cd5\u8f6c\u5316\u4e3aPython\u7a0b\u5e8f\uff1f\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u7528Python\u5217\u8868\u7684\u672f\u8bed\u91cd\u65b0\u8868\u8ff0\u603b\u548c\u95ee\u9898\u3002\u6211\u4eec\u53ef\u4ee5\u8bf4\uff0c\u5217\u8868 <code>num_list</code> \u7684\u603b\u548c\u662f\u5217\u8868\u7b2c\u4e00\u4e2a\u5143\u7d20\uff08<code>num_list[0]</code>\uff09\u548c\u5217\u8868\u5176\u4f59\u90e8\u5206\u7684\u603b\u548c\uff08<code>num_list[1:]</code>\uff09\u3002\u7528\u51fd\u6570\u5f62\u5f0f\u8868\u8ff0\u4e3a\uff1a</p> <p>\\(list\\_sum(num\\_list) = first(num\\_list) + list\\_sum(rest(num\\_list))\\)</p> <p>\u5728\u8fd9\u4e2a\u65b9\u7a0b\u4e2d\uff0c<code>first(num_list)</code> \u8fd4\u56de\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c<code>rest(num_list)</code> \u8fd4\u56de\u9664\u7b2c\u4e00\u4e2a\u5143\u7d20\u5916\u7684\u5217\u8868\u3002\u8fd9\u5728Python\u4e2d\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u8868\u793a\uff0c\u5982 <code>ActiveCode 4.3.2</code> \u6240\u793a\u3002</p> Activity: 4.3.2 Recursive Summation<pre><code>def list_sum(num_list):\n    if len(num_list) == 1:\n        return num_list[0]\n    else:\n        return num_list[0] + list_sum(num_list[1:])\n\nprint(list_sum([1, 3, 5, 7, 9]))\n</code></pre> <p>\u5728\u8fd9\u4e2a\u5217\u8868\u4e2d\uff0c\u6709\u51e0\u4e2a\u5173\u952e\u70b9\u9700\u8981\u6ce8\u610f\u3002\u9996\u5148\uff0c\u5728\u7b2c2\u884c\uff0c\u6211\u4eec\u68c0\u67e5\u5217\u8868\u7684\u957f\u5ea6\u662f\u5426\u4e3a1\u3002\u8fd9\u4e2a\u68c0\u67e5\u81f3\u5173\u91cd\u8981\uff0c\u662f\u6211\u4eec\u4ece\u51fd\u6570\u4e2d\u9003\u9038\u7684\u6761\u4ef6\u3002\u957f\u5ea6\u4e3a1\u7684\u5217\u8868\u7684\u603b\u548c\u5f88\u7b80\u5355\uff1b\u5b83\u53ea\u662f\u5217\u8868\u4e2d\u7684\u90a3\u4e2a\u6570\u5b57\u3002\u5176\u6b21\uff0c\u5728\u7b2c5\u884c\uff0c\u6211\u4eec\u7684\u51fd\u6570\u8c03\u7528\u4e86\u81ea\u5df1\uff01\u8fd9\u5c31\u662f\u6211\u4eec\u79f0 <code>list_sum</code> \u7b97\u6cd5\u4e3a\u9012\u5f52\u7684\u539f\u56e0\u3002\u9012\u5f52\u51fd\u6570\u662f\u8c03\u7528\u81ea\u8eab\u7684\u51fd\u6570\u3002</p> <p><code>Figure 4.1</code> \u663e\u793a\u4e86\u8ba1\u7b97\u5217\u8868 [1, 3, 5, 7, 9] \u6240\u9700\u7684\u4e00\u7cfb\u5217 \u9012\u5f52\u8c03\u7528\u3002\u4f60\u5e94\u8be5\u628a\u8fd9\u4e00\u7cfb\u5217\u8c03\u7528\u770b\u4f5c\u662f\u4e00\u7cfb\u5217\u7b80\u5316\u3002\u6bcf\u6b21\u6211\u4eec\u8fdb\u884c\u9012\u5f52\u8c03\u7528\u65f6\uff0c\u6211\u4eec\u5728\u89e3\u51b3\u4e00\u4e2a\u66f4\u5c0f\u7684\u95ee\u9898\uff0c\u76f4\u5230\u6211\u4eec\u8fbe\u5230\u95ee\u9898\u4e0d\u80fd\u518d\u53d8\u5f97\u66f4\u5c0f\u7684\u70b9\u3002</p> <p> Figure 4.1: \u9012\u5f52\u8c03\u7528\u5e8f\u5217\uff0c\u8ba1\u7b97\u6570\u5b57\u5217\u8868\u7684\u548c </p> <p>\u5f53\u6211\u4eec\u5230\u8fbe\u95ee\u9898\u53d8\u5f97\u5c3d\u53ef\u80fd\u7b80\u5355\u7684\u70b9\u65f6\uff0c\u6211\u4eec\u5f00\u59cb\u5c06\u6bcf\u4e2a\u5c0f\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u62fc\u51d1\u5728\u4e00\u8d77\uff0c\u76f4\u5230\u6700\u521d\u7684\u95ee\u9898\u5f97\u5230\u89e3\u51b3\u3002<code>Figure 4.2</code> \u663e\u793a\u4e86\u5728 <code>list_sum</code> \u51fd\u6570\u901a\u8fc7\u8c03\u7528\u5e8f\u5217\u5411\u540e\u5de5\u4f5c\u65f6\u6267\u884c\u7684\u52a0\u6cd5\u3002\u5f53 <code>list_sum</code> \u4ece\u6700\u4e0a\u5c42\u7684\u95ee\u9898\u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u5f97\u5230\u4e86\u6574\u4e2a\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u3002</p> <p> Figure 4.2: \u9012\u5f52\u8fd4\u56de\u5e8f\u5217\uff0c\u8ba1\u7b97\u6570\u5b57\u5217\u8868\u7684\u548c </p> <p>We will begin our investigation with a simple problem that you already know how to solve without using recursion. Suppose that you want to calculate the sum of a list of numbers such as: \\([1, 3, 5, 7, 9]\\). An iterative function that computes the sum is shown in <code>ActiveCode 4.3.1</code>. The function uses an accumulator variable (<code>the_sum</code>) to compute a running total of all the numbers in the list by starting with \\(0\\) and adding each number in the list.</p> Activity: 4.3.1 Iterative Summation<pre><code>def list_sum(num_list):\n    the_sum = 0\n    for i in num_list:\n        the_sum = the_sum + i\n    return the_sum\n\nprint(list_sum([1, 3, 5, 7, 9]))\n</code></pre> <p>Pretend for a minute that you do not have <code>while</code> loops or <code>for</code> loops. How would you compute the sum of a list of numbers? If you were a mathematician you might start by recalling that addition is a function that is defined for two parameters, a pair of numbers. To redefine the problem from adding a list to adding pairs of numbers, we could rewrite the list as a fully parenthesized expression. Such an expression looks like this: </p> <p>\\(((((1 + 3) + 5) + 7) + 9)\\)</p> <p>We can also parenthesize the expression the other way around,</p> <p>\\((1 + (3 + (5 + (7 + 9))))\\)</p> <p>Notice that the innermost set of parentheses, \\((7 + 9)\\), is a problem that we can solve without a loop or any special constructs. In fact, we can use the following sequence of simplifications to compute a final sum.</p> <p>\\(\\begin{align}  total &amp;= \\  (1 + (3 + (5 + (7 + 9)))) \\\\ total &amp;= \\  (1 + (3 + (5 + 16))) \\\\ total &amp;= \\  (1 + (3 + 21)) \\\\ total &amp;= \\  (1 + 24) \\\\ total &amp;= \\  25 \\end{align}\\)</p> <p>How can we take this idea and turn it into a Python program? First, let\u2019s restate the sum problem in terms of Python lists. We might say the sum of the list <code>num_list</code> is the sum of the first element of the list (<code>num_list[0]</code>) and the sum of the numbers in the rest of the list (<code>num_list[1:]</code>). To state it in a functional form:</p> <p>\\(list\\_sum(num\\_list) = first(num\\_list) + list\\_sum(rest(num\\_list))\\)</p> <p>In this equation \\(irst(num\\_list)\\) returns the first element of the list and \\(rest(num\\_list)\\) returns a list of everything but the first element. This is easily expressed in Python as shown in <code>ActiveCode 4.3.2</code>.</p> Activity: 4.3.2 Recursive Summation<pre><code>    def list_sum(num_list):\n        if len(num_list) == 1:\n            return num_list[0]\n        else:\n            return num_list[0] + list_sum(num_list[1:])\n\n    print(list_sum([1, 3, 5, 7, 9]))\n</code></pre> <p>There are a few key ideas in this listing to look at. First, on line 2 we are checking to see if the list is one element long. This check is crucial and is our escape clause from the function. The sum of a list of length 1 is trivial; it is just the number in the list. Second, on line 5 our function calls itself! This is the reason that we call the <code>list_sum</code> algorithm recursive. A recursive function is a function that calls itself.</p> <p><code>Figure 4.1</code> shows the series of recursive calls that are needed to sum the list \\([1, 3, 5, 7, 9]\\). You should think of this series of calls as a series of simplifications. Each time we make a recursive call we are solving a smaller problem, until we reach the point where the problem cannot get any smaller.</p> <p> Figure 4.1: Series of Recursive Calls Adding a List of Numbers </p> <p>When we reach the point where the problem is as simple as it can get, we begin to piece together the solutions of each of the small problems until the initial problem is solved. <code>Figure 4.2</code> shows the additions that are performed as <code>list_sum</code> works its way backward through the series of calls. When <code>list_sum</code> returns from the topmost problem, we have the solution to the whole problem.</p> <p> Figure 4.2: Series of Recursive Returns from Adding a List of Numbers </p>"},{"location":"c4/s4/","title":"4.4. \u9012\u5f52\u7684\u4e09\u6761\u6cd5\u5219","text":"<p>4.4. The Three Laws of Recursion</p> \u4e2d\u6587\u82f1\u6587 <p>\u50cf\u963f\u897f\u83ab\u592b\u6545\u4e8b\u4e2d\u7684\u673a\u5668\u4eba\u4e00\u6837\uff0c\u6240\u6709\u9012\u5f52\u7b97\u6cd5\u90fd\u5fc5\u987b\u9075\u5faa\u4e09\u4e2a\u91cd\u8981\u7684\u6cd5\u5219\uff1a</p> <ol> <li>\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u6709\u4e00\u4e2a \u57fa\u672c\u60c5\u51b5\u3002</li> <li>\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u6539\u53d8\u5176\u72b6\u6001\u5e76\u671d\u5411\u57fa\u672c\u60c5\u51b5\u524d\u8fdb\u3002</li> <li>\u9012\u5f52\u7b97\u6cd5\u5fc5\u987b\u9012\u5f52\u5730\u8c03\u7528\u81ea\u8eab\u3002</li> </ol> <p>\u8ba9\u6211\u4eec\u8be6\u7ec6\u770b\u770b\u8fd9\u4e9b\u6cd5\u5219\uff0c\u5e76\u4e86\u89e3\u5b83\u4eec\u5728 <code>list_sum</code> \u7b97\u6cd5\u4e2d\u7684\u5e94\u7528\u3002\u9996\u5148\uff0c\u57fa\u672c\u60c5\u51b5\u662f\u5141\u8bb8\u7b97\u6cd5\u505c\u6b62\u9012\u5f52\u7684\u6761\u4ef6\u3002\u57fa\u672c\u60c5\u51b5\u901a\u5e38\u662f\u4e00\u4e2a\u8db3\u591f\u5c0f\u7684\u95ee\u9898\uff0c\u53ef\u4ee5\u76f4\u63a5\u89e3\u51b3\u3002\u5728 <code>list_sum</code> \u7b97\u6cd5\u4e2d\uff0c\u57fa\u672c\u60c5\u51b5\u662f\u957f\u5ea6\u4e3a1\u7684\u5217\u8868\u3002</p> <p>\u4e3a\u4e86\u9075\u5b88\u7b2c\u4e8c\u6761\u6cd5\u5219\uff0c\u6211\u4eec\u5fc5\u987b\u5b89\u6392\u72b6\u6001\u7684\u53d8\u5316\uff0c\u4f7f\u7b97\u6cd5\u671d\u5411\u57fa\u672c\u60c5\u51b5\u524d\u8fdb\u3002\u72b6\u6001\u7684\u53d8\u5316\u610f\u5473\u7740\u7b97\u6cd5\u4f7f\u7528\u7684\u4e00\u4e9b\u6570\u636e\u88ab\u4fee\u6539\u3002\u901a\u5e38\uff0c\u4ee3\u8868\u6211\u4eec\u95ee\u9898\u7684\u6570\u636e\u4f1a\u4ee5\u67d0\u79cd\u65b9\u5f0f\u53d8\u5c0f\u3002\u5728 <code>list_sum</code> \u7b97\u6cd5\u4e2d\uff0c\u6211\u4eec\u7684\u4e3b\u8981\u6570\u636e\u7ed3\u6784\u662f\u4e00\u4e2a\u5217\u8868\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5c06\u72b6\u6001\u53d8\u5316\u7684\u5de5\u4f5c\u96c6\u4e2d\u5728\u5217\u8868\u4e0a\u3002\u7531\u4e8e\u57fa\u672c\u60c5\u51b5\u662f\u957f\u5ea6\u4e3a1\u7684\u5217\u8868\uff0c\u671d\u5411\u57fa\u672c\u60c5\u51b5\u7684\u81ea\u7136\u8fdb\u5c55\u662f\u7f29\u77ed\u5217\u8868\u3002\u8fd9\u6b63\u662f\u5728 <code>ActiveCode 4.3.2</code> \u7684\u7b2c5\u884c\u53d1\u751f\u7684\uff0c\u5f53\u6211\u4eec\u7528\u66f4\u77ed\u7684\u5217\u8868\u8c03\u7528 <code>list_sum</code> \u65f6\u3002</p> <p>\u6700\u540e\u7684\u6cd5\u5219\u662f\u7b97\u6cd5\u5fc5\u987b\u8c03\u7528\u81ea\u8eab\u3002\u8fd9\u6b63\u662f\u9012\u5f52\u7684\u5b9a\u4e49\u3002\u9012\u5f52\u5bf9\u8bb8\u591a\u521d\u5b66\u7a0b\u5e8f\u5458\u6765\u8bf4\u662f\u4e00\u4e2a\u4ee4\u4eba\u56f0\u60d1\u7684\u6982\u5ff5\u3002\u4f5c\u4e3a\u521d\u5b66\u8005\uff0c\u4f60\u5df2\u7ecf\u4e86\u89e3\u5230\u51fd\u6570\u5f88\u597d\uff0c\u56e0\u4e3a\u4f60\u53ef\u4ee5\u5c06\u4e00\u4e2a\u5927\u95ee\u9898\u5206\u89e3\u6210\u66f4\u5c0f\u7684\u95ee\u9898\u3002\u8fd9\u4e9b\u66f4\u5c0f\u7684\u95ee\u9898\u53ef\u4ee5\u901a\u8fc7\u7f16\u5199\u51fd\u6570\u6765\u89e3\u51b3\u3002\u5f53\u6211\u4eec\u8c08\u8bba\u9012\u5f52\u65f6\uff0c\u5b83\u53ef\u80fd\u770b\u8d77\u6765\u50cf\u662f\u5728\u81ea\u6211\u5faa\u73af\u3002\u6211\u4eec\u6709\u4e00\u4e2a\u51fd\u6570\u9700\u8981\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4f46\u90a3\u4e2a\u51fd\u6570\u901a\u8fc7\u8c03\u7528\u81ea\u8eab\u6765\u89e3\u51b3\u95ee\u9898\uff01\u4f46\u903b\u8f91\u6839\u672c\u4e0d\u662f\u5faa\u73af\u7684\uff1b\u9012\u5f52\u7684\u903b\u8f91\u662f\u901a\u8fc7\u5c06\u95ee\u9898\u5206\u89e3\u6210\u66f4\u5c0f\u3001\u66f4\u5bb9\u6613\u89e3\u51b3\u7684\u95ee\u9898\u6765\u4f18\u96c5\u5730\u89e3\u51b3\u95ee\u9898\u3002</p> <p>\u5728\u672c\u7ae0\u7684\u5176\u4f59\u90e8\u5206\uff0c\u6211\u4eec\u5c06\u67e5\u770b\u66f4\u591a\u9012\u5f52\u7684\u4f8b\u5b50\u3002\u5728\u6bcf\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u91cd\u70b9\u8bbe\u8ba1\u4e00\u4e2a\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6848\uff0c\u5e76\u4f7f\u7528\u9012\u5f52\u7684\u4e09\u4e2a\u6cd5\u5219\u3002</p> <p>\u81ea\u6d4b</p> <p>Q-1: \u8ba1\u7b97\u5217\u8868 [2, 4, 6, 8, 10] \u7684\u603b\u548c\u65f6\uff0c\u8fdb\u884c\u4e86\u591a\u5c11\u6b21\u9012\u5f52\u8c03\u7528\uff1f</p> <ul> <li>\u7b54\u6848 a: 6</li> <li>\u7b54\u6848 b: 5</li> <li>\u7b54\u6848 c: 4</li> <li>\u7b54\u6848 d: 3</li> </ul> <p>\u6b63\u786e: c</p> <ul> <li>\u53cd\u9988 a: \u5217\u8868\u4e2d\u53ea\u6709\u4e94\u4e2a\u6570\u5b57\uff0c\u9012\u5f52\u8c03\u7528\u7684\u6b21\u6570\u4e0d\u4f1a\u8d85\u8fc7\u5217\u8868\u7684\u5927\u5c0f\u3002</li> <li>\u53cd\u9988 b: \u521d\u59cb\u8c03\u7528 <code>list_sum</code> \u5e76\u4e0d\u662f\u9012\u5f52\u8c03\u7528\u3002</li> <li>\u53cd\u9988 c: \u7b2c\u4e00\u6b21\u9012\u5f52\u8c03\u7528\u4f20\u9012\u5217\u8868 [4, 6, 8, 10]\uff0c\u7b2c\u4e8c\u6b21 [6, 8, 10]\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u76f4\u5230 [10]\u3002</li> <li>\u53cd\u9988 d: \u8fd9\u4e0d\u4f1a\u8986\u76d6\u5217\u8868\u4e2d\u7684\u6240\u6709\u6570\u5b57\uff0c\u9012\u5f52\u8c03\u7528\u6b21\u6570\u4e0d\u8db3\u3002</li> </ul> <p>Q-2: \u5047\u8bbe\u4f60\u8981\u7f16\u5199\u4e00\u4e2a\u9012\u5f52\u51fd\u6570\u6765\u8ba1\u7b97\u4e00\u4e2a\u6570\u5b57\u7684\u9636\u4e58\u3002<code>fact(n)</code> \u8fd4\u56de n * (n-1) * (n-2) * ... \u5176\u4e2d\u96f6\u7684\u9636\u4e58\u5b9a\u4e49\u4e3a1\u3002\u6700\u5408\u9002\u7684\u57fa\u672c\u60c5\u51b5\u662f\u4ec0\u4e48\uff1f</p> <ul> <li>\u7b54\u6848 a: n == 0</li> <li>\u7b54\u6848 b: n == 1</li> <li>\u7b54\u6848 c: n &gt;= 0</li> <li>\u7b54\u6848 d: n &lt;= 1</li> </ul> <p>\u6b63\u786e: d</p> <ul> <li>\u53cd\u9988 a: \u867d\u7136\u8fd9\u4e5f\u53ef\u4ee5\u5de5\u4f5c\uff0c\u4f46\u6709\u66f4\u597d\u7684\u3001\u7a0d\u5fae\u66f4\u9ad8\u6548\u7684\u9009\u62e9\uff0c\u56e0\u4e3a fact(1) \u548c fact(0) \u662f\u76f8\u540c\u7684\u3002</li> <li>\u53cd\u9988 b: \u4e00\u4e2a\u597d\u7684\u9009\u62e9\uff0c\u4f46\u5982\u679c\u4f60\u8c03\u7528 fact(0) \u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</li> <li>\u53cd\u9988 c: \u8fd9\u4e2a\u57fa\u672c\u60c5\u51b5\u9002\u7528\u4e8e\u6240\u6709\u5927\u4e8e\u96f6\u7684\u6570\u5b57\uff0c\u56e0\u6b64\u4efb\u4f55\u6b63\u6570\u7684\u9636\u4e58\u90fd\u4f1a\u662f1\u3002</li> <li>\u53cd\u9988 d: \u5f88\u597d\uff0c\u8fd9\u662f\u6700\u6709\u6548\u7684\uff0c\u5e76\u4e14\u5373\u4f7f\u4f60\u5c1d\u8bd5\u8ba1\u7b97\u8d1f\u6570\u7684\u9636\u4e58\u4e5f\u80fd\u9632\u6b62\u7a0b\u5e8f\u5d29\u6e83\u3002</li> </ul> <p>Like robots in Asimov's stories, all recursive algorithms must obey three important laws:</p> <ol> <li>A recursive algorithm must have a base case.</li> <li>A recursive algorithm must change its state and move toward the base case.</li> <li>A recursive algorithm must call itself recursively.</li> </ol> <p>Let\u2019s look at each one of these laws in more detail and see how it was used in the <code>list_sum</code> algorithm. First, a base case is the condition that allows the algorithm to stop recursing. A base case is typically a problem that is small enough to solve directly. In the <code>list_sum</code> algorithm the base case is a list of length 1.</p> <p>To obey the second law, we must arrange for a change of state that moves the algorithm toward the base case. A change of state means that some data that the algorithm is using is modified. Usually the data that represents our problem gets smaller in some way. In the <code>list_sum</code> algorithm our primary data structure is a list, so we must focus our state-changing efforts on the list. Since the base case is a list of length 1, a natural progression toward the base case is to shorten the list. This is exactly what happens on line 5 of <code>ActiveCode 4.3.2</code> when we call <code>list_sum</code> with a shorter list.</p> <p>The final law is that the algorithm must call itself. This is the very definition of recursion. Recursion is a confusing concept to many beginning programmers. As a novice programmer, you have learned that functions are good because you can take a large problem and break it up into smaller problems. The smaller problems can be solved by writing a function to solve each problem. When we talk about recursion it may seem that we are talking ourselves in circles. We have a problem to solve with a function, but that function solves the problem by calling itself! But the logic is not circular at all; the logic of recursion is an elegant expression of solving a problem by breaking it down into a smaller and easier problems.</p> <p>In the remainder of this chapter we will look at more examples of recursion. In each case we will focus on designing a solution to a problem by using the three laws of recursion.</p> <p>Self Check</p> <p>Q-1: How many recursive calls are made when computing the sum of the list [2, 4, 6, 8, 10]?</p> <ul> <li>answer a: 6</li> <li>answer b: 5</li> <li>answer c: 4</li> <li>answer d: 3</li> </ul> <p>correct: c</p> <ul> <li>feedback a: There are only five numbers on the list, the number of recursive calls will not be greater than the size of the list.</li> <li>feedback b: The initial call to list_sum is not a recursive call.</li> <li>feedback c: the first recursive call passes the list [4, 6, 8, 10], the second [6, 8, 10] and so on until [10].</li> <li>feedback d: This would not be enough calls to cover all the numbers on the list</li> </ul> <p>Q-2: Suppose you are going to write a recusive function to calculate the factorial of a number.  fact(n) returns n * n-1 * n-2 * ... Where the factorial of zero is defined to be 1.  What would be the most appropriate base case?</p> <ul> <li>answer a: n == 0</li> <li>answer b: n == 1</li> <li>answer c: n &gt;= 0</li> <li>answer d: n &lt;= 1</li> </ul> <p>correct: d</p> <ul> <li>feedback a:  Although this would work there are better and slightly more efficient choices. since fact(1) and fact(0) are the same.</li> <li>feedback b: A good choice, but what happens if you call fact(0)?</li> <li>feedback c: This basecase would be true for all numbers greater than zero so fact of any positive number would be 1.</li> <li>feedback d: Good, this is the most efficient, and even keeps your program from crashing if you try to compute the factorial of a negative number.</li> </ul>"},{"location":"c4/s5/","title":"4.5. \u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u4efb\u610f\u8fdb\u5236\u7684\u5b57\u7b26\u4e32","text":"<p>4.5. Converting an Integer to a String in Any Base</p> \u4e2d\u6587\u82f1\u6587 <p>\u5047\u8bbe\u4f60\u60f3\u5c06\u4e00\u4e2a\u6574\u6570\u8f6c\u6362\u4e3a\u67d0\u4e2a\u4ecb\u4e8e\u4e8c\u8fdb\u5236\u548c\u5341\u516d\u8fdb\u5236\u4e4b\u95f4\u7684\u5b57\u7b26\u4e32\u3002\u4f8b\u5982\uff0c\u5c06\u6574\u6570 10 \u8f6c\u6362\u4e3a\u5176\u5341\u8fdb\u5236\u5b57\u7b26\u4e32\u8868\u793a\u4e3a <code>\"10\"</code>\uff0c\u6216\u5c06\u5176\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u8868\u793a\u4e3a <code>\"1010\"</code>\u3002\u867d\u7136\u6709\u8bb8\u591a\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5305\u62ec\u5728\u5806\u6808\u90e8\u5206\u8ba8\u8bba\u7684\u7b97\u6cd5\uff0c\u4f46\u95ee\u9898\u7684\u9012\u5f52\u8868\u8ff0\u975e\u5e38\u4f18\u96c5\u3002</p> <p>\u8ba9\u6211\u4eec\u770b\u4e00\u4e2a\u5177\u4f53\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528\u57fa\u6570 10 \u548c\u6570\u5b57 769\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u5b57\u7b26\u5e8f\u5217\u5bf9\u5e94\u4e8e\u524d 10 \u4e2a\u6570\u5b57\uff0c\u4f8b\u5982 <code>convert_string = \"0123456789\"</code>\u3002\u901a\u8fc7\u67e5\u627e\u5e8f\u5217\uff0c\u8f6c\u6362\u4e00\u4e2a\u5c0f\u4e8e 10 \u7684\u6570\u5b57\u4e3a\u5176\u5b57\u7b26\u4e32\u7b49\u4ef7\u7269\u662f\u5f88\u7b80\u5355\u7684\u3002\u4f8b\u5982\uff0c\u5982\u679c\u6570\u5b57\u662f 9\uff0c\u90a3\u4e48\u5b57\u7b26\u4e32\u662f <code>convert_string[9]</code> \u6216 <code>\"9\"</code>\u3002\u5982\u679c\u6211\u4eec\u80fd\u591f\u5c06\u6570\u5b57 769 \u62c6\u5206\u6210\u4e09\u4e2a\u5355\u6570\u5b57\u7684\u6570\u5b57 7\u30016 \u548c 9\uff0c\u90a3\u4e48\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u5c31\u5f88\u7b80\u5355\u4e86\u3002\u5c0f\u4e8e 10 \u7684\u6570\u5b57\u542c\u8d77\u6765\u50cf\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u57fa\u672c\u60c5\u51b5\u3002</p> <p>\u77e5\u9053\u4e86\u6211\u4eec\u7684\u57fa\u6570\uff0c\u610f\u5473\u7740\u6574\u4f53\u7b97\u6cd5\u5c06\u5305\u542b\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u5c06\u539f\u59cb\u6570\u5b57\u7f29\u51cf\u4e3a\u4e00\u7cfb\u5217\u5355\u6570\u5b57\u3002</li> <li>\u4f7f\u7528\u67e5\u627e\u5c06\u5355\u6570\u5b57\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002</li> <li>\u5c06\u5355\u6570\u5b57\u5b57\u7b26\u4e32\u8fde\u63a5\u5728\u4e00\u8d77\u5f62\u6210\u6700\u7ec8\u7ed3\u679c\u3002</li> </ol> <p>\u4e0b\u4e00\u6b65\u662f\u5f04\u6e05\u695a\u5982\u4f55\u6539\u53d8\u72b6\u6001\u5e76\u5411\u57fa\u672c\u60c5\u51b5\u8fc8\u8fdb\u3002\u7531\u4e8e\u6211\u4eec\u6b63\u5728\u5904\u7406\u6574\u6570\uff0c\u8003\u8651\u4e00\u4e0b\u54ea\u4e9b\u6570\u5b66\u64cd\u4f5c\u53ef\u80fd\u4f1a\u7f29\u51cf\u4e00\u4e2a\u6570\u5b57\u3002\u6700\u53ef\u80fd\u7684\u5019\u9009\u662f\u9664\u6cd5\u548c\u51cf\u6cd5\u3002\u867d\u7136\u51cf\u6cd5\u53ef\u80fd\u6709\u6548\uff0c\u4f46\u4e0d\u6e05\u695a\u6211\u4eec\u5e94\u8be5\u4ece\u4ec0\u4e48\u4e2d\u51cf\u53bb\u3002\u6574\u6570\u9664\u6cd5\u5e26\u4f59\u6570\u7ed9\u4e86\u6211\u4eec\u660e\u786e\u7684\u65b9\u5411\u3002\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u679c\u5c06\u4e00\u4e2a\u6570\u5b57\u9664\u4ee5\u6211\u4eec\u8bd5\u56fe\u8f6c\u6362\u5230\u7684\u57fa\u6570\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002</p> <p>\u4f7f\u7528\u6574\u6570\u9664\u6cd5\u5c06 769 \u9664\u4ee5 10\uff0c\u6211\u4eec\u5f97\u5230 76 \u4f59 9\u3002\u8fd9\u7ed9\u4e86\u6211\u4eec\u4e24\u4e2a\u597d\u7684\u7ed3\u679c\u3002\u9996\u5148\uff0c\u4f59\u6570\u662f\u4e00\u4e2a\u5c0f\u4e8e\u57fa\u6570\u7684\u6570\u5b57\uff0c\u53ef\u4ee5\u901a\u8fc7\u67e5\u627e\u7acb\u5373\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002\u7b2c\u4e8c\uff0c\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u6bd4\u539f\u59cb\u6570\u5b57\u5c0f\u7684\u6570\u5b57\uff0c\u5e76\u5c06\u6211\u4eec\u671d\u5411\u57fa\u6570\u7684\u57fa\u672c\u60c5\u51b5\uff0c\u5373\u5c0f\u4e8e\u57fa\u6570\u7684\u5355\u4e2a\u6570\u5b57\u3002\u73b0\u5728\u6211\u4eec\u7684\u4efb\u52a1\u662f\u5c06 76 \u8f6c\u6362\u4e3a\u5176\u5b57\u7b26\u4e32\u8868\u793a\u3002\u6211\u4eec\u518d\u6b21\u4f7f\u7528\u6574\u6570\u9664\u6cd5\u52a0\u4f59\u6570\uff0c\u5206\u522b\u5f97\u5230 7 \u548c 6\u3002\u6700\u540e\uff0c\u6211\u4eec\u5c06\u95ee\u9898\u7f29\u51cf\u4e3a\u8f6c\u6362 7\uff0c\u8fd9\u5f88\u5bb9\u6613\uff0c\u56e0\u4e3a\u5b83\u6ee1\u8db3\u57fa\u672c\u60c5\u51b5\u6761\u4ef6 \\(n &lt; base\\)\uff0c\u5176\u4e2d \\(base = 10\\)\u3002\u6211\u4eec\u521a\u521a\u6267\u884c\u7684\u64cd\u4f5c\u5e8f\u5217\u5982 <code>Figure 4.3</code> \u6240\u793a\u3002\u6ce8\u610f\u6211\u4eec\u8981\u8bb0\u4f4f\u7684\u6570\u5b57\u5728\u56fe\u53f3\u4fa7\u7684\u4f59\u6570\u6846\u4e2d\u3002</p> <p> Figure 4.3: \u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u57fa\u6570 10 \u7684\u5b57\u7b26\u4e32 </p> <p><code>ActiveCode 4.5.1</code> \u663e\u793a\u4e86\u5b9e\u73b0\u4e0a\u8ff0\u7b97\u6cd5\u7684 Python \u4ee3\u7801\uff0c\u9002\u7528\u4e8e\u57fa\u6570 2 \u5230 16 \u4e4b\u95f4\u7684\u4efb\u4f55\u57fa\u6570\u3002</p> Activity: 4.5.1 \u9012\u5f52\u5730\u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32<pre><code>def to_str(n, base):\n    convert_string = \"0123456789ABCDEF\"\n    if n &lt; base:\n        return convert_string[n]\n    else:\n        return to_str(n // base, base) + convert_string[n % base]\n\nprint(to_str(1453, 16))\n</code></pre> <p>\u6ce8\u610f\u5728\u7b2c 3 \u884c\u6211\u4eec\u68c0\u67e5\u57fa\u672c\u60c5\u51b5\uff0c\u5373 <code>n</code> \u5c0f\u4e8e\u6211\u4eec\u8981\u8f6c\u6362\u5230\u7684\u57fa\u6570\u3002\u5f53\u6211\u4eec\u68c0\u6d4b\u5230\u57fa\u672c\u60c5\u51b5\u65f6\uff0c\u6211\u4eec\u505c\u6b62\u9012\u5f52\uff0c\u76f4\u63a5\u4ece <code>convert_string</code> \u5e8f\u5217\u4e2d\u8fd4\u56de\u5b57\u7b26\u4e32\u3002\u5728\u7b2c 6 \u884c\uff0c\u6211\u4eec\u901a\u8fc7\u9012\u5f52\u8c03\u7528\u548c\u4f7f\u7528\u9664\u6cd5\u6765\u6ee1\u8db3\u7b2c\u4e8c\u548c\u7b2c\u4e09\u6cd5\u5219\u3002</p> <p>\u8ba9\u6211\u4eec\u518d\u6b21\u8ddf\u8e2a <code>ActiveCode 4.5.1</code> \u4e2d\u7684\u7b97\u6cd5\uff1b\u8fd9\u6b21\u6211\u4eec\u5c06\u6570\u5b57 10 \u8f6c\u6362\u4e3a\u57fa\u6570 2 \u7684\u5b57\u7b26\u4e32\u8868\u793a\uff08<code>\"1010\"</code>\uff09\u3002</p> <p> Figure 4.4: \u5c06\u6570\u5b57 10 \u8f6c\u6362\u4e3a\u57fa\u6570 2 \u7684\u5b57\u7b26\u4e32\u8868\u793a </p> <p><code>Figure 4.4</code> \u663e\u793a\u6211\u4eec\u5f97\u5230\u4e86\u6240\u9700\u7684\u7ed3\u679c\uff0c\u4f46\u770b\u8d77\u6765\u6570\u5b57\u7684\u987a\u5e8f\u662f\u9519\u8bef\u7684\u3002\u7b97\u6cd5\u662f\u6b63\u786e\u7684\uff0c\u56e0\u4e3a\u6211\u4eec\u9996\u5148\u5728\u7b2c 6 \u884c\u8fdb\u884c\u9012\u5f52\u8c03\u7528\uff0c\u7136\u540e\u5c06\u4f59\u6570\u7684\u5b57\u7b26\u4e32\u8868\u793a\u52a0\u5230\u7ed3\u679c\u4e2d\u3002\u5982\u679c\u6211\u4eec\u5c06\u8fd4\u56de <code>convert_string</code> \u67e5\u627e\u548c\u8fd4\u56de <code>to_str</code> \u8c03\u7528\u7684\u987a\u5e8f\u53cd\u8f6c\uff0c\u90a3\u4e48\u5f97\u5230\u7684\u5b57\u7b26\u4e32\u5c06\u662f\u5012\u7f6e\u7684\uff01\u4f46\u901a\u8fc7\u5c06\u8fde\u63a5\u64cd\u4f5c\u5ef6\u8fdf\u5230\u9012\u5f52\u8c03\u7528\u8fd4\u56de\u4e4b\u540e\uff0c\u6211\u4eec\u5f97\u5230\u4e86\u6b63\u786e\u987a\u5e8f\u7684\u7ed3\u679c\u3002\u8fd9\u5e94\u8be5\u8ba9\u4f60\u60f3\u8d77\u6211\u4eec\u5728\u524d\u4e00\u7ae0\u8ba8\u8bba\u7684\u5806\u6808\u3002</p> <p>\u81ea\u6d4b</p> <p>\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u65b0\u5b57\u7b26\u4e32\uff0c\u8be5\u5b57\u7b26\u4e32\u662f\u65e7\u5b57\u7b26\u4e32\u7684\u53cd\u8f6c\u3002</p> recursion_sc_1<pre><code>from test import testEqual\n\n\ndef reverse(s):\n    return s\n\ntestEqual(reverse(\"hello\"), \"olleh\")\ntestEqual(reverse(\"l\"), \"l\")      \ntestEqual(reverse(\"follow\"), \"wollof\")\ntestEqual(reverse(\"\"), \"\")\n</code></pre> <p>\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u8fd4\u56de <code>True</code> \u5982\u679c\u5b57\u7b26\u4e32\u662f\u56de\u6587\uff0c<code>False</code> \u5982\u679c\u4e0d\u662f\u3002\u8bb0\u4f4f\uff0c\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\u56de\u6587\uff0c\u5982\u679c\u5b83\u6b63\u5411\u548c\u53cd\u5411\u62fc\u5199\u90fd\u662f\u4e00\u6837\u7684\u3002\u4f8b\u5982\uff1aradar \u662f\u4e00\u4e2a\u56de\u6587\u3002\u4f5c\u4e3a\u9644\u52a0\u5206\uff0c\u56de\u6587\u4e5f\u53ef\u4ee5\u662f\u77ed\u8bed\uff0c\u4f46\u4f60\u9700\u8981\u5728\u68c0\u67e5\u4e4b\u524d\u53bb\u9664\u7a7a\u683c\u548c\u6807\u70b9\u7b26\u53f7\u3002\u4f8b\u5982\uff1amadam i'm adam \u662f\u4e00\u4e2a\u56de\u6587\u3002\u5176\u4ed6\u6709\u8da3\u7684\u56de\u6587\u5305\u62ec\uff1a</p> <ul> <li>kayak</li> <li>aibohphobia</li> <li>Live not on evil</li> <li>Reviled did I live, said I, as evil I did deliver</li> <li>Go hang a salami; I'm a lasagna hog.</li> <li>Able was I ere I saw Elba</li> <li>Kanakanak -- \u963f\u62c9\u65af\u52a0\u7684\u4e00\u4e2a\u57ce\u9547</li> <li>Wassamassaw -- \u5357\u8fbe\u79d1\u4ed6\u5dde\u7684\u4e00\u4e2a\u57ce\u9547</li> </ul> recursion_sc_2<pre><code>from test import testEqual\n\n\ndef remove_white(s):\n    return s\n\ndef is_pal(s):\n    return False\n\ntestEqual(is_pal(remove_white(\"x\")), True)            \ntestEqual(is_pal(remove_white(\"radar\")), True)\ntestEqual(is_pal(remove_white(\"hello\")), False)\ntestEqual(is_pal(remove_white(\"\")), True)                  \ntestEqual(is_pal(remove_white(\"hannah\")), True)      \ntestEqual(is_pal(remove_white(\"madam i'm adam\")), True)\n</code></pre> <p>Suppose you want to convert an integer to a string in some base between binary and hexadecimal. For example, convert the integer 10 to its string representation in decimal as <code>\"10\"</code>, or to its string representation in binary as <code>\"1010\"</code>. While there are many algorithms to solve this problem, including the algorithm discussed in the stack section, the recursive formulation of the problem is very elegant.</p> <p>Let\u2019s look at a concrete example using base 10 and the number 769. Suppose we have a sequence of characters corresponding to the first 10 digits, like <code>convert_string = \"0123456789\"</code>. It is easy to convert a number less than 10 to its string equivalent by looking it up in the sequence. For example, if the number is 9, then the string is <code>convert_string[9]</code> or <code>\"9\"</code>. If we can arrange to break up the number 769 into three single-digit numbers, 7, 6, and 9, then converting it to a string is simple. A number less than 10 sounds like a good base case.</p> <p>Knowing what our base is suggests that the overall algorithm will involve three components:</p> <ol> <li>Reduce the original number to a series of single-digit numbers.</li> <li>Convert the single digit-number to a string using a lookup.</li> <li>Concatenate the single-digit strings together to form the final result.</li> </ol> <p>The next step is to figure out how to change state and make progress toward the base case. Since we are working with an integer, let\u2019s consider what mathematical operations might reduce a number. The most likely candidates are division and subtraction. While subtraction might work, it is unclear what we should subtract from what. Integer division with remainders gives us a clear direction. Let\u2019s look at what happens if we divide a number by the base we are trying to convert to.</p> <p>Using integer division to divide 769 by 10, we get 76 with a remainder of 9. This gives us two good results. First, the remainder is a number less than our base that can be converted to a string immediately by lookup. Second, we get a number that is smaller than our original and moves us toward the base case of having a single number less than our base. Now our job is to convert 76 to its string representation. Again we will use integer division plus remainder to get results of 7 and 6 respectively. Finally, we have reduced the problem to converting 7, which we can do easily since it satisfies the base case condition of \\(n &lt; base\\), where \\(base = 10\\). The series of operations we have just performed is illustrated in <code>Figure 4.3</code>. Notice that the numbers we want to remember are in the remainder boxes along the right side of the diagram.</p> <p> Figure 4.3: Converting an Integer to a String in Base 10 </p> <p><code>ActiveCode 4.5.1</code> shows the Python code that implements the algorithm outlined above for any base between 2 and 16.</p> Activity: 4.5.1 Recursively Converting from Integer to String<pre><code>def to_str(n, base):\n    convert_string = \"0123456789ABCDEF\"\n    if n &lt; base:\n        return convert_string[n]\n    else:\n        return to_str(n // base, base) + convert_string[n % base]\n\nprint(to_str(1453, 16))\n</code></pre> <p>Notice that in line 3 we check for the base case where <code>n</code> is less than the base we are converting to. When we detect the base case, we stop recursing and simply return the string from the <code>convert_string</code> sequence. In line 6 we satisfy both the second and third laws\u2013by making the recursive call and by reducing the problem size\u2013using division.</p> <p>Let\u2019s trace the algorithm shown in <code>ActiveCode 4.5.1</code> again; this time we will convert the number 10 to its base 2 string representation (<code>\"1010\"</code>).</p> <p> Figure 4.4: Converting the Number 10 to its Base 2 String Representation </p> <p><code>Figure 4.4</code> shows that we get the results we are looking for, but it looks like the digits are in the wrong order. The algorithm works correctly because we make the recursive call first on line 6, then we add the string representation of the remainder. If we reversed returning the <code>convert_string</code> lookup and returning the <code>to_str</code> call, the resulting string would be backward! But by delaying the concatenation operation until after the recursive call has returned, we get the result in the proper order. This should remind you of our discussion of stacks back in the previous chapter.</p> <p>Self Check</p> <p>Write a function that takes a string as a parameter and returns a new string that is the reverse of the old string.</p> recursion_sc_1<pre><code>from test import testEqual\n\n\ndef reverse(s):\n    return s\n\ntestEqual(reverse(\"hello\"), \"olleh\")\ntestEqual(reverse(\"l\"), \"l\")      \ntestEqual(reverse(\"follow\"), \"wollof\")\ntestEqual(reverse(\"\"), \"\")\n</code></pre> <p>Write a function that takes a string as a parameter and returns <code>True</code> if the string is a palindrome, <code>False</code> otherwise.  Remember that a string is a palindrome if it is spelled the same both forward and backward.  For example:  radar is a palindrome.  For bonus points palindromes can also be phrases, but you need to remove the spaces and punctuation before checking.  For example:  madam i'm adam  is a palindrome.  Other fun palindromes include:</p> <ul> <li>kayak</li> <li>aibohphobia</li> <li>Live not on evil</li> <li>Reviled did I live, said I, as evil I did deliver</li> <li>Go hang a salami; I'm a lasagna hog.</li> <li>Able was I ere I saw Elba</li> <li>Kanakanak -- a town in Alaska</li> <li>Wassamassaw -- a town in South Dakota</li> </ul> recursion_sc_2<pre><code>from test import testEqual\n\n\ndef remove_white(s):\n    return s\n\ndef is_pal(s):\n    return False\n\ntestEqual(is_pal(remove_white(\"x\")), True)            \ntestEqual(is_pal(remove_white(\"radar\")), True)\ntestEqual(is_pal(remove_white(\"hello\")), False)\ntestEqual(is_pal(removeWremove_whitehite(\"\")), True)                  \ntestEqual(is_pal(remove_white(\"hannah\")), True)      \ntestEqual(is_pal(remove_white(\"madam i'm adam\")), True)\n</code></pre>"},{"location":"c4/s6/","title":"4.6. \u6808\u5e27\uff1a\u5b9e\u73b0\u9012\u5f52","text":"<p>4.6. Stack Frames: Implementing Recursion</p> \u4e2d\u6587\u82f1\u6587 <p>\u5047\u8bbe\u6211\u4eec\u4e0d\u662f\u5c06\u9012\u5f52\u8c03\u7528 <code>to_str</code> \u7684\u7ed3\u679c\u4e0e <code>convert_string</code> \u4e2d\u7684\u5b57\u7b26\u4e32\u8fde\u63a5\u8d77\u6765\uff0c\u800c\u662f\u4fee\u6539\u7b97\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u63a8\u9001\u5230\u6808\u4e0a\uff0c\u800c\u4e0d\u662f\u8fdb\u884c\u9012\u5f52\u8c03\u7528\u3002\u8fd9\u4e2a\u4fee\u6539\u540e\u7684\u7b97\u6cd5\u7684\u4ee3\u7801\u89c1 <code>ActiveCode 4.6.1</code>\u3002</p> Activity: 4.6.1 \u4f7f\u7528\u6808\u5c06\u6574\u6570\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32<pre><code>from pythonds3.basic import Stack\n\ndef to_str(n, base):\n    r_stack = Stack()\n    convert_string = \"0123456789ABCDEF\"\n    while n &gt; 0:\n        if n &lt; base:\n            r_stack.push(convert_string[n])\n        else:\n            r_stack.push(convert_string[n % base])\n        n = n // base\n    res = \"\"\n    while not r_stack.is_empty():\n        res = res + str(r_stack.pop())\n    return res\n\nprint(to_str(1453, 16))\n</code></pre> <p>\u6bcf\u6b21\u6211\u4eec\u8c03\u7528 <code>to_str</code> \u65f6\uff0c\u6211\u4eec\u90fd\u4f1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u63a8\u5165\u6808\u4e2d\u3002\u8fd4\u56de\u5230\u4e4b\u524d\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u5728\u7b2c\u56db\u6b21\u8c03\u7528 <code>to_str</code> \u540e\uff0c\u6808\u7684\u72b6\u6001\u5982 <code>Figure 4.5</code> \u6240\u793a\u3002\u6ce8\u610f\uff0c\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u4ece\u6808\u4e2d\u5f39\u51fa\u5b57\u7b26\uff0c\u5e76\u5c06\u5b83\u4eec\u8fde\u63a5\u6210\u6700\u7ec8\u7ed3\u679c <code>\"1010\"</code>\u3002</p> <p> Figure 4.5: \u8f6c\u6362\u8fc7\u7a0b\u4e2d\u653e\u7f6e\u5728\u6808\u4e0a\u7684\u5b57\u7b26\u4e32 </p> <p>\u524d\u9762\u7684\u4f8b\u5b50\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e9b\u5173\u4e8e Python \u5982\u4f55\u5b9e\u73b0\u9012\u5f52\u51fd\u6570\u8c03\u7528\u7684\u89c1\u89e3\u3002\u5f53\u5728 Python \u4e2d\u8c03\u7528\u4e00\u4e2a\u51fd\u6570\u65f6\uff0c\u4f1a\u4e3a\u5904\u7406\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u5206\u914d\u4e00\u4e2a \u6808\u5e27\u3002\u5f53\u51fd\u6570\u8fd4\u56de\u65f6\uff0c\u8fd4\u56de\u503c\u4f1a\u4fdd\u7559\u5728\u6808\u9876\uff0c\u4ee5\u4f9b\u8c03\u7528\u51fd\u6570\u8bbf\u95ee\u3002<code>Figure 4.6</code> \u5c55\u793a\u4e86\u7b2c 4 \u884c\u8fd4\u56de\u8bed\u53e5\u540e\u7684\u8c03\u7528\u6808\u3002</p> <p> Figure 4.6: <code>to_str(10, 2)</code> \u751f\u6210\u7684\u8c03\u7528\u6808 </p> <p>\u6ce8\u610f\uff0c\u8c03\u7528 <code>to_str(2 // 2, 2)</code>\uff08\u89c1 Listing 4.4\uff09\u4f1a\u5728\u6808\u4e0a\u7559\u4e0b\u8fd4\u56de\u503c <code>\"1\"</code>\u3002\u7136\u540e\uff0c\u8fd9\u4e2a\u8fd4\u56de\u503c\u4f1a\u5728\u8868\u8fbe\u5f0f <code>\"1\" + convert_string[2 % 2]</code> \u4e2d\u66ff\u4ee3\u51fd\u6570\u8c03\u7528\uff08<code>to_str(1, 2)</code>\uff09\uff0c\u8fd9\u5c06\u628a\u5b57\u7b26\u4e32 <code>\"10\"</code> \u7559\u5728\u6808\u9876\u3002\u8fd9\u6837\uff0cPython \u7684\u8c03\u7528\u6808\u5c31\u53d6\u4ee3\u4e86\u6211\u4eec\u5728 <code>ActiveCode 4.6.1</code> \u4e2d\u663e\u5f0f\u4f7f\u7528\u7684\u6808\u3002\u5728\u6211\u4eec\u7684\u5217\u8868\u6c42\u548c\u793a\u4f8b\u4e2d\uff0c\u4f60\u53ef\u4ee5\u628a\u6808\u4e0a\u7684\u8fd4\u56de\u503c\u770b\u4f5c\u662f\u7d2f\u52a0\u5668\u53d8\u91cf\u3002</p> <p>\u6808\u5e27\u8fd8\u4e3a\u51fd\u6570\u4f7f\u7528\u7684\u53d8\u91cf\u63d0\u4f9b\u4e86\u4f5c\u7528\u57df\u3002\u5373\u4f7f\u6211\u4eec\u4e00\u904d\u904d\u5730\u8c03\u7528\u76f8\u540c\u7684\u51fd\u6570\uff0c\u6bcf\u6b21\u8c03\u7528\u90fd\u4f1a\u4e3a\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u4f5c\u7528\u57df\u3002</p> <p>Suppose that instead of concatenating the result of the recursive call to <code>to_str</code> with the string from <code>convert_string</code>, we modified our algorithm to push the strings onto a stack instead of making the recursive call. The code for this modified algorithm is shown in <code>ActiveCode 4.6.1</code>.</p> Activity: 4.6.1 Converting an Integer to a String Using a Stack<pre><code>from pythonds3.basic import Stack\n\n\ndef to_str(n, base):\n    r_stack = Stack()\n    convert_string = \"0123456789ABCDEF\"\n    while n &gt; 0:\n        if n &lt; base:\n            r_stack.push(convert_string[n])\n        else:\n            r_stack.push(convert_string[n % base])\n        n = n // base\n    res = \"\"\n    while not r_stack.is_empty():\n        res = res + str(r_stack.pop())\n    return res\n\n\nprint(to_str(1453, 16))\n</code></pre> <p>Each time we make a call to <code>to_str</code>, we push a character on the stack. Returning to the previous example we can see that after the fourth call to <code>to_str</code> the stack would look like <code>Figure 4.5</code>. Notice that now we can simply pop the characters off the stack and concatenate them into the final result, <code>\"1010\"</code>.</p> <p> Figure 4.5: Strings Placed on the Stack During Conversion </p> <p>The previous example gives us some insight into how Python implements a recursive function call. When a function is called in Python, a stack frame is allocated to handle the local variables of the function. When the function returns, the return value is left on top of the stack for the calling function to access. <code>Figure 4.6</code> illustrates the call stack after the return statement on line 4.</p> <p> Figure 4.6: Call Stack Generated from <code>to_str(10, 2)</code> </p> <p>Notice that the call to <code>to_str(2 // 2, 2)</code> defined in Listing 4.4 leaves a return value of <code>\"1\"</code> on the stack. This return value is then used in place of the function call (<code>to_str(1, 2)</code>) in the expression <code>\"1\" + convert_string[2 % 2]</code>, which will leave the string <code>\"10\"</code> on the top of the stack. In this way, the Python call stack takes the place of the stack we used explicitly in <code>ActiveCode 4.6.1</code>. In our list summing example, you can think of the return value on the stack taking the place of an accumulator variable.</p> <p>The stack frames also provide a scope for the variables used by the function. Even though we are calling the same function over and over, each call creates a new scope for the variables that are local to the function.</p>"},{"location":"c4/s7/","title":"4.7. \u9012\u5f52\u7684\u53ef\u89c6\u5316","text":"<p>4.7. Visualizing Recursion</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u524d\u4e00\u8282\u4e2d\uff0c\u6211\u4eec\u770b\u5230\u4e86\u4f7f\u7528\u9012\u5f52\u89e3\u51b3\u7684\u4e00\u4e9b\u7b80\u5355\u95ee\u9898\uff1b\u7136\u800c\uff0c\u627e\u5230\u4e00\u4e2a\u5fc3\u667a\u6a21\u578b\u6216\u53ef\u89c6\u5316\u9012\u5f52\u51fd\u6570\u7684\u8fd0\u884c\u65b9\u5f0f\u4ecd\u7136\u53ef\u80fd\u5f88\u56f0\u96be\u3002\u8fd9\u53ef\u80fd\u4f1a\u4f7f\u5f97\u9012\u5f52\u5bf9\u5f88\u591a\u4eba\u6765\u8bf4\u96be\u4ee5\u7406\u89e3\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u901a\u8fc7\u51e0\u4e2a\u793a\u4f8b\uff0c\u4f7f\u7528\u9012\u5f52\u7ed8\u5236\u4e00\u4e9b\u6709\u8da3\u7684\u56fe\u5f62\u3002\u968f\u7740\u8fd9\u4e9b\u56fe\u5f62\u9010\u6e10\u6210\u578b\uff0c\u4f60\u5c06\u83b7\u5f97\u5bf9\u9012\u5f52\u8fc7\u7a0b\u7684\u65b0\u89c1\u89e3\uff0c\u8fd9\u53ef\u80fd\u5bf9\u5de9\u56fa\u4f60\u5bf9\u9012\u5f52\u7684\u7406\u89e3\u6709\u6240\u5e2e\u52a9\u3002</p> <p>\u6211\u4eec\u5c06\u4f7f\u7528\u7684\u5de5\u5177\u662f Python \u7684 turtle \u56fe\u5f62\u6a21\u5757\uff0c\u540d\u4e3a <code>turtle</code>\u3002<code>turtle</code> \u6a21\u5757\u5728\u6240\u6709\u7248\u672c\u7684 Python \u4e2d\u90fd\u662f\u6807\u51c6\u914d\u5907\u7684\uff0c\u4f7f\u7528\u8d77\u6765\u975e\u5e38\u7b80\u5355\u3002\u5b83\u7684\u9690\u55bb\u5f88\u7b80\u5355\u3002\u4f60\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u4e4c\u9f9f\uff0c\u4e4c\u9f9f\u53ef\u4ee5\u5411\u524d\u79fb\u52a8\u3001\u5411\u540e\u79fb\u52a8\u3001\u5411\u5de6\u8f6c\u3001\u5411\u53f3\u8f6c\u7b49\u7b49\u3002\u4e4c\u9f9f\u53ef\u4ee5\u5c06\u5c3e\u5df4\u62ac\u8d77\u6216\u653e\u4e0b\u3002\u5f53\u4e4c\u9f9f\u7684\u5c3e\u5df4\u653e\u4e0b\u65f6\uff0c\u5b83\u5728\u79fb\u52a8\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u753b\u51fa\u4e00\u6761\u7ebf\u3002\u4e3a\u4e86\u589e\u52a0\u4e4c\u9f9f\u7684\u827a\u672f\u4ef7\u503c\uff0c\u4f60\u53ef\u4ee5\u6539\u53d8\u5c3e\u5df4\u7684\u5bbd\u5ea6\u4ee5\u53ca\u5c3e\u5df4\u6cbe\u67d3\u7684\u58a8\u6c34\u7684\u989c\u8272\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\uff0c\u5c55\u793a\u4e86\u4e00\u4e9b <code>turtle</code> \u56fe\u5f62\u7684\u57fa\u7840\u77e5\u8bc6\u3002\u6211\u4eec\u5c06\u4f7f\u7528 <code>turtle</code> \u6a21\u5757\u9012\u5f52\u5730\u7ed8\u5236\u4e00\u4e2a\u87ba\u65cb\u5f62\u3002<code>ActiveCode 4.7.1</code> \u5c55\u793a\u4e86\u5982\u4f55\u5b8c\u6210\u8fd9\u9879\u4efb\u52a1\u3002\u5bfc\u5165 <code>turtle</code> \u6a21\u5757\u540e\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u4e4c\u9f9f\u3002\u521b\u5efa\u4e4c\u9f9f\u65f6\uff0c\u5b83\u8fd8\u4f1a\u4e3a\u81ea\u5df1\u521b\u5efa\u4e00\u4e2a\u7ed8\u56fe\u7a97\u53e3\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 <code>draw_spiral</code> \u51fd\u6570\u3002\u8fd9\u4e2a\u7b80\u5355\u51fd\u6570\u7684\u57fa\u672c\u60c5\u51b5\u662f\u5f53\u6211\u4eec\u8981\u7ed8\u5236\u7684\u7ebf\u6bb5\u957f\u5ea6\uff08\u7531 <code>len</code> \u53c2\u6570\u6307\u5b9a\uff09\u51cf\u5c11\u5230\u96f6\u6216\u66f4\u5c0f\u3002\u5982\u679c\u7ebf\u6bb5\u957f\u5ea6\u5927\u4e8e\u96f6\uff0c\u6211\u4eec\u6307\u793a\u4e4c\u9f9f\u524d\u8fdb <code>len</code> \u5355\u4f4d\uff0c\u7136\u540e\u53f3\u8f6c 90 \u5ea6\u3002\u9012\u5f52\u6b65\u9aa4\u662f\u5f53\u6211\u4eec\u518d\u6b21\u8c03\u7528 <code>draw_spiral</code>\uff0c\u5e76\u5c06\u957f\u5ea6\u51cf\u5c11\u3002\u4f60\u4f1a\u6ce8\u610f\u5230 <code>ActiveCode 4.7.1</code> \u7684\u7ed3\u5c3e\uff0c\u6211\u4eec\u8c03\u7528\u4e86 <code>my_win.exitonclick()</code>\u3002\u8fd9\u662f\u4e00\u4e2a\u7a97\u53e3\u7684\u65b9\u4fbf\u5c0f\u65b9\u6cd5\uff0c\u5b83\u5c06\u4e4c\u9f9f\u7f6e\u4e8e\u7b49\u5f85\u6a21\u5f0f\uff0c\u76f4\u5230\u4f60\u70b9\u51fb\u7a97\u53e3\u5185\uff0c\u7136\u540e\u7a0b\u5e8f\u5c06\u6e05\u7406\u5e76\u9000\u51fa\u3002</p> Activity: 4.7.1 \u4f7f\u7528\u6808\u9012\u5f52\u7ed8\u5236\u87ba\u65cb<pre><code>import turtle\n\ndef draw_spiral(my_turtle, line_len):\n    if line_len &gt; 0:\n        my_turtle.forward(line_len)\n        my_turtle.right(90)\n        draw_spiral(my_turtle, line_len - 5)\n\nmy_turtle = turtle.Turtle()\nmy_win = turtle.Screen()\ndraw_spiral(my_turtle, 100)\nmy_win.exitonclick()\n</code></pre> <p>\u8fd9\u57fa\u672c\u4e0a\u5c31\u662f\u4f60\u9700\u8981\u4e86\u89e3\u7684\u6240\u6709 <code>turtle</code> \u56fe\u5f62\u77e5\u8bc6\uff0c\u4ee5\u4fbf\u7ed8\u5236\u4e00\u4e9b\u4ee4\u4eba\u5370\u8c61\u6df1\u523b\u7684\u56fe\u5f62\u3002\u5728\u4e0b\u4e00\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u5c06\u8f6c\u5411\u5206\u5f62\u3002\u5206\u5f62\u6765\u81ea\u6570\u5b66\u7684\u4e00\u4e2a\u5206\u652f\uff0c\u5e76\u4e14\u4e0e\u9012\u5f52\u6709\u5f88\u591a\u76f8\u4f3c\u4e4b\u5904\u3002\u6839\u636e\u5b9a\u4e49\uff0c\u5206\u5f62\u5728\u4e0d\u540c\u7684\u653e\u5927\u7ea7\u522b\u4e0b\u90fd\u6709\u76f8\u540c\u7684\u57fa\u672c\u5f62\u72b6\u3002\u81ea\u7136\u754c\u4e2d\u7684\u4e00\u4e9b\u4f8b\u5b50\u5305\u62ec\u5927\u9646\u7684\u6d77\u5cb8\u7ebf\u3001\u96ea\u82b1\u3001\u5c71\u8109\uff0c\u751a\u81f3\u662f\u6811\u6728\u6216\u704c\u6728\u3002\u8bb8\u591a\u81ea\u7136\u73b0\u8c61\u7684\u5206\u5f62\u7279\u6027\u4f7f\u5f97\u7a0b\u5e8f\u5458\u80fd\u591f\u751f\u6210\u975e\u5e38\u903c\u771f\u7684\u8ba1\u7b97\u673a\u751f\u6210\u56fe\u50cf\u3002\u5728\u4e0b\u4e00\u4e2a\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5c06\u751f\u6210\u4e00\u4e2a\u5206\u5f62\u6811\u3002</p> <p>\u4e3a\u4e86\u7406\u89e3\u8fd9\u5c06\u5982\u4f55\u5de5\u4f5c\uff0c\u8003\u8651\u5982\u4f55\u7528\u5206\u5f62\u8bcd\u6c47\u6765\u63cf\u8ff0\u4e00\u68f5\u6811\u662f\u5f88\u6709\u5e2e\u52a9\u7684\u3002\u8bb0\u4f4f\uff0c\u6211\u4eec\u5728\u4e0a\u9762\u8bf4\u8fc7\uff0c\u5206\u5f62\u5728\u6240\u6709\u4e0d\u540c\u7684\u653e\u5927\u7ea7\u522b\u4e0b\u770b\u8d77\u6765\u90fd\u662f\u76f8\u540c\u7684\u3002\u5982\u679c\u6211\u4eec\u5c06\u8fd9\u4e00\u70b9\u8f6c\u5316\u4e3a\u6811\u6728\u548c\u704c\u6728\uff0c\u6211\u4eec\u53ef\u4ee5\u8bf4\uff0c\u5373\u4f7f\u662f\u4e00\u4e2a\u5c0f\u6811\u679d\u4e5f\u5177\u6709\u4e0e\u6574\u68f5\u6811\u76f8\u540c\u7684\u5f62\u72b6\u548c\u7279\u5f81\u3002\u5229\u7528\u8fd9\u4e2a\u60f3\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8bf4\uff0c\u4e00\u68f5\u6811\u662f\u4e00\u4e2a\u6811\u5e72\uff0c\u5176\u4e2d\u6709\u4e00\u68f5\u8f83\u5c0f\u7684\u6811\u5411\u53f3\u5ef6\u4f38\uff0c\u53e6\u4e00\u68f5\u8f83\u5c0f\u7684\u6811\u5411\u5de6\u5ef6\u4f38\u3002\u5982\u679c\u4f60\u5c06\u8fd9\u4e2a\u5b9a\u4e49\u9012\u5f52\u5730\u7406\u89e3\uff0c\u5b83\u610f\u5473\u7740\u6211\u4eec\u5c06\u9012\u5f52\u5730\u5c06\u6811\u7684\u5b9a\u4e49\u5e94\u7528\u4e8e\u4e24\u4e2a\u8f83\u5c0f\u7684\u5de6\u6811\u548c\u53f3\u6811\u3002</p> <p>\u8ba9\u6211\u4eec\u5c06\u8fd9\u4e2a\u60f3\u6cd5\u8f6c\u5316\u4e3a Python \u4ee3\u7801\u3002<code>Listing 4.6</code> \u663e\u793a\u4e86\u5982\u4f55\u4f7f\u7528\u6211\u4eec\u7684\u4e4c\u9f9f\u751f\u6210\u4e00\u4e2a\u5206\u5f62\u6811\u3002\u8ba9\u6211\u4eec\u66f4\u8be6\u7ec6\u5730\u770b\u4e00\u4e0b\u4ee3\u7801\u3002\u4f60\u4f1a\u770b\u5230\u5728\u7b2c 5 \u884c\u548c\u7b2c 7 \u884c\u6211\u4eec\u8fdb\u884c\u4e86\u9012\u5f52\u8c03\u7528\u3002\u5728\u7b2c 5 \u884c\uff0c\u6211\u4eec\u5728\u4e4c\u9f9f\u53f3\u8f6c 20 \u5ea6\u540e\u8fdb\u884c\u9012\u5f52\u8c03\u7528\uff1b\u8fd9\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684\u53f3\u4fa7\u6811\u3002\u7136\u540e\u5728\u7b2c 7 \u884c\uff0c\u4e4c\u9f9f\u8fdb\u884c\u4e86\u53e6\u4e00\u8f6e\u9012\u5f52\u8c03\u7528\uff0c\u4f46\u8fd9\u6b21\u662f\u5728\u5de6\u8f6c 40 \u5ea6\u4e4b\u540e\u3002\u4e4c\u9f9f\u5fc5\u987b\u5de6\u8f6c 40 \u5ea6\u7684\u539f\u56e0\u662f\u5b83\u9700\u8981\u64a4\u9500\u6700\u521d\u7684 20 \u5ea6\u53f3\u8f6c\uff0c\u7136\u540e\u518d\u5de6\u8f6c\u989d\u5916 20 \u5ea6\u4ee5\u7ed8\u5236\u5de6\u4fa7\u6811\u3002\u8fd8\u8981\u6ce8\u610f\uff0c\u6bcf\u6b21\u6211\u4eec\u9012\u5f52\u8c03\u7528 <code>tree</code> \u65f6\uff0c\u6211\u4eec\u90fd\u4f1a\u4ece <code>branch_len</code> \u53c2\u6570\u4e2d\u51cf\u53bb\u4e00\u4e9b\u91cf\uff1b\u8fd9\u662f\u4e3a\u4e86\u786e\u4fdd\u9012\u5f52\u6811\u8d8a\u6765\u8d8a\u5c0f\u3002\u4f60\u8fd8\u5e94\u8be5\u8ba4\u8bc6\u5230\u7b2c 2 \u884c\u7684\u521d\u59cb <code>if</code> \u8bed\u53e5\u4f5c\u4e3a\u5bf9 <code>branch_len</code> \u8fc7\u5c0f\u7684\u57fa\u672c\u60c5\u51b5\u7684\u68c0\u67e5\u3002</p> **Listing 4.6:** \u5206\u5f62\u6811\u4ee3\u7801<pre><code>def tree(branch_len, t):\n    if branch_len &gt; 5:\n        t.forward(branch_len)\n        t.right(20)\n        tree(branch_len - 15, t)\n        t.left(40)\n        tree(branch_len - 15, t)\n        t.right(20)\n        t.backward(branch_len)\n</code></pre> <p>\u5206\u5f62\u6811\u793a\u4f8b\u7684\u5b8c\u6574\u7a0b\u5e8f\u89c1 <code>ActiveCode 4.7.2</code>\u3002\u5728\u8fd0\u884c\u4ee3\u7801\u4e4b\u524d\uff0c\u8003\u8651\u4e00\u4e0b\u4f60\u671f\u671b\u770b\u5230\u6811\u7684\u5f62\u6210\u65b9\u5f0f\u3002\u67e5\u770b\u9012\u5f52\u8c03\u7528\uff0c\u601d\u8003\u8fd9\u68f5\u6811\u5c06\u5982\u4f55\u5c55\u5f00\u3002\u5b83\u4f1a\u5bf9\u79f0\u5730\u7ed8\u5236\u51fa\u6811\u7684\u5de6\u53f3\u4e24\u534a\u5417\uff1f\u8fd8\u662f\u5148\u7ed8\u5236\u53f3\u4fa7\u518d\u7ed8\u5236\u5de6\u4fa7\uff1f</p> Activity: 4.7.2 \u9012\u5f52\u7ed8\u5236\u4e00\u68f5\u6811<pre><code>import turtle\n\ndef tree(branch_len, t):\n    if branch_len &gt; 5:\n        t.forward(branch_len)\n        t.right(20)\n        tree(branch_len - 15, t)\n        t.left(40)\n        tree(branch_len - 15, t)\n        t.right(20)\n        t.backward(branch_len)\n\ndef main():\n    t = turtle.Turtle()\n    my_win = turtle.Screen()\n    t.left(90)\n    t.up()\n    t.backward(100)\n    t.down()\n    t.color(\"green\")\n    tree(75, t)\n    my_win.exitonclick()\n\nmain()\n</code></pre> <p>\u6ce8\u610f\u6811\u4e0a\u7684\u6bcf\u4e2a\u5206\u652f\u70b9\u90fd\u5bf9\u5e94\u4e8e\u4e00\u4e2a\u9012\u5f52\u8c03\u7528\uff0c\u5e76\u4e14\u6ce8\u610f\u6811\u662f\u5982\u4f55\u4e00\u76f4\u7ed8\u5236\u5230\u6700\u77ed\u7684\u6811\u679d\u3002\u4f60\u53ef\u4ee5\u5728 <code>Figure 4.7</code> \u4e2d\u770b\u5230\u8fd9\u4e00\u70b9\u3002\u73b0\u5728\uff0c\u6ce8\u610f\u7a0b\u5e8f\u5982\u4f55\u5411\u4e0a\u7ed8\u5236\u6811\u5e72\uff0c\u76f4\u5230\u6574\u4e2a\u53f3\u534a\u4fa7\u7684\u6811\u88ab\u7ed8\u5236\u5b8c\u6210\u3002\u4f60\u53ef\u4ee5\u5728 <code>Figure 4.8</code> \u4e2d\u770b\u5230\u53f3\u534a\u90e8\u5206\u7684\u6811\u3002\u7136\u540e\u7ed8\u5236\u5de6\u4fa7\u7684\u6811\uff0c\u4f46\u5e76\u4e0d\u662f\u5411\u5de6\u5c3d\u53ef\u80fd\u8fdc\u5730\u7ed8\u5236\u3002\u76f8\u53cd\uff0c\u4e00\u65e6\u7ed8\u5236\u5b8c\u6210\u5de6\u6811\u7684\u53f3\u4fa7\u90e8\u5206\uff0c\u6211\u4eec\u624d\u6700\u7ec8\u7ed8\u5236\u5230\u6700\u5c0f\u7684\u5de6\u4fa7\u6811\u679d\u3002</p> <p> Figure 4.7: \u5206\u5f62\u6811\u7684\u5f00\u59cb </p> <p> Figure 4.8: \u6811\u7684\u524d\u534a\u90e8\u5206 </p> <p>\u8fd9\u4e2a\u7b80\u5355\u7684\u6811\u7a0b\u5e8f\u53ea\u662f\u4e00\u4e2a\u8d77\u70b9\uff0c\u4f60\u4f1a\u53d1\u73b0\u6811\u7684\u5916\u89c2\u5e76\u4e0d\u7279\u522b\u73b0\u5b9e\uff0c\u56e0\u4e3a\u81ea\u7136\u754c\u5e76\u4e0d\u50cf\u8ba1\u7b97\u673a\u7a0b\u5e8f\u90a3\u6837\u5bf9\u79f0\u3002\u672c\u7ae0\u672b\u5c3e\u7684\u7ec3\u4e60\u5c06\u7ed9\u4f60\u4e00\u4e9b\u60f3\u6cd5\uff0c\u63a2\u7d22\u4e00\u4e9b\u6709\u8da3\u7684\u9009\u9879\u6765\u4f7f\u4f60\u7684\u6811\u770b\u8d77\u6765\u66f4\u73b0\u5b9e\u3002</p> <p>In the previous section we looked at some problems that were easy to solve using recursion; however, it can still be difficult to find a mental model or a way of visualizing what is happening in a recursive function. This can make recursion difficult for people to grasp. In this section we will look at a couple of examples of using recursion to draw some interesting pictures. As you watch these pictures take shape you will get some new insight into the recursive process that may be helpful in cementing your understanding of recursion.</p> <p>The tool we will use for our illustrations is Python\u2019s turtle graphics module called <code>turtle</code>. The <code>turtle</code> module is standard with all versions of Python and is very easy to use. The metaphor is quite simple. You can create a turtle and the turtle can move forward, move backward, turn left, turn right, etc. The turtle can have its tail up or down. When the turtle\u2019s tail is down and the turtle moves, it draws a line as it moves. To increase the artistic value of the turtle, you can change the width of the tail as well as the color of the ink the tail is dipped in.</p> <p>Here is a simple example to illustrate some <code>turtle</code> graphics basics. We will use the <code>turtle</code> module to draw a spiral recursively. <code>ActiveCode 4.7.1</code> shows how it is done. After importing the <code>turtle</code> module we create a turtle. When the turtle is created it also creates a window for itself to draw in. Next we define the <code>draw_spiral</code> function. The base case for this simple function is when the length of the line we want to draw, as given by the <code>len</code> parameter, is reduced to zero or less. If the length of the line is longer than zero, we instruct the turtle to go forward by <code>len</code> units and then turn right 90 degrees. The recursive step is when we call <code>draw_spiral</code> again with a reduced length. At the end of <code>ActiveCode 4.7.1</code> you will notice that we call the function <code>my_win.exitonclick()</code>. This is a handy little method of the window that puts the turtle into a wait mode until you click inside the window, after which the program cleans up and exits.</p> Activity: 4.7.1 Drawing a Recursive Spiral using turtle<pre><code>import turtle\n\n\ndef draw_spiral(my_turtle, line_len):\n    if line_len &gt; 0:\n        my_turtle.forward(line_len)\n        my_turtle.right(90)\n        draw_spiral(my_turtle, line_len - 5)\n\n\nmy_turtle = turtle.Turtle()\nmy_win = turtle.Screen()\ndraw_spiral(my_turtle, 100)\nmy_win.exitonclick()\n</code></pre> <p>That is really about all the turtle graphics you need to know in order to make some pretty impressive drawings. For our next program we will turn to fractals. Fractals come from a branch of mathematics, and have much in common with recursion. By definition, a fractal has the same basic shape no matter how much you magnify it. Some examples from nature are the coastlines of continents, snowflakes, mountains, and even trees or shrubs. The fractal nature of many of these natural phenomena makes it possible for programmers to generate very realistic looking scenery for computer-generated movies. In our next example we will generate a fractal tree.</p> <p>To understand how this is going to work it is helpful to think of how we might describe a tree using a fractal vocabulary. Remember that we said above that a fractal is something that looks the same at all different levels of magnification. If we translate this to trees and shrubs, we might say that even a small twig has the same shape and characteristics as a whole tree. Using this idea we could say that a tree is a trunk, with a smaller tree going off to the right and another smaller tree going off to the left. If you think of this definition recursively, it means that we will apply the recursive definition of a tree to both of the smaller left and right trees.</p> <p>Let's translate this idea to some Python code. <code>Listing 4.6</code> shows how we can use our turtle to generate a fractal tree. Let's look at the code a bit more closely. You will see that on lines 5 and 7 we are making a recursive call. On line 5 we make the recursive call right after the turtle turns to the right by 20 degrees; this is the right tree mentioned above. Then in line 7 the turtle makes another recursive call, but this time after turning left by 40 degrees. The reason the turtle must turn left by 40 degrees is that it needs to undo the original 20-degree turn to the right and then do an additional 20-degree turn to the left in order to draw the left tree. Also notice that each time we make a recursive call to <code>tree</code> we subtract some amount from the <code>branch_len</code> parameter; this is to make sure that the recursive trees get smaller and smaller. You should also recognize the initial <code>if</code> statement on line 2 as a check for the base case of <code>branch_len</code> getting too small.</p> **Listing 4.6:** Fractal Tree Code<pre><code>def tree(branch_len, t):\n    if branch_len &gt; 5:\n        t.forward(branch_len)\n        t.right(20)\n        tree(branch_len - 15, t)\n        t.left(40)\n        tree(branch_len - 15, t)\n        t.right(20)\n        t.backward(branch_len)\n</code></pre> <p>The complete program for this tree example is shown in <code>ActiveCode 4.7.2</code>.  Before you run the code think about how you expect to see the tree take shape. Look at the recursive calls and think about how this tree will unfold. Will it be drawn symmetrically with the right and left halves of the tree taking shape simultaneously? Will it be drawn right side first then left side?</p> Activity: 4.7.2 Recursively Drawing a Tree<pre><code>import turtle\n\n\ndef tree(branch_len, t):\n    if branch_len &gt; 5:\n        t.forward(branch_len)\n        t.right(20)\n        tree(branch_len - 15, t)\n        t.left(40)\n        tree(branch_len - 15, t)\n        t.right(20)\n        t.backward(branch_len)\n\ndef main():\n    t = turtle.Turtle()\n    my_win = turtle.Screen()\n    t.left(90)\n    t.up()\n    t.backward(100)\n    t.down()\n    t.color(\"green\")\n    tree(75, t)\n    my_win.exitonclick()\n\nmain()\n</code></pre> <p>Notice how each branch point on the tree corresponds to a recursive call, and notice how the tree is drawn to the right all the way down to its shortest twig. You can see this in <code>Figure 4.7</code>. Now, notice how the program works its way back up the trunk until the entire right side of the tree is drawn. You can see the right half of the tree in <code>Figure 4.8</code>. Then the left side of the tree is drawn, but not by going as far out to the left as possible. Rather, once again the entire right side of the left tree is drawn until we finally make our way out to the smallest twig on the left.</p> <p> Figure 4.7: The Beginning of a Fractal Tree </p> <p> Figure 8: The First Half of the Tree </p> <p>This simple tree program is just a starting point for you, and you will notice that the tree does not look particularly realistic because nature is just not as symmetrical as a computer program. The exercises at the end of the chapter will give you some ideas for how to explore some interesting options to make your tree look more realistic.</p> <p>Self Check</p> <p>Modify the recursive tree program using one or all of the following ideas:</p> <ul> <li>Modify the thickness of the branches so that as the <code>branch_len</code> gets smaller, the line gets thinner.</li> <li>Modify the color of the branches so that as the <code>branch_len</code> gets very short it is colored like a leaf.</li> <li>Modify the angle used in turning the turtle so that at each branch point the angle is selected at random in some range. For example choose the angle between 15 and 45 degrees. Play around to see what looks good.</li> <li>Modify the <code>branch_len</code> recursively so that instead of always subtracting the same amount you subtract a random amount in some range.</li> </ul>"},{"location":"c4/s8/","title":"4.8. \u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62","text":"<p>4.8. Sierpinski Triangle</p> \u4e2d\u6587\u82f1\u6587 <p>\u53e6\u4e00\u4e2a\u5c55\u793a\u81ea\u76f8\u4f3c\u6027\u8d28\u7684\u5206\u5f62\u662f\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u3002<code>Figure 4.9</code> \u5c55\u793a\u4e86\u4e00\u4e2a\u4f8b\u5b50\u3002\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u5c55\u793a\u4e86\u4e00\u79cd\u4e09\u91cd\u9012\u5f52\u7b97\u6cd5\u3002\u624b\u52a8\u7ed8\u5236\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u7684\u65b9\u6cd5\u5f88\u7b80\u5355\u3002\u9996\u5148\u4ece\u4e00\u4e2a\u5927\u4e09\u89d2\u5f62\u5f00\u59cb\u3002\u901a\u8fc7\u8fde\u63a5\u6bcf\u6761\u8fb9\u7684\u4e2d\u70b9\uff0c\u5c06\u8fd9\u4e2a\u5927\u4e09\u89d2\u5f62\u5212\u5206\u4e3a\u56db\u4e2a\u65b0\u4e09\u89d2\u5f62\u3002\u5ffd\u7565\u521a\u521a\u521b\u5efa\u7684\u4e2d\u95f4\u4e09\u89d2\u5f62\uff0c\u5bf9\u5176\u4f59\u4e09\u4e2a\u89d2\u843d\u7684\u4e09\u89d2\u5f62\u5e94\u7528\u76f8\u540c\u7684\u65b9\u6cd5\u3002\u6bcf\u6b21\u521b\u5efa\u4e00\u7ec4\u65b0\u4e09\u89d2\u5f62\u65f6\uff0c\u4f60\u9012\u5f52\u5730\u5bf9\u8fd9\u4e09\u4e2a\u8f83\u5c0f\u7684\u89d2\u843d\u4e09\u89d2\u5f62\u5e94\u7528\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5982\u679c\u4f60\u6709\u8db3\u591f\u950b\u5229\u7684\u94c5\u7b14\uff0c\u4f60\u53ef\u4ee5\u65e0\u9650\u671f\u5730\u5e94\u7528\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5728\u7ee7\u7eed\u9605\u8bfb\u4e4b\u524d\uff0c\u4f60\u53ef\u80fd\u60f3\u5c1d\u8bd5\u81ea\u5df1\u7528\u8fd9\u79cd\u65b9\u6cd5\u7ed8\u5236\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u3002</p> <p> Figure 4.9: \u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62 </p> <p>\u7531\u4e8e\u6211\u4eec\u53ef\u4ee5\u65e0\u9650\u671f\u5730\u5e94\u7528\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u90a3\u4e48\u57fa\u672c\u60c5\u51b5\u662f\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u4f1a\u770b\u5230\uff0c\u57fa\u672c\u60c5\u51b5\u88ab\u4efb\u610f\u8bbe\u7f6e\u4e3a\u6211\u4eec\u5e0c\u671b\u5c06\u4e09\u89d2\u5f62\u5212\u5206\u4e3a\u591a\u5c11\u6b21\u3002\u6709\u65f6\u6211\u4eec\u79f0\u8fd9\u4e2a\u6570\u5b57\u4e3a\u5206\u5f62\u7684\u5ea6\u6570\u3002\u6bcf\u6b21\u8fdb\u884c\u9012\u5f52\u8c03\u7528\u65f6\uff0c\u6211\u4eec\u5c06\u5ea6\u6570\u51cf 1\uff0c\u76f4\u5230\u8fbe\u5230 0\u3002\u5f53\u6211\u4eec\u8fbe\u5230\u5ea6\u6570\u4e3a 0 \u65f6\uff0c\u6211\u4eec\u505c\u6b62\u9012\u5f52\u8c03\u7528\u3002\u751f\u6210 <code>Figure 4.9</code> \u4e2d\u7684\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u7684\u4ee3\u7801\u89c1 <code>ActiveCode 4.8.1</code>\u3002</p> Activity: 4.8.1 \u7ed8\u5236\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62<pre><code>import turtle\n\ndef draw_triangle(points, color, my_turtle):\n    my_turtle.fillcolor(color)\n    my_turtle.up()\n    my_turtle.goto(points[0][0], points[0][1])\n    my_turtle.down()\n    my_turtle.begin_fill()\n    my_turtle.goto(points[1][0], points[1][1])\n    my_turtle.goto(points[2][0], points[2][1])\n    my_turtle.goto(points[0][0], points[0][1])\n    my_turtle.end_fill()\n\ndef get_mid(p1, p2):\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n\ndef sierpinski(points, degree, my_turtle):\n    colormap = [\"blue\", \"red\", \"green\", \"white\", \"yellow\", \"violet\", \"orange\"]\n    draw_triangle(points, colormap[degree], my_turtle)\n    if degree &gt; 0:\n        sierpinski(\n            [points[0], get_mid(points[0], points[1]), get_mid(points[0], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n        sierpinski(\n            [points[1], get_mid(points[0], points[1]), get_mid(points[1], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n        sierpinski(\n            [points[2], get_mid(points[2], points[1]), get_mid(points[0], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n\ndef main():\n    my_turtle = turtle.Turtle()\n    my_win = turtle.Screen()\n    my_points = [[-180, -150], [0, 150], [180, -150]]\n    sierpinski(my_points, 5, my_turtle)\n    my_win.exitonclick()\n\nmain()\n</code></pre> <p><code>ActiveCode 4.8.1</code> \u4e2d\u7684\u7a0b\u5e8f\u9075\u5faa\u4e86\u4e0a\u8ff0\u601d\u60f3\u3002<code>sierpinski</code> \u9996\u5148\u7ed8\u5236\u5916\u90e8\u4e09\u89d2\u5f62\u3002\u63a5\u4e0b\u6765\uff0c\u6709\u4e09\u4e2a\u9012\u5f52\u8c03\u7528\uff0c\u6bcf\u4e2a\u89d2\u843d\u7684\u4e09\u89d2\u5f62\u90fd\u5bf9\u5e94\u4e00\u4e2a\u9012\u5f52\u8c03\u7528\u3002\u4e00\u65e6\u518d\u6b21\u4f7f\u7528\u4e86\u6807\u51c6\u7684 <code>turtle</code> \u6a21\u5757\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u4ece Python \u63d0\u793a\u7b26\u4f7f\u7528 <code>help(\"turtle\")</code> \u6765\u5b66\u4e60 <code>turtle</code> \u6a21\u5757\u4e2d\u7684\u6240\u6709\u65b9\u6cd5\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u67e5\u770b\u4ee3\u7801\u5e76\u601d\u8003\u4e09\u89d2\u5f62\u7ed8\u5236\u7684\u987a\u5e8f\u3002\u867d\u7136\u89d2\u843d\u7684\u786e\u5207\u987a\u5e8f\u53d6\u51b3\u4e8e\u521d\u59cb\u96c6\u5408\u7684\u6307\u5b9a\u65b9\u5f0f\uff0c\u4f46\u6211\u4eec\u5047\u8bbe\u89d2\u843d\u7684\u987a\u5e8f\u662f\u5de6\u4e0b\u3001\u9876\u90e8\u3001\u53f3\u4e0b\u3002\u7531\u4e8e <code>sierpinski</code> \u51fd\u6570\u8c03\u7528\u81ea\u8eab\u7684\u65b9\u5f0f\uff0c<code>sierpinski</code> \u4f1a\u5148\u7ed8\u5236\u5230\u6700\u5c0f\u7684\u5de6\u4e0b\u89d2\u4e09\u89d2\u5f62\uff0c\u7136\u540e\u5f00\u59cb\u586b\u5145\u5176\u4f59\u7684\u4e09\u89d2\u5f62\uff0c\u518d\u8fd4\u56de\u586b\u5145\u9876\u90e8\u89d2\u843d\u7684\u4e09\u89d2\u5f62\uff0c\u6700\u540e\u586b\u5145\u53f3\u4e0b\u89d2\uff0c\u9010\u6e10\u7ed8\u5236\u5230\u53f3\u4e0b\u89d2\u7684\u6700\u5c0f\u4e09\u89d2\u5f62\u3002</p> <p>\u6709\u65f6\uff0c\u7528\u51fd\u6570\u8c03\u7528\u7684\u56fe\u793a\u6765\u601d\u8003\u9012\u5f52\u7b97\u6cd5\u662f\u5f88\u6709\u5e2e\u52a9\u7684\u3002<code>Figure 4.10</code> \u5c55\u793a\u4e86\u9012\u5f52\u8c03\u7528\u603b\u662f\u5411\u5de6\u8fdb\u884c\u3002\u6d3b\u52a8\u51fd\u6570\u7528\u9ed1\u8272\u8f6e\u5ed3\u663e\u793a\uff0c\u975e\u6d3b\u52a8\u51fd\u6570\u8c03\u7528\u7528\u7070\u8272\u663e\u793a\u3002\u4f60\u8d8a\u5f80\u4e0b\u770b <code>Figure 4.10</code>\uff0c\u4e09\u89d2\u5f62\u8d8a\u5c0f\u3002\u51fd\u6570\u6bcf\u6b21\u5b8c\u6210\u4e00\u4e2a\u7ea7\u522b\u7684\u7ed8\u5236\uff1b\u5b8c\u6210\u5de6\u4e0b\u89d2\u540e\uff0c\u5b83\u4f1a\u8f6c\u5230\u5de6\u4e2d\u95f4\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002</p> <p> Figure 4.10: \u6784\u5efa\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62 </p> <p><code>sierpinski</code> \u51fd\u6570\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u4f9d\u8d56\u4e8e <code>get_mid</code> \u51fd\u6570\u3002<code>get_mid</code> \u51fd\u6570\u63a5\u53d7\u4e24\u4e2a\u7aef\u70b9\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u5b83\u4eec\u4e4b\u95f4\u7684\u4e2d\u70b9\u3002\u6b64\u5916\uff0c<code>ActiveCode 4.8.1</code> \u4e2d\u8fd8\u6709\u4e00\u4e2a\u4f7f\u7528 <code>begin_fill</code> \u548c <code>end_fill</code> \u65b9\u6cd5\u7ed8\u5236\u586b\u5145\u4e09\u89d2\u5f62\u7684\u51fd\u6570\u3002</p> <p>Another fractal that exhibits the property of self-similarity is the Sierpinski triangle. An example is shown in <code>Figure 4.9</code>. The Sierpinski triangle illustrates a three-way recursive algorithm. The procedure for drawing a Sierpinski triangle by hand is simple. Start with a single large triangle. Divide this large triangle into four new triangles by connecting the midpoint of each side. Ignoring the middle triangle that you just created, apply the same procedure to each of the three corner triangles. Each time you create a new set of triangles, you recursively apply this procedure to the three smaller corner triangles. You can continue to apply this procedure indefinitely if you have a sharp enough pencil. Before you continue reading, you may want to try drawing the Sierpinski triangle yourself, using the method described.</p> <p> Figure 4.9: The Sierpinski Triangle </p> <p>Since we can continue to apply the algorithm indefinitely, what is the base case? We will see that the base case is set arbitrarily as the number of times we want to divide the triangle into pieces. Sometimes we call this number the degree of the fractal. Each time we make a recursive call, we subtract 1 from the degree until we reach 0. When we reach a degree of 0, we stop making recursive calls. The code that generated the Sierpinski Triangle in <code>Figure 4.9</code> is shown in <code>ActiveCode 4.8.1</code>.</p> Activity: 4.8.1 Drawing a Sierpinski Triangle<pre><code>import turtle\n\n\ndef draw_triangle(points, color, my_turtle):\n    my_turtle.fillcolor(color)\n    my_turtle.up()\n    my_turtle.goto(points[0][0], points[0][1])\n    my_turtle.down()\n    my_turtle.begin_fill()\n    my_turtle.goto(points[1][0], points[1][1])\n    my_turtle.goto(points[2][0], points[2][1])\n    my_turtle.goto(points[0][0], points[0][1])\n    my_turtle.end_fill()\n\n\ndef get_mid(p1, p2):\n    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n\n\ndef sierpinski(points, degree, my_turtle):\n    colormap = [\"blue\", \"red\", \"green\", \"white\", \"yellow\", \"violet\", \"orange\"]\n    draw_triangle(points, colormap[degree], my_turtle)\n    if degree &gt; 0:\n        sierpinski(\n            [points[0], get_mid(points[0], points[1]), get_mid(points[0], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n        sierpinski(\n            [points[1], get_mid(points[0], points[1]), get_mid(points[1], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n        sierpinski(\n            [points[2], get_mid(points[2], points[1]), get_mid(points[0], points[2])],\n            degree - 1,\n            my_turtle,\n        )\n\n\ndef main():\n    my_turtle = turtle.Turtle()\n    my_win = turtle.Screen()\n    my_points = [[-180, -150], [0, 150], [180, -150]]\n    sierpinski(my_points, 5, my_turtle)\n    my_win.exitonclick()\n\n\nmain()\n</code></pre> <p>The program in <code>ActiveCode 4.8.1</code> follows the ideas outlined above. The first thing <code>sierpinski</code> does is draw the outer triangle. Next, there are three recursive calls, one for each of the new corner triangles we get when we connect the midpoints. Once again we make use of the standard <code>turtle</code> module that comes with Python. You can learn all the details of the methods available in the turtle module by using <code>help(\"turtle\")</code> from the Python prompt.</p> <p>Look at the code and think about the order in which the triangles will be drawn. While the exact order of the corners depends upon how the initial set is specified, let\u2019s assume that the corners are ordered lower left, top, lower right. Because of the way the <code>sierpinski</code> function calls itself, <code>sierpinski</code> works its way to the smallest allowed triangle in the lower-left corner and then begins to fill out the rest of the triangles working back. Then it fills in the triangles in the top corner by working toward the smallest, topmost triangle. Finally, it fills in the lower-right corner, working its way toward the smallest triangle in the lower right.</p> <p>Sometimes it is helpful to think of a recursive algorithm in terms of a diagram of function calls. <code>Figure 4.10</code> shows that the recursive calls are always made going to the left. The active functions are outlined in black, and the inactive function calls are in gray. The farther you go toward the bottom of <code>Figure 4.10</code>, the smaller the triangles. The function finishes drawing one level at a time; once it is finished with the bottom left it moves to the bottom middle, and so on.</p> <p> Figure 4.10: Building a Sierpinski Triangle </p> <p>The <code>sierpinski</code> function relies heavily on the <code>get_mid</code> function. <code>get_mid</code> takes as arguments two endpoints and returns the point halfway between them. In addition, <code>ActiveCode 4.8.1</code> has a function that draws a filled triangle using the <code>begin_fill</code> and <code>end_fill</code> turtle methods.</p>"},{"location":"c4/s9/","title":"4.9. \u590d\u6742\u7684\u9012\u5f52\u95ee\u9898","text":"<p>4.9. Complex Recursive Problems</p> \u4e2d\u6587\u82f1\u6587 <p>\u5728\u524d\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u8ba8\u8bba\u4e86\u4e00\u4e9b\u76f8\u5bf9\u5bb9\u6613\u89e3\u51b3\u7684\u95ee\u9898\uff0c\u4ee5\u53ca\u4e00\u4e9b\u5728\u56fe\u5f62\u4e0a\u6709\u8da3\u7684\u95ee\u9898\uff0c\u8fd9\u4e9b\u95ee\u9898\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u5efa\u7acb\u9012\u5f52\u7b97\u6cd5\u7684\u5fc3\u667a\u6a21\u578b\u3002\u5728\u672c\u8282\u53ca\u540e\u7eed\u7ae0\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u63a2\u8ba8\u4e00\u4e9b\u4f7f\u7528\u8fed\u4ee3\u7f16\u7a0b\u98ce\u683c\u96be\u4ee5\u89e3\u51b3\uff0c\u4f46\u4f7f\u7528\u9012\u5f52\u65b9\u6cd5\u5374\u975e\u5e38\u4f18\u96c5\u4e14\u5bb9\u6613\u89e3\u51b3\u7684\u95ee\u9898\u3002\u6700\u540e\uff0c\u6211\u4eec\u4f1a\u8ba8\u8bba\u4e00\u4e2a\u770b\u4f3c\u62e5\u6709\u4f18\u96c5\u9012\u5f52\u89e3\u51b3\u65b9\u6848\uff0c\u4f46\u5b9e\u9645\u4e0a\u5e76\u975e\u5982\u6b64\u7684\u201c\u8ff7\u60d1\u6027\u201d\u95ee\u9898\u3002</p> <p>In the previous sections we looked at some problems that are relatively easy to solve and some graphically interesting problems that can help us gain a mental model of what is happening in a recursive algorithm. In this and the following sections we will look at some problems that are really difficult to solve using an iterative programming style but are very elegant and easy to solve using recursion. We will finish up by looking at a deceptive problem that at first looks like it has an elegant recursive solution but in fact does not.</p>"},{"location":"c5/","title":"5. \u641c\u7d22\u4e0e\u6392\u5e8f","text":"<p>5. Searching and Sorting</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>5.1. \u76ee\u6807</li> <li>5.2. \u641c\u7d22</li> <li>5.3. \u987a\u5e8f\u641c\u7d22<ul> <li>5.3.1. \u987a\u5e8f\u641c\u7d22\u7684\u5206\u6790</li> </ul> </li> <li>5.4. \u4e8c\u5206\u641c\u7d22<ul> <li>5.4.1. \u4e8c\u5206\u641c\u7d22\u7684\u5206\u6790</li> </ul> </li> <li>5.5. \u54c8\u5e0c<ul> <li>5.5.1. \u54c8\u5e0c\u51fd\u6570</li> <li>5.5.2. \u78b0\u649e\u89e3\u51b3</li> <li>5.5.3. \u5b9e\u73b0Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b</li> <li>5.5.4. \u54c8\u5e0c\u5206\u6790</li> </ul> </li> <li>5.6. \u6392\u5e8f</li> <li>5.7. \u5192\u6ce1\u6392\u5e8f</li> <li>5.8. \u9009\u62e9\u6392\u5e8f</li> <li>5.9. \u63d2\u5165\u6392\u5e8f</li> <li>5.10. \u5e0c\u5c14\u6392\u5e8f</li> <li>5.11. \u5f52\u5e76\u6392\u5e8f</li> <li>5.12. \u5feb\u901f\u6392\u5e8f</li> <li>5.13. \u603b\u7ed3</li> <li>5.14. \u5173\u952e\u672f\u8bed</li> <li>5.15. \u7ec3\u4e60</li> </ul> <ul> <li>5.1. Objectives</li> <li>5.2. Searching</li> <li>5.3. The Sequential Search<ul> <li>5.3.1. Analysis of Sequential Search</li> </ul> </li> <li>5.4. The Binary Search<ul> <li>5.4.1. Analysis of Binary Search</li> </ul> </li> <li>5.5. Hashing<ul> <li>5.5.1. Hash Functions</li> <li>5.5.2. Collision Resolution</li> <li>5.5.3. Implementing the Map Abstract Data Type</li> <li>5.5.4. Analysis of Hashing</li> </ul> </li> <li>5.6. Sorting</li> <li>5.7. The Bubble Sort</li> <li>5.8. The Selection Sort</li> <li>5.9. The Insertion Sort</li> <li>5.10. The Shell Sort</li> <li>5.11. The Merge Sort</li> <li>5.12. The Quicksort</li> <li>5.13. Summary</li> <li>5.14. Key Terms</li> <li>5.15. Exercises</li> </ul>"},{"location":"c5/s1/","title":"5.1. \u76ee\u6807","text":"<p>5.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>To be able to explain and implement sequential search and binary search.</li> <li>To be able to explain and implement selection sort, bubble sort, merge sort, quick sort, insertion sort, and Shell sort.</li> <li>To understand the idea of hashing as a search technique.</li> <li>To understand the map abstract data type.</li> <li>To implement the map abstract data type using hashing.</li> </ul> <ul> <li>To be able to explain and implement sequential search and binary search.</li> <li>To be able to explain and implement selection sort, bubble sort, merge sort, quick sort, insertion sort, and Shell sort.</li> <li>To understand the idea of hashing as a search technique.</li> <li>To understand the map abstract data type.</li> <li>To implement the map abstract data type using hashing.</li> </ul>"},{"location":"c5/s10/","title":"5.10. \u5e0c\u5c14\u6392\u5e8f","text":"<p>5.10. The Shell Sort</p> \u4e2d\u6587\u82f1\u6587 <p>The Shell sort, sometimes called the diminishing increment sort, improves on the insertion sort by breaking the original list into a number of smaller sublists, each of which is sorted using an insertion sort. The unique way that these sublists are chosen is the key to the Shell sort. Instead of breaking the list into sublists of contiguous items, the Shell sort uses an increment \\(i\\), sometimes called the gap, to create a sublist by choosing all items that are \\(i\\) items apart.</p> <p>This can be seen in <code>Figure 6</code>. This list has nine items. If we use an increment of three, there are three sublists, each of which can be sorted by an insertion sort. After completing these sorts, we get the list shown in <code>Figure 7</code>. Although the list shown in <code>Figure 7</code> is not completely sorted, something very interesting has happened. By sorting the sublists, we have moved the items closer to where they actually belong.</p> <p> Figure 6: A Shell Sort with Increments of Three </p> <p> Figure 7: A Shell Sort after Sorting Each Sublist </p> <p><code>Figure 8</code> shows a final insertion sort using an increment of one\u2014in other words, a standard insertion sort. Note that by performing the earlier sublist sorts, we have now reduced the total number of shifting operations necessary to put the list in its final order. For this case, we need only four more shifts to complete the process.</p> <p> Figure 8: ShellSort: A Final Insertion Sort with Increment of 1 </p> <p> Figure 9: Initial Sublists for a Shell Sort </p> <p>We said earlier that the way in which the increments are chosen is the unique feature of the Shell sort. The function shown in <code>ActiveCode 1</code> uses a different set of increments. In this case, we begin with \\(\\frac {n}{2}\\) sublists. On the next pass, \\(\\frac {n}{4}\\) sublists are sorted. Eventually, a single list is sorted with the basic insertion sort. <code>Figure 9</code> shows the first sublists for our example using this increment.</p> <p>The following invocation of the <code>shell_sort</code> function shows the partially sorted lists after each increment, with the final sort being an insertion sort with an increment of one.</p> Activity: 5.10.1 Shell Sort Implementation<pre><code>def shell_sort(a_list):\n    sublist_count = len(a_list) // 2\n    while sublist_count &gt; 0:\n        for pos_start in range(sublist_count):\n            gap_insertion_sort(a_list, pos_start, sublist_count)\n        print(\"After increments of size\", sublist_count, \"the list is\", a_list)\n        sublist_count = sublist_count // 2\n\ndef gap_insertion_sort(a_list, start, gap):\n    for i in range(start + gap, len(a_list), gap):\n        cur_val = a_list[i]\n        cur_pos = i\n        while cur_pos &gt;= gap and a_list[cur_pos - gap] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nshell_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 5 allows you to step through the algorithm.</p> Tracing the Shell Sort<pre><code>def shell_sort(a_list):\n    sublist_count = len(a_list) // 2\n    while sublist_count &gt; 0:\n        for pos_start in range(sublist_count):\n            gap_insertion_sort(a_list, pos_start, sublist_count)\n        print(\"After increments of size\", sublist_count, \"the list is\", a_list)\n        sublist_count = sublist_count // 2\n\n\ndef gap_insertion_sort(a_list, start, gap):\n    for i in range(start + gap, len(a_list), gap):\n        cur_val = a_list[i]\n        cur_pos = i\n        while cur_pos &gt;= gap and a_list[cur_pos - gap] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nshell_sort(a_list)\nprint(alist)\n</code></pre> <p>At first glance you may think that a Shell sort cannot be better than an insertion sort since it does a complete insertion sort as the last step. It turns out, however, that this final insertion sort does not need to do very many comparisons (or shifts) since the list has been presorted by earlier incremental insertion sorts, as described above. In other words, each pass produces a list that is \u201cmore sorted\u201d than the previous one. This makes the final pass very efficient.</p> <p>Although a general analysis of the Shell sort is well beyond the scope of this text, we can say that it tends to fall somewhere between \\(O(n)\\) and \\(O(n^{2})\\), based on the behavior described above. For the increments shown in <code>Listing 5</code>, the performance is \\(O(n^{2})\\). By changing the increment, for example using \\(2^{k}-1\\) (1, 3, 7, 15, 31, and so on), a Shell sort can perform at \\(O(n^{\\frac {3}{2}})\\).</p> <p>Self Check</p> <p>Given the following list of numbers:  [5, 16, 20, 12, 3, 8, 9, 17, 19, 7] Which answer illustrates the contents of the list after all swapping is complete for a gap size of 3?</p> <ul> <li>answer a: [5, 3, 8, 7, 16, 19, 9, 17, 20, 12]</li> <li>answer b: [3, 7, 5, 8, 9, 12, 19, 16, 20, 17]</li> <li>answer c: [3, 5, 7, 8, 9, 12, 16, 17, 19, 20]</li> <li>answer d: [5, 16, 20, 3, 8, 12, 9, 17, 20, 7]</li> </ul> <p>correct: a</p> <ul> <li>feedback a:  Each group of numbers represented by index positions 3 apart are sorted correctly.</li> <li>feedback b:  This solution is for a gap size of two.</li> <li>feedback c: This is list completely sorted, you have gone too far.</li> <li>feedback d: The gap size of three indicates that the group represented by every third number e.g. 0, 3, 6, 9  and 1, 4, 7 and 2, 5, 8 are sorted not groups of 3.</li> </ul> <p>The Shell sort, sometimes called the diminishing increment sort, improves on the insertion sort by breaking the original list into a number of smaller sublists, each of which is sorted using an insertion sort. The unique way that these sublists are chosen is the key to the Shell sort. Instead of breaking the list into sublists of contiguous items, the Shell sort uses an increment \\(i\\), sometimes called the gap, to create a sublist by choosing all items that are \\(i\\) items apart.</p> <p>This can be seen in <code>Figure 6</code>. This list has nine items. If we use an increment of three, there are three sublists, each of which can be sorted by an insertion sort. After completing these sorts, we get the list shown in <code>Figure 7</code>. Although the list shown in <code>Figure 7</code> is not completely sorted, something very interesting has happened. By sorting the sublists, we have moved the items closer to where they actually belong.</p> <p> Figure 6: A Shell Sort with Increments of Three </p> <p> Figure 7: A Shell Sort after Sorting Each Sublist </p> <p><code>Figure 8</code> shows a final insertion sort using an increment of one\u2014in other words, a standard insertion sort. Note that by performing the earlier sublist sorts, we have now reduced the total number of shifting operations necessary to put the list in its final order. For this case, we need only four more shifts to complete the process.</p> <p> Figure 8: ShellSort: A Final Insertion Sort with Increment of 1 </p> <p> Figure 9: Initial Sublists for a Shell Sort </p> <p>We said earlier that the way in which the increments are chosen is the unique feature of the Shell sort. The function shown in <code>ActiveCode 1</code> uses a different set of increments. In this case, we begin with \\(\\frac {n}{2}\\) sublists. On the next pass, \\(\\frac {n}{4}\\) sublists are sorted. Eventually, a single list is sorted with the basic insertion sort. <code>Figure 9</code> shows the first sublists for our example using this increment.</p> <p>The following invocation of the <code>shell_sort</code> function shows the partially sorted lists after each increment, with the final sort being an insertion sort with an increment of one.</p> Activity: 5.10.1 Shell Sort Implementation<pre><code>def shell_sort(a_list):\n    sublist_count = len(a_list) // 2\n    while sublist_count &gt; 0:\n        for pos_start in range(sublist_count):\n            gap_insertion_sort(a_list, pos_start, sublist_count)\n        print(\"After increments of size\", sublist_count, \"the list is\", a_list)\n        sublist_count = sublist_count // 2\n\ndef gap_insertion_sort(a_list, start, gap):\n    for i in range(start + gap, len(a_list), gap):\n        cur_val = a_list[i]\n        cur_pos = i\n        while cur_pos &gt;= gap and a_list[cur_pos - gap] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nshell_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 5 allows you to step through the algorithm.</p> Tracing the Shell Sort<pre><code>def shell_sort(a_list):\n    sublist_count = len(a_list) // 2\n    while sublist_count &gt; 0:\n        for pos_start in range(sublist_count):\n            gap_insertion_sort(a_list, pos_start, sublist_count)\n        print(\"After increments of size\", sublist_count, \"the list is\", a_list)\n        sublist_count = sublist_count // 2\n\n\ndef gap_insertion_sort(a_list, start, gap):\n    for i in range(start + gap, len(a_list), gap):\n        cur_val = a_list[i]\n        cur_pos = i\n        while cur_pos &gt;= gap and a_list[cur_pos - gap] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nshell_sort(a_list)\nprint(alist)\n</code></pre> <p>At first glance you may think that a Shell sort cannot be better than an insertion sort since it does a complete insertion sort as the last step. It turns out, however, that this final insertion sort does not need to do very many comparisons (or shifts) since the list has been presorted by earlier incremental insertion sorts, as described above. In other words, each pass produces a list that is \u201cmore sorted\u201d than the previous one. This makes the final pass very efficient.</p> <p>Although a general analysis of the Shell sort is well beyond the scope of this text, we can say that it tends to fall somewhere between \\(O(n)\\) and \\(O(n^{2})\\), based on the behavior described above. For the increments shown in <code>Listing 5</code>, the performance is \\(O(n^{2})\\). By changing the increment, for example using \\(2^{k}-1\\) (1, 3, 7, 15, 31, and so on), a Shell sort can perform at \\(O(n^{\\frac {3}{2}})\\).</p> <p>Self Check</p> <p>Given the following list of numbers:  [5, 16, 20, 12, 3, 8, 9, 17, 19, 7] Which answer illustrates the contents of the list after all swapping is complete for a gap size of 3?</p> <ul> <li>answer a: [5, 3, 8, 7, 16, 19, 9, 17, 20, 12]</li> <li>answer b: [3, 7, 5, 8, 9, 12, 19, 16, 20, 17]</li> <li>answer c: [3, 5, 7, 8, 9, 12, 16, 17, 19, 20]</li> <li>answer d: [5, 16, 20, 3, 8, 12, 9, 17, 20, 7]</li> </ul> <p>correct: a</p> <ul> <li>feedback a:  Each group of numbers represented by index positions 3 apart are sorted correctly.</li> <li>feedback b:  This solution is for a gap size of two.</li> <li>feedback c: This is list completely sorted, you have gone too far.</li> <li>feedback d: The gap size of three indicates that the group represented by every third number e.g. 0, 3, 6, 9  and 1, 4, 7 and 2, 5, 8 are sorted not groups of 3.</li> </ul>"},{"location":"c5/s11/","title":"5.11. \u5f52\u5e76\u6392\u5e8f","text":"<p>5.11. The Merge Sort</p> \u4e2d\u6587\u82f1\u6587 <p>We now turn our attention to using a divide and conquer strategy as a way to improve the performance of sorting algorithms. The first algorithm we will study is the merge sort. Merge sort is a recursive algorithm that continually splits a list in half. If the list is empty or has one item, it is sorted by definition (the base case). If the list has more than one item, we split the list and recursively invoke a merge sort on both halves. Once the two halves are sorted, the fundamental operation, called a merge, is performed. Merging is the process of taking two smaller sorted lists and combining them together into a single sorted new list. <code>Figure 10</code> shows our familiar example list as it is being split by <code>merge_sort</code>. <code>Figure 11</code> shows the simple lists, now sorted, as they are merged back together.</p> <p> Figure 10: Splitting the List in a Merge Sort </p> <p> Figure 11: Lists as They Are Merged Together </p> <p>The <code>merge_sort</code> function shown in <code>ActiveCode 1</code> begins by asking the base case question. If the length of the list is less than or equal to one, then we already have a sorted list and no more processing is necessary. If, on the other hand, the length is greater than one, then we use the Python <code>slice</code> operation to extract the left and right halves. It is important to note that the list may not have an even number of items. That does not matter, as the lengths will differ by at most one.</p> Activity: 5.11.1 Merge Sort<pre><code>def merge_sort(a_list):\n    print(\"Splitting\", a_list)\n    if len(a_list) &gt; 1:\n        mid = len(a_list) // 2\n        left_half = a_list[:mid]\n        right_half = a_list[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n        while i &lt; len(left_half) and j &lt; len(right_half):\n            if left_half[i] &lt;= right_half[j]:\n                a_list[k] = left_half[i]\n                i = i + 1\n            else:\n                a_list[k] = right_half[j]\n                j = j + 1\n            k = k + 1\n\n        while i &lt; len(left_half):\n            a_list[k] = left_half[i]\n            i = i + 1\n            k = k + 1\n\n        while j &lt; len(right_half):\n            a_list[k] = right_half[j]\n            j = j + 1\n            k = k + 1\n    print(\"Merging\", a_list)\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nmerge_sort(a_list)\nprint(a_list)\n</code></pre> <p>Once the <code>merge_sort</code> function is invoked on the left half and the right half (lines 8\u20139), it is assumed they are sorted. The rest of the function (lines\u00a011\u201329) is responsible for merging the two smaller sorted lists into a larger sorted list. Notice that the merge operation places the items back into the original list (<code>a_list</code>) one at a time by repeatedly taking the smallest item from the sorted lists. Note that the condition in line 13 (<code>left_half[i] &lt;= right_half[j]</code>) ensures that the algorithm is stable. A stable algorithm maintains the order of duplicate items in a list and is preferred in most cases.</p> <p>The <code>merge_sort</code> function has been augmented with a <code>print</code> statement (line 2) to show the contents of the list being sorted at the start of each invocation. There is also a <code>print</code> statement (line 30) to show the merging process. The transcript shows the result of executing the function on our example list. Note that the list with 44, 55, and 20 will not divide evenly. The first split gives <code>[44]</code> and the second gives <code>[55, 20]</code>. It is easy to see how the splitting process eventually yields a list that can be immediately merged with other sorted lists.</p> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 6 allows you to step through the algorithm.</p> Tracing the Merge Sort<pre><code>def merge_sort(a_list):\n    print(\"Splitting \",a_list)\n    if len(a_list)&gt;1:\n        mid = len(a_list)//2\n        left_half = a_list[:mid]\n        right_half = a_list[mid:]\n        merge_sort(left_half)\n        merge_sort(right_half)\n        i, j, k = 0, 0, 0\n        while i&lt;len(left_half) and j&lt;len(right_half):\n            if left_half[i]&lt;=right_half[j]:\n                a_list[k]=left_half[i]\n                i=i+1\n            else:\n                a_list[k]=right_half[j]\n                j=j+1\n            k=k+1\n        while i&lt;len(left_half):\n            a_list[k]=left_half[i]\n            i=i+1\n            k=k+1\n        while j&lt;len(right_half):\n            a_list[k]=right_half[j]\n            j=j+1\n            k=k+1\n    print(\"Merging \",a_list)\na_list = [54,26,93,17,77,31,44,55,20]\nmerge_sort(a_list)\nprint(a_list)\n</code></pre> <p>In order to analyze the <code>merge_sort</code> function, we need to consider the two distinct processes that make up its implementation. First, the list is split into halves. We already computed (in a binary search) that we can divide a list in half \\(\\log{n}\\) times where \\(n\\) is the length of the list. The second process is the merge. Each item in the list will eventually be processed and placed on the sorted list. So the merge operation which results in a list of size \\(n\\) requires \\(n\\) operations. The result of this analysis is that \\(\\log{n}\\) splits, each of which costs \\(n\\) for a total of \\(n\\log{n}\\) operations. A merge sort is an \\(O(n\\log{n})\\) algorithm.</p> <p>Recall that the slicing operator is \\(O(k)\\) where \\(k\\) is the size of the slice. In order to guarantee that <code>merge_sort</code> will be \\(O(n\\log n)\\) we will need to remove the slice operator. Again, this is possible if we simply pass the starting and ending indices along with the list when we make the recursive call. We leave this as an exercise.</p> <p>It is important to notice that the <code>merge_sort</code> function requires extra space to hold the two halves as they are extracted with the slicing operations. This additional space can be a critical factor if the list is large and can make this sort problematic when working on large data sets.</p> <p>Self Check</p> question_sort_5question_sort_6 <p>Given the following list of numbers:  [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]  which answer illustrates the list to be sorted after 3 recursive calls to mergesort?</p> <ul> <li>answer a: [16, 49, 39, 27, 43, 34, 46, 40]</li> <li>answer b: [21,1]</li> <li>answer c: [21, 1, 26, 45]</li> <li>answer d: [21]</li> </ul> <p>correct: b</p> <ul> <li>feedback a: This is the second half of the list.</li> <li>feedback b: Yes, mergesort will continue to recursively move toward the beginning of the list until it hits a base case.</li> <li>feedback c: Remember mergesort doesn't work on the right half of the list until the left half is completely sorted.</li> <li>feedback d: This is the list after 4 recursive calls</li> </ul> <p>Given the following list of numbers:  [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]  which answer illustrates the first two lists to be merged?</p> <ul> <li>answer a: [21, 1] and [26, 45]</li> <li>answer b: [[1, 2, 9, 21, 26, 28, 29, 45] and [16, 27, 34, 39, 40, 43, 46, 49]</li> <li>answer c: [21] and [1]</li> <li>answer d: [9] and [16]</li> </ul> <p>correct: c</p> <ul> <li>feedback a: The first two lists merged will be base case lists, we have not yet reached a base case.</li> <li>feedback b: These will be the last two lists merged</li> <li>feedback c: The lists [21] and [1] are the first two base cases encountered by mergesort and will therefore be the first two lists merged.</li> <li>feedback d: Although 9 and 16 are next to each other they are in different halves of the list starting with the first split.</li> </ul> <p>We now turn our attention to using a divide and conquer strategy as a way to improve the performance of sorting algorithms. The first algorithm we will study is the merge sort. Merge sort is a recursive algorithm that continually splits a list in half. If the list is empty or has one item, it is sorted by definition (the base case). If the list has more than one item, we split the list and recursively invoke a merge sort on both halves. Once the two halves are sorted, the fundamental operation, called a merge, is performed. Merging is the process of taking two smaller sorted lists and combining them together into a single sorted new list. <code>Figure 10</code> shows our familiar example list as it is being split by <code>merge_sort</code>. <code>Figure 11</code> shows the simple lists, now sorted, as they are merged back together.</p> <p> Figure 10: Splitting the List in a Merge Sort </p> <p> Figure 11: Lists as They Are Merged Together </p> <p>The <code>merge_sort</code> function shown in <code>ActiveCode 1</code> begins by asking the base case question. If the length of the list is less than or equal to one, then we already have a sorted list and no more processing is necessary. If, on the other hand, the length is greater than one, then we use the Python <code>slice</code> operation to extract the left and right halves. It is important to note that the list may not have an even number of items. That does not matter, as the lengths will differ by at most one.</p> Activity: 5.11.1 Merge Sort<pre><code>def merge_sort(a_list):\n    print(\"Splitting\", a_list)\n    if len(a_list) &gt; 1:\n        mid = len(a_list) // 2\n        left_half = a_list[:mid]\n        right_half = a_list[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n        while i &lt; len(left_half) and j &lt; len(right_half):\n            if left_half[i] &lt;= right_half[j]:\n                a_list[k] = left_half[i]\n                i = i + 1\n            else:\n                a_list[k] = right_half[j]\n                j = j + 1\n            k = k + 1\n\n        while i &lt; len(left_half):\n            a_list[k] = left_half[i]\n            i = i + 1\n            k = k + 1\n\n        while j &lt; len(right_half):\n            a_list[k] = right_half[j]\n            j = j + 1\n            k = k + 1\n    print(\"Merging\", a_list)\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nmerge_sort(a_list)\nprint(a_list)\n</code></pre> <p>Once the <code>merge_sort</code> function is invoked on the left half and the right half (lines 8\u20139), it is assumed they are sorted. The rest of the function (lines\u00a011\u201329) is responsible for merging the two smaller sorted lists into a larger sorted list. Notice that the merge operation places the items back into the original list (<code>a_list</code>) one at a time by repeatedly taking the smallest item from the sorted lists. Note that the condition in line 13 (<code>left_half[i] &lt;= right_half[j]</code>) ensures that the algorithm is stable. A stable algorithm maintains the order of duplicate items in a list and is preferred in most cases.</p> <p>The <code>merge_sort</code> function has been augmented with a <code>print</code> statement (line 2) to show the contents of the list being sorted at the start of each invocation. There is also a <code>print</code> statement (line 30) to show the merging process. The transcript shows the result of executing the function on our example list. Note that the list with 44, 55, and 20 will not divide evenly. The first split gives <code>[44]</code> and the second gives <code>[55, 20]</code>. It is easy to see how the splitting process eventually yields a list that can be immediately merged with other sorted lists.</p> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 6 allows you to step through the algorithm.</p> Tracing the Merge Sort<pre><code>def merge_sort(a_list):\n    print(\"Splitting \",a_list)\n    if len(a_list)&gt;1:\n        mid = len(a_list)//2\n        left_half = a_list[:mid]\n        right_half = a_list[mid:]\n        merge_sort(left_half)\n        merge_sort(right_half)\n        i, j, k = 0, 0, 0\n        while i&lt;len(left_half) and j&lt;len(right_half):\n            if left_half[i]&lt;=right_half[j]:\n                a_list[k]=left_half[i]\n                i=i+1\n            else:\n                a_list[k]=right_half[j]\n                j=j+1\n            k=k+1\n        while i&lt;len(left_half):\n            a_list[k]=left_half[i]\n            i=i+1\n            k=k+1\n        while j&lt;len(right_half):\n            a_list[k]=right_half[j]\n            j=j+1\n            k=k+1\n    print(\"Merging \",a_list)\na_list = [54,26,93,17,77,31,44,55,20]\nmerge_sort(a_list)\nprint(a_list)\n</code></pre> <p>In order to analyze the <code>merge_sort</code> function, we need to consider the two distinct processes that make up its implementation. First, the list is split into halves. We already computed (in a binary search) that we can divide a list in half \\(\\log{n}\\) times where \\(n\\) is the length of the list. The second process is the merge. Each item in the list will eventually be processed and placed on the sorted list. So the merge operation which results in a list of size \\(n\\) requires \\(n\\) operations. The result of this analysis is that \\(\\log{n}\\) splits, each of which costs \\(n\\) for a total of \\(n\\log{n}\\) operations. A merge sort is an \\(O(n\\log{n})\\) algorithm.</p> <p>Recall that the slicing operator is \\(O(k)\\) where \\(k\\) is the size of the slice. In order to guarantee that <code>merge_sort</code> will be \\(O(n\\log n)\\) we will need to remove the slice operator. Again, this is possible if we simply pass the starting and ending indices along with the list when we make the recursive call. We leave this as an exercise.</p> <p>It is important to notice that the <code>merge_sort</code> function requires extra space to hold the two halves as they are extracted with the slicing operations. This additional space can be a critical factor if the list is large and can make this sort problematic when working on large data sets.</p> <p>Self Check</p> question_sort_5question_sort_6 <p>Given the following list of numbers:  [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]  which answer illustrates the list to be sorted after 3 recursive calls to mergesort?</p> <ul> <li>answer a: [16, 49, 39, 27, 43, 34, 46, 40]</li> <li>answer b: [21,1]</li> <li>answer c: [21, 1, 26, 45]</li> <li>answer d: [21]</li> </ul> <p>correct: b</p> <ul> <li>feedback a: This is the second half of the list.</li> <li>feedback b: Yes, mergesort will continue to recursively move toward the beginning of the list until it hits a base case.</li> <li>feedback c: Remember mergesort doesn't work on the right half of the list until the left half is completely sorted.</li> <li>feedback d: This is the list after 4 recursive calls</li> </ul> <p>Given the following list of numbers:  [21, 1, 26, 45, 29, 28, 2, 9, 16, 49, 39, 27, 43, 34, 46, 40]  which answer illustrates the first two lists to be merged?</p> <ul> <li>answer a: [21, 1] and [26, 45]</li> <li>answer b: [[1, 2, 9, 21, 26, 28, 29, 45] and [16, 27, 34, 39, 40, 43, 46, 49]</li> <li>answer c: [21] and [1]</li> <li>answer d: [9] and [16]</li> </ul> <p>correct: c</p> <ul> <li>feedback a: The first two lists merged will be base case lists, we have not yet reached a base case.</li> <li>feedback b: These will be the last two lists merged</li> <li>feedback c: The lists [21] and [1] are the first two base cases encountered by mergesort and will therefore be the first two lists merged.</li> <li>feedback d: Although 9 and 16 are next to each other they are in different halves of the list starting with the first split.</li> </ul>"},{"location":"c5/s12/","title":"5.12. \u5feb\u901f\u6392\u5e8f","text":"<p>5.12. The Quicksort</p> \u4e2d\u6587\u82f1\u6587 <p>The quicksort uses divide and conquer to gain the same advantages as the merge sort, while not using additional storage. As a trade-off, however, it is possible that the list may not be divided in half. When this happens, we will see that performance is diminished.</p> <p>A quicksort first selects a value, which is called the pivot value. Although there are many different ways to choose the pivot value, we will simply use the first item in the list. The role of the pivot value is to assist with splitting the list. The actual position where the pivot value belongs in the final sorted list, commonly called the split point, will be used to divide the list for subsequent calls to the quicksort.</p> <p><code>Figure 12</code> shows that 54 will serve as our first pivot value. Since we have looked at this example a few times already, we know that 54 will eventually end up in the position currently holding 31. The partition process will happen next. It will find the split point and at the same time move other items to the appropriate side of the list, either less than or greater than the pivot value.</p> <p> Figure 12: The First Pivot Value for a Quicksort </p> <p>Partitioning begins by locating two position markers\u2014let\u2019s call them <code>left_mark</code> and <code>right_mark</code>\u2014at the beginning and end of the remaining items in the list (positions 1 and 8 in <code>Figure 13</code>). The goal of the partition process is to move items that are on the wrong side with respect to the pivot value while also converging on the split point. <code>Figure 13</code> shows this process as we locate the position of 54.</p> <p> Figure 13: Finding the Split Point for 54 </p> <p>We begin by incrementing <code>left_mark</code> until we locate a value that is greater than the pivot value. We then decrement <code>right_mark</code> until we find a value that is less than the pivot value. At this point we have discovered two items that are out of place with respect to the eventual split point. For our example, this occurs at 93 and 20. Now we can exchange these two items and then repeat the process again.</p> <p>At the point where <code>right_mark</code> becomes less than <code>left_mark</code>, we stop. The position of <code>right_mark</code> is now the split point. The pivot value can be exchanged with the contents of the split point and the pivot value is now in place (<code>Figure 14</code>). In addition, all the items to the left of the split point are less than the pivot value, and all the items to the right of the split point are greater than the pivot value. The list can now be divided at the split point and the quicksort can be invoked recursively on the two halves.</p> <p> Figure 14: Completing the Partition Process to Find the Split Point for 54 </p> <p>The <code>quick_sort</code> function shown in <code>ActiveCode 1</code> invokes a recursive function, <code>quick_sort_helper</code>. <code>quick_sort_helper</code> begins with the same base case as the merge sort. If the length of the list is less than or equal to one, it is already sorted. If it is greater, then it can be partitioned and recursively sorted. The <code>partition</code> function implements the process described earlier.</p> Activity: 5.12.1 Quicksort<pre><code>def quick_sort(a_list):\n    quick_sort_helper(a_list, 0, len(a_list) - 1)\n\n\ndef quick_sort_helper(a_list, first, last):\n    if first &lt; last:\n        split = partition(a_list, first, last)\n        quick_sort_helper(a_list, first, split - 1)\n        quick_sort_helper(a_list, split + 1, last)\n\n\ndef partition(a_list, first, last):\n    pivot_val = a_list[first]\n    left_mark = first + 1\n    right_mark = last\n    done = False\n\n    while not done:\n        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_val:\n            left_mark = left_mark + 1\n        while left_mark &lt;= right_mark and a_list[right_mark] &gt;= pivot_val:\n            right_mark = right_mark - 1\n        if right_mark &lt; left_mark:\n            done = True\n        else:\n            a_list[left_mark], a_list[right_mark] = (\n                a_list[right_mark],\n                a_list[left_mark],\n            )\n    a_list[first], a_list[right_mark] = a_list[right_mark], a_list[first]\n\n    return right_mark\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nquick_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 7 lets you step through the algorithm.</p> Tracing the Quicksort<pre><code>def quick_sort(a_list):\n    quick_sort_helper(a_list, 0, len(a_list) - 1)\n\n\ndef quick_sort_helper(a_list, first, last):\n    if first &lt; last:\n        split = partition(a_list, first, last)\n        quick_sort_helper(a_list, first, split - 1)\n        quick_sort_helper(a_list, split + 1, last)\n\n\ndef partition(a_list, first, last):\n    pivot_val = a_list[first]\n    left_mark = first + 1\n    right_mark = last\n    done = False\n\n    while not done:\n        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_val:\n            left_mark = left_mark + 1\n        while left_mark &lt;= right_mark and a_list[right_mark] &gt;= pivot_val:\n            right_mark = right_mark - 1\n        if right_mark &lt; left_mark:\n            done = True\n        else:\n            a_list[left_mark], a_list[right_mark] = (\n                a_list[right_mark],\n                a_list[left_mark],\n            )\n    a_list[first], a_list[right_mark] = a_list[right_mark], a_list[first]\n\n    return right_mark\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nquick_sort(a_list)\nprint(a_list)\n</code></pre> <p>To analyze the <code>quick_sort</code> function, note that for a list of length \\(n\\), if the partition always occurs in the middle of the list, there will again be \\(\\log{n}\\) divisions. In order to find the split point, each of the \\(n\\) items needs to be checked against the pivot value. The result is \\(n\\log{n}\\). In addition, there is no need for additional memory as in the merge sort process.</p> <p>Unfortunately, in the worst case, the split points may not be in the middle and can be very skewed to the left or the right, leaving a very uneven division. In this case, sorting a list of \\(n\\) items divides into sorting a list of 0 items and a list of \\(n - 1\\) items. Then sorting a list of \\(n - 1\\) divides into a list of size 0 and a list of size \\(n - 2\\), and so on. The result is an \\(O(n^{2})\\) sort with all of the overhead that recursion requires.</p> <p>We mentioned earlier that there are different ways to choose the pivot value. In particular, we can attempt to alleviate some of the potential for an uneven division by using a technique called median of three. To choose the pivot value, we will consider the first, the middle, and the last element in the list. In our example, those are 54, 77, and 20. Now pick the median value, in our case 54, and use it for the pivot value (of course, that was the pivot value we used originally). The idea is that in the case where the first item in the list does not belong toward the middle of the list, the median of three will choose a better \u201cmiddle\u201d value. This will be particularly useful when the original list is somewhat sorted to begin with. We leave the implementation of this pivot value selection as an exercise.</p> <p>Self Check</p> question_sort_7question_sort_8question_sort_9 <p>Given the following list of numbers [14, 17, 13, 15, 19, 10, 3, 16, 9, 12] which answer shows the contents of the list after the second partitioning according to the quicksort algorithm?</p> <ul> <li>answer_a: [9, 3, 10, 13, 12]</li> <li>answer_b: [9, 3, 10, 13, 12, 14]</li> <li>answer_c: [9, 3, 10, 13, 12, 14, 17, 16, 15, 19]</li> <li>answer_d: [9, 3, 10, 13, 12, 14, 19, 16, 15, 17]</li> </ul> <p>correct: d</p> <ul> <li>feedback_a: It's important to remember that quicksort works on the entire list and sorts it in place.</li> <li>feedback_b: Remember quicksort works on the entire list and sorts it in place.</li> <li>feedback_c: The first partitioning works on the entire list, and the second partitioning works on the left partition not the right.</li> <li>feedback_d: The first partitioning works on the entire list, and the second partitioning works on the left partition.</li> </ul> <p>Given the following list of numbers [1, 20, 11, 5, 2, 9, 16, 14, 13, 19] what would be the first pivot value using the median of 3 method?</p> <ul> <li>answer_a: 1</li> <li>answer_b: 9</li> <li>answer_c: 16</li> <li>answer_d: 19</li> </ul> <p>correct: b</p> <ul> <li>feedback_a: The three numbers used in selecting the pivot are 1, 9, 19.  1 is not the median, and would be a very bad choice for the pivot since it is the smallest number in the list.</li> <li>feedback b:  Good job.</li> <li>feedback c: although 16 would be the median of 1, 16, 19 the middle is at len(list) // 2.</li> <li>feedback d: the three numbers used in selecting the pivot are 1, 9, 19.  9 is the median.  19 would be a bad choice since it is almost the largest.</li> </ul> <p>Which of the following sort algorithms are guaranteed to be O(n log n) even in the worst case?</p> <p>multiple_answers:</p> <ul> <li>answer a: Shell Sort</li> <li>answer b: Quick Sort</li> <li>answer c: Merge Sort</li> <li>answer d: Insertion Sort</li> </ul> <p>correct: c</p> <ul> <li>feedback a: Shell sort is about <code>n^1.5</code></li> <li>feedback b: Quicksort can be O(n log n), but if the pivot points are not well chosen and the list is just so, it can be O(n^2).</li> <li>feedback c: Merge Sort is the only guaranteed O(n log n) even in the worst case.  The cost is that merge sort uses more memory.</li> <li>feedback d: Insertion sort is <code>O(n^2)</code></li> </ul> <p>The quicksort uses divide and conquer to gain the same advantages as the merge sort, while not using additional storage. As a trade-off, however, it is possible that the list may not be divided in half. When this happens, we will see that performance is diminished.</p> <p>A quicksort first selects a value, which is called the pivot value. Although there are many different ways to choose the pivot value, we will simply use the first item in the list. The role of the pivot value is to assist with splitting the list. The actual position where the pivot value belongs in the final sorted list, commonly called the split point, will be used to divide the list for subsequent calls to the quicksort.</p> <p><code>Figure 12</code> shows that 54 will serve as our first pivot value. Since we have looked at this example a few times already, we know that 54 will eventually end up in the position currently holding 31. The partition process will happen next. It will find the split point and at the same time move other items to the appropriate side of the list, either less than or greater than the pivot value.</p> <p> Figure 12: The First Pivot Value for a Quicksort </p> <p>Partitioning begins by locating two position markers\u2014let\u2019s call them <code>left_mark</code> and <code>right_mark</code>\u2014at the beginning and end of the remaining items in the list (positions 1 and 8 in <code>Figure 13</code>). The goal of the partition process is to move items that are on the wrong side with respect to the pivot value while also converging on the split point. <code>Figure 13</code> shows this process as we locate the position of 54.</p> <p> Figure 13: Finding the Split Point for 54 </p> <p>We begin by incrementing <code>left_mark</code> until we locate a value that is greater than the pivot value. We then decrement <code>right_mark</code> until we find a value that is less than the pivot value. At this point we have discovered two items that are out of place with respect to the eventual split point. For our example, this occurs at 93 and 20. Now we can exchange these two items and then repeat the process again.</p> <p>At the point where <code>right_mark</code> becomes less than <code>left_mark</code>, we stop. The position of <code>right_mark</code> is now the split point. The pivot value can be exchanged with the contents of the split point and the pivot value is now in place (<code>Figure 14</code>). In addition, all the items to the left of the split point are less than the pivot value, and all the items to the right of the split point are greater than the pivot value. The list can now be divided at the split point and the quicksort can be invoked recursively on the two halves.</p> <p> Figure 14: Completing the Partition Process to Find the Split Point for 54 </p> <p>The <code>quick_sort</code> function shown in <code>ActiveCode 1</code> invokes a recursive function, <code>quick_sort_helper</code>. <code>quick_sort_helper</code> begins with the same base case as the merge sort. If the length of the list is less than or equal to one, it is already sorted. If it is greater, then it can be partitioned and recursively sorted. The <code>partition</code> function implements the process described earlier.</p> Activity: 5.12.1 Quicksort<pre><code>def quick_sort(a_list):\n    quick_sort_helper(a_list, 0, len(a_list) - 1)\n\n\ndef quick_sort_helper(a_list, first, last):\n    if first &lt; last:\n        split = partition(a_list, first, last)\n        quick_sort_helper(a_list, first, split - 1)\n        quick_sort_helper(a_list, split + 1, last)\n\n\ndef partition(a_list, first, last):\n    pivot_val = a_list[first]\n    left_mark = first + 1\n    right_mark = last\n    done = False\n\n    while not done:\n        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_val:\n            left_mark = left_mark + 1\n        while left_mark &lt;= right_mark and a_list[right_mark] &gt;= pivot_val:\n            right_mark = right_mark - 1\n        if right_mark &lt; left_mark:\n            done = True\n        else:\n            a_list[left_mark], a_list[right_mark] = (\n                a_list[right_mark],\n                a_list[left_mark],\n            )\n    a_list[first], a_list[right_mark] = a_list[right_mark], a_list[first]\n\n    return right_mark\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nquick_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 7 lets you step through the algorithm.</p> Tracing the Quicksort<pre><code>def quick_sort(a_list):\n    quick_sort_helper(a_list, 0, len(a_list) - 1)\n\n\ndef quick_sort_helper(a_list, first, last):\n    if first &lt; last:\n        split = partition(a_list, first, last)\n        quick_sort_helper(a_list, first, split - 1)\n        quick_sort_helper(a_list, split + 1, last)\n\n\ndef partition(a_list, first, last):\n    pivot_val = a_list[first]\n    left_mark = first + 1\n    right_mark = last\n    done = False\n\n    while not done:\n        while left_mark &lt;= right_mark and a_list[left_mark] &lt;= pivot_val:\n            left_mark = left_mark + 1\n        while left_mark &lt;= right_mark and a_list[right_mark] &gt;= pivot_val:\n            right_mark = right_mark - 1\n        if right_mark &lt; left_mark:\n            done = True\n        else:\n            a_list[left_mark], a_list[right_mark] = (\n                a_list[right_mark],\n                a_list[left_mark],\n            )\n    a_list[first], a_list[right_mark] = a_list[right_mark], a_list[first]\n\n    return right_mark\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nquick_sort(a_list)\nprint(a_list)\n</code></pre> <p>To analyze the <code>quick_sort</code> function, note that for a list of length \\(n\\), if the partition always occurs in the middle of the list, there will again be \\(\\log{n}\\) divisions. In order to find the split point, each of the \\(n\\) items needs to be checked against the pivot value. The result is \\(n\\log{n}\\). In addition, there is no need for additional memory as in the merge sort process.</p> <p>Unfortunately, in the worst case, the split points may not be in the middle and can be very skewed to the left or the right, leaving a very uneven division. In this case, sorting a list of \\(n\\) items divides into sorting a list of 0 items and a list of \\(n - 1\\) items. Then sorting a list of \\(n - 1\\) divides into a list of size 0 and a list of size \\(n - 2\\), and so on. The result is an \\(O(n^{2})\\) sort with all of the overhead that recursion requires.</p> <p>We mentioned earlier that there are different ways to choose the pivot value. In particular, we can attempt to alleviate some of the potential for an uneven division by using a technique called median of three. To choose the pivot value, we will consider the first, the middle, and the last element in the list. In our example, those are 54, 77, and 20. Now pick the median value, in our case 54, and use it for the pivot value (of course, that was the pivot value we used originally). The idea is that in the case where the first item in the list does not belong toward the middle of the list, the median of three will choose a better \u201cmiddle\u201d value. This will be particularly useful when the original list is somewhat sorted to begin with. We leave the implementation of this pivot value selection as an exercise.</p> <p>Self Check</p> question_sort_7question_sort_8question_sort_9 <p>Given the following list of numbers [14, 17, 13, 15, 19, 10, 3, 16, 9, 12] which answer shows the contents of the list after the second partitioning according to the quicksort algorithm?</p> <ul> <li>answer_a: [9, 3, 10, 13, 12]</li> <li>answer_b: [9, 3, 10, 13, 12, 14]</li> <li>answer_c: [9, 3, 10, 13, 12, 14, 17, 16, 15, 19]</li> <li>answer_d: [9, 3, 10, 13, 12, 14, 19, 16, 15, 17]</li> </ul> <p>correct: d</p> <ul> <li>feedback_a: It's important to remember that quicksort works on the entire list and sorts it in place.</li> <li>feedback_b: Remember quicksort works on the entire list and sorts it in place.</li> <li>feedback_c: The first partitioning works on the entire list, and the second partitioning works on the left partition not the right.</li> <li>feedback_d: The first partitioning works on the entire list, and the second partitioning works on the left partition.</li> </ul> <p>Given the following list of numbers [1, 20, 11, 5, 2, 9, 16, 14, 13, 19] what would be the first pivot value using the median of 3 method?</p> <ul> <li>answer_a: 1</li> <li>answer_b: 9</li> <li>answer_c: 16</li> <li>answer_d: 19</li> </ul> <p>correct: b</p> <ul> <li>feedback_a: The three numbers used in selecting the pivot are 1, 9, 19.  1 is not the median, and would be a very bad choice for the pivot since it is the smallest number in the list.</li> <li>feedback b:  Good job.</li> <li>feedback c: although 16 would be the median of 1, 16, 19 the middle is at len(list) // 2.</li> <li>feedback d: the three numbers used in selecting the pivot are 1, 9, 19.  9 is the median.  19 would be a bad choice since it is almost the largest.</li> </ul> <p>Which of the following sort algorithms are guaranteed to be O(n log n) even in the worst case?</p> <p>multiple_answers:</p> <ul> <li>answer a: Shell Sort</li> <li>answer b: Quick Sort</li> <li>answer c: Merge Sort</li> <li>answer d: Insertion Sort</li> </ul> <p>correct: c</p> <ul> <li>feedback a: Shell sort is about <code>n^1.5</code></li> <li>feedback b: Quicksort can be O(n log n), but if the pivot points are not well chosen and the list is just so, it can be O(n^2).</li> <li>feedback c: Merge Sort is the only guaranteed O(n log n) even in the worst case.  The cost is that merge sort uses more memory.</li> <li>feedback d: Insertion sort is <code>O(n^2)</code></li> </ul>"},{"location":"c5/s13/","title":"5.13. \u603b\u7ed3","text":"<p>5.13. Summary</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>A sequential search is \\(O(n)\\) for ordered and unordered lists.</li> <li>A binary search of an ordered list is \\(O(\\log{n})\\) in the worst case.</li> <li>Hash tables can provide constant time searching.</li> <li>A bubble sort, a selection sort, and an insertion sort are \\(O(n^{2})\\) algorithms.</li> <li>A Shell sort improves on the insertion sort by sorting incremental sublists. It falls between \\(O(n)\\) and \\(O(n^{2})\\).</li> <li>A merge sort is \\(O(n \\log{n})\\), but requires additional space for the merging process.</li> <li>A quicksort is \\(O(n \\log{n})\\), but may degrade to \\(O(n^{2})\\) if the split points are not near the middle of the list. It does not require additional space.</li> </ul> <ul> <li>A sequential search is \\(O(n)\\) for ordered and unordered lists.</li> <li>A binary search of an ordered list is \\(O(\\log{n})\\) in the worst case.</li> <li>Hash tables can provide constant time searching.</li> <li>A bubble sort, a selection sort, and an insertion sort are \\(O(n^{2})\\) algorithms.</li> <li>A Shell sort improves on the insertion sort by sorting incremental sublists. It falls between \\(O(n)\\) and \\(O(n^{2})\\).</li> <li>A merge sort is \\(O(n \\log{n})\\), but requires additional space for the merging process.</li> <li>A quicksort is \\(O(n \\log{n})\\), but may degrade to \\(O(n^{2})\\) if the split points are not near the middle of the list. It does not require additional space.</li> </ul>"},{"location":"c5/s14/","title":"5.14. \u5173\u952e\u672f\u8bed","text":"<p>5.14. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - binary search insertion sort pivot value bubble sort linear probing quadratic probing chaining load factor quicksort clustering map rehashing collision median of three selection sort collision resolution merge sequential search folding method merge sort Shell sort gap mid-square method short bubble hash function open addressing slot hash table partition split point hashing perfect hash function stable algorithm - - - binary search insertion sort pivot value bubble sort linear probing quadratic probing chaining load factor quicksort clustering map rehashing collision median of three selection sort collision resolution merge sequential search folding method merge sort Shell sort gap mid-square method short bubble hash function open addressing slot hash table partition split point hashing perfect hash function stable algorithm"},{"location":"c5/s15/","title":"5.15. \u7ec3\u4e60","text":"<p>5.15. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>Using the hash table performance formulas given in the chapter, compute the average number of comparisons necessary when the table is</p> <ul> <li>10% full</li> <li>25% full</li> <li>50% full</li> <li>75% full</li> <li>90% full</li> <li>99% full</li> </ul> <p>At what point do you think the hash table is too small? Explain.</p> </li> <li> <p>Modify the hash function for strings to use positional weightings.</p> </li> <li>We used a hash function for strings that weighted the characters by position. Devise an alternative weighting scheme. What are the biases that exist with these functions?</li> <li>Research perfect hash functions. Using a list of names (classmates, family members, etc.), generate the hash values using the perfect hash algorithm.</li> <li> <p>Generate a random list of integers. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the list of characters: [<code>\"P\", \"Y\", \"T\", \"H\", \"O\", \"N\"</code>]. Show how this list is sorted using the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Devise alternative strategies for choosing the pivot value in a quicksort. For example, pick the middle item. Reimplement the algorithm and then execute it on random data sets. Under what criteria does your new strategy perform better or worse than the strategy from this chapter?</p> </li> <li>Set up a random experiment to test the difference between a sequential search and a binary search on a list of integers.</li> <li>Use the binary search functions given in the text (recursive and iterative). Generate a random, ordered list of integers and do a benchmark analysis for each one. What are your results? Can you explain them?</li> <li>Implement the binary search using recursion without the slice operator. Recall that you will need to pass the list along with the starting and ending index values for the sublist. Generate a random, ordered list of integers and do a benchmark analysis.</li> <li>Implement the <code>len</code> method (<code>__len__</code>) for the hash table Map ADT implementation.</li> <li>Implement the <code>in</code> method (<code>__contains__</code>) for the hash table Map ADT implementation.</li> <li>How can you delete items from a hash table that uses chaining for collision resolution? How about if open addressing is used? What are the special circumstances that must be handled? Implement the <code>del</code> method for the <code>HashTable</code> class.</li> <li>In the hash table map implementation, the hash table size was chosen to be 101. If the table gets full, this needs to be increased. Re-implement the <code>put</code> method so that the table will automatically resize itself when the loading factor reaches a predetermined value (you can decide the value based on your assessment of load versus performance).</li> <li>Implement quadratic probing as a rehash technique.</li> <li>Using a random number generator, create a list of 500 integers. Perform a benchmark analysis using some of the sorting algorithms from this chapter. What is the difference in execution speed?</li> <li>A bubble sort can be modified to \u201cbubble\u201d in both directions. The first pass moves \u201cup\u201d the list, and the second pass moves \u201cdown.\u201d This alternating pattern continues until no more passes are necessary. Implement this variation and describe under what circumstances it might be appropriate.</li> <li>Perform a benchmark analysis for a shell sort, using different increment sets on the same list.</li> <li>Implement the <code>merge_sort</code> function without using the slice operator.</li> <li>One way to improve the quicksort is to use an insertion sort on lists that have a short length (call it the \u201cpartition limit\u201d). Why does this make sense? Reimplement the quicksort and use it to sort a random list of integers. Perform an analysis using different list sizes for the partition limit.</li> <li>Implement the median of three method for selecting a pivot value as a modification to <code>quick_sort</code>. Run an experiment to compare the two techniques.</li> </ol> <ol> <li> <p>Using the hash table performance formulas given in the chapter, compute the average number of comparisons necessary when the table is</p> <ul> <li>10% full</li> <li>25% full</li> <li>50% full</li> <li>75% full</li> <li>90% full</li> <li>99% full</li> </ul> <p>At what point do you think the hash table is too small? Explain.</p> </li> <li> <p>Modify the hash function for strings to use positional weightings.</p> </li> <li>We used a hash function for strings that weighted the characters by position. Devise an alternative weighting scheme. What are the biases that exist with these functions?</li> <li>Research perfect hash functions. Using a list of names (classmates, family members, etc.), generate the hash values using the perfect hash algorithm.</li> <li> <p>Generate a random list of integers. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show how this list is sorted by the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Consider the list of characters: [<code>\"P\", \"Y\", \"T\", \"H\", \"O\", \"N\"</code>]. Show how this list is sorted using the following algorithms:</p> <ul> <li>bubble sort</li> <li>selection sort</li> <li>insertion sort</li> <li>Shell sort (you decide on the increments)</li> <li>merge sort</li> <li>quicksort (you decide on the pivot value)</li> </ul> </li> <li> <p>Devise alternative strategies for choosing the pivot value in a quicksort. For example, pick the middle item. Reimplement the algorithm and then execute it on random data sets. Under what criteria does your new strategy perform better or worse than the strategy from this chapter?</p> </li> <li>Set up a random experiment to test the difference between a sequential search and a binary search on a list of integers.</li> <li>Use the binary search functions given in the text (recursive and iterative). Generate a random, ordered list of integers and do a benchmark analysis for each one. What are your results? Can you explain them?</li> <li>Implement the binary search using recursion without the slice operator. Recall that you will need to pass the list along with the starting and ending index values for the sublist. Generate a random, ordered list of integers and do a benchmark analysis.</li> <li>Implement the <code>len</code> method (<code>__len__</code>) for the hash table Map ADT implementation.</li> <li>Implement the <code>in</code> method (<code>__contains__</code>) for the hash table Map ADT implementation.</li> <li>How can you delete items from a hash table that uses chaining for collision resolution? How about if open addressing is used? What are the special circumstances that must be handled? Implement the <code>del</code> method for the <code>HashTable</code> class.</li> <li>In the hash table map implementation, the hash table size was chosen to be 101. If the table gets full, this needs to be increased. Re-implement the <code>put</code> method so that the table will automatically resize itself when the loading factor reaches a predetermined value (you can decide the value based on your assessment of load versus performance).</li> <li>Implement quadratic probing as a rehash technique.</li> <li>Using a random number generator, create a list of 500 integers. Perform a benchmark analysis using some of the sorting algorithms from this chapter. What is the difference in execution speed?</li> <li>A bubble sort can be modified to \u201cbubble\u201d in both directions. The first pass moves \u201cup\u201d the list, and the second pass moves \u201cdown.\u201d This alternating pattern continues until no more passes are necessary. Implement this variation and describe under what circumstances it might be appropriate.</li> <li>Perform a benchmark analysis for a shell sort, using different increment sets on the same list.</li> <li>Implement the <code>merge_sort</code> function without using the slice operator.</li> <li>One way to improve the quicksort is to use an insertion sort on lists that have a short length (call it the \u201cpartition limit\u201d). Why does this make sense? Reimplement the quicksort and use it to sort a random list of integers. Perform an analysis using different list sizes for the partition limit.</li> <li>Implement the median of three method for selecting a pivot value as a modification to <code>quick_sort</code>. Run an experiment to compare the two techniques.</li> </ol>"},{"location":"c5/s2/","title":"5.2. \u641c\u7d22","text":"<p>5.2. Searching</p> \u4e2d\u6587\u82f1\u6587 <p>\u73b0\u5728\uff0c\u6211\u4eec\u5c06\u6ce8\u610f\u529b\u8f6c\u5411\u8ba1\u7b97\u4e2d\u6700\u5e38\u89c1\u7684\u4e00\u4e9b\u95ee\u9898\u2014\u2014\u641c\u7d22\u548c\u6392\u5e8f\u3002\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u5b66\u4e60\u641c\u7d22\u3002\u6392\u5e8f\u7684\u95ee\u9898\u6211\u4eec\u5c06\u5728\u672c\u7ae0\u7a0d\u540e\u8ba8\u8bba\u3002\u641c\u7d22\u662f\u6307\u5728\u4e00\u7ec4\u9879\u76ee\u4e2d\u5bfb\u627e\u7279\u5b9a\u9879\u76ee\u7684\u7b97\u6cd5\u8fc7\u7a0b\u3002\u641c\u7d22\u901a\u5e38\u5728\u67e5\u8be2\u67d0\u4e2a\u9879\u76ee\u662f\u5426\u5b58\u5728\u65f6\u8fd4\u56de\u201cTrue\u201d\u6216\u201cFalse\u201d\u3002\u6709\u65f6\uff0c\u641c\u7d22\u53ef\u4ee5\u4fee\u6539\u4e3a\u8fd4\u56de\u627e\u5230\u8be5\u9879\u76ee\u7684\u4f4d\u7f6e\u3002\u5bf9\u4e8e\u6211\u4eec\u76ee\u524d\u7684\u76ee\u7684\uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u6210\u5458\u8d44\u683c\u7684\u95ee\u9898\u3002</p> <p>\u5728 Python \u4e2d\uff0c\u6709\u4e00\u79cd\u975e\u5e38\u7b80\u5355\u7684\u65b9\u6cd5\u53ef\u4ee5\u5224\u65ad\u67d0\u4e2a\u9879\u76ee\u662f\u5426\u5728\u4e00\u7ec4\u9879\u76ee\u4e2d\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>in</code> \u8fd0\u7b97\u7b26\u3002</p> <pre><code>&gt;&gt;&gt; 15 in [3, 5, 2, 4, 1]\nFalse\n&gt;&gt;&gt; 3 in [3, 5, 2, 4, 1]\nTrue\n&gt;&gt;&gt; \n</code></pre> <p>\u867d\u7136\u8fd9\u5f88\u5bb9\u6613\u7f16\u5199\uff0c\u4f46\u5728\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u4e4b\u524d\u5fc5\u987b\u6267\u884c\u4e00\u4e2a\u5e95\u5c42\u7684\u8fc7\u7a0b\u3002\u4e8b\u5b9e\u8bc1\u660e\uff0c\u6709\u8bb8\u591a\u4e0d\u540c\u7684\u65b9\u6cd5\u53ef\u4ee5\u641c\u7d22\u67d0\u4e2a\u9879\u76ee\u3002\u6211\u4eec\u611f\u5174\u8da3\u7684\u662f\u8fd9\u4e9b\u7b97\u6cd5\u662f\u5982\u4f55\u5de5\u4f5c\u7684\uff0c\u4ee5\u53ca\u5b83\u4eec\u5f7c\u6b64\u4e4b\u95f4\u7684\u6bd4\u8f83\u3002</p> <p>We will now turn our attention to some of the most common problems that arise in computing, those of searching and sorting. In this section we will study searching. We will return to sorting later in the chapter. Searching is the algorithmic process of finding a particular item in a collection of items. A search typically returns either <code>True</code> or <code>False</code> when queried on whether an item is present. On occasion a search may be modified to return where the item is found. For our purposes here, we will simply concern ourselves with the question of membership.</p> <p>In Python, there is a very easy way to ask whether an item is in a list of items. We use the <code>in</code> operator.</p> <pre><code>&gt;&gt;&gt; 15 in [3, 5, 2, 4, 1]\nFalse\n&gt;&gt;&gt; 3 in [3, 5, 2, 4, 1]\nTrue\n&gt;&gt;&gt; \n</code></pre> <p>Even though this is easy to write, an underlying process must be carried out to answer the question. It turns out that there are many different ways to search for the item. What we are interested in here is how these algorithms work and how they compare to one another.</p>"},{"location":"c5/s3/","title":"5.3. \u987a\u5e8f\u641c\u7d22","text":"<p>5.3. The Sequential Search</p> \u4e2d\u6587\u82f1\u6587 <p>When data items are stored in a collection such as a list, we say that they have a linear or sequential relationship. Each data item is stored in a position relative to the others. In Python lists, these relative positions are the index values of the individual items. Since these index values are ordered, it is possible for us to visit them in sequence. This process gives rise to our first search technique, the sequential search.</p> <p><code>Figure 1</code>  shows that if we start  at the first item in the list and move from item to item, we follow the underlying sequential order until we either find what we are looking for or run out of items, which would mean the item we were searching for was not present.</p> <p> Figure 1: Sequential Search of a List of Integers </p> <p>The Python implementation for this algorithm is shown in <code>CodeLens 1</code>. The function needs two items--the list and the item we are looking for--and returns a Boolean value as to whether it is present.</p> Activity: CodeLens Sequential Search of an Unordered List (search1)<pre><code>def sequential_search(a_list, item):\n    pos = 0\n\n    while pos &lt; len(a_list):\n        if a_list[pos] == item:\n            return True\n        pos = pos + 1\n\n    return False\n\n\ntest_list = [1, 2, 32, 8, 17, 19, 42, 13, 0]\nprint(sequential_search(test_list, 3))\nprint(sequential_search(test_list, 13))\n</code></pre> <p>When data items are stored in a collection such as a list, we say that they have a linear or sequential relationship. Each data item is stored in a position relative to the others. In Python lists, these relative positions are the index values of the individual items. Since these index values are ordered, it is possible for us to visit them in sequence. This process gives rise to our first search technique, the sequential search.</p> <p><code>Figure 1</code>  shows that if we start  at the first item in the list and move from item to item, we follow the underlying sequential order until we either find what we are looking for or run out of items, which would mean the item we were searching for was not present.</p> <p> Figure 1: Sequential Search of a List of Integers </p> <p>The Python implementation for this algorithm is shown in <code>CodeLens 1</code>. The function needs two items--the list and the item we are looking for--and returns a Boolean value as to whether it is present.</p> Activity: CodeLens Sequential Search of an Unordered List (search1)<pre><code>def sequential_search(a_list, item):\n    pos = 0\n\n    while pos &lt; len(a_list):\n        if a_list[pos] == item:\n            return True\n        pos = pos + 1\n\n    return False\n\n\ntest_list = [1, 2, 32, 8, 17, 19, 42, 13, 0]\nprint(sequential_search(test_list, 3))\nprint(sequential_search(test_list, 13))\n</code></pre>"},{"location":"c5/s3/#531-\u987a\u5e8f\u641c\u7d22\u7684\u5206\u6790","title":"5.3.1. \u987a\u5e8f\u641c\u7d22\u7684\u5206\u6790","text":"<p>5.3.1. Analysis of Sequential Search</p> \u4e2d\u6587\u82f1\u6587 <p>To analyze searching algorithms, we need to decide on a basic unit of computation. Recall that this is typically the common step that must be repeated in order to solve the problem. For searching, it makes sense to count the number of comparisons performed. Each comparison may or may not discover the item we are looking for. In addition, we make another assumption here. The list of items is not ordered in any way. The items have been placed randomly into the list. In other words, the probability that the item we are looking for is in any particular position is exactly the same for each position of the list.</p> <p>If the item is not in the list, the only way to know that is to compare it against every item present. If there are \\(n\\) items, then the sequential search requires \\(n\\) comparisons to discover that the item is not there. In the case where the item is in the list, the analysis is not so straightforward. There are actually three different scenarios that can occur. In the best case we will find the item in the first place we look, at the beginning of the list. We will need only one comparison. In the worst case, we will not discover the item until the very last comparison, the n-th comparison.</p> <p>What about the average case? On average, we will find the item about half way into the list; that is, we will compare against \\(\\frac{n}{2}\\) items. Recall, however, that as \\(n\\) gets large, the coefficients, no matter what they are, become insignificant in our approximation, so the complexity of the sequential search is \\(O(n)\\). <code>Table 1</code> summarizes these results.</p> <p>Table 1: Comparisons Used in a Sequential Search of an Unordered List</p> Case Best Case Worst Case Average Case item is present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) item is not present \\(n\\) \\(n\\) \\(n\\) <p>We assumed earlier that the items in our collection had been randomly placed so that there is no relative order between the items. What would happen to the sequential search if the items were ordered in some way? Would we be able to gain any efficiency in our search technique?</p> <p>Assume that the list of items was constructed so that the items are in ascending order, from low to high. If the item we are looking for is present in the list, the chance of it being in any one of the \\(n\\) positions is still the same as before. We will still have the same number of comparisons to find the item. However, if the item is not present there is a slight advantage. <code>Figure 2</code> shows this process as the algorithm looks for the item 50. Notice that items are still compared in sequence until 54. At this point, however, we know something extra. Not only is 54 not the item we are looking for, but no other elements beyond 54 can work either since the list is sorted. In this case, the algorithm does not have to continue looking through all of the items to report that the item was not found. It can stop immediately. <code>CodeLens 2</code> shows this variation of the sequential search function.</p> <p> Figure 2: Sequential Search of an Ordered List of Integers </p> Activity: CodeLens Sequential Search of an Ordered List (search2)<pre><code>def ordered_sequential_search(a_list, item):\n    pos = 0\n\n    while pos &lt; len(a_list):\n        if a_list[pos] == item:\n            return True\n        if a_list[pos] &gt; item:\n            return False\n        pos = pos + 1\n\n    return False\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\nprint(ordered_sequential_search(test_list, 3))\nprint(ordered_sequential_search(test_list, 13))\n</code></pre> <p><code>Table 2</code> summarizes these results. Note that in the best case we might discover that the item is not in the list by looking at only one item. On average, we will know after looking through only \\(\\frac {n}{2}\\) items. However, this technique is still \\(O(n)\\). In summary, a sequential search is improved by ordering the list only in the case where we do not find the item.</p> <p>Table 2: Comparisons Used in Sequential Search of an Ordered List</p> Best Case Worst Case Average Case item is present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) item not present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) <p>Self Check</p> Q 3Q 4 <p>Suppose you are doing a sequential search of the list [15, 18, 2, 19, 18, 0, 8, 14, 19, 14].  How many comparisons would you need to do in order to find the key 18?</p> <ul> <li>answer a: 5</li> <li>answer b: 10</li> <li>answer c: 4</li> <li>answer d: 2</li> </ul> <p>correct: d</p> <ul> <li>feedback a: Five comparisons would get the second 18 in the list.</li> <li>feedback b: You do not need to search the entire list, only until you find the key you are looking for.</li> <li>feedback c: No, remember in a sequential search you start at the beginning and check each key until you find what you are looking for or exhaust the list.</li> <li>feedback d: In this case only 2 comparisons were needed to find the key.</li> </ul> <p>Suppose you are doing a sequential search of the ordered list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18].  How many comparisons would you need to do in order to find the key 13?</p> <ul> <li>answer a: 10</li> <li>answer b: 5</li> <li>answer c: 7</li> <li>answer d: 6</li> </ul> <p>correct: c</p> <ul> <li>feedback a:  You do not need to search the entire list, since it is ordered you can stop searching when you have compared with a value larger than the key.</li> <li>feedback b: Since 11 is less than the key value 13 you need to keep searching.</li> <li>feedback c: Since 14 is greater than the key value 13 you can stop.</li> <li>feedback d: Because 12 is less than the key value 13 you need to keep going.</li> </ul> <p>To analyze searching algorithms, we need to decide on a basic unit of computation. Recall that this is typically the common step that must be repeated in order to solve the problem. For searching, it makes sense to count the number of comparisons performed. Each comparison may or may not discover the item we are looking for. In addition, we make another assumption here. The list of items is not ordered in any way. The items have been placed randomly into the list. In other words, the probability that the item we are looking for is in any particular position is exactly the same for each position of the list.</p> <p>If the item is not in the list, the only way to know that is to compare it against every item present. If there are \\(n\\) items, then the sequential search requires \\(n\\) comparisons to discover that the item is not there. In the case where the item is in the list, the analysis is not so straightforward. There are actually three different scenarios that can occur. In the best case we will find the item in the first place we look, at the beginning of the list. We will need only one comparison. In the worst case, we will not discover the item until the very last comparison, the n-th comparison.</p> <p>What about the average case? On average, we will find the item about half way into the list; that is, we will compare against \\(\\frac{n}{2}\\) items. Recall, however, that as \\(n\\) gets large, the coefficients, no matter what they are, become insignificant in our approximation, so the complexity of the sequential search is \\(O(n)\\). <code>Table 1</code> summarizes these results.</p> <p>Table 1: Comparisons Used in a Sequential Search of an Unordered List</p> Case Best Case Worst Case Average Case item is present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) item is not present \\(n\\) \\(n\\) \\(n\\) <p>We assumed earlier that the items in our collection had been randomly placed so that there is no relative order between the items. What would happen to the sequential search if the items were ordered in some way? Would we be able to gain any efficiency in our search technique?</p> <p>Assume that the list of items was constructed so that the items are in ascending order, from low to high. If the item we are looking for is present in the list, the chance of it being in any one of the \\(n\\) positions is still the same as before. We will still have the same number of comparisons to find the item. However, if the item is not present there is a slight advantage. <code>Figure 2</code> shows this process as the algorithm looks for the item 50. Notice that items are still compared in sequence until 54. At this point, however, we know something extra. Not only is 54 not the item we are looking for, but no other elements beyond 54 can work either since the list is sorted. In this case, the algorithm does not have to continue looking through all of the items to report that the item was not found. It can stop immediately. <code>CodeLens 2</code> shows this variation of the sequential search function.</p> <p> Figure 2: Sequential Search of an Ordered List of Integers </p> Activity: CodeLens Sequential Search of an Ordered List (search2)<pre><code>def ordered_sequential_search(a_list, item):\n    pos = 0\n\n    while pos &lt; len(a_list):\n        if a_list[pos] == item:\n            return True\n        if a_list[pos] &gt; item:\n            return False\n        pos = pos + 1\n\n    return False\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\nprint(ordered_sequential_search(test_list, 3))\nprint(ordered_sequential_search(test_list, 13))\n</code></pre> <p><code>Table 2</code> summarizes these results. Note that in the best case we might discover that the item is not in the list by looking at only one item. On average, we will know after looking through only \\(\\frac {n}{2}\\) items. However, this technique is still \\(O(n)\\). In summary, a sequential search is improved by ordering the list only in the case where we do not find the item.</p> <p>Table 2: Comparisons Used in Sequential Search of an Ordered List</p> Best Case Worst Case Average Case item is present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) item not present \\(1\\) \\(n\\) \\(\\frac{n}{2}\\) <p>Self Check</p> Q 3Q 4 <p>Suppose you are doing a sequential search of the list [15, 18, 2, 19, 18, 0, 8, 14, 19, 14].  How many comparisons would you need to do in order to find the key 18?</p> <ul> <li>answer a: 5</li> <li>answer b: 10</li> <li>answer c: 4</li> <li>answer d: 2</li> </ul> <p>correct: d</p> <ul> <li>feedback a: Five comparisons would get the second 18 in the list.</li> <li>feedback b: You do not need to search the entire list, only until you find the key you are looking for.</li> <li>feedback c: No, remember in a sequential search you start at the beginning and check each key until you find what you are looking for or exhaust the list.</li> <li>feedback d: In this case only 2 comparisons were needed to find the key.</li> </ul> <p>Suppose you are doing a sequential search of the ordered list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18].  How many comparisons would you need to do in order to find the key 13?</p> <ul> <li>answer a: 10</li> <li>answer b: 5</li> <li>answer c: 7</li> <li>answer d: 6</li> </ul> <p>correct: c</p> <ul> <li>feedback a:  You do not need to search the entire list, since it is ordered you can stop searching when you have compared with a value larger than the key.</li> <li>feedback b: Since 11 is less than the key value 13 you need to keep searching.</li> <li>feedback c: Since 14 is greater than the key value 13 you can stop.</li> <li>feedback d: Because 12 is less than the key value 13 you need to keep going.</li> </ul>"},{"location":"c5/s4/","title":"5.4. \u4e8c\u5206\u641c\u7d22","text":"<p>5.4. The Binary Search</p> \u4e2d\u6587\u82f1\u6587 <p>It is possible to take greater advantage of the ordered list if we are clever with our comparisons. In the sequential search, when we compare against the first item, there are at most :math:<code>n-1</code> more items to look through if the first item is not what we are looking for. Instead of searching the list in sequence, a binary search will start by examining the middle item. If that item is the one we are searching for, we are done. If it is not the correct item, we can use the ordered nature of the list to eliminate half of the remaining items. If the item we are searching for is greater than the middle item, we know that the entire first (left) half of the list as well as the middle item can be eliminated from further consideration. The item, if it is in the list, must be in the second (right) half.</p> <p>We can then repeat the process with the left half. Start at the middle item and compare it against what we are looking for. Again, we either find it or split the list in half, therefore eliminating another large part of our possible search space. <code>Figure 3</code> shows how this algorithm can quickly find the value 54. The complete function is shown in <code>CodeLens 3</code>.</p> <p> Figure 3: Binary Search of an Ordered List of Integers </p> Activity: CodeLens Binary Search of an Ordered List (search3)<pre><code>def binary_search(a_list, item):\n    first = 0\n    last = len(a_list) - 1\n\n    while first &lt;= last:\n        midpoint = (first + last) // 2\n        if a_list[midpoint] == item:\n            return True\n        elif item &lt; a_list[midpoint]:\n            last = midpoint - 1\n        else:\n            first = midpoint + 1\n\n    return False\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n\nprint(binary_search(test_list, 3))\nprint(binary_search(test_list, 13))\n</code></pre> <p>Before we move on to the analysis, we should note that this algorithm is a great example of a divide and conquer strategy. Divide and conquer means that we divide the problem into smaller pieces, solve the smaller pieces in some way, and then reassemble the whole problem to get the result. When we perform a binary search of a list, we first check the middle item. If the item we are searching for is less than the middle item, we can simply perform a binary search of the left half of the original list. Likewise, if the item is greater, we can perform a binary search of the right half. Either way, this is a recursive call to the binary search function passing a smaller list. <code>CodeLens 4</code> shows this recursive version.</p> Activity: CodeLens A Binary Search--Recursive Version (search4)<pre><code>def binary_search_rec(a_list, item):\n    if len(a_list) == 0:\n        return False\n    midpoint = len(a_list) // 2\n    if a_list[midpoint] == item:\n        return True\n    elif item &lt; a_list[midpoint]:\n        return binary_search_rec(a_list[:midpoint], item)\n    else:\n        return binary_search_rec(a_list[midpoint + 1 :], item)\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n\nprint(binary_search_rec(test_list, 3))\nprint(binary_search_rec(test_list, 13))\n</code></pre> <p>It is possible to take greater advantage of the ordered list if we are clever with our comparisons. In the sequential search, when we compare against the first item, there are at most :math:<code>n-1</code> more items to look through if the first item is not what we are looking for. Instead of searching the list in sequence, a binary search will start by examining the middle item. If that item is the one we are searching for, we are done. If it is not the correct item, we can use the ordered nature of the list to eliminate half of the remaining items. If the item we are searching for is greater than the middle item, we know that the entire first (left) half of the list as well as the middle item can be eliminated from further consideration. The item, if it is in the list, must be in the second (right) half.</p> <p>We can then repeat the process with the left half. Start at the middle item and compare it against what we are looking for. Again, we either find it or split the list in half, therefore eliminating another large part of our possible search space. <code>Figure 3</code> shows how this algorithm can quickly find the value 54. The complete function is shown in <code>CodeLens 3</code>.</p> <p> Figure 3: Binary Search of an Ordered List of Integers </p> Activity: CodeLens Binary Search of an Ordered List (search3)<pre><code>def binary_search(a_list, item):\n    first = 0\n    last = len(a_list) - 1\n\n    while first &lt;= last:\n        midpoint = (first + last) // 2\n        if a_list[midpoint] == item:\n            return True\n        elif item &lt; a_list[midpoint]:\n            last = midpoint - 1\n        else:\n            first = midpoint + 1\n\n    return False\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n\nprint(binary_search(test_list, 3))\nprint(binary_search(test_list, 13))\n</code></pre> <p>Before we move on to the analysis, we should note that this algorithm is a great example of a divide and conquer strategy. Divide and conquer means that we divide the problem into smaller pieces, solve the smaller pieces in some way, and then reassemble the whole problem to get the result. When we perform a binary search of a list, we first check the middle item. If the item we are searching for is less than the middle item, we can simply perform a binary search of the left half of the original list. Likewise, if the item is greater, we can perform a binary search of the right half. Either way, this is a recursive call to the binary search function passing a smaller list. <code>CodeLens 4</code> shows this recursive version.</p> Activity: CodeLens A Binary Search--Recursive Version (search4)<pre><code>def binary_search_rec(a_list, item):\n    if len(a_list) == 0:\n        return False\n    midpoint = len(a_list) // 2\n    if a_list[midpoint] == item:\n        return True\n    elif item &lt; a_list[midpoint]:\n        return binary_search_rec(a_list[:midpoint], item)\n    else:\n        return binary_search_rec(a_list[midpoint + 1 :], item)\n\n\ntest_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]\n\nprint(binary_search_rec(test_list, 3))\nprint(binary_search_rec(test_list, 13))\n</code></pre>"},{"location":"c5/s4/#541-\u4e8c\u5206\u641c\u7d22\u7684\u5206\u6790","title":"5.4.1. \u4e8c\u5206\u641c\u7d22\u7684\u5206\u6790","text":"<p>5.4.1. Analysis of Binary Search</p> \u4e2d\u6587\u82f1\u6587 <p>To analyze the binary search algorithm, we need to recall that each comparison eliminates about half of the remaining items from consideration. What is the maximum number of comparisons this algorithm will require to check the entire list? If we start with \\(n\\) items, about \\(\\frac{n}{2}\\) items will be left after the first comparison. After the second comparison, there will be about \\(\\frac{n}{4}\\). Then \\(\\frac{n}{8}\\), \\(\\frac{n}{16}\\), and so on. How many times can we split the list? <code>Table 3</code> helps us to see the answer.</p> <p>Table 3: Tabular Analysis for a Binary Search</p> Comparisons Approximate Number of Items Left 1 \\(\\frac {n}{2}\\) 2 \\(\\frac {n}{4}\\) 3 \\(\\frac {n}{8}\\) ... \\(i\\) \\(\\frac {n}{2^i}\\) <p>When we split the list enough times, we end up with a list that has just one item. Either that is the item we are looking for or it is not. Either way, we are done. The number of comparisons necessary to get to this point is \\(i\\) where \\(\\frac {n}{2^i} =1\\). Solving for \\(i\\) gives us \\(i=\\log{n}\\). The maximum number of comparisons is logarithmic with respect to the number of items in the list. Therefore, the binary search is \\(O(\\log{n})\\).</p> <p>One additional analysis issue needs to be addressed. In the recursive solution shown above, the recursive call</p> <p><code>binary_search_rec(a_list[:midpoint], item)</code></p> <p>uses slicing operator to create the left half of the list that is then passed to the next invocation (similarly for the right half as well). The analysis that we did above assumed that slicing takes constant time. However, we know that in Python it is actually \\(O(k)\\). This means that the binary search using slicing will not perform in strict logarithmic time. Luckily this can be remedied by passing the list along with the starting and ending indices. The indices can be calculated as we did in <code>Listing 3</code>. We leave this implementation as an exercise.</p> <p>Even though a binary search is generally better than a sequential search, it is important to note that for small values of \\(n\\), the additional cost of sorting is probably not worth it. In fact, we should always consider whether it is cost effective to take on the extra work of sorting to gain searching benefits. If we can sort once and then search many times, the cost of the sort is not so significant. However, for large lists, sorting even once can be so expensive that simply performing a sequential search from the start may be the best choice.</p> <p>Self Check</p> Q 3Q 4 <p>Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm.  Which group of numbers correctly shows the sequence of comparisons used to find the key 8.</p> <ul> <li>answer a: 11, 5, 6, 8</li> <li>answer b: 12, 6, 11, 8</li> <li>answer c: 3, 5, 6, 8</li> <li>answer d: 18, 12, 6, 8</li> </ul> <p>correct: b</p> <ul> <li>feedback a:  Looks like you might be guilty of an off-by-one error.  Remember the first position is index 0.</li> <li>feedback b:  Binary search starts at the midpoint and halves the list each time.</li> <li>feedback c: Binary search does not start at the beginning and search sequentially, its starts in the middle and halves the list after each compare.</li> <li>feedback d: It appears that you are starting from the end and halving the list each time.</li> </ul> <p>Suppose you have the following sorted list [3, 5, 6, 8, 11, 12, 14, 15, 17, 18] and are using the recursive binary search algorithm.  Which group of numbers correctly shows the sequence of comparisons used to search for the key 16?</p> <ul> <li>answer a: 11, 14, 17</li> <li>answer b: 18, 17, 15</li> <li>answer c: 14, 17, 15</li> <li>answer d: 12, 17, 15</li> </ul> <p>correct: d</p> <ul> <li>feedback a:  Looks like you might be guilty of an off-by-one error.  Remember the first position is index 0.</li> <li>feedback b:  Remember binary search starts in the middle and halves the list.</li> <li>feedback c:  Looks like you might be off by one, be careful that you are calculating the midpont using integer arithmetic.</li> <li>feedback d:  Binary search starts at the midpoint and halves the list each time. It is done when the list is empty.</li> </ul>"},{"location":"c5/s5/","title":"5.5. \u54c8\u5e0c","text":"<p>5.5. Hashing</p> \u4e2d\u6587\u82f1\u6587 <p>In previous sections we were able to make improvements in our search algorithms by taking advantage of information about where items are stored in the collection with respect to one another. For example, by knowing that a list was ordered, we could search in logarithmic time using a binary search. In this section we will attempt to go one step further by building a data structure that can be searched in \\(O(1)\\) time. This concept is referred to as hashing.</p> <p>In order to do this, we will need to know even more about where the items might be when we go to look for them in the collection. If every item is where it should be, then the search can use a single comparison to discover the presence of an item. We will see, however, that this is typically not the case.</p> <p>A hash table is a collection of items which are stored in such a way as to make it easy to find them later. Each position of the hash table, often called a slot, can hold an item and is named by an integer value starting at 0. For example, we will have a slot named 0, a slot named 1, a slot named 2, and so on. Initially, the hash table contains no items so every slot is empty. We can implement a hash table by using a list with each element initialized to the special Python value <code>None</code>. <code>Figure 4</code> shows a hash table of size \\(m = 11\\). In other words, there are \\(m\\) slots in the table, named 0 through 10.</p> <p> Figure 4: Hash Table with 11 Empty Slots </p> <p>The mapping between an item and the slot where that item belongs in the hash table is called the hash function. The hash function will take any item in the collection and return an integer in the range of slot names between 0 and \\(m - 1\\). Assume that we have the set of integer items 54, 26, 93, 17, 77, and 31. Our first hash function, sometimes referred to as the remainder method, simply takes an item and divides it by the table size, returning the remainder as its hash value (\\(h(item)=item \\% 11\\)). \\(Table 4\\) gives all of the hash values for our example items. Note that this remainder method (modulo) will typically be present in some form in all hash functions since the result must be in the range of slot names.</p> <p>Table 4: Simple Hash Function Using Remainders</p> Item Hash Value 54 10 26 4 93 5 17 6 77 0 31 9 <p>Once the hash values have been computed, we can insert each item into the hash table at the designated position as shown in <code>Figure 5</code>. Note that 6 of the 11 slots are now occupied. This is referred to as the load factor, and is commonly denoted by \\(\\lambda = \\frac {number\\_of\\_items}{table\\_size}\\). For this example, \\(\\lambda = \\frac {6}{11}\\).</p> <p> Figure 5: Hash Table with Six Items </p> <p>Now when we want to search for an item, we simply use the hash function to compute the slot name for the item and then check the hash table to see if it is present. This searching operation is \\(O(1)\\) since a constant amount of time is required to compute the hash value and then index the hash table at that location. If everything is where it should be, we have found a constant time search algorithm.</p> <p>You can probably already see that this technique is going to work only if each item maps to a unique location in the hash table. For example, if the item 44 had been the next item in our collection, it would have a hash value of 0 (\\(44\\ \\%\\ 11 = 0\\)). Since 77 also had a hash value of 0, we would have a problem. According to the hash function, two or more items would need to be in the same slot. This is referred to as a collision (it may also be called a clash). Clearly, collisions create a problem for the hashing technique. We will discuss them in detail later.</p> <p>In previous sections we were able to make improvements in our search algorithms by taking advantage of information about where items are stored in the collection with respect to one another. For example, by knowing that a list was ordered, we could search in logarithmic time using a binary search. In this section we will attempt to go one step further by building a data structure that can be searched in \\(O(1)\\) time. This concept is referred to as hashing.</p> <p>In order to do this, we will need to know even more about where the items might be when we go to look for them in the collection. If every item is where it should be, then the search can use a single comparison to discover the presence of an item. We will see, however, that this is typically not the case.</p> <p>A hash table is a collection of items which are stored in such a way as to make it easy to find them later. Each position of the hash table, often called a slot, can hold an item and is named by an integer value starting at 0. For example, we will have a slot named 0, a slot named 1, a slot named 2, and so on. Initially, the hash table contains no items so every slot is empty. We can implement a hash table by using a list with each element initialized to the special Python value <code>None</code>. <code>Figure 4</code> shows a hash table of size \\(m = 11\\). In other words, there are \\(m\\) slots in the table, named 0 through 10.</p> <p> Figure 4: Hash Table with 11 Empty Slots </p> <p>The mapping between an item and the slot where that item belongs in the hash table is called the hash function. The hash function will take any item in the collection and return an integer in the range of slot names between 0 and \\(m - 1\\). Assume that we have the set of integer items 54, 26, 93, 17, 77, and 31. Our first hash function, sometimes referred to as the remainder method, simply takes an item and divides it by the table size, returning the remainder as its hash value (\\(h(item)=item \\% 11\\)). \\(Table 4\\) gives all of the hash values for our example items. Note that this remainder method (modulo) will typically be present in some form in all hash functions since the result must be in the range of slot names.</p> <p>Table 4: Simple Hash Function Using Remainders</p> Item Hash Value 54 10 26 4 93 5 17 6 77 0 31 9 <p>Once the hash values have been computed, we can insert each item into the hash table at the designated position as shown in <code>Figure 5</code>. Note that 6 of the 11 slots are now occupied. This is referred to as the load factor, and is commonly denoted by \\(\\lambda = \\frac {number\\_of\\_items}{table\\_size}\\). For this example, \\(\\lambda = \\frac {6}{11}\\).</p> <p> Figure 5: Hash Table with Six Items </p> <p>Now when we want to search for an item, we simply use the hash function to compute the slot name for the item and then check the hash table to see if it is present. This searching operation is \\(O(1)\\) since a constant amount of time is required to compute the hash value and then index the hash table at that location. If everything is where it should be, we have found a constant time search algorithm.</p> <p>You can probably already see that this technique is going to work only if each item maps to a unique location in the hash table. For example, if the item 44 had been the next item in our collection, it would have a hash value of 0 (\\(44\\ \\%\\ 11 = 0\\)). Since 77 also had a hash value of 0, we would have a problem. According to the hash function, two or more items would need to be in the same slot. This is referred to as a collision (it may also be called a clash). Clearly, collisions create a problem for the hashing technique. We will discuss them in detail later.</p>"},{"location":"c5/s5/#551-\u54c8\u5e0c\u51fd\u6570","title":"5.5.1. \u54c8\u5e0c\u51fd\u6570","text":"<p>5.5.1. Hash Functions</p> \u4e2d\u6587\u82f1\u6587 <p>Given a collection of items, a hash function that maps each item into a unique slot is referred to as a perfect hash function. If we know the items and the collection will never change, then it is possible to construct a perfect hash function. Unfortunately, given an arbitrary collection of items, there is no systematic way to construct a perfect hash function. Luckily, we do not need the hash function to be perfect to still gain performance efficiency.</p> <p>One way to always have a perfect hash function is to increase the size of the hash table so that each possible value in the item range can be accommodated. This guarantees that each item will have a unique slot. Although this is practical for small numbers of items, it is not feasible when the number of possible items is large. For example, if the items were nine-digit Social Security numbers, this method would require almost one billion slots. If we only want to store data for a class of 25 students, we will be wasting an enormous amount of memory.</p> <p>Our goal is to create a hash function that minimizes the number of collisions, is easy to compute, and evenly distributes the items in the hash table. To that end, there are a number of common ways to extend the simple remainder method. We will consider a few of them here.</p> <p>The folding method for constructing hash functions begins by dividing the item into equal-sized pieces (the last piece may not be of equal size). These pieces are then added together to give the resulting hash value. For example, if our item was the phone number 436-555-4601, we would take the digits and divide them into groups of 2 (43, 65, 55, 46, 01). After the addition, \\(43 + 65 + 55 + 46 + 01\\), we get 1.   If we assume our hash table has 11 slots, then we need to perform the extra step of dividing by 11 and keeping the remainder. In this case \\(210\\ \\%\\ 11\\) is 1, so the phone number 436-555-4601 hashes to slot 1. Some folding methods go one step further and reverse every other piece before the addition. For the above example, we get \\(43 + 56 + 55 + 64 + 01 = 219\\) which gives \\(219\\ \\%\\ 11 = 10\\).</p> <p>Another numerical technique for constructing a hash function is called the mid-square method. We first square the item, and then extract some portion of the resulting digits. For example, if the item were 44, we would first compute \\(44 ^{2} = 1936\\). By extracting the middle two digits, 93, and performing the remainder step, we get 5 (\\(93\\ \\%\\ 11\\)). <code>Table 5</code> shows items under both the remainder method and the mid-square method. You should verify that you understand how these values were computed.</p> <p>Table 5: Comparison of Remainder and Mid-Square Methods</p> Item Remainder Mid-Square 54 10 3 26 4 7 93 5 9 17 6 8 77 0 4 31 9 6 <p>We can also create hash functions for character-based items such as strings. For example, the word cat can be thought of as a sequence of ordinal values.</p> <pre><code>&gt;&gt;&gt; ord(\"c\")\n99\n&gt;&gt;&gt; ord(\"a\")\n97\n&gt;&gt;&gt; ord(\"t\")\n116\n</code></pre> <p>We can then take these three ordinal values, add them up, and use the remainder method to get a hash value (see <code>Figure 6</code>). <code>Listing 1</code> shows a function called <code>hash_str</code> that takes a string and a table size and returns the hash value in the range from 0 to <code>table_size</code>-1.</p> <p> Figure 6: Hashing a String Using Ordinal Values </p> **Listing 1**<pre><code>def hash_str(a_string, table_size):\n    return sum([ord(c) for c in a_string]) % table_size\n</code></pre> <p>It is interesting to note that when using this hash function, anagrams will always be given the same hash value. To remedy this, we could use the position of the character as a weight. <code>Figure 7</code> shows one possible way to use the positional value as a weighting factor. The modification to the <code>hash_str</code> function is left as an exercise.</p> <p> Figure 7: Hashing a String Using Ordinal Values with Weighting </p> <p>You may be able to think of a number of additional ways to compute hash values for items in a collection. The important thing to remember is that the hash function has to be efficient so that it does not become the dominant part of the storage and search process. If the hash function is too complex, then it becomes more work to compute the slot name than it would be to simply do a basic sequential or binary search as described earlier. This would quickly defeat the purpose of hashing.</p> <p>Given a collection of items, a hash function that maps each item into a unique slot is referred to as a perfect hash function. If we know the items and the collection will never change, then it is possible to construct a perfect hash function. Unfortunately, given an arbitrary collection of items, there is no systematic way to construct a perfect hash function. Luckily, we do not need the hash function to be perfect to still gain performance efficiency.</p> <p>One way to always have a perfect hash function is to increase the size of the hash table so that each possible value in the item range can be accommodated. This guarantees that each item will have a unique slot. Although this is practical for small numbers of items, it is not feasible when the number of possible items is large. For example, if the items were nine-digit Social Security numbers, this method would require almost one billion slots. If we only want to store data for a class of 25 students, we will be wasting an enormous amount of memory.</p> <p>Our goal is to create a hash function that minimizes the number of collisions, is easy to compute, and evenly distributes the items in the hash table. To that end, there are a number of common ways to extend the simple remainder method. We will consider a few of them here.</p> <p>The folding method for constructing hash functions begins by dividing the item into equal-sized pieces (the last piece may not be of equal size). These pieces are then added together to give the resulting hash value. For example, if our item was the phone number 436-555-4601, we would take the digits and divide them into groups of 2 (43, 65, 55, 46, 01). After the addition, \\(43 + 65 + 55 + 46 + 01\\), we get 1.   If we assume our hash table has 11 slots, then we need to perform the extra step of dividing by 11 and keeping the remainder. In this case \\(210\\ \\%\\ 11\\) is 1, so the phone number 436-555-4601 hashes to slot 1. Some folding methods go one step further and reverse every other piece before the addition. For the above example, we get \\(43 + 56 + 55 + 64 + 01 = 219\\) which gives \\(219\\ \\%\\ 11 = 10\\).</p> <p>Another numerical technique for constructing a hash function is called the mid-square method. We first square the item, and then extract some portion of the resulting digits. For example, if the item were 44, we would first compute \\(44 ^{2} = 1936\\). By extracting the middle two digits, 93, and performing the remainder step, we get 5 (\\(93\\ \\%\\ 11\\)). <code>Table 5</code> shows items under both the remainder method and the mid-square method. You should verify that you understand how these values were computed.</p> <p>Table 5: Comparison of Remainder and Mid-Square Methods</p> Item Remainder Mid-Square 54 10 3 26 4 7 93 5 9 17 6 8 77 0 4 31 9 6 <p>We can also create hash functions for character-based items such as strings. For example, the word cat can be thought of as a sequence of ordinal values.</p> <pre><code>&gt;&gt;&gt; ord(\"c\")\n99\n&gt;&gt;&gt; ord(\"a\")\n97\n&gt;&gt;&gt; ord(\"t\")\n116\n</code></pre> <p>We can then take these three ordinal values, add them up, and use the remainder method to get a hash value (see <code>Figure 6</code>). <code>Listing 1</code> shows a function called <code>hash_str</code> that takes a string and a table size and returns the hash value in the range from 0 to <code>table_size</code>-1.</p> <p> Figure 6: Hashing a String Using Ordinal Values </p> **Listing 1**<pre><code>def hash_str(a_string, table_size):\n    return sum([ord(c) for c in a_string]) % table_size\n</code></pre> <p>It is interesting to note that when using this hash function, anagrams will always be given the same hash value. To remedy this, we could use the position of the character as a weight. <code>Figure 7</code> shows one possible way to use the positional value as a weighting factor. The modification to the <code>hash_str</code> function is left as an exercise.</p> <p> Figure 7: Hashing a String Using Ordinal Values with Weighting </p> <p>You may be able to think of a number of additional ways to compute hash values for items in a collection. The important thing to remember is that the hash function has to be efficient so that it does not become the dominant part of the storage and search process. If the hash function is too complex, then it becomes more work to compute the slot name than it would be to simply do a basic sequential or binary search as described earlier. This would quickly defeat the purpose of hashing.</p>"},{"location":"c5/s5/#552-\u78b0\u649e\u89e3\u51b3","title":"5.5.2. \u78b0\u649e\u89e3\u51b3","text":"<p>5.5.2. Collision Resolution</p> \u4e2d\u6587\u82f1\u6587 <p>We now return to the problem of collisions. When two items hash to the same slot, we must have a systematic method for placing the second item in the hash table. This process is called collision resolution. As we stated earlier, if the hash function is perfect, collisions will never occur. However, since this is often not possible, collision resolution becomes a very important part of hashing.</p> <p>One method for resolving collisions looks into the hash table and tries to find another open slot to hold the item that caused the collision. A simple way to do this is to start at the original hash value position and then move in a sequential manner through the slots until we encounter the first slot that is empty. Note that we may need to go back to the first slot (circularly) to cover the entire hash table. This collision resolution process is referred to as open addressing in that it tries to find the next open slot or address in the hash table. By systematically visiting each slot one at a time, we are performing an open addressing technique called linear probing.</p> <p><code>Figure 8</code> shows an extended set of integer items under the simple remainder method hash function (54, 26, 93, 17, 77, 31, 44, 55, 20). <code>Table 4</code> above shows the hash values for the original six items and <code>Figure 5</code> shows the contents of a hash table with those six items. Let's see what happens when we attempt to place the additional three items into the table. When we attempt to place 44 into slot 0, a collision occurs. Under linear probing, we look sequentially, slot by slot, until we find an open position. In this case, we find slot 1.</p> <p>Again, 55 should go in slot 0 but must be placed in slot 2 since it is the next open position. The final value of 20 hashes to slot 9. Since slot 9 is full, we begin to do linear probing. We visit slots 10, 0, 1, and 2, and finally find an empty slot at position 3.</p> <p> Figure 8: Collision Resolution with Linear Probing </p> <p>Once we have built a hash table using open addressing and linear probing, it is essential that we utilize the same methods to search for items. Assume we want to look up the item 93. When we compute the hash value, we get 5. Looking in slot 5 reveals 93, and we can return <code>True</code>. What if we are looking for 20? Now the hash value is 9, and slot 9 is currently holding 31. We cannot simply return <code>False</code> since we know that there could have been collisions. We are now forced to do a sequential search, starting at position 10, looking until either we find the item 20 or we find an empty slot.</p> <p>A disadvantage to linear probing is the tendency for clustering; items become clustered in the table. This means that if many collisions occur at the same hash value, a number of surrounding slots will be filled by the linear probing resolution. This will have an impact on other items that are being inserted, as we saw when we tried to add the item 20 above. A cluster of values hashing to 0 had to be skipped to finally find an open position. This cluster is shown in <code>Figure 9</code>.</p> <p> Figure 9: A Cluster of Items for Slot 0 </p> <p>One way to deal with clustering is to extend the linear probing technique so that instead of looking sequentially for the next open slot, we skip slots, thereby more evenly distributing the items that have caused collisions. This will potentially reduce the clustering that occurs. <code>Figure 10</code> shows the items when collision resolution is done with what we will call a \u201cplus 3\u201d probe. This means that once a collision occurs, we will look at every third slot until we find one that is empty.</p> <p> Figure 10: Collision Resolution Using a Plus 3 Probe </p> <p>The general name for this process of looking for another slot after a collision is rehashing. With simple linear probing, the rehash function is \\(new\\_hash = rehash(old\\_hash)\\) where \\(rehash(pos) = (pos + 1) \\% size\\). The plus 3 rehash can be defined as \\(rehash(pos) = (pos + 3) \\% size\\). In general, \\(rehash(pos) = (pos + skip) \\% size\\). It is important to note that the size of the skip must be such that all the slots in the table will eventually be visited. Otherwise, part of the table will be unused. To ensure this, it is often suggested that the table size be a prime number. This is the reason we have been using 11 in our examples.</p> <p>A variation of the linear probing idea is called quadratic probing. Instead of using a constant skip value, we use a rehash function that increments the hash value by 1, 3, 5, 7, 9, and so on. This means that if the first hash value is \\(h\\), the successive values are \\(h + 1\\), \\(h + 4\\), \\(h + 9\\), \\(h + 16\\), and so on. In general, the \\(i\\) will be \\(i ^ {2}\\) and \\(rehash(pos) = (h + i ^ {2}) \\% size\\). In other words, quadratic probing uses a skip consisting of successive perfect squares. <code>Figure 11</code> shows our example values after they are placed using this technique.</p> <p> Figure 11: Collision Resolution with Quadratic Probing </p> <p>An alternative method for handling the collision problem is to allow each slot to hold a reference to a collection (or chain) of items. Chaining allows many items to exist at the same location in the hash table. When collisions happen, the item is still placed in the proper slot of the hash table. As more and more items hash to the same location, the difficulty of searching for the item in the collection increases. <code>Figure 12</code> shows the items as they are added to a hash table that uses chaining to resolve collisions.</p> <p> Figure 12: Collision Resolution with Chaining </p> <p>When we want to search for an item, we use the hash function to generate the slot where it should reside. Since with chaining each slot holds a collection, we use a searching technique to decide whether the item is present. The advantage is that on the average there are likely to be many fewer items in each slot, so the search is perhaps more efficient. We will look at the analysis for hashing at the end of this section.</p> <p>Self Check</p> HASH_1HASH_2 <p>In a hash table of size 13 which index positions would the following two keys map to?  27,  130</p> <ul> <li>answer a: 1, 10</li> <li>answer b: 13, 0</li> <li>answer c: 1, 0</li> <li>answer d: 2, 3</li> </ul> <p>correct: c</p> <ul> <li>feedback a:  Be careful to use modulo not integer division</li> <li>feedback b:  Don't divide by two, use the modulo operator.</li> <li>feedback c: 27 % 13 == 1 and 130 % 13 == 0</li> <li>feedback d: Use the modulo operator</li> </ul> <p>Suppose you are given the following set of keys to insert into a hash table that holds exactly 11 values:  113 , 117 , 97 , 100 , 114 , 108 , 116 , 105 , 99 Which of the following best demonstrates the contents of the hash table after all the keys have been inserted using linear probing?</p> <ul> <li>answer a: 100, , , 113, 114, 105, 116, 117, 97, 108, 99</li> <li>answer b: 99, 100, , 113, 114, , 116, 117, 105, 97, 108</li> <li>answer c: 100, 113, 117, 97, 14, 108, 116, 105, 99, , </li> <li>answer d: 117, 114, 108, 116, 105, 99, , , 97, 100, 113</li> </ul> <p>correct: b</p> <ul> <li>feedback a:  It looks like you may have been doing modulo 2 arithmentic.  You need to use the hash table size as the modulo value.</li> <li>feedback b:  Using modulo 11 arithmetic and linear probing gives these values</li> <li>feedback c: It looks like you are using modulo 10 arithmetic, use the table size.</li> <li>feedback d: Be careful to use modulo not integer division.</li> </ul> <p>We now return to the problem of collisions. When two items hash to the same slot, we must have a systematic method for placing the second item in the hash table. This process is called collision resolution. As we stated earlier, if the hash function is perfect, collisions will never occur. However, since this is often not possible, collision resolution becomes a very important part of hashing.</p> <p>One method for resolving collisions looks into the hash table and tries to find another open slot to hold the item that caused the collision. A simple way to do this is to start at the original hash value position and then move in a sequential manner through the slots until we encounter the first slot that is empty. Note that we may need to go back to the first slot (circularly) to cover the entire hash table. This collision resolution process is referred to as open addressing in that it tries to find the next open slot or address in the hash table. By systematically visiting each slot one at a time, we are performing an open addressing technique called linear probing.</p> <p><code>Figure 8</code> shows an extended set of integer items under the simple remainder method hash function (54, 26, 93, 17, 77, 31, 44, 55, 20). <code>Table 4</code> above shows the hash values for the original six items and <code>Figure 5</code> shows the contents of a hash table with those six items. Let's see what happens when we attempt to place the additional three items into the table. When we attempt to place 44 into slot 0, a collision occurs. Under linear probing, we look sequentially, slot by slot, until we find an open position. In this case, we find slot 1.</p> <p>Again, 55 should go in slot 0 but must be placed in slot 2 since it is the next open position. The final value of 20 hashes to slot 9. Since slot 9 is full, we begin to do linear probing. We visit slots 10, 0, 1, and 2, and finally find an empty slot at position 3.</p> <p> Figure 8: Collision Resolution with Linear Probing </p> <p>Once we have built a hash table using open addressing and linear probing, it is essential that we utilize the same methods to search for items. Assume we want to look up the item 93. When we compute the hash value, we get 5. Looking in slot 5 reveals 93, and we can return <code>True</code>. What if we are looking for 20? Now the hash value is 9, and slot 9 is currently holding 31. We cannot simply return <code>False</code> since we know that there could have been collisions. We are now forced to do a sequential search, starting at position 10, looking until either we find the item 20 or we find an empty slot.</p> <p>A disadvantage to linear probing is the tendency for clustering; items become clustered in the table. This means that if many collisions occur at the same hash value, a number of surrounding slots will be filled by the linear probing resolution. This will have an impact on other items that are being inserted, as we saw when we tried to add the item 20 above. A cluster of values hashing to 0 had to be skipped to finally find an open position. This cluster is shown in <code>Figure 9</code>.</p> <p> Figure 9: A Cluster of Items for Slot 0 </p> <p>One way to deal with clustering is to extend the linear probing technique so that instead of looking sequentially for the next open slot, we skip slots, thereby more evenly distributing the items that have caused collisions. This will potentially reduce the clustering that occurs. <code>Figure 10</code> shows the items when collision resolution is done with what we will call a \u201cplus 3\u201d probe. This means that once a collision occurs, we will look at every third slot until we find one that is empty.</p> <p> Figure 10: Collision Resolution Using a Plus 3 Probe </p> <p>The general name for this process of looking for another slot after a collision is rehashing. With simple linear probing, the rehash function is \\(new\\_hash = rehash(old\\_hash)\\) where \\(rehash(pos) = (pos + 1) \\% size\\). The plus 3 rehash can be defined as \\(rehash(pos) = (pos + 3) \\% size\\). In general, \\(rehash(pos) = (pos + skip) \\% size\\). It is important to note that the size of the skip must be such that all the slots in the table will eventually be visited. Otherwise, part of the table will be unused. To ensure this, it is often suggested that the table size be a prime number. This is the reason we have been using 11 in our examples.</p> <p>A variation of the linear probing idea is called quadratic probing. Instead of using a constant skip value, we use a rehash function that increments the hash value by 1, 3, 5, 7, 9, and so on. This means that if the first hash value is \\(h\\), the successive values are \\(h + 1\\), \\(h + 4\\), \\(h + 9\\), \\(h + 16\\), and so on. In general, the \\(i\\) will be \\(i ^ {2}\\) and \\(rehash(pos) = (h + i ^ {2}) \\% size\\). In other words, quadratic probing uses a skip consisting of successive perfect squares. <code>Figure 11</code> shows our example values after they are placed using this technique.</p> <p> Figure 11: Collision Resolution with Quadratic Probing </p> <p>An alternative method for handling the collision problem is to allow each slot to hold a reference to a collection (or chain) of items. Chaining allows many items to exist at the same location in the hash table. When collisions happen, the item is still placed in the proper slot of the hash table. As more and more items hash to the same location, the difficulty of searching for the item in the collection increases. <code>Figure 12</code> shows the items as they are added to a hash table that uses chaining to resolve collisions.</p> <p> Figure 12: Collision Resolution with Chaining </p> <p>When we want to search for an item, we use the hash function to generate the slot where it should reside. Since with chaining each slot holds a collection, we use a searching technique to decide whether the item is present. The advantage is that on the average there are likely to be many fewer items in each slot, so the search is perhaps more efficient. We will look at the analysis for hashing at the end of this section.</p> <p>Self Check</p> HASH_1HASH_2 <p>In a hash table of size 13 which index positions would the following two keys map to?  27,  130</p> <ul> <li>answer a: 1, 10</li> <li>answer b: 13, 0</li> <li>answer c: 1, 0</li> <li>answer d: 2, 3</li> </ul> <p>correct: c</p> <ul> <li>feedback a:  Be careful to use modulo not integer division</li> <li>feedback b:  Don't divide by two, use the modulo operator.</li> <li>feedback c: 27 % 13 == 1 and 130 % 13 == 0</li> <li>feedback d: Use the modulo operator</li> </ul> <p>Suppose you are given the following set of keys to insert into a hash table that holds exactly 11 values:  113 , 117 , 97 , 100 , 114 , 108 , 116 , 105 , 99 Which of the following best demonstrates the contents of the hash table after all the keys have been inserted using linear probing?</p> <ul> <li>answer a: 100, , , 113, 114, 105, 116, 117, 97, 108, 99</li> <li>answer b: 99, 100, , 113, 114, , 116, 117, 105, 97, 108</li> <li>answer c: 100, 113, 117, 97, 14, 108, 116, 105, 99, , </li> <li>answer d: 117, 114, 108, 116, 105, 99, , , 97, 100, 113</li> </ul> <p>correct: b</p> <ul> <li>feedback a:  It looks like you may have been doing modulo 2 arithmentic.  You need to use the hash table size as the modulo value.</li> <li>feedback b:  Using modulo 11 arithmetic and linear probing gives these values</li> <li>feedback c: It looks like you are using modulo 10 arithmetic, use the table size.</li> <li>feedback d: Be careful to use modulo not integer division.</li> </ul>"},{"location":"c5/s5/#553-\u5b9e\u73b0map\u62bd\u8c61\u6570\u636e\u7c7b\u578b","title":"5.5.3. \u5b9e\u73b0Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>5.5.3. Implementing the Map Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>One of the most useful Python collections is the dictionary. Recall that a dictionary is an associative data type where you can store key-data pairs. The key is used to look up the associated data value. We often refer to this idea as a map.</p> <p>The map abstract data type is defined as follows. The structure is an unordered collection of associations between a key and a data value. The keys in a map are all unique so that there is a one-to-one relationship between a key and a value. The operations are given below.</p> <ul> <li><code>Map()</code> creates a new empty map.</li> <li><code>put(key, val)</code> adds a new key--value pair to the map. If the key is already in the map, it replaces the old value with the new value.</li> <li><code>get(key)</code> takes a key and returns the matching value stored in the map or <code>None</code> otherwise.</li> <li><code>del</code> deletes the key--value pair from the map using a statement of the form <code>del map[key]</code>.</li> <li><code>size()</code> returns the number of key--value pairs stored in the map.</li> <li><code>in</code> return <code>True</code> for a statement of the form <code>key in map</code> if the given key is in the map, <code>False</code> otherwise.</li> </ul> <p>One of the great benefits of a dictionary is the fact that given a key, we can look up the associated data value very quickly. In order to provide this fast look-up capability, we need an implementation that supports an efficient search. We could use a list with sequential or binary search, but it would be even better to use a hash table as described above since looking up an item in a hash table can approach $O(1)` performance.</p> <p>In <code>Listing 2</code> we use two lists to create a <code>HashTable</code> class that implements the map abstract data type. One list, called <code>slots</code>, will hold the key items and a parallel list, called <code>data</code>, will hold the data values. When we look up a key, the corresponding position in the data list will hold the associated data value. We will treat the key list as a hash table using the ideas presented earlier. Note that the initial size for the hash table has been chosen to be 11. Although this is arbitrary, it is important that the size be a prime number so that the collision resolution algorithm can be as efficient as possible.</p> **Listing 2**<pre><code>class HashTable:\n    def __init__(self):\n        self.size = 11\n        self.slots = [None] * self.size\n        self.data = [None] * self.size\n</code></pre> <p>As seen in <code>Listing 3</code>, <code>hash_function</code> implements the simple remainder method. The collision resolution technique is linear probing with a \u201cplus 1\u201d rehash value. The <code>put</code> function (see <code>Listing 3</code>) assumes that there will eventually be an empty slot unless the key is already present in the <code>self.slots</code>. It computes the original hash value and if that slot is not empty, iterates the <code>rehash</code> function until an empty slot occurs. If a nonempty slot already contains the key, the old data value is replaced with the new data value.</p> **Listing 3**<pre><code>def put(self, key, data):\n    hash_value = self.hash_function(key, len(self.slots))\n\n    if self.slots[hash_value] is None:\n        self.slots[hash_value] = key\n        self.data[hash_value] = data\n    else:\n        if self.slots[hash_value] == key:\n            self.data[hash_value] = data  # replace\n        else:\n            next_slot = self.rehash(hash_value, len(self.slots))\n            while (\n                self.slots[next_slot] is not None\n                and self.slots[next_slot] != key\n            ):\n                next_slot = self.rehash(next_slot, len(self.slots))\n\n            if self.slots[next_slot] is None:\n                self.slots[next_slot] = key\n                self.data[next_slot] = data\n            else:\n                self.data[next_slot] = data\n\ndef hash_function(self, key, size):\n    return key % size\n\ndef rehash(self, old_hash, size):\n    return (old_hash + 1) % size\n</code></pre> <p>The <code>get</code> function (see <code>Listing 4</code>) begins by computing the initial hash value. If the value is not in the initial slot, <code>rehash</code> is used to locate the next possible position. Notice that line 14 guarantees that the search will terminate by checking to make sure that we have not returned to the initial slot. If that happens, we have exhausted all possible slots and the item must not be present.</p> <p>The final methods of the <code>HashTable</code> class provide additional dictionary functionality. We overload the <code>__getitem__</code> and <code>__setitem__</code> methods to allow access using <code>[]</code>. This means that once a <code>HashTable</code> has been created, the familiar index operator will be available. We leave the remaining methods as exercises.</p> **Listing 4**<pre><code>def get(self, key):\n    start_slot = self.hash_function(key, len(self.slots))\n\n    position = start_slot\n    while self.slots[position] is not None:\n        if self.slots[position] == key:\n            return self.data[position]\n        else:\n            position = self.rehash(position, len(self.slots))\n            if position == start_slot:\n                return None\n\ndef __getitem__(self, key):\n    return self.get(key)\n\ndef __setitem__(self, key, data):\n    self.put(key, data)\n</code></pre> <p>The following session shows the <code>HashTable</code> class in action. First we will create a hash table and store some items with integer keys and string data values.</p> <pre><code>&gt;&gt;&gt; h = HashTable()\n&gt;&gt;&gt; h[54] = \"cat\"\n&gt;&gt;&gt; h[26] = \"dog\"\n&gt;&gt;&gt; h[93] = \"lion\"\n&gt;&gt;&gt; h[17] = \"tiger\"\n&gt;&gt;&gt; h[77] = \"bird\"\n&gt;&gt;&gt; h[31] = \"cow\"\n&gt;&gt;&gt; h[44] = \"goat\"\n&gt;&gt;&gt; h[55] = \"pig\"\n&gt;&gt;&gt; h[20] = \"chicken\"\n&gt;&gt;&gt; h.slots\n[77, 44, 55, 20, 26, 93, 17, None, None, 31, 54]\n&gt;&gt;&gt; h.data\n['bird', 'goat', 'pig', 'chicken', 'dog', 'lion',\n        'tiger', None, None, 'cow', 'cat']\n</code></pre> <p>Next we will access and modify some items in the hash table. Note that the value for the key 20 is being replaced.</p> <pre><code>&gt;&gt;&gt; h[20]\n'chicken'\n&gt;&gt;&gt; h[17]\n'tiger'\n&gt;&gt;&gt; h[20] = \"duck\"\n&gt;&gt;&gt; h[20]\n'duck'\n&gt;&gt;&gt; h.data\n['bird', 'goat', 'pig', 'duck', 'dog', 'lion',\n        'tiger', None, None, 'cow', 'cat']\n&gt;&gt; print(h[99])\nNone\n</code></pre> <p>The complete hash table example can be found in ActiveCode 1.</p> Activity: 5.5.3.1 Complete Hash Table Example<pre><code>class HashTable:\n    def __init__(self):\n        self.size = 11\n        self.slots = [None] * self.size\n        self.data = [None] * self.size\n\n    def put(self, key, data):\n        hash_value = self.hash_function(key, len(self.slots))\n\n        if self.slots[hash_value] is None:\n            self.slots[hash_value] = key\n            self.data[hash_value] = data\n        else:\n            if self.slots[hash_value] == key:\n                self.data[hash_value] = data  # replace\n            else:\n                next_slot = self.rehash(hash_value, len(self.slots))\n                while (\n                    self.slots[next_slot] is not None\n                    and self.slots[next_slot] != key\n                ):\n                    next_slot = self.rehash(next_slot, len(self.slots))\n\n                if self.slots[next_slot] is None:\n                    self.slots[next_slot] = key\n                    self.data[next_slot] = data\n                else:\n                    self.data[next_slot] = data\n\n    def hash_function(self, key, size):\n        return key % size\n\n    def rehash(self, old_hash, size):\n        return (old_hash + 1) % size\n\n    def get(self, key):\n        start_slot = self.hash_function(key, len(self.slots))\n\n        position = start_slot\n        while self.slots[position] is not None:\n            if self.slots[position] == key:\n                return self.data[position]\n            else:\n                position = self.rehash(position, len(self.slots))\n                if position == start_slot:\n                    return None\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        self.put(key, data)\n\nh = HashTable()\nh[54] = \"cat\"\nh[26] = \"dog\"\nh[93] = \"lion\"\nh[17] = \"tiger\"\nh[77] = \"bird\"\nh[31] = \"cow\"\nh[44] = \"goat\"\nh[55] = \"pig\"\nh[20] = \"chicken\"\nprint(h.slots)\nprint(h.data)\nprint(h[20])\nprint(h[17])\nh[20] = \"duck\"\nprint(h[20])\nprint(h[99])\n</code></pre> <p>One of the most useful Python collections is the dictionary. Recall that a dictionary is an associative data type where you can store key-data pairs. The key is used to look up the associated data value. We often refer to this idea as a map.</p> <p>The map abstract data type is defined as follows. The structure is an unordered collection of associations between a key and a data value. The keys in a map are all unique so that there is a one-to-one relationship between a key and a value. The operations are given below.</p> <ul> <li><code>Map()</code> creates a new empty map.</li> <li><code>put(key, val)</code> adds a new key--value pair to the map. If the key is already in the map, it replaces the old value with the new value.</li> <li><code>get(key)</code> takes a key and returns the matching value stored in the map or <code>None</code> otherwise.</li> <li><code>del</code> deletes the key--value pair from the map using a statement of the form <code>del map[key]</code>.</li> <li><code>size()</code> returns the number of key--value pairs stored in the map.</li> <li><code>in</code> return <code>True</code> for a statement of the form <code>key in map</code> if the given key is in the map, <code>False</code> otherwise.</li> </ul> <p>One of the great benefits of a dictionary is the fact that given a key, we can look up the associated data value very quickly. In order to provide this fast look-up capability, we need an implementation that supports an efficient search. We could use a list with sequential or binary search, but it would be even better to use a hash table as described above since looking up an item in a hash table can approach $O(1)` performance.</p> <p>In <code>Listing 2</code> we use two lists to create a <code>HashTable</code> class that implements the map abstract data type. One list, called <code>slots</code>, will hold the key items and a parallel list, called <code>data</code>, will hold the data values. When we look up a key, the corresponding position in the data list will hold the associated data value. We will treat the key list as a hash table using the ideas presented earlier. Note that the initial size for the hash table has been chosen to be 11. Although this is arbitrary, it is important that the size be a prime number so that the collision resolution algorithm can be as efficient as possible.</p> **Listing 2**<pre><code>class HashTable:\n    def __init__(self):\n        self.size = 11\n        self.slots = [None] * self.size\n        self.data = [None] * self.size\n</code></pre> <p>As seen in <code>Listing 3</code>, <code>hash_function</code> implements the simple remainder method. The collision resolution technique is linear probing with a \u201cplus 1\u201d rehash value. The <code>put</code> function (see <code>Listing 3</code>) assumes that there will eventually be an empty slot unless the key is already present in the <code>self.slots</code>. It computes the original hash value and if that slot is not empty, iterates the <code>rehash</code> function until an empty slot occurs. If a nonempty slot already contains the key, the old data value is replaced with the new data value.</p> **Listing 3**<pre><code>def put(self, key, data):\n    hash_value = self.hash_function(key, len(self.slots))\n\n    if self.slots[hash_value] is None:\n        self.slots[hash_value] = key\n        self.data[hash_value] = data\n    else:\n        if self.slots[hash_value] == key:\n            self.data[hash_value] = data  # replace\n        else:\n            next_slot = self.rehash(hash_value, len(self.slots))\n            while (\n                self.slots[next_slot] is not None\n                and self.slots[next_slot] != key\n            ):\n                next_slot = self.rehash(next_slot, len(self.slots))\n\n            if self.slots[next_slot] is None:\n                self.slots[next_slot] = key\n                self.data[next_slot] = data\n            else:\n                self.data[next_slot] = data\n\ndef hash_function(self, key, size):\n    return key % size\n\ndef rehash(self, old_hash, size):\n    return (old_hash + 1) % size\n</code></pre> <p>The <code>get</code> function (see <code>Listing 4</code>) begins by computing the initial hash value. If the value is not in the initial slot, <code>rehash</code> is used to locate the next possible position. Notice that line 14 guarantees that the search will terminate by checking to make sure that we have not returned to the initial slot. If that happens, we have exhausted all possible slots and the item must not be present.</p> <p>The final methods of the <code>HashTable</code> class provide additional dictionary functionality. We overload the <code>__getitem__</code> and <code>__setitem__</code> methods to allow access using <code>[]</code>. This means that once a <code>HashTable</code> has been created, the familiar index operator will be available. We leave the remaining methods as exercises.</p> **Listing 4**<pre><code>def get(self, key):\n    start_slot = self.hash_function(key, len(self.slots))\n\n    position = start_slot\n    while self.slots[position] is not None:\n        if self.slots[position] == key:\n            return self.data[position]\n        else:\n            position = self.rehash(position, len(self.slots))\n            if position == start_slot:\n                return None\n\ndef __getitem__(self, key):\n    return self.get(key)\n\ndef __setitem__(self, key, data):\n    self.put(key, data)\n</code></pre> <p>The following session shows the <code>HashTable</code> class in action. First we will create a hash table and store some items with integer keys and string data values.</p> <pre><code>&gt;&gt;&gt; h = HashTable()\n&gt;&gt;&gt; h[54] = \"cat\"\n&gt;&gt;&gt; h[26] = \"dog\"\n&gt;&gt;&gt; h[93] = \"lion\"\n&gt;&gt;&gt; h[17] = \"tiger\"\n&gt;&gt;&gt; h[77] = \"bird\"\n&gt;&gt;&gt; h[31] = \"cow\"\n&gt;&gt;&gt; h[44] = \"goat\"\n&gt;&gt;&gt; h[55] = \"pig\"\n&gt;&gt;&gt; h[20] = \"chicken\"\n&gt;&gt;&gt; h.slots\n[77, 44, 55, 20, 26, 93, 17, None, None, 31, 54]\n&gt;&gt;&gt; h.data\n['bird', 'goat', 'pig', 'chicken', 'dog', 'lion',\n        'tiger', None, None, 'cow', 'cat']\n</code></pre> <p>Next we will access and modify some items in the hash table. Note that the value for the key 20 is being replaced.</p> <pre><code>&gt;&gt;&gt; h[20]\n'chicken'\n&gt;&gt;&gt; h[17]\n'tiger'\n&gt;&gt;&gt; h[20] = \"duck\"\n&gt;&gt;&gt; h[20]\n'duck'\n&gt;&gt;&gt; h.data\n['bird', 'goat', 'pig', 'duck', 'dog', 'lion',\n        'tiger', None, None, 'cow', 'cat']\n&gt;&gt; print(h[99])\nNone\n</code></pre> <p>The complete hash table example can be found in ActiveCode 1.</p> Activity: 5.5.3.1 Complete Hash Table Example<pre><code>class HashTable:\n    def __init__(self):\n        self.size = 11\n        self.slots = [None] * self.size\n        self.data = [None] * self.size\n\n    def put(self, key, data):\n        hash_value = self.hash_function(key, len(self.slots))\n\n        if self.slots[hash_value] is None:\n            self.slots[hash_value] = key\n            self.data[hash_value] = data\n        else:\n            if self.slots[hash_value] == key:\n                self.data[hash_value] = data  # replace\n            else:\n                next_slot = self.rehash(hash_value, len(self.slots))\n                while (\n                    self.slots[next_slot] is not None\n                    and self.slots[next_slot] != key\n                ):\n                    next_slot = self.rehash(next_slot, len(self.slots))\n\n                if self.slots[next_slot] is None:\n                    self.slots[next_slot] = key\n                    self.data[next_slot] = data\n                else:\n                    self.data[next_slot] = data\n\n    def hash_function(self, key, size):\n        return key % size\n\n    def rehash(self, old_hash, size):\n        return (old_hash + 1) % size\n\n    def get(self, key):\n        start_slot = self.hash_function(key, len(self.slots))\n\n        position = start_slot\n        while self.slots[position] is not None:\n            if self.slots[position] == key:\n                return self.data[position]\n            else:\n                position = self.rehash(position, len(self.slots))\n                if position == start_slot:\n                    return None\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        self.put(key, data)\n\nh = HashTable()\nh[54] = \"cat\"\nh[26] = \"dog\"\nh[93] = \"lion\"\nh[17] = \"tiger\"\nh[77] = \"bird\"\nh[31] = \"cow\"\nh[44] = \"goat\"\nh[55] = \"pig\"\nh[20] = \"chicken\"\nprint(h.slots)\nprint(h.data)\nprint(h[20])\nprint(h[17])\nh[20] = \"duck\"\nprint(h[20])\nprint(h[99])\n</code></pre>"},{"location":"c5/s5/#554-\u54c8\u5e0c\u5206\u6790","title":"5.5.4. \u54c8\u5e0c\u5206\u6790","text":"<p>5.5.4. Analysis of Hashing</p> \u4e2d\u6587\u82f1\u6587 <p>We stated earlier that in the best case hashing would provide an \\(O(1)\\), constant time search technique. However, due to collisions, the number of comparisons is typically not so simple. Even though a complete analysis of hashing is beyond the scope of this text, we can state some well-known results that approximate the number of comparisons necessary to search for an item.</p> <p>The most important piece of information we need to analyze the use of a hash table is the load factor, \\(\\lambda\\). Conceptually, if \\(\\lambda\\) is small, then there is a lower chance of collisions, meaning that items are more likely to be in the slots where they belong. If \\(\\lambda\\) is large, meaning that the table is filling up, then there are more and more collisions. This means that collision resolution is more difficult, requiring more comparisons to find an empty slot. With chaining, increased collisions means an increased number of items on each chain.</p> <p>As before, we will have a result for both a successful and an unsuccessful search. For a successful search using open addressing with linear probing, the average number of comparisons is approximately \\(\\frac{1}{2}\\left(1+\\frac{1}{1-\\lambda}\\right)\\) and an unsuccessful search gives \\(\\frac{1}{2}\\left(1+\\left(\\frac{1}{1-\\lambda}\\right)^2\\right)\\) If we are using chaining, the average number of comparisons is \\(1 + \\frac {\\lambda}{2}\\) for the successful case, and simply \\(\\lambda\\) comparisons if the search is unsuccessful.</p> <p>We stated earlier that in the best case hashing would provide an \\(O(1)\\), constant time search technique. However, due to collisions, the number of comparisons is typically not so simple. Even though a complete analysis of hashing is beyond the scope of this text, we can state some well-known results that approximate the number of comparisons necessary to search for an item.</p> <p>The most important piece of information we need to analyze the use of a hash table is the load factor, \\(\\lambda\\). Conceptually, if \\(\\lambda\\) is small, then there is a lower chance of collisions, meaning that items are more likely to be in the slots where they belong. If \\(\\lambda\\) is large, meaning that the table is filling up, then there are more and more collisions. This means that collision resolution is more difficult, requiring more comparisons to find an empty slot. With chaining, increased collisions means an increased number of items on each chain.</p> <p>As before, we will have a result for both a successful and an unsuccessful search. For a successful search using open addressing with linear probing, the average number of comparisons is approximately \\(\\frac{1}{2}\\left(1+\\frac{1}{1-\\lambda}\\right)\\) and an unsuccessful search gives \\(\\frac{1}{2}\\left(1+\\left(\\frac{1}{1-\\lambda}\\right)^2\\right)\\) If we are using chaining, the average number of comparisons is \\(1 + \\frac {\\lambda}{2}\\) for the successful case, and simply \\(\\lambda\\) comparisons if the search is unsuccessful.</p>"},{"location":"c5/s6/","title":"5.6. \u6392\u5e8f","text":"<p>5.6. Sorting</p> \u4e2d\u6587\u82f1\u6587 <p>Sorting is the process of placing elements from a collection in some kind of order. For example, a list of words could be sorted alphabetically or by length. A list of cities could be sorted by population, by area, or by zip code. We have already seen a number of algorithms that were able to benefit from having a sorted list (recall the final anagram example and the binary search).</p> <p>There are many, many sorting algorithms that have been developed and analyzed. This suggests that sorting is an important area of study in computer science. Sorting a large number of items can take a substantial amount of computing resources. Like searching, the efficiency of a sorting algorithm is related to the number of items being processed. For small collections, a complex sorting method may be more trouble than it is worth. The overhead may be too high. On the other hand, for larger collections, we want to take advantage of as many improvements as possible. In this section we will discuss several sorting techniques and compare them with respect to their running time.</p> <p>Before getting into specific algorithms, we should think about the operations that can be used to analyze a sorting process. First, it will be necessary to compare two values to see which is smaller (or larger). In order to sort a collection, it will be necessary to have some systematic way to compare values to see if they are out of order. The total number of comparisons will be the most common way to measure a sort procedure. Second, when values are not in the correct position with respect to one another, it may be necessary to exchange them. This exchange is a costly operation and the total number of exchanges will also be important for evaluating the overall efficiency of the algorithm.</p> <p>Sorting is the process of placing elements from a collection in some kind of order. For example, a list of words could be sorted alphabetically or by length. A list of cities could be sorted by population, by area, or by zip code. We have already seen a number of algorithms that were able to benefit from having a sorted list (recall the final anagram example and the binary search).</p> <p>There are many, many sorting algorithms that have been developed and analyzed. This suggests that sorting is an important area of study in computer science. Sorting a large number of items can take a substantial amount of computing resources. Like searching, the efficiency of a sorting algorithm is related to the number of items being processed. For small collections, a complex sorting method may be more trouble than it is worth. The overhead may be too high. On the other hand, for larger collections, we want to take advantage of as many improvements as possible. In this section we will discuss several sorting techniques and compare them with respect to their running time.</p> <p>Before getting into specific algorithms, we should think about the operations that can be used to analyze a sorting process. First, it will be necessary to compare two values to see which is smaller (or larger). In order to sort a collection, it will be necessary to have some systematic way to compare values to see if they are out of order. The total number of comparisons will be the most common way to measure a sort procedure. Second, when values are not in the correct position with respect to one another, it may be necessary to exchange them. This exchange is a costly operation and the total number of exchanges will also be important for evaluating the overall efficiency of the algorithm.</p>"},{"location":"c5/s7/","title":"5.7. \u5192\u6ce1\u6392\u5e8f","text":"<p>5.7. The Bubble Sort</p> \u4e2d\u6587\u82f1\u6587 <p>The bubble sort makes multiple passes through a list. It compares adjacent items and exchanges those that are out of order. Each pass through the list places the next largest value in its proper place. In essence, each item bubbles up to the location where it belongs.</p> <p><code>Figure 1</code> shows the first pass of a bubble sort. The shaded items are being compared to see if they are out of order. If there are \\(n\\) items in the list, then there are \\(n-1\\) pairs of items that need to be compared on the first pass. It is important to note that once the largest value in the list is part of a pair, it will continually be moved along until the pass is complete.</p> <p> Figure 1: Bubble Sort: The First Pass </p> <p>At the start of the second pass, the largest value is now in place. There are \\(n-1\\) items left to sort, meaning that there will be \\(n-2\\) pairs. Since each pass places the next largest value in place, the total number of passes necessary will be \\(n-1\\). After completing the \\(n-1\\) passes, the smallest item must be in the correct position with no further processing required. <code>ActiveCode 1</code> shows the complete <code>bubble_sort</code> function. It takes the list as a parameter and modifies it by exchanging items as necessary.</p> <p>The exchange operation, sometimes called a swap, is slightly different in Python than in most other programming languages. Typically, swapping two elements in a list requires a temporary variable (an additional memory location). A code fragment such as</p> <pre><code>    temp = a_list[i]\n    a_list[i] = a_list[j]\n    a_list[j] = temp\n</code></pre> <p>will exchange the \\(i\\)-th and \\(j\\)-th items in the list. Without the temporary storage, one of the values would be overwritten.</p> <p>In Python, it is possible to perform simultaneous assignment. The statement <code>a, b = b, a</code> will result in two assignment statements being done at the same time (see <code>Figure 2</code>). Using simultaneous assignment, the exchange operation can be done in one statement.</p> <p>Lines 5--7 in <code>ActiveCode 1</code> perform the exchange of the \\(i\\) and \\((i+1)\\)-th items using the three-step procedure described earlier. Note that we could also have used the simultaneous assignment to swap the items.</p> <p> Figure 2: Exchanging Two Values in Python </p> <p>The following activecode example shows the complete <code>bubble_sort</code> function working on the list shown above.</p> Activity: 5.7.1 The Bubble Sort Implementation<pre><code>def bubble_sort(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                temp = a_list[j]\n                a_list[j] = a_list[j + 1]\n                a_list[j + 1] = temp\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nbubble_sort(a_list)\nprint(a_list)\n</code></pre> <p>The following animation shows <code>bubble_sort</code> in action.</p> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 1 allows you to step through the algorithm.</p> Tracing the Bubble Sort<pre><code>def bubble_sort(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                temp = a_list[j]\n                a_list[j] = a_list[j + 1]\n                a_list[j + 1] = temp\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nbubble_sort(a_list)\nprint(a_list)\n</code></pre> <p>To analyze the bubble sort, we should note that regardless of how the items are arranged in the initial list, \\(n - 1\\) passes will be made to sort a list of size \\(n\\). <code>Table 1</code> shows the number of comparisons for each pass. The total number of comparisons is the sum of the first \\(n - 1\\) integers. Recall that the sum of the first \\(n\\) integers is \\(\\frac{1}{2}n^{2} + \\frac{1}{2}n\\). The sum of the first \\(n - 1\\) integers is \\(\\frac{1}{2}n^{2} + \\frac{1}{2}n - n\\), which is \\(\\frac{1}{2}n^{2} - \\frac{1}{2}n\\). This is still \\(O(n^{2})\\) comparisons. In the best case, if the list is already ordered, no exchanges will be made. However, in the worst case, every comparison will cause an exchange. On average, we exchange half of the time.</p> <p>Table 1: Comparisons for Each Pass of Bubble Sort</p> Pass Comparisons 1 \\(n-1\\) 2 \\(n-2\\) 3 \\(n-3\\) ... ... \\(n-1\\) \\(1\\) <p>A bubble sort is often considered the most inefficient sorting method since it must exchange items before the final location is known. These \u201cwasted\u201d exchange operations are very costly. However, because the bubble sort makes passes through the entire unsorted portion of the list, it has the capability to do something most sorting algorithms cannot. In particular, if during a pass there are no exchanges, then we know that the list must be sorted. A bubble sort can be modified to stop early if it finds that the list has become sorted. This means that for lists that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted list and stop. <code>ActiveCode 2</code> shows this modification, which is often referred to as the short bubble.</p> Activity: 5.7.2 The Short Bubble Sort Implementation<pre><code>def bubble_sort_short(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                exchanges = True\n                a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]\n        if not exchanges:\n            break\n\n\na_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]\nbubble_sort_short(a_list)\nprint(a_list)\n</code></pre> <p>Finally, here is <code>bubble_sort_short</code> in CodeLens (CodeLens 2)..</p> Tracing the Short Bubble Sort<pre><code>def bubble_sort_short(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                exchanges = True\n                a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]\n        if not exchanges:\n            break\n\n\na_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]\nbubble_sort_short(a_list)\nprint(a_list)\n</code></pre> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:  [19, 1, 9, 7, 3, 10, 13, 15, 8, 12] which list represents the partially sorted list after three complete passes of bubble sort?</p> <ul> <li>answer a: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]</li> <li>answer b: [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]</li> <li>answer c: [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]</li> <li>answer d: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]</li> </ul> <p>correct: b</p> <ul> <li>feedback a:  This answer represents three swaps.  A pass means that you continue swapping all the way to the end of the list.</li> <li>feedback b:  Very Good</li> <li>feedback c: A bubble sort contines to swap numbers up to index position passnum.  But remember that passnum starts at the length of the list - 1.</li> <li>feedback d: You have been doing an insertion sort, not a bubble sort.</li> </ul> <p>The bubble sort makes multiple passes through a list. It compares adjacent items and exchanges those that are out of order. Each pass through the list places the next largest value in its proper place. In essence, each item bubbles up to the location where it belongs.</p> <p><code>Figure 1</code> shows the first pass of a bubble sort. The shaded items are being compared to see if they are out of order. If there are \\(n\\) items in the list, then there are \\(n-1\\) pairs of items that need to be compared on the first pass. It is important to note that once the largest value in the list is part of a pair, it will continually be moved along until the pass is complete.</p> <p> Figure 1: Bubble Sort: The First Pass </p> <p>At the start of the second pass, the largest value is now in place. There are \\(n-1\\) items left to sort, meaning that there will be \\(n-2\\) pairs. Since each pass places the next largest value in place, the total number of passes necessary will be \\(n-1\\). After completing the \\(n-1\\) passes, the smallest item must be in the correct position with no further processing required. <code>ActiveCode 1</code> shows the complete <code>bubble_sort</code> function. It takes the list as a parameter and modifies it by exchanging items as necessary.</p> <p>The exchange operation, sometimes called a swap, is slightly different in Python than in most other programming languages. Typically, swapping two elements in a list requires a temporary variable (an additional memory location). A code fragment such as</p> <pre><code>    temp = a_list[i]\n    a_list[i] = a_list[j]\n    a_list[j] = temp\n</code></pre> <p>will exchange the \\(i\\)-th and \\(j\\)-th items in the list. Without the temporary storage, one of the values would be overwritten.</p> <p>In Python, it is possible to perform simultaneous assignment. The statement <code>a, b = b, a</code> will result in two assignment statements being done at the same time (see <code>Figure 2</code>). Using simultaneous assignment, the exchange operation can be done in one statement.</p> <p>Lines 5--7 in <code>ActiveCode 1</code> perform the exchange of the \\(i\\) and \\((i+1)\\)-th items using the three-step procedure described earlier. Note that we could also have used the simultaneous assignment to swap the items.</p> <p> Figure 2: Exchanging Two Values in Python </p> <p>The following activecode example shows the complete <code>bubble_sort</code> function working on the list shown above.</p> Activity: 5.7.1 The Bubble Sort Implementation<pre><code>def bubble_sort(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                temp = a_list[j]\n                a_list[j] = a_list[j + 1]\n                a_list[j + 1] = temp\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nbubble_sort(a_list)\nprint(a_list)\n</code></pre> <p>The following animation shows <code>bubble_sort</code> in action.</p> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 1 allows you to step through the algorithm.</p> Tracing the Bubble Sort<pre><code>def bubble_sort(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                temp = a_list[j]\n                a_list[j] = a_list[j + 1]\n                a_list[j + 1] = temp\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nbubble_sort(a_list)\nprint(a_list)\n</code></pre> <p>To analyze the bubble sort, we should note that regardless of how the items are arranged in the initial list, \\(n - 1\\) passes will be made to sort a list of size \\(n\\). <code>Table 1</code> shows the number of comparisons for each pass. The total number of comparisons is the sum of the first \\(n - 1\\) integers. Recall that the sum of the first \\(n\\) integers is \\(\\frac{1}{2}n^{2} + \\frac{1}{2}n\\). The sum of the first \\(n - 1\\) integers is \\(\\frac{1}{2}n^{2} + \\frac{1}{2}n - n\\), which is \\(\\frac{1}{2}n^{2} - \\frac{1}{2}n\\). This is still \\(O(n^{2})\\) comparisons. In the best case, if the list is already ordered, no exchanges will be made. However, in the worst case, every comparison will cause an exchange. On average, we exchange half of the time.</p> <p>Table 1: Comparisons for Each Pass of Bubble Sort</p> Pass Comparisons 1 \\(n-1\\) 2 \\(n-2\\) 3 \\(n-3\\) ... ... \\(n-1\\) \\(1\\) <p>A bubble sort is often considered the most inefficient sorting method since it must exchange items before the final location is known. These \u201cwasted\u201d exchange operations are very costly. However, because the bubble sort makes passes through the entire unsorted portion of the list, it has the capability to do something most sorting algorithms cannot. In particular, if during a pass there are no exchanges, then we know that the list must be sorted. A bubble sort can be modified to stop early if it finds that the list has become sorted. This means that for lists that require just a few passes, a bubble sort may have an advantage in that it will recognize the sorted list and stop. <code>ActiveCode 2</code> shows this modification, which is often referred to as the short bubble.</p> Activity: 5.7.2 The Short Bubble Sort Implementation<pre><code>def bubble_sort_short(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                exchanges = True\n                a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]\n        if not exchanges:\n            break\n\n\na_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]\nbubble_sort_short(a_list)\nprint(a_list)\n</code></pre> <p>Finally, here is <code>bubble_sort_short</code> in CodeLens (CodeLens 2)..</p> Tracing the Short Bubble Sort<pre><code>def bubble_sort_short(a_list):\n    for i in range(len(a_list) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if a_list[j] &gt; a_list[j + 1]:\n                exchanges = True\n                a_list[j], a_list[j + 1] = a_list[j + 1], a_list[j]\n        if not exchanges:\n            break\n\n\na_list = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]\nbubble_sort_short(a_list)\nprint(a_list)\n</code></pre> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:  [19, 1, 9, 7, 3, 10, 13, 15, 8, 12] which list represents the partially sorted list after three complete passes of bubble sort?</p> <ul> <li>answer a: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]</li> <li>answer b: [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]</li> <li>answer c: [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]</li> <li>answer d: [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]</li> </ul> <p>correct: b</p> <ul> <li>feedback a:  This answer represents three swaps.  A pass means that you continue swapping all the way to the end of the list.</li> <li>feedback b:  Very Good</li> <li>feedback c: A bubble sort contines to swap numbers up to index position passnum.  But remember that passnum starts at the length of the list - 1.</li> <li>feedback d: You have been doing an insertion sort, not a bubble sort.</li> </ul>"},{"location":"c5/s8/","title":"5.8. \u9009\u62e9\u6392\u5e8f","text":"<p>5.8. The Selection Sort</p> \u4e2d\u6587\u82f1\u6587 <p>The selection sort improves on the bubble sort by making only one exchange for every pass through the list. In order to do this, a selection sort looks for the largest value as it makes a pass and, after completing the pass, places it in the proper location. As with a bubble sort, after the first pass, the largest item is in the correct place. After the second pass, the next largest is in place. This process continues and requires \\(n - 1\\) passes to sort \\(n\\) items, since the final item must be in place after the \\((n - 1)\\)-th pass.</p> <p><code>Figure 3</code> shows the entire sorting process for the selection sort. On each pass, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. The function is shown in <code>ActiveCode 1</code>.</p> <p> Figure 3: Selection Sort: Complete </p> Activity: 5.8.1 Selection Sort<pre><code>def selection_sort(a_list):\n    for i, item in enumerate(a_list):\n        min_idx = len(a_list) - 1\n        for j in range(i, len(a_list)):\n            if a_list[j] &lt; a_list[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nselection_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 3 allows you to step through the algorithm.</p> Tracing the Selection Sort<pre><code>def selection_sort(a_list):\n    for i, item in enumerate(a_list):\n        min_idx = len(a_list) - 1\n        for j in range(i, len(a_list)):\n            if a_list[j] &lt; a_list[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nselection_sort(a_list)\nprint(a_list)\n</code></pre> <p>You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also \\(O(n^{2})\\). However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies. In fact, for our list, the bubble sort makes 20 exchanges, while the selection sort makes only 8.</p> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:</p> <p>[11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which list represents the partially sorted list after three complete passes of selection sort?</p> <ul> <li>answer a: [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]</li> <li>answer b: [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]</li> <li>answer c: [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]</li> <li>answer d: [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]</li> </ul> <p>correct: d</p> <ul> <li>feedback a: Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps</li> <li>feedback b: This looks like an insertion sort.</li> <li>feedback c: This one looks similar to the correct answer but instead of swapping the numbers have been shifted to the left to make room for the correct numbers.</li> <li>feedback d: Selection sort improves upon bubble sort by making fewer swaps.</li> </ul> <p>The selection sort improves on the bubble sort by making only one exchange for every pass through the list. In order to do this, a selection sort looks for the largest value as it makes a pass and, after completing the pass, places it in the proper location. As with a bubble sort, after the first pass, the largest item is in the correct place. After the second pass, the next largest is in place. This process continues and requires \\(n - 1\\) passes to sort \\(n\\) items, since the final item must be in place after the \\((n - 1)\\)-th pass.</p> <p><code>Figure 3</code> shows the entire sorting process for the selection sort. On each pass, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. The function is shown in <code>ActiveCode 1</code>.</p> <p> Figure 3: Selection Sort: Complete </p> Activity: 5.8.1 Selection Sort<pre><code>def selection_sort(a_list):\n    for i, item in enumerate(a_list):\n        min_idx = len(a_list) - 1\n        for j in range(i, len(a_list)):\n            if a_list[j] &lt; a_list[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nselection_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 3 allows you to step through the algorithm.</p> Tracing the Selection Sort<pre><code>def selection_sort(a_list):\n    for i, item in enumerate(a_list):\n        min_idx = len(a_list) - 1\n        for j in range(i, len(a_list)):\n            if a_list[j] &lt; a_list[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            a_list[min_idx], a_list[i] = a_list[i], a_list[min_idx]\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\nselection_sort(a_list)\nprint(a_list)\n</code></pre> <p>You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also \\(O(n^{2})\\). However, due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies. In fact, for our list, the bubble sort makes 20 exchanges, while the selection sort makes only 8.</p> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:</p> <p>[11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which list represents the partially sorted list after three complete passes of selection sort?</p> <ul> <li>answer a: [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]</li> <li>answer b: [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]</li> <li>answer c: [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]</li> <li>answer d: [11, 7, 12, 14, 8, 1, 6, 18, 19, 20]</li> </ul> <p>correct: d</p> <ul> <li>feedback a: Selection sort is similar to bubble sort (which you appear to have done) but uses fewer swaps</li> <li>feedback b: This looks like an insertion sort.</li> <li>feedback c: This one looks similar to the correct answer but instead of swapping the numbers have been shifted to the left to make room for the correct numbers.</li> <li>feedback d: Selection sort improves upon bubble sort by making fewer swaps.</li> </ul>"},{"location":"c5/s9/","title":"5.9. \u63d2\u5165\u6392\u5e8f","text":"<p>5.9. The Insertion Sort</p> \u4e2d\u6587\u82f1\u6587 <p>The insertion sort, although still \\(O(n^{2})\\), works in a slightly different way. It always maintains a sorted sublist in the lower positions of the list. Each new item is then inserted back into the previous sublist such that the sorted sublist is one item larger. <code>Figure 4</code> shows the insertion sorting process. The shaded items represent the ordered sublists as the algorithm makes each pass.</p> <p> Figure 4: Insertion Sort: Complete </p> <p>We begin by assuming that a list with one item (position \\(0\\)) is already sorted. On each pass, one for each item 1 through \\(n-1\\), the current item is checked against those in the already sorted sublist. As we look back into the already sorted sublist, we shift those items that are greater to the right. When we reach a smaller item or the end of the sublist, the current item can be inserted.</p> <p><code>Figure 5</code> shows the fifth pass in detail. At this point in the algorithm, here is a sorted sublist of five items: 17, 26, 54, 77, and 93. We want to insert 31 back into the already sorted items. The first comparison against 93 causes 93 to be shifted to the right. 77 and 54 are also shifted. When the item 26 is encountered, the shifting process stops and 31 is placed in the open position. Now we have a sorted sublist of six items.</p> <p> Figure 5: Insertion Sort: Fifth Pass of the Sort </p> <p>The implementation of <code>insertion_sort</code> (<code>ActiveCode 1</code>) shows that there are again \\(n-1\\) passes to sort \\(n\\) items. The iteration starts at position 1 and moves through position \\(n-1\\), as these are the items that need to be inserted back into the sorted sublists. Line 8 performs the shift operation that moves a value up one position in the list, making room behind it for the insertion. Remember that this is not a complete exchange as was performed in the previous algorithms.</p> <p>The maximum number of comparisons for an insertion sort is the sum of the first \\(n-1\\) integers. Again, this is \\(O(n^{2})\\). However, in the best case, only one comparison needs to be done on each pass. This would be the case for an already sorted list.</p> <p>One note about shifting versus exchanging is also important. In general, a shift operation requires approximately a third of the processing work of an exchange since only one assignment is performed. In benchmark studies, insertion sort will show very good performance.</p> Activity: 5.9.1 Insertion Sort<pre><code>def insertion_sort(a_list):\n    for i in range(1, len(a_list)):\n        cur_val = a_list[i]\n        cur_pos = i\n\n        while cur_pos &gt; 0 and a_list[cur_pos - 1] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\ninsertion_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 4 allows you to step through the algorithm.</p> Tracing the Insertion Sort<pre><code>def insertion_sort(a_list):\n    for i in range(1, len(a_list)):\n        cur_val = a_list[i]\n        cur_pos = i\n\n        while cur_pos &gt; 0 and a_list[cur_pos - 1] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\ninsertion_sort(a_list)\nprint(a_list)\n</code></pre> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:  [15, 5, 4, 18, 12, 19, 14, 10, 8, 20] which list represents the partially sorted list after three complete passes of insertion sort?</p> <ul> <li>answer a: [4, 5, 12, 15, 14, 10, 8, 18, 19, 20]</li> <li>answer b: [15, 5, 4, 10, 12, 8, 14, 18, 19, 20]</li> <li>answer c: [4, 5, 15, 18, 12, 19, 14, 10, 8, 20]</li> <li> <p>answer d: [15, 5, 4, 18, 12, 19, 14, 8, 10, 20]</p> </li> <li> <p>correct: c</p> </li> <li> <p>feedback a: This is a bubble sort.</p> </li> <li>feedback b:  This is the result of selection sort.</li> <li>feedback c: Insertion sort works at the start of the list.  Each pass produces a longer sorted list.</li> <li>feedback d: Insertion sort works on the front of the list not the end.</li> </ul> <p>The insertion sort, although still \\(O(n^{2})\\), works in a slightly different way. It always maintains a sorted sublist in the lower positions of the list. Each new item is then inserted back into the previous sublist such that the sorted sublist is one item larger. <code>Figure 4</code> shows the insertion sorting process. The shaded items represent the ordered sublists as the algorithm makes each pass.</p> <p> Figure 4: Insertion Sort: Complete </p> <p>We begin by assuming that a list with one item (position \\(0\\)) is already sorted. On each pass, one for each item 1 through \\(n-1\\), the current item is checked against those in the already sorted sublist. As we look back into the already sorted sublist, we shift those items that are greater to the right. When we reach a smaller item or the end of the sublist, the current item can be inserted.</p> <p><code>Figure 5</code> shows the fifth pass in detail. At this point in the algorithm, here is a sorted sublist of five items: 17, 26, 54, 77, and 93. We want to insert 31 back into the already sorted items. The first comparison against 93 causes 93 to be shifted to the right. 77 and 54 are also shifted. When the item 26 is encountered, the shifting process stops and 31 is placed in the open position. Now we have a sorted sublist of six items.</p> <p> Figure 5: Insertion Sort: Fifth Pass of the Sort </p> <p>The implementation of <code>insertion_sort</code> (<code>ActiveCode 1</code>) shows that there are again \\(n-1\\) passes to sort \\(n\\) items. The iteration starts at position 1 and moves through position \\(n-1\\), as these are the items that need to be inserted back into the sorted sublists. Line 8 performs the shift operation that moves a value up one position in the list, making room behind it for the insertion. Remember that this is not a complete exchange as was performed in the previous algorithms.</p> <p>The maximum number of comparisons for an insertion sort is the sum of the first \\(n-1\\) integers. Again, this is \\(O(n^{2})\\). However, in the best case, only one comparison needs to be done on each pass. This would be the case for an already sorted list.</p> <p>One note about shifting versus exchanging is also important. In general, a shift operation requires approximately a third of the processing work of an exchange since only one assignment is performed. In benchmark studies, insertion sort will show very good performance.</p> Activity: 5.9.1 Insertion Sort<pre><code>def insertion_sort(a_list):\n    for i in range(1, len(a_list)):\n        cur_val = a_list[i]\n        cur_pos = i\n\n        while cur_pos &gt; 0 and a_list[cur_pos - 1] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\ninsertion_sort(a_list)\nprint(a_list)\n</code></pre> <p> Initialize Run Stop Beginning Step Forward Step Backward End </p> <p>For more detail, CodeLens 4 allows you to step through the algorithm.</p> Tracing the Insertion Sort<pre><code>def insertion_sort(a_list):\n    for i in range(1, len(a_list)):\n        cur_val = a_list[i]\n        cur_pos = i\n\n        while cur_pos &gt; 0 and a_list[cur_pos - 1] &gt; cur_val:\n            a_list[cur_pos] = a_list[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        a_list[cur_pos] = cur_val\n\n\na_list = [54, 26, 93, 17, 77, 31, 44, 55, 20]\ninsertion_sort(a_list)\nprint(a_list)\n</code></pre> <p>Self Check</p> <p>Suppose you have the following list of numbers to sort:  [15, 5, 4, 18, 12, 19, 14, 10, 8, 20] which list represents the partially sorted list after three complete passes of insertion sort?</p> <ul> <li>answer a: [4, 5, 12, 15, 14, 10, 8, 18, 19, 20]</li> <li>answer b: [15, 5, 4, 10, 12, 8, 14, 18, 19, 20]</li> <li>answer c: [4, 5, 15, 18, 12, 19, 14, 10, 8, 20]</li> <li> <p>answer d: [15, 5, 4, 18, 12, 19, 14, 8, 10, 20]</p> </li> <li> <p>correct: c</p> </li> <li> <p>feedback a: This is a bubble sort.</p> </li> <li>feedback b:  This is the result of selection sort.</li> <li>feedback c: Insertion sort works at the start of the list.  Each pass produces a longer sorted list.</li> <li>feedback d: Insertion sort works on the front of the list not the end.</li> </ul>"},{"location":"c6/","title":"6. \u6811\u548c\u6811\u7b97\u6cd5","text":"\u4e2d\u6587\u82f1\u6587 <ul> <li>6.1. \u76ee\u6807</li> <li>6.2. \u6811\u7684\u793a\u4f8b</li> <li>6.3. \u8bcd\u6c47\u548c\u5b9a\u4e49</li> <li>6.4. \u5b9e\u73b0</li> <li>6.5. \u5217\u8868\u8868\u793a\u6cd5</li> <li>6.6. \u8282\u70b9\u4e0e\u5f15\u7528</li> <li>6.7. \u89e3\u6790\u6811</li> <li>6.8. \u6811\u904d\u5386</li> <li>6.9. \u4f7f\u7528\u4e8c\u53c9\u5806\u7684\u4f18\u5148\u961f\u5217</li> <li>6.10. \u4e8c\u53c9\u5806\u64cd\u4f5c</li> <li>6.11. \u4e8c\u53c9\u5806\u5b9e\u73b0<ul> <li>6.11.1. \u7ed3\u6784\u5c5e\u6027</li> <li>6.11.2. \u5806\u5e8f\u5c5e\u6027</li> <li>6.11.3. \u5806\u64cd\u4f5c</li> </ul> </li> <li>6.12. \u4e8c\u53c9\u641c\u7d22\u6811</li> <li>6.13. \u641c\u7d22\u6811\u64cd\u4f5c</li> <li>6.14. \u641c\u7d22\u6811\u5b9e\u73b0</li> <li>6.15. \u641c\u7d22\u6811\u5206\u6790</li> <li>6.16. \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811</li> <li>6.17. AVL\u6811\u6027\u80fd</li> <li>6.18. AVL\u6811\u5b9e\u73b0</li> <li>6.19. Map ADT\u5b9e\u73b0\u603b\u7ed3</li> <li>6.20. \u603b\u7ed3</li> <li>6.21. \u5173\u952e\u672f\u8bed</li> <li>6.22. \u7ec3\u4e60</li> </ul> <ul> <li>6.1. Objectives</li> <li>6.2. Examples of Trees</li> <li>6.3. Vocabulary and Definitions</li> <li>6.4. Implementation</li> <li>6.5. List of Lists Representation</li> <li>6.6. Nodes and References</li> <li>6.7. Parse Tree</li> <li>6.8. Tree Traversals</li> <li>6.9. Priority Queues with Binary Heaps</li> <li>6.10. Binary Heap Operations</li> <li>6.11. Binary Heap Implementation<ul> <li>6.11.1. The Structure Property</li> <li>6.11.2. The Heap Order Property</li> <li>6.11.3. Heap Operations</li> </ul> </li> <li>6.12. Binary Search Trees</li> <li>6.13. Search Tree Operations</li> <li>6.14. Search Tree Implementation</li> <li>6.15. Search Tree Analysis</li> <li>6.16. Balanced Binary Search Trees</li> <li>6.17. AVL Tree Performance</li> <li>6.18. AVL Tree Implementation</li> <li>6.19. Summary of Map ADT Implementations</li> <li>6.20. Summary</li> <li>6.21. Key Terms</li> <li>6.22. Exercises</li> </ul>"},{"location":"c6/s1/","title":"6.1. \u76ee\u6807","text":"<p>6.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>To understand what a tree data structure is and how it is used.</li> <li>To see how trees can be used to implement a map data structure.</li> <li>To implement trees using a list.</li> <li>To implement trees using classes and references.</li> <li>To implement trees as a recursive data structure.</li> <li>To implement a priority queue using a heap.</li> </ul> <ul> <li>To understand what a tree data structure is and how it is used.</li> <li>To see how trees can be used to implement a map data structure.</li> <li>To implement trees using a list.</li> <li>To implement trees using classes and references.</li> <li>To implement trees as a recursive data structure.</li> <li>To implement a priority queue using a heap.</li> </ul>"},{"location":"c6/s10/","title":"6.10. \u4e8c\u53c9\u5806\u64cd\u4f5c","text":"<p>6.10. Binary Heap Operations</p> \u4e2d\u6587\u82f1\u6587 <p>The basic operations we will implement for our binary heap are as follows:</p> <ul> <li><code>BinaryHeap()</code> creates a new empty binary heap.</li> <li><code>insert(k)</code> adds a new item to the heap.</li> <li><code>get_min()</code> returns the item with the minimum key value, leaving the item in the heap.</li> <li><code>delete()</code> returns the item with the minimum key value, removing the item from the heap.</li> <li><code>is_empty()</code> returns <code>True</code> if the heap is empty, <code>False</code> otherwise.</li> <li><code>size()</code> returns the number of items in the heap.</li> <li><code>heapify(list)</code> builds a new heap from a list of keys.</li> </ul> <p><code>ActiveCode 1</code> demonstrates the use of some of the binary heap methods.  Notice that no matter what order we add items to the heap, the smallest is removed each time.</p> Activity: 6.10.1 Using the Binary Heap<pre><code>from pythonds3.trees import BinaryHeap\n\nmy_heap = BinaryHeap()\nmy_heap.insert(5)\nmy_heap.insert(7)\nmy_heap.insert(3)\nmy_heap.insert(11)\n\nprint(my_heap.delete())\nprint(my_heap.delete())\nprint(my_heap.delete())\nprint(my_heap.delete())\n</code></pre> <p>The basic operations we will implement for our binary heap are as follows:</p> <ul> <li><code>BinaryHeap()</code> creates a new empty binary heap.</li> <li><code>insert(k)</code> adds a new item to the heap.</li> <li><code>get_min()</code> returns the item with the minimum key value, leaving the item in the heap.</li> <li><code>delete()</code> returns the item with the minimum key value, removing the item from the heap.</li> <li><code>is_empty()</code> returns <code>True</code> if the heap is empty, <code>False</code> otherwise.</li> <li><code>size()</code> returns the number of items in the heap.</li> <li><code>heapify(list)</code> builds a new heap from a list of keys.</li> </ul> <p><code>ActiveCode 1</code> demonstrates the use of some of the binary heap methods.  Notice that no matter what order we add items to the heap, the smallest is removed each time.</p> Activity: 6.10.1 Using the Binary Heap<pre><code>from pythonds3.trees import BinaryHeap\n\nmy_heap = BinaryHeap()\nmy_heap.insert(5)\nmy_heap.insert(7)\nmy_heap.insert(3)\nmy_heap.insert(11)\n\nprint(my_heap.delete())\nprint(my_heap.delete())\nprint(my_heap.delete())\nprint(my_heap.delete())\n</code></pre>"},{"location":"c6/s11/","title":"6.11. \u4e8c\u53c9\u5806\u5b9e\u73b0","text":"<p>6.11. Binary Heap Implementation</p>"},{"location":"c6/s11/#6111-\u7ed3\u6784\u5c5e\u6027","title":"6.11.1. \u7ed3\u6784\u5c5e\u6027","text":"<p>6.11.1. The Structure Property</p> \u4e2d\u6587\u82f1\u6587 <p>In order to make our heap work efficiently, we will take advantage of the logarithmic nature of the binary tree to represent our heap. In order to guarantee logarithmic performance, we must keep our tree balanced. A balanced binary tree has roughly the same number of nodes in the left and right subtrees of the root. In our heap implementation we keep the tree balanced by creating a complete binary tree. A complete binary tree is a tree in which each level has all of its nodes. The exception to this is the bottom level of the tree, which we fill in from left to right. <code>Figure 1</code> shows an example of a complete binary tree.</p> <p> Figure 1: A Complete Binary Tree </p> <p>Another interesting property of a complete tree is that we can represent it using a single list. We do not need to use nodes and references or even lists of lists. Because the tree is complete, the left child of a parent (at position \\(p\\)) is the node that is found in position \\(2p + 1\\) in the list. Similarly, the right child of the parent is at position \\(2p + 2\\) in the list. To find the parent of any node in the tree, we can simply use Python\u2019s integer division. Given that a node is at position \\(n\\) in the list, the parent is at position \\((n - 1) // 2<code>.</code>Figure 2\\) shows a complete binary tree and also gives the list representation of the tree.  Note the \\(2p + 1\\) and \\(2p + 2\\) relationship between parent and children. The list representation of the tree, along with the full structure property, allows us to efficiently traverse a complete binary tree using only a few simple mathematical operations. We will see that this also leads to an efficient implementation of our binary heap.</p> <p>In order to make our heap work efficiently, we will take advantage of the logarithmic nature of the binary tree to represent our heap. In order to guarantee logarithmic performance, we must keep our tree balanced. A balanced binary tree has roughly the same number of nodes in the left and right subtrees of the root. In our heap implementation we keep the tree balanced by creating a complete binary tree. A complete binary tree is a tree in which each level has all of its nodes. The exception to this is the bottom level of the tree, which we fill in from left to right. <code>Figure 1</code> shows an example of a complete binary tree.</p> <p> Figure 1: A Complete Binary Tree </p> <p>Another interesting property of a complete tree is that we can represent it using a single list. We do not need to use nodes and references or even lists of lists. Because the tree is complete, the left child of a parent (at position \\(p\\)) is the node that is found in position \\(2p + 1\\) in the list. Similarly, the right child of the parent is at position \\(2p + 2\\) in the list. To find the parent of any node in the tree, we can simply use Python\u2019s integer division. Given that a node is at position \\(n\\) in the list, the parent is at position \\((n - 1) // 2<code>.</code>Figure 2\\) shows a complete binary tree and also gives the list representation of the tree.  Note the \\(2p + 1\\) and \\(2p + 2\\) relationship between parent and children. The list representation of the tree, along with the full structure property, allows us to efficiently traverse a complete binary tree using only a few simple mathematical operations. We will see that this also leads to an efficient implementation of our binary heap.</p>"},{"location":"c6/s11/#6112-\u5806\u5e8f\u5c5e\u6027","title":"6.11.2. \u5806\u5e8f\u5c5e\u6027","text":"<p>6.11.2. The Heap Order Property</p> \u4e2d\u6587\u82f1\u6587 <p>The method that we will use to store items in a heap relies on maintaining the heap order property. The heap order property is as follows: in a heap, for every node \\(x\\) with parent \\(p\\), the key in \\(p\\) is smaller than or equal to the key in \\(x\\). <code>Figure 2</code> also illustrates a complete binary tree that has the heap order property.</p> <p> Figure 2: A Complete Binary Tree, along with Its List Representation </p> <p>The method that we will use to store items in a heap relies on maintaining the heap order property. The heap order property is as follows: in a heap, for every node \\(x\\) with parent \\(p\\), the key in \\(p\\) is smaller than or equal to the key in \\(x\\). <code>Figure 2</code> also illustrates a complete binary tree that has the heap order property.</p> <p> Figure 2: A Complete Binary Tree, along with Its List Representation </p>"},{"location":"c6/s11/#6113-\u5806\u64cd\u4f5c","title":"6.11.3. \u5806\u64cd\u4f5c","text":"<p>6.11.3. Heap Operations</p> \u4e2d\u6587\u82f1\u6587 <p>We will begin our implementation of a binary heap with the constructor. Since the entire binary heap can be represented by a single list, all the constructor will do is initialize the list. <code>Listing 1</code> shows the Python code for the constructor.</p> Listing 1<pre><code>class BinaryHeap:\n    def __init__(self):\n        self._heap = []\n</code></pre> <p>The next method we will implement is <code>insert</code>. The easiest, and most efficient, way to add an item to a list is to simply append the item to the end of the list. The good news about appending is that it guarantees that we will maintain the complete tree property. The bad news about appending is that we will very likely violate the heap structure property. However, it is possible to write a method that will allow us to regain the heap structure property by comparing the newly added item with its parent. If the newly added item is less than its parent, then we can swap the item with its parent. <code>Figure 2</code> shows the series of swaps needed to percolate the newly added item up to its proper position in the tree.</p> <p> Figure 2: Percolate the New Node up to Its Proper Position </p> <p>Notice that when we percolate an item up, we are restoring the heap property between the newly added item and the parent. We are also preserving the heap property for any siblings. Of course, if the newly added item is very small, we may still need to swap it up another level. In fact, we may need to keep swapping until we get to the top of the tree. <code>Listing 2</code> shows the <code>_perc_up</code> method, which percolates a new item as far up in the tree as it needs to go to maintain the heap property. We used a leading underscore (<code>_</code>) in  the name of the method as it is an internal operation. The parent of the current node can be computed by subtracting 1 from the index of the current node and dividing the result by 2.</p> <p>We are now ready to write the <code>insert</code> method (see <code>Listing 3</code>). Most of the work in the <code>insert</code> method is really done by <code>_perc_up</code>. Once a new item is appended to the tree, <code>_perc_up</code> takes over and positions the new item properly.</p> Listing 2<pre><code>def _perc_up(self, i):\n    while (i - 1) // 2 &gt;= 0:\n        parent_idx = (i - 1) // 2\n        if self._heap[i] &lt; self._heap[parent_idx]:\n            self._heap[i], self._heap[parent_idx] = (\n                self._heap[parent_idx],\n                self._heap[i],\n            )\n        i = parent_idx\n</code></pre> Listing 3<pre><code>def insert(self, item):\n    self._heap.append(item)\n    self._perc_up(len(self._heap) - 1)\n</code></pre> <p>With the <code>insert</code> method properly defined, we can now look at the <code>delete</code> method. Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy. The hard part of <code>delete</code> is restoring full compliance with the heap structure and heap order properties after the root has been removed. We can restore our heap in two steps. First, we will restore the root item by taking the last item in the list and moving it to the root position. Moving the last item maintains our heap structure property. However, we have probably destroyed the heap order property of our binary heap. Second, we will restore the heap order property by pushing the new root node down the tree to its proper position. <code>Figure 3</code> shows the series of swaps needed to move the new root node to its proper position in the heap.</p> <p> Figure 3: Percolating the Root Node down the Tree </p> <p>In order to maintain the heap order property, all we need to do is swap the root with its smaller child that is less than the root. After the initial swap, we may repeat the swapping process with a node and its children until the node is swapped into a position on the tree where it is already less than both children. The code for percolating a node down the tree is found in the <code>_perc_down</code> and <code>_get_min_child</code> methods in <code>Listing 4</code>.</p> Listing 4<pre><code>def _perc_down(self, i):\n    while 2 * i + 1 &lt; len(self._heap):\n        sm_child = self._get_min_child(i)\n        if self._heap[i] &gt; self._heap[sm_child]:\n            self._heap[i], self._heap[sm_child] = (\n                self._heap[sm_child],\n                self._heap[i],\n            )\n        else:\n            break\n        i = sm_child\n\ndef _get_min_child(self, i):\n    if 2 * i + 2 &gt; len(self._heap) - 1:\n        return 2 * i + 1\n    if self._heap[2 * i + 1] &lt; self._heap[2 * i + 2]:\n        return 2 * i + 1\n    return 2 * i + 2\n</code></pre> <p>The code for the <code>delete</code> operation is in <code>Listing 5</code>. Note that once again the hard work is handled by a helper function, in this case <code>_perc_down</code>.</p> Listing 5<pre><code>def delete(self):\n    self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n    result = self._heap.pop()\n    self._perc_down(0)\n    return result\n</code></pre> <p>To finish our discussion of binary heaps, we will look at a method to build an entire heap from a list of keys. The first method you might think of may be like the following. Given a list of keys, you could easily build a heap by inserting each key one at a time. Since you are starting with an empy list, it is sorted and you could use binary search to find the right position to insert the next key at a cost of approximately \\(O(\\log{n})\\) operations. However, remember that inserting an item in the middle of the list may require \\(O(n)\\) operations to shift the rest of the list over to make room for the new key. Therefore, to insert \\(n\\) keys into the heap would require a total of \\(O(n \\log{n})\\) operations. However, if we start with an entire list then we can build the whole heap in \\(O(n)\\) operations. <code>Listing 6</code> shows the code to build the entire heap.</p> Listing 6<pre><code>def heapify(self, not_a_heap):\n    self._heap = not_a_heap[:]\n    i = len(self._heap) // 2 - 1\n    while i &gt;= 0:\n        self._perc_down(i)\n        i = i - 1\n</code></pre> <p> Figure 4: Building a Heap from the List [9, 6, 5, 2, 3] </p> <p><code>Figure 4</code> shows the swaps that the <code>hepify</code> method makes as it moves the nodes in an initial tree of [9, 6, 5, 2, 3] into their proper positions. Although we start out in the middle of the tree and work our way back toward the root, the <code>_perc_down</code> method ensures that the largest child is always moved down the tree. Because the heap is a complete binary tree, any nodes past the halfway point will be leaves and therefore have no children. Notice that when <code>i = 0</code>, we are percolating down from the root of the tree, so this may require multiple swaps. As you can see in the rightmost two trees of <code>Figure 4</code>, first the 9 is moved out of the root position, but after 9 is moved down one level in the tree, <code>_perc_down</code> ensures that we check the next set of children farther down in the tree to ensure that it is pushed as low as it can go. In this case it results in a second swap with 3. Now that 9 has been moved to the lowest level of the tree, no further swapping can be done. It is useful to compare the list representation of this series of swaps with the tree representation shown in <code>Figure 4</code></p> <pre><code>start  [9, 6, 5, 2, 3]\ni = 1  [9, 2, 5, 6, 3]\ni = 0  [2, 3, 5, 6, 9]\n</code></pre> <p>The complete binary heap implementation can be seen in ActiveCode 1.</p> Activity: 6.11.3.1 The Complete Binary Heap Example<pre><code>class BinaryHeap:\n    def __init__(self):\n        self._heap = []\n\n    def _perc_up(self, cur_idx):\n        while (cur_idx - 1) // 2 &gt;= 0:\n            parent_idx = (cur_idx - 1) // 2\n            if self._heap[cur_idx] &lt; self._heap[parent_idx]:\n                self._heap[cur_idx], self._heap[parent_idx] = (\n                    self._heap[parent_idx],\n                    self._heap[cur_idx],\n                )\n            cur_idx = parent_idx\n\n    def _perc_down(self, cur_idx):\n        while 2 * cur_idx + 1 &lt; len(self._heap):\n            min_child_idx = self._get_min_child(cur_idx)\n            if self._heap[cur_idx] &gt; self._heap[min_child_idx]:\n                self._heap[cur_idx], self._heap[min_child_idx] = (\n                    self._heap[min_child_idx],\n                    self._heap[cur_idx],\n                )\n            else:\n                return\n            cur_idx = min_child_idx\n\n    def _get_min_child(self, parent_idx):\n        if 2 * parent_idx + 2 &gt; len(self._heap) - 1:\n            return 2 * parent_idx + 1\n        if self._heap[2 * parent_idx + 1] &lt; self._heap[2 * parent_idx + 2]:\n            return 2 * parent_idx + 1\n        return 2 * parent_idx + 2\n\n    def heapify(self, not_a_heap):\n        self._heap = not_a_heap[:]\n        cur_idx = len(self._heap) // 2 - 1\n        while cur_idx &gt;= 0:\n            self._perc_down(cur_idx)\n            cur_idx = cur_idx - 1\n\n    def get_min(self):\n        return self._heap[0]\n\n    def insert(self, item):\n        self._heap.append(item)\n        self._perc_up(len(self._heap) - 1)\n\n    def delete(self):\n        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n        result = self._heap.pop()\n        self._perc_down(0)\n        return result\n\n    def is_empty(self):\n        return not bool(self._heap)\n\n    def __len__(self):\n        return len(self._heap)\n\n    def __str__(self):\n        return str(self._heap)\n\na_heap = BinaryHeap()\na_heap.heapify([9, 5, 6, 2, 3])\n\nwhile not a_heap.is_empty():\n    print(a_heap.delete())\n</code></pre> <p>The assertion that we can build the heap in \\(O(n)\\) may seem a bit mysterious at first, and a proof is beyond the scope of this book. However, the key to understanding that you can build the heap in \\(O(n)\\) is to remember that the \\(\\log{n}\\) factor is derived from the height of the tree. For most of the work in <code>heapify</code>, the tree is shorter than \\(\\log{n}\\).</p> <p>Using the fact that you can build a heap from a list in \\(O(n)\\) time, you will construct a sorting algorithm that uses a heap and sorts a list in \\(O(n\\log{n})\\) as an exercise at the end of this chapter.</p> <p>We will begin our implementation of a binary heap with the constructor. Since the entire binary heap can be represented by a single list, all the constructor will do is initialize the list. <code>Listing 1</code> shows the Python code for the constructor.</p> Listing 1<pre><code>class BinaryHeap:\n    def __init__(self):\n        self._heap = []\n</code></pre> <p>The next method we will implement is <code>insert</code>. The easiest, and most efficient, way to add an item to a list is to simply append the item to the end of the list. The good news about appending is that it guarantees that we will maintain the complete tree property. The bad news about appending is that we will very likely violate the heap structure property. However, it is possible to write a method that will allow us to regain the heap structure property by comparing the newly added item with its parent. If the newly added item is less than its parent, then we can swap the item with its parent. <code>Figure 2</code> shows the series of swaps needed to percolate the newly added item up to its proper position in the tree.</p> <p> Figure 2: Percolate the New Node up to Its Proper Position </p> <p>Notice that when we percolate an item up, we are restoring the heap property between the newly added item and the parent. We are also preserving the heap property for any siblings. Of course, if the newly added item is very small, we may still need to swap it up another level. In fact, we may need to keep swapping until we get to the top of the tree. <code>Listing 2</code> shows the <code>_perc_up</code> method, which percolates a new item as far up in the tree as it needs to go to maintain the heap property. We used a leading underscore (<code>_</code>) in  the name of the method as it is an internal operation. The parent of the current node can be computed by subtracting 1 from the index of the current node and dividing the result by 2.</p> <p>We are now ready to write the <code>insert</code> method (see <code>Listing 3</code>). Most of the work in the <code>insert</code> method is really done by <code>_perc_up</code>. Once a new item is appended to the tree, <code>_perc_up</code> takes over and positions the new item properly.</p> Listing 2<pre><code>def _perc_up(self, i):\n    while (i - 1) // 2 &gt;= 0:\n        parent_idx = (i - 1) // 2\n        if self._heap[i] &lt; self._heap[parent_idx]:\n            self._heap[i], self._heap[parent_idx] = (\n                self._heap[parent_idx],\n                self._heap[i],\n            )\n        i = parent_idx\n</code></pre> Listing 3<pre><code>def insert(self, item):\n    self._heap.append(item)\n    self._perc_up(len(self._heap) - 1)\n</code></pre> <p>With the <code>insert</code> method properly defined, we can now look at the <code>delete</code> method. Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy. The hard part of <code>delete</code> is restoring full compliance with the heap structure and heap order properties after the root has been removed. We can restore our heap in two steps. First, we will restore the root item by taking the last item in the list and moving it to the root position. Moving the last item maintains our heap structure property. However, we have probably destroyed the heap order property of our binary heap. Second, we will restore the heap order property by pushing the new root node down the tree to its proper position. <code>Figure 3</code> shows the series of swaps needed to move the new root node to its proper position in the heap.</p> <p> Figure 3: Percolating the Root Node down the Tree </p> <p>In order to maintain the heap order property, all we need to do is swap the root with its smaller child that is less than the root. After the initial swap, we may repeat the swapping process with a node and its children until the node is swapped into a position on the tree where it is already less than both children. The code for percolating a node down the tree is found in the <code>_perc_down</code> and <code>_get_min_child</code> methods in <code>Listing 4</code>.</p> Listing 4<pre><code>def _perc_down(self, i):\n    while 2 * i + 1 &lt; len(self._heap):\n        sm_child = self._get_min_child(i)\n        if self._heap[i] &gt; self._heap[sm_child]:\n            self._heap[i], self._heap[sm_child] = (\n                self._heap[sm_child],\n                self._heap[i],\n            )\n        else:\n            break\n        i = sm_child\n\ndef _get_min_child(self, i):\n    if 2 * i + 2 &gt; len(self._heap) - 1:\n        return 2 * i + 1\n    if self._heap[2 * i + 1] &lt; self._heap[2 * i + 2]:\n        return 2 * i + 1\n    return 2 * i + 2\n</code></pre> <p>The code for the <code>delete</code> operation is in <code>Listing 5</code>. Note that once again the hard work is handled by a helper function, in this case <code>_perc_down</code>.</p> Listing 5<pre><code>def delete(self):\n    self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n    result = self._heap.pop()\n    self._perc_down(0)\n    return result\n</code></pre> <p>To finish our discussion of binary heaps, we will look at a method to build an entire heap from a list of keys. The first method you might think of may be like the following. Given a list of keys, you could easily build a heap by inserting each key one at a time. Since you are starting with an empy list, it is sorted and you could use binary search to find the right position to insert the next key at a cost of approximately \\(O(\\log{n})\\) operations. However, remember that inserting an item in the middle of the list may require \\(O(n)\\) operations to shift the rest of the list over to make room for the new key. Therefore, to insert \\(n\\) keys into the heap would require a total of \\(O(n \\log{n})\\) operations. However, if we start with an entire list then we can build the whole heap in \\(O(n)\\) operations. <code>Listing 6</code> shows the code to build the entire heap.</p> Listing 6<pre><code>def heapify(self, not_a_heap):\n    self._heap = not_a_heap[:]\n    i = len(self._heap) // 2 - 1\n    while i &gt;= 0:\n        self._perc_down(i)\n        i = i - 1\n</code></pre> <p> Figure 4: Building a Heap from the List [9, 6, 5, 2, 3] </p> <p><code>Figure 4</code> shows the swaps that the <code>hepify</code> method makes as it moves the nodes in an initial tree of [9, 6, 5, 2, 3] into their proper positions. Although we start out in the middle of the tree and work our way back toward the root, the <code>_perc_down</code> method ensures that the largest child is always moved down the tree. Because the heap is a complete binary tree, any nodes past the halfway point will be leaves and therefore have no children. Notice that when <code>i = 0</code>, we are percolating down from the root of the tree, so this may require multiple swaps. As you can see in the rightmost two trees of <code>Figure 4</code>, first the 9 is moved out of the root position, but after 9 is moved down one level in the tree, <code>_perc_down</code> ensures that we check the next set of children farther down in the tree to ensure that it is pushed as low as it can go. In this case it results in a second swap with 3. Now that 9 has been moved to the lowest level of the tree, no further swapping can be done. It is useful to compare the list representation of this series of swaps with the tree representation shown in <code>Figure 4</code></p> <pre><code>start  [9, 6, 5, 2, 3]\ni = 1  [9, 2, 5, 6, 3]\ni = 0  [2, 3, 5, 6, 9]\n</code></pre> <p>The complete binary heap implementation can be seen in ActiveCode 1.</p> Activity: 6.11.3.1 The Complete Binary Heap Example<pre><code>class BinaryHeap:\n    def __init__(self):\n        self._heap = []\n\n    def _perc_up(self, cur_idx):\n        while (cur_idx - 1) // 2 &gt;= 0:\n            parent_idx = (cur_idx - 1) // 2\n            if self._heap[cur_idx] &lt; self._heap[parent_idx]:\n                self._heap[cur_idx], self._heap[parent_idx] = (\n                    self._heap[parent_idx],\n                    self._heap[cur_idx],\n                )\n            cur_idx = parent_idx\n\n    def _perc_down(self, cur_idx):\n        while 2 * cur_idx + 1 &lt; len(self._heap):\n            min_child_idx = self._get_min_child(cur_idx)\n            if self._heap[cur_idx] &gt; self._heap[min_child_idx]:\n                self._heap[cur_idx], self._heap[min_child_idx] = (\n                    self._heap[min_child_idx],\n                    self._heap[cur_idx],\n                )\n            else:\n                return\n            cur_idx = min_child_idx\n\n    def _get_min_child(self, parent_idx):\n        if 2 * parent_idx + 2 &gt; len(self._heap) - 1:\n            return 2 * parent_idx + 1\n        if self._heap[2 * parent_idx + 1] &lt; self._heap[2 * parent_idx + 2]:\n            return 2 * parent_idx + 1\n        return 2 * parent_idx + 2\n\n    def heapify(self, not_a_heap):\n        self._heap = not_a_heap[:]\n        cur_idx = len(self._heap) // 2 - 1\n        while cur_idx &gt;= 0:\n            self._perc_down(cur_idx)\n            cur_idx = cur_idx - 1\n\n    def get_min(self):\n        return self._heap[0]\n\n    def insert(self, item):\n        self._heap.append(item)\n        self._perc_up(len(self._heap) - 1)\n\n    def delete(self):\n        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n        result = self._heap.pop()\n        self._perc_down(0)\n        return result\n\n    def is_empty(self):\n        return not bool(self._heap)\n\n    def __len__(self):\n        return len(self._heap)\n\n    def __str__(self):\n        return str(self._heap)\n\na_heap = BinaryHeap()\na_heap.heapify([9, 5, 6, 2, 3])\n\nwhile not a_heap.is_empty():\n    print(a_heap.delete())\n</code></pre> <p>The assertion that we can build the heap in \\(O(n)\\) may seem a bit mysterious at first, and a proof is beyond the scope of this book. However, the key to understanding that you can build the heap in \\(O(n)\\) is to remember that the \\(\\log{n}\\) factor is derived from the height of the tree. For most of the work in <code>heapify</code>, the tree is shorter than \\(\\log{n}\\).</p> <p>Using the fact that you can build a heap from a list in \\(O(n)\\) time, you will construct a sorting algorithm that uses a heap and sorts a list in \\(O(n\\log{n})\\) as an exercise at the end of this chapter.</p>"},{"location":"c6/s12/","title":"6.12. \u4e8c\u53c9\u641c\u7d22\u6811","text":"<p>6.12. Binary Search Trees</p> \u4e2d\u6587\u82f1\u6587 <p>We have already seen two different ways to get key-value pairs in a collection. Recall that these collections implement the map abstract data type. The two implementations of the map ADT that we have discussed were binary search on a list and hash tables. In this section we will study binary search trees as yet another way to map from a key to a value. In this case we are not interested in the exact placement of items in the tree, but we are interested in using the binary tree structure to provide for efficient searching.</p> <p>We have already seen two different ways to get key-value pairs in a collection. Recall that these collections implement the map abstract data type. The two implementations of the map ADT that we have discussed were binary search on a list and hash tables. In this section we will study binary search trees as yet another way to map from a key to a value. In this case we are not interested in the exact placement of items in the tree, but we are interested in using the binary tree structure to provide for efficient searching.</p>"},{"location":"c6/s13/","title":"6.13. \u641c\u7d22\u6811\u64cd\u4f5c","text":"<p>6.13. Search Tree Operations</p> \u4e2d\u6587\u82f1\u6587 <p>Before we look at the implementation, let\u2019s review the interface provided by the map ADT. You will notice that this interface is very similar to the Python dictionary.</p> <ul> <li><code>Map()</code> creates a new empty map.</li> <li><code>put(key, val)</code> adds a new key--value pair to the map. If the key is already in the map, it replaces the old value with the new value.</li> <li><code>get(key)</code> takes a key and returns the matching value stored in the map or <code>None</code> otherwise.</li> <li><code>del</code> deletes the key--value pair from the map using a statement of the form <code>del map[key]</code>.</li> <li><code>size()</code> returns the number of key--value pairs stored in the map.</li> <li><code>in</code> return <code>True</code> for a statement of the form <code>key in map</code> if the given key is in the map, <code>False</code> otherwise.</li> </ul> <p>Before we look at the implementation, let\u2019s review the interface provided by the map ADT. You will notice that this interface is very similar to the Python dictionary.</p> <ul> <li><code>Map()</code> creates a new empty map.</li> <li><code>put(key, val)</code> adds a new key--value pair to the map. If the key is already in the map, it replaces the old value with the new value.</li> <li><code>get(key)</code> takes a key and returns the matching value stored in the map or <code>None</code> otherwise.</li> <li><code>del</code> deletes the key--value pair from the map using a statement of the form <code>del map[key]</code>.</li> <li><code>size()</code> returns the number of key--value pairs stored in the map.</li> <li><code>in</code> return <code>True</code> for a statement of the form <code>key in map</code> if the given key is in the map, <code>False</code> otherwise.</li> </ul>"},{"location":"c6/s14/","title":"6.14. \u641c\u7d22\u6811\u5b9e\u73b0","text":"<p>6.14. Search Tree Implementation</p> \u4e2d\u6587\u82f1\u6587 <p>A binary search tree (BST) relies on the property that keys that are less than the parent are found in the left subtree, and keys that are greater than the parent are found in the right subtree. We will call this the BST property. As we implement the <code>Map</code> interface as described above, the BST property will guide our implementation. <code>Figure 1</code> illustrates this property of a binary search tree, showing the keys without any associated values. Notice that the property holds for each parent and child. All of the keys in the left subtree are less than the key in the root. All of the keys in the right subtree are greater than the root.</p> <p> Figure 1: A Simple Binary Search Tree </p> <p>Now that you know what a binary search tree is, we will look at how a binary search tree is constructed. The search tree in <code>Figure 1</code> represents the nodes that exist after we have inserted the following keys in the order shown: \\(70, 31, 93, 94, 14, 23, 73\\). Since 70 was the first key inserted into the tree, it is the root. Next, 31 is less than 70, so it becomes the left child of 70. Next, 93 is greater than 70, so it becomes the right child of 70. Now we have two levels of the tree filled, so the next key is going to be the left or right child of either 31 or 93. Since 94 is greater than 70 and 93, it becomes the right child of 93. Similarly 14 is less than 70 and 31, so it becomes the left child of 31. 23 is also less than 31, so it must be in the left subtree of 31. However, it is greater than 14, so it becomes the right child of 14.</p> <p>To implement the binary search tree, we will use the nodes and references approach similar to the one we used to implement the linked list and the expression tree. However, because we must be able create and work with a binary search tree that is empty, our implementation will use two classes. The first class we will call <code>BinarySearchTree</code>, and the second class we will call <code>TreeNode</code>. The <code>BinarySearchTree</code> class has a reference to the <code>TreeNode</code> that is the root of the binary search tree. In most cases the external methods defined in the outer class simply check to see if the tree is empty. If there are nodes in the tree, the request is just passed on to a private method defined in the <code>BinarySearchTree</code> class that takes the root as a parameter. In the case where the tree is empty or we want to delete the key at the root of the tree, we must take special action. The code for the <code>BinarySearchTree</code> class constructor along with a few other miscellaneous methods is shown in <code>Listing 1</code>.</p> Listing 1<pre><code>class BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n</code></pre> <p>The <code>TreeNode</code> class provides many helper methods that make the work done in the <code>BinarySearchTree</code> class methods much easier. The constructor for a <code>TreeNode</code>, along with these helper methods, is shown in <code>Listing 2</code>. As you can see in the listing many of these helper methods help to classify a node according to its own position as a child (left or right) and the kind of children the node has. The <code>TreeNode</code> class will also explicitly keep track of the parent as an attribute of each node. You will see why this is important when we discuss the implementation for the <code>del</code> operator.</p> <p>Another interesting aspect of the implementation of <code>TreeNode</code> in <code>Listing 2</code> is that we use Python\u2019s optional parameters. Optional parameters make it easy for us to create a <code>TreeNode</code> under several different circumstances. Sometimes we will want to construct a new <code>TreeNode</code> that already has both a parent and a child (e.g. left) and in that case we can pass <code>parent</code> and <code>left_child</code> as parameters. At other times we will just create a <code>TreeNode</code> with the key-value pair, and we will not pass any parameters for <code>parent</code> or <code>child</code>. In this case, the default values of the optional parameters are used.</p> Listing 2<pre><code>class TreeNode:\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        self.parent = parent\n\n    def is_left_child(self):\n        return self.parent and self.parent.left_child is self\n\n    def is_right_child(self):\n        return self.parent and self.parent.right_child is self\n\n    def is_root(self):\n        return not self.parent\n\n    def is_leaf(self):\n        return not (self.right_child or self.left_child)\n\n    def has_any_child(self):\n        return self.right_child or self.left_child\n\n    def has_children(self):\n        return self.right_child and self.left_child\n\n    def replace_value(self, key, value, left, right):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        if self.left_child:\n            self.left_child.parent = self\n        if self.right_child:\n            self.right_child.parent = self\n</code></pre> <p>Now that we have the <code>BinarySearchTree</code> shell and the <code>TreeNode</code>, it is time to write the <code>put</code> method that will allow us to build our binary search tree. The <code>put</code> method is a method of the <code>BinarySearchTree</code> class. This method will check to see if the tree already has a root. If there is not a root, then <code>put</code> will create a new <code>TreeNode</code> and install it as the root of the tree. If a root node is already in place, then <code>put</code> calls the private recursive helper method <code>_put</code> to search the tree according to the following algorithm:</p> <ul> <li>Starting at the root of the tree, search the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.</li> <li>When there is no left or right child to search, we have found the position in the tree where the new node should be installed.</li> <li>To add a node to the tree, create a new <code>TreeNode</code> object and insert the object at the point discovered in the previous step.</li> </ul> <p><code>Listing 3</code> shows the Python code for inserting a new node in the tree. The <code>_put</code> method is written recursively following the steps outlined above. Notice that when a new child is inserted into the tree, the <code>current_node</code> is passed to the new tree as the parent.</p> <p>One important problem with our implementation of insertion is that duplicate keys are not handled properly. As our tree is implemented, a duplicate key will create a new node with the same key value in the right subtree of the node having the original key. The result of this is that the node with the new key will never be found during a search. A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value. We leave fixing this bug as an exercise for you.</p> Listing 3<pre><code>def put(self, key, value):\n    if self.root:\n        self._put(key, value, self.root)\n    else:\n        self.root = TreeNode(key, value)\n    self.size = self.size + 1\n\ndef _put(self, key, value, current_node):\n    if key &lt; current_node.key:\n        if current_node.left_child:\n            self._put(key, value, current_node.left_child)\n        else:\n            current_node.left_child = TreeNode(key, value, parent=current_node)\n    else:\n        if current_node.right_child:\n            self._put(key, value, current_node.right_child)\n        else:\n            current_node.right_child = TreeNode(key, value, parent=current_node)\n</code></pre> <p>With the <code>put</code> method defined, we can easily overload the <code>[]</code> operator for assignment by having the <code>__setitem__</code> method call the <code>put</code> method (see <code>Listing 4</code>). This allows us to write Python statements like <code>my_zip_tree['Plymouth'] = 55446</code>, just like a Python dictionary.</p> Listing 4<pre><code>    def __setitem__(self, key, value):\n        self.put(key, value)\n</code></pre> <p><code>Figure 2</code> illustrates the process for inserting a new node into a binary search tree. The lightly shaded nodes indicate the nodes that were visited during the insertion process.</p> <p> Figure 2: Inserting a Node with Key = 19 </p> <p>Self Check</p> <p>Which of the trees shows a correct binary search tree given that the keys were inserted in the following order 5, 30, 2, 40, 25, 4.</p> <ul> <li>answer_a: </li> <li>answer_b: </li> <li>answer_c: </li> </ul> <p>correct: b</p> <ul> <li>feedback a: Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.</li> <li>feedback b: good job.</li> <li>feedback c: This looks like a binary tree that satisfies the full tree property needed for a heap.</li> </ul> <p>Once the tree is constructed, the next task is to implement the retrieval of a value for a given key. The <code>get</code> method is even easier than the <code>put</code> method because it simply searches the tree recursively until it gets to a non-matching leaf node or finds a matching key. When a matching key is found, the value stored in the payload of the node is returned.</p> <p><code>Listing 5</code> shows the code for <code>get</code> and <code>_get</code>. The search code in the <code>_get</code> method uses the same logic for choosing the left or right child as the <code>_put</code> method. Notice that the <code>_get</code> method returns a <code>TreeNode</code> to <code>get</code>, this allows <code>_get</code> to be used as a flexible helper method for other <code>BinarySearchTree</code> methods that may need to make use of other data from the <code>TreeNode</code> besides the payload.</p> Listing 5<pre><code>def get(self, key):\n    if self.root:\n        result = self._get(key, self.root)\n        if result:\n            return result.value\n    return None\n\ndef _get(self, key, current_node):\n    if not current_node:\n        return None\n    if current_node.key == key:\n        return current_node\n    elif key &lt; current_node.key:\n        return self._get(key, current_node.left_child)\n    else:\n        return self._get(key, current_node.right_child)\n</code></pre> <p>By implementing the <code>__getitem__</code> method we can write a Python statement that looks just like we are accessing a dictionary, when in fact we are using a binary search tree, for example <code>z = my_zip_tree[\"Fargo\"]</code>.  As you can see in <code>Listing 6</code>, all the <code>__getitem__</code> method does is call <code>get</code>.</p> Listing 6<pre><code>    def __getitem__(self, key):\n        return self.get(key)\n</code></pre> <p>Using <code>get</code>, we can implement the <code>in</code> operation by writing a <code>__contains__</code> method for the <code>BinarySearchTree</code>. The <code>__contains__</code> method will simply call <code>get</code> and return <code>True</code> if <code>get</code> returns a value, or <code>False</code> if it returns <code>None</code>. The code for <code>__contains__</code> is shown in <code>Listing 7</code>.</p> Listing 7<pre><code>    def __contains__(self, key):\n        return bool(self._get(key, self.root))\n</code></pre> <p>Recall that <code>__contains__</code> overloads the <code>in</code> operator and allows us to write statements such as <code>\"Northfield\" in my_zip_tree</code>.</p> <p>Finally, we turn our attention to the most challenging operation on the binary search tree, the deletion of a key (see <code>Listing 8</code>). The first task is to find the node to delete by searching the tree. If the tree has more than one node we search using the <code>_get</code> method to find the <code>TreeNode</code> that needs to be removed. If the tree only has a single node, that means we are removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted. In either case if the key is not found the <code>del</code> operator raises an error.</p> Listing 8<pre><code>def delete(self, key):\n    if self.size &gt; 1:\n        node_to_remove = self._get(key, self.root)\n        if node_to_remove:\n            self._delete(node_to_remove)\n            self.size = self.size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n    elif self.size == 1 and self.root.key == key:\n        self.root = None\n        self.size = self.size - 1\n    else:\n        raise KeyError(\"Error, key not in tree\")\n</code></pre> <p>Once we\u2019ve found the node containing the key we want to delete, there are three cases that we must consider:</p> <ol> <li>The node to be deleted has no children (see <code>Figure 3</code>).</li> <li>The node to be deleted has only one child (see <code>Figure 4</code>).</li> <li>The node to be deleted has two children (see <code>Figure 5</code>).</li> </ol> <p> Figure 3: Deleting Node 16, a Node without Children </p> <p> Figure 4: Deleting Node 25, a Node That Has a Single Child </p> <p> Figure 5: Deleting Node 5, a Node with Two Children </p> <p>The first case is straightforward. If the current node has no children, all we need to do is delete the node and remove the reference to this node in the parent. The code for this case is shown in <code>Listing 9</code>.</p> Listing 9<pre><code>if current_node.is_leaf():\n    if current_node == current_node.parent.left_child:\n        current_node.parent.left_child = None\n    else:\n        current_node.parent.right_child = None\n</code></pre> <p>The second case is only slightly more complicated. If a node has only a single child, then we can simply promote the child to take the place of its parent. The code for this case is shown in <code>Listing 10</code>. As you look at this code, you will see that there are six cases to consider. Since the cases are symmetric with respect to either having a left or right child, we will just discuss the case where the current node has a left child. The decision proceeds as follows:</p> <ol> <li>If the current node is a left child, then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the left child reference of the parent to point to the current node\u2019s left child.</li> <li> <p>If the current node is a right child, then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the right child reference of the parent to point to the current node\u2019s left child.</p> </li> <li> <p>If the current node has no parent, it must be the root. In this case we will just replace the <code>key</code>, <code>value</code>, <code>left_child</code>, and <code>right_child</code> data by calling the <code>replace_value</code> method on the root</p> </li> </ol> Listing 10<pre><code>else:  # removing a node with one child\n    if current_node.get_left_child():\n        if current_node.is_left_child():\n            current_node.left_child.parent = current_node.parent\n            current_node.parent.left_child = current_node.left_child\n        elif current_node.is_right_child():\n            current_node.left_child.parent = current_node.parent\n            current_node.parent.right_child = current_node.left_child\n        else:\n            current_node.replace_value(\n                current_node.left_child.key,\n                current_node.left_child.value,\n                current_node.left_child.left_child,\n                current_node.left_child.right_child,\n            )\n    else:\n        if current_node.is_left_child():\n            current_node.right_child.parent = current_node.parent\n            current_node.parent.left_child = current_node.right_child\n        elif current_node.is_right_child():\n            current_node.right_child.parent = current_node.parent\n            current_node.parent.right_child = current_node.right_child\n        else:\n            current_node.replace_value(\n                current_node.right_child.key,\n                current_node.right_child.value,\n                current_node.right_child.left_child,\n                current_node.right_child.right_child,\n            )\n</code></pre> <p>The third case is the most difficult case to handle. If a node has two children, then it is unlikely that we can simply promote one of them to take the node\u2019s place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the successor, and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted. The code  to handle the third case is shown in <code>Listing 11</code>.</p> <p>In <code>Listing 11</code> we make use of the helper methods <code>find_successor</code> and <code>splice_out</code> to find and remove the successor. The reason we use <code>splice_out</code> is that it goes directly to the node we want to splice out and makes the right changes. We could call <code>delete</code> recursively, but then we would waste time searching again for the key node.</p> Listing 11<pre><code>elif current_node.has_children():  # removing a node with two children\n    successor = current_node.find_successor()\n    successor.splice_out()\n    current_node.key = successor.key\n    current_node.value = successor.value\n</code></pre> <p>The code to find the successor is shown below (see <code>Listing 12</code>) and as you can see is a method of the <code>TreeNode</code> class. This code makes use of the same properties of binary search trees that cause an inorder traversal to print out the nodes in the tree from smallest to largest. There are three cases to consider when looking for the successor:</p> <ol> <li>If the node has a right child, then the successor is the smallest key in the right subtree.</li> <li>If the node has no right child and is the left child of its parent, then the parent is the successor.</li> <li>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</li> </ol> <p>The first condition is the only one that matters for us when deleting a node from a binary search tree. However, the <code>find_successor</code> method has other uses that we will explore in the exercises at the end of this chapter.</p> <p>The <code>find_min</code> method is called to find the minimum key in a subtree. You should convince yourself that the minimum value key in any binary search tree is the leftmost child of the tree. Therefore the <code>find_min</code> method simply follows the <code>left_child</code> references in each node of the subtree until it reaches a node that does not have a left child.</p> Listing 12<pre><code>def find_successor(self):\n    successor = None\n    if self.right_child:\n        successor = self.right_child.find_min()\n    else:\n        if self.parent:\n            if self.is_left_child():\n                successor = self.parent\n            else:\n                self.parent.right_child = None\n                successor = self.parent.find_successor()\n                self.parent.right_child = self\n    return successor\n\ndef find_min(self):\n    current = self\n    while current.left_child:\n        current = current.left_child\n    return current\n\ndef splice_out(self):\n    if self.is_leaf():\n        if self.is_left_child():\n            self.parent.left_child = None\n        else:\n            self.parent.right_child = None\n    elif self.has_any_child():\n        if self.left_child:\n            if self.is_left_child():\n                self.parent.left_child = self.left_child\n            else:\n                self.parent.right_child = self.left_child\n            self.left_child.parent = self.parent\n        else:\n            if self.is_left_child():\n                self.parent.left_child = self.right_child\n            else:\n                self.parent.right_child = self.right_child\n            self.right_child.parent = self.parent\n</code></pre> <p>We can implement the <code>del</code> operator by writing a <code>__delete__</code> method for the <code>BinarySearchTree</code> as shown in <code>Listing 13</code>. It is a wrapper method that allows us to remove a key from the map by writing <code>del my_zip_tree[\"NYC\"]</code>.</p> Listing 13<pre><code>def __delitem__(self, key):\n    self.delete(key)\n</code></pre> <p>We need to look at one last interface method for the binary search tree. Suppose that we would like to simply iterate over all the keys in the tree in order. This is definitely something we have done with dictionaries, so why not trees? You already know how to traverse a binary tree in order, using the <code>inorder</code> traversal algorithm. However, writing an iterator requires a bit more work since an iterator should return only one node each time the iterator is called.</p> <p>Python provides us with a very powerful function to use when creating an iterator. The function is called <code>yield</code>. <code>yield</code> is similar to <code>return</code> in that it returns a value to the caller. However, <code>yield</code> also takes the additional step of freezing the state of the function so that the next time the function is called it continues executing from the exact point it left off earlier. Functions that create objects that can be iterated are called generator functions.</p> <p>The code for an <code>inorder</code> iterator of a binary tree is shown in the next listing. Look at this code carefully; at first glance you might think that the code is not recursive. However, remember that <code>__iter__</code> overrides the <code>for ... in</code> operation for iteration, so it really is recursive! Because it is recursive over <code>TreeNode</code> instances, the <code>__iter__</code> method is defined in the <code>TreeNode</code> class.</p> <pre><code>def __iter__(self):\n    if self:\n        if self.left_child:\n            for elem in self.left_child:\n                yield elem\n        yield self.key\n        if self.right_child:\n            for elem in self.right_child:\n                yield elem\n</code></pre> <p>At this point you may want to download the entire file containing the full version of the <code>BinarySearchTree</code> and <code>TreeNode</code> classes.</p> Activity: 6.14.2 ActiveCode<pre><code>class TreeNode:\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        self.parent = parent\n\n    def is_left_child(self):\n        return self.parent and self.parent.left_child is self\n\n    def is_right_child(self):\n        return self.parent and self.parent.right_child is self\n\n    def is_root(self):\n        return not self.parent\n\n    def is_leaf(self):\n        return not (self.right_child or self.left_child)\n\n    def has_any_child(self):\n        return self.right_child or self.left_child\n\n    def has_children(self):\n        return self.right_child and self.left_child\n\n    def replace_value(self, key, value, left, right):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        if self.left_child:\n            self.left_child.parent = self\n        if self.right_child:\n            self.right_child.parent = self\n\n    def find_successor(self):\n        successor = None\n        if self.right_child:\n            successor = self.right_child.find_min()\n        else:\n            if self.parent:\n                if self.is_left_child():\n                    successor = self.parent\n                else:\n                    self.parent.right_child = None\n                    successor = self.parent.find_successor()\n                    self.parent.right_child = self\n        return successor\n\n    def find_min(self):\n        current = self\n        while current.left_child:\n            current = current.left_child\n        return current\n\n    def splice_out(self):\n        if self.is_leaf():\n            if self.is_left_child():\n                self.parent.left_child = None\n            else:\n                self.parent.right_child = None\n        elif self.has_any_child():\n            if self.left_child:\n                if self.is_left_child():\n                    self.parent.left_child = self.left_child\n                else:\n                    self.parent.right_child = self.left_child\n                self.left_child.parent = self.parent\n            else:\n                if self.is_left_child():\n                    self.parent.left_child = self.right_child\n                else:\n                    self.parent.right_child = self.right_child\n                self.right_child.parent = self.parent\n\n    def __iter__(self):\n        if self:\n            if self.left_child:\n                for elem in self.left_child:\n                    yield elem\n            yield self.key\n            if self.right_child:\n                for elem in self.right_child:\n                    yield elem\n\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, value):\n        if self.root:\n            self._put(key, value, self.root)\n        else:\n            self.root = TreeNode(key, value)\n        self.size = self.size + 1\n\n    def _put(self, key, value, current_node):\n        if key &lt; current_node.key:\n            if current_node.left_child:\n                self._put(key, value, current_node.left_child)\n            else:\n                current_node.left_child = TreeNode(\n                    key, value, parent=current_node\n                )\n        else:\n            if current_node.right_child:\n                self._put(key, value, current_node.right_child)\n            else:\n                current_node.right_child = TreeNode(\n                    key, value, parent=current_node\n                )\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def get(self, key):\n        if self.root:\n            result = self._get(key, self.root)\n            if result:\n                return result.value\n        return None\n\n    def _get(self, key, current_node):\n        if not current_node:\n            return None\n        if current_node.key == key:\n            return current_node\n        elif key &lt; current_node.key:\n            return self._get(key, current_node.left_child)\n        else:\n            return self._get(key, current_node.right_child)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        return bool(self._get(key, self.root))\n\n    def delete(self, key):\n        if self.size &gt; 1:\n            node_to_remove = self._get(key, self.root)\n            if node_to_remove:\n                self._delete(node_to_remove)\n                self.size = self.size - 1\n            else:\n                raise KeyError(\"Error, key not in tree\")\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n\n    def _delete(self, current_node):\n        if current_node.is_leaf():  # removing a leaf\n            if current_node == current_node.parent.left_child:\n                current_node.parent.left_child = None\n            else:\n                current_node.parent.right_child = None\n        elif current_node.has_children():  # removing a node with two children\n            successor = current_node.find_successor()\n            successor.splice_out()\n            current_node.key = successor.key\n            current_node.value = successor.value\n        else:  # removing a node with one child\n            if current_node.left_child:\n                if current_node.is_left_child():\n                    current_node.left_child.parent = current_node.parent\n                    current_node.parent.left_child = current_node.left_child\n                elif current_node.is_right_child():\n                    current_node.left_child.parent = current_node.parent\n                    current_node.parent.right_child = current_node.left_child\n                else:\n                    current_node.replace_value(\n                        current_node.left_child.key,\n                        current_node.left_child.value,\n                        current_node.left_child.left_child,\n                        current_node.left_child.right_child,\n                    )\n            else:\n                if current_node.is_left_child():\n                    current_node.right_child.parent = current_node.parent\n                    current_node.parent.left_child = current_node.right_child\n                elif current_node.is_right_child():\n                    current_node.right_child.parent = current_node.parent\n                    current_node.parent.right_child = current_node.right_child\n                else:\n                    current_node.replace_value(\n                        current_node.right_child.key,\n                        current_node.right_child.value,\n                        current_node.right_child.left_child,\n                        current_node.right_child.right_child,\n                    )\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n\nmy_tree = BinarySearchTree()\nmy_tree[\"a\"] = \"a\"\nmy_tree[\"q\"] = \"quick\"\nmy_tree[\"b\"] = \"brown\"\nmy_tree[\"f\"] = \"fox\"\nmy_tree[\"j\"] = \"jumps\"\nmy_tree[\"o\"] = \"over\"\nmy_tree[\"t\"] = \"the\"\nmy_tree[\"l\"] = \"lazy\"\nmy_tree[\"d\"] = \"dog\"\n\nprint(my_tree[\"q\"])\nprint(my_tree[\"l\"])\nprint(\"There are {} items in this tree\".format(len(my_tree)))\nmy_tree.delete(\"a\")\nprint(\"There are {} items in this tree\".format(len(my_tree)))\n\nfor node in my_tree:\n    print(my_tree[node], end=\" \")\nprint()\n</code></pre> <p>A binary search tree (BST) relies on the property that keys that are less than the parent are found in the left subtree, and keys that are greater than the parent are found in the right subtree. We will call this the BST property. As we implement the <code>Map</code> interface as described above, the BST property will guide our implementation. <code>Figure 1</code> illustrates this property of a binary search tree, showing the keys without any associated values. Notice that the property holds for each parent and child. All of the keys in the left subtree are less than the key in the root. All of the keys in the right subtree are greater than the root.</p> <p> Figure 1: A Simple Binary Search Tree </p> <p>Now that you know what a binary search tree is, we will look at how a binary search tree is constructed. The search tree in <code>Figure 1</code> represents the nodes that exist after we have inserted the following keys in the order shown: \\(70, 31, 93, 94, 14, 23, 73\\). Since 70 was the first key inserted into the tree, it is the root. Next, 31 is less than 70, so it becomes the left child of 70. Next, 93 is greater than 70, so it becomes the right child of 70. Now we have two levels of the tree filled, so the next key is going to be the left or right child of either 31 or 93. Since 94 is greater than 70 and 93, it becomes the right child of 93. Similarly 14 is less than 70 and 31, so it becomes the left child of 31. 23 is also less than 31, so it must be in the left subtree of 31. However, it is greater than 14, so it becomes the right child of 14.</p> <p>To implement the binary search tree, we will use the nodes and references approach similar to the one we used to implement the linked list and the expression tree. However, because we must be able create and work with a binary search tree that is empty, our implementation will use two classes. The first class we will call <code>BinarySearchTree</code>, and the second class we will call <code>TreeNode</code>. The <code>BinarySearchTree</code> class has a reference to the <code>TreeNode</code> that is the root of the binary search tree. In most cases the external methods defined in the outer class simply check to see if the tree is empty. If there are nodes in the tree, the request is just passed on to a private method defined in the <code>BinarySearchTree</code> class that takes the root as a parameter. In the case where the tree is empty or we want to delete the key at the root of the tree, we must take special action. The code for the <code>BinarySearchTree</code> class constructor along with a few other miscellaneous methods is shown in <code>Listing 1</code>.</p> Listing 1<pre><code>class BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n</code></pre> <p>The <code>TreeNode</code> class provides many helper methods that make the work done in the <code>BinarySearchTree</code> class methods much easier. The constructor for a <code>TreeNode</code>, along with these helper methods, is shown in <code>Listing 2</code>. As you can see in the listing many of these helper methods help to classify a node according to its own position as a child (left or right) and the kind of children the node has. The <code>TreeNode</code> class will also explicitly keep track of the parent as an attribute of each node. You will see why this is important when we discuss the implementation for the <code>del</code> operator.</p> <p>Another interesting aspect of the implementation of <code>TreeNode</code> in <code>Listing 2</code> is that we use Python\u2019s optional parameters. Optional parameters make it easy for us to create a <code>TreeNode</code> under several different circumstances. Sometimes we will want to construct a new <code>TreeNode</code> that already has both a parent and a child (e.g. left) and in that case we can pass <code>parent</code> and <code>left_child</code> as parameters. At other times we will just create a <code>TreeNode</code> with the key-value pair, and we will not pass any parameters for <code>parent</code> or <code>child</code>. In this case, the default values of the optional parameters are used.</p> Listing 2<pre><code>class TreeNode:\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        self.parent = parent\n\n    def is_left_child(self):\n        return self.parent and self.parent.left_child is self\n\n    def is_right_child(self):\n        return self.parent and self.parent.right_child is self\n\n    def is_root(self):\n        return not self.parent\n\n    def is_leaf(self):\n        return not (self.right_child or self.left_child)\n\n    def has_any_child(self):\n        return self.right_child or self.left_child\n\n    def has_children(self):\n        return self.right_child and self.left_child\n\n    def replace_value(self, key, value, left, right):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        if self.left_child:\n            self.left_child.parent = self\n        if self.right_child:\n            self.right_child.parent = self\n</code></pre> <p>Now that we have the <code>BinarySearchTree</code> shell and the <code>TreeNode</code>, it is time to write the <code>put</code> method that will allow us to build our binary search tree. The <code>put</code> method is a method of the <code>BinarySearchTree</code> class. This method will check to see if the tree already has a root. If there is not a root, then <code>put</code> will create a new <code>TreeNode</code> and install it as the root of the tree. If a root node is already in place, then <code>put</code> calls the private recursive helper method <code>_put</code> to search the tree according to the following algorithm:</p> <ul> <li>Starting at the root of the tree, search the binary tree comparing the new key to the key in the current node. If the new key is less than the current node, search the left subtree. If the new key is greater than the current node, search the right subtree.</li> <li>When there is no left or right child to search, we have found the position in the tree where the new node should be installed.</li> <li>To add a node to the tree, create a new <code>TreeNode</code> object and insert the object at the point discovered in the previous step.</li> </ul> <p><code>Listing 3</code> shows the Python code for inserting a new node in the tree. The <code>_put</code> method is written recursively following the steps outlined above. Notice that when a new child is inserted into the tree, the <code>current_node</code> is passed to the new tree as the parent.</p> <p>One important problem with our implementation of insertion is that duplicate keys are not handled properly. As our tree is implemented, a duplicate key will create a new node with the same key value in the right subtree of the node having the original key. The result of this is that the node with the new key will never be found during a search. A better way to handle the insertion of a duplicate key is for the value associated with the new key to replace the old value. We leave fixing this bug as an exercise for you.</p> Listing 3<pre><code>def put(self, key, value):\n    if self.root:\n        self._put(key, value, self.root)\n    else:\n        self.root = TreeNode(key, value)\n    self.size = self.size + 1\n\ndef _put(self, key, value, current_node):\n    if key &lt; current_node.key:\n        if current_node.left_child:\n            self._put(key, value, current_node.left_child)\n        else:\n            current_node.left_child = TreeNode(key, value, parent=current_node)\n    else:\n        if current_node.right_child:\n            self._put(key, value, current_node.right_child)\n        else:\n            current_node.right_child = TreeNode(key, value, parent=current_node)\n</code></pre> <p>With the <code>put</code> method defined, we can easily overload the <code>[]</code> operator for assignment by having the <code>__setitem__</code> method call the <code>put</code> method (see <code>Listing 4</code>). This allows us to write Python statements like <code>my_zip_tree['Plymouth'] = 55446</code>, just like a Python dictionary.</p> Listing 4<pre><code>    def __setitem__(self, key, value):\n        self.put(key, value)\n</code></pre> <p><code>Figure 2</code> illustrates the process for inserting a new node into a binary search tree. The lightly shaded nodes indicate the nodes that were visited during the insertion process.</p> <p> Figure 2: Inserting a Node with Key = 19 </p> <p>Self Check</p> <p>Which of the trees shows a correct binary search tree given that the keys were inserted in the following order 5, 30, 2, 40, 25, 4.</p> <ul> <li>answer_a: </li> <li>answer_b: </li> <li>answer_c: </li> </ul> <p>correct: b</p> <ul> <li>feedback a: Remember, starting at the root keys less than the root must be in the left subtree, while keys greater than the root go in the right subtree.</li> <li>feedback b: good job.</li> <li>feedback c: This looks like a binary tree that satisfies the full tree property needed for a heap.</li> </ul> <p>Once the tree is constructed, the next task is to implement the retrieval of a value for a given key. The <code>get</code> method is even easier than the <code>put</code> method because it simply searches the tree recursively until it gets to a non-matching leaf node or finds a matching key. When a matching key is found, the value stored in the payload of the node is returned.</p> <p><code>Listing 5</code> shows the code for <code>get</code> and <code>_get</code>. The search code in the <code>_get</code> method uses the same logic for choosing the left or right child as the <code>_put</code> method. Notice that the <code>_get</code> method returns a <code>TreeNode</code> to <code>get</code>, this allows <code>_get</code> to be used as a flexible helper method for other <code>BinarySearchTree</code> methods that may need to make use of other data from the <code>TreeNode</code> besides the payload.</p> Listing 5<pre><code>def get(self, key):\n    if self.root:\n        result = self._get(key, self.root)\n        if result:\n            return result.value\n    return None\n\ndef _get(self, key, current_node):\n    if not current_node:\n        return None\n    if current_node.key == key:\n        return current_node\n    elif key &lt; current_node.key:\n        return self._get(key, current_node.left_child)\n    else:\n        return self._get(key, current_node.right_child)\n</code></pre> <p>By implementing the <code>__getitem__</code> method we can write a Python statement that looks just like we are accessing a dictionary, when in fact we are using a binary search tree, for example <code>z = my_zip_tree[\"Fargo\"]</code>.  As you can see in <code>Listing 6</code>, all the <code>__getitem__</code> method does is call <code>get</code>.</p> Listing 6<pre><code>    def __getitem__(self, key):\n        return self.get(key)\n</code></pre> <p>Using <code>get</code>, we can implement the <code>in</code> operation by writing a <code>__contains__</code> method for the <code>BinarySearchTree</code>. The <code>__contains__</code> method will simply call <code>get</code> and return <code>True</code> if <code>get</code> returns a value, or <code>False</code> if it returns <code>None</code>. The code for <code>__contains__</code> is shown in <code>Listing 7</code>.</p> Listing 7<pre><code>    def __contains__(self, key):\n        return bool(self._get(key, self.root))\n</code></pre> <p>Recall that <code>__contains__</code> overloads the <code>in</code> operator and allows us to write statements such as <code>\"Northfield\" in my_zip_tree</code>.</p> <p>Finally, we turn our attention to the most challenging operation on the binary search tree, the deletion of a key (see <code>Listing 8</code>). The first task is to find the node to delete by searching the tree. If the tree has more than one node we search using the <code>_get</code> method to find the <code>TreeNode</code> that needs to be removed. If the tree only has a single node, that means we are removing the root of the tree, but we still must check to make sure the key of the root matches the key that is to be deleted. In either case if the key is not found the <code>del</code> operator raises an error.</p> Listing 8<pre><code>def delete(self, key):\n    if self.size &gt; 1:\n        node_to_remove = self._get(key, self.root)\n        if node_to_remove:\n            self._delete(node_to_remove)\n            self.size = self.size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n    elif self.size == 1 and self.root.key == key:\n        self.root = None\n        self.size = self.size - 1\n    else:\n        raise KeyError(\"Error, key not in tree\")\n</code></pre> <p>Once we\u2019ve found the node containing the key we want to delete, there are three cases that we must consider:</p> <ol> <li>The node to be deleted has no children (see <code>Figure 3</code>).</li> <li>The node to be deleted has only one child (see <code>Figure 4</code>).</li> <li>The node to be deleted has two children (see <code>Figure 5</code>).</li> </ol> <p> Figure 3: Deleting Node 16, a Node without Children </p> <p> Figure 4: Deleting Node 25, a Node That Has a Single Child </p> <p> Figure 5: Deleting Node 5, a Node with Two Children </p> <p>The first case is straightforward. If the current node has no children, all we need to do is delete the node and remove the reference to this node in the parent. The code for this case is shown in <code>Listing 9</code>.</p> Listing 9<pre><code>if current_node.is_leaf():\n    if current_node == current_node.parent.left_child:\n        current_node.parent.left_child = None\n    else:\n        current_node.parent.right_child = None\n</code></pre> <p>The second case is only slightly more complicated. If a node has only a single child, then we can simply promote the child to take the place of its parent. The code for this case is shown in <code>Listing 10</code>. As you look at this code, you will see that there are six cases to consider. Since the cases are symmetric with respect to either having a left or right child, we will just discuss the case where the current node has a left child. The decision proceeds as follows:</p> <ol> <li>If the current node is a left child, then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the left child reference of the parent to point to the current node\u2019s left child.</li> <li> <p>If the current node is a right child, then we only need to update the parent reference of the left child to point to the parent of the current node, and then update the right child reference of the parent to point to the current node\u2019s left child.</p> </li> <li> <p>If the current node has no parent, it must be the root. In this case we will just replace the <code>key</code>, <code>value</code>, <code>left_child</code>, and <code>right_child</code> data by calling the <code>replace_value</code> method on the root</p> </li> </ol> Listing 10<pre><code>else:  # removing a node with one child\n    if current_node.get_left_child():\n        if current_node.is_left_child():\n            current_node.left_child.parent = current_node.parent\n            current_node.parent.left_child = current_node.left_child\n        elif current_node.is_right_child():\n            current_node.left_child.parent = current_node.parent\n            current_node.parent.right_child = current_node.left_child\n        else:\n            current_node.replace_value(\n                current_node.left_child.key,\n                current_node.left_child.value,\n                current_node.left_child.left_child,\n                current_node.left_child.right_child,\n            )\n    else:\n        if current_node.is_left_child():\n            current_node.right_child.parent = current_node.parent\n            current_node.parent.left_child = current_node.right_child\n        elif current_node.is_right_child():\n            current_node.right_child.parent = current_node.parent\n            current_node.parent.right_child = current_node.right_child\n        else:\n            current_node.replace_value(\n                current_node.right_child.key,\n                current_node.right_child.value,\n                current_node.right_child.left_child,\n                current_node.right_child.right_child,\n            )\n</code></pre> <p>The third case is the most difficult case to handle. If a node has two children, then it is unlikely that we can simply promote one of them to take the node\u2019s place. We can, however, search the tree for a node that can be used to replace the one scheduled for deletion. What we need is a node that will preserve the binary search tree relationships for both of the existing left and right subtrees. The node that will do this is the node that has the next-largest key in the tree. We call this node the successor, and we will look at a way to find the successor shortly. The successor is guaranteed to have no more than one child, so we know how to remove it using the two cases for deletion that we have already implemented. Once the successor has been removed, we simply put it in the tree in place of the node to be deleted. The code  to handle the third case is shown in <code>Listing 11</code>.</p> <p>In <code>Listing 11</code> we make use of the helper methods <code>find_successor</code> and <code>splice_out</code> to find and remove the successor. The reason we use <code>splice_out</code> is that it goes directly to the node we want to splice out and makes the right changes. We could call <code>delete</code> recursively, but then we would waste time searching again for the key node.</p> Listing 11<pre><code>elif current_node.has_children():  # removing a node with two children\n    successor = current_node.find_successor()\n    successor.splice_out()\n    current_node.key = successor.key\n    current_node.value = successor.value\n</code></pre> <p>The code to find the successor is shown below (see <code>Listing 12</code>) and as you can see is a method of the <code>TreeNode</code> class. This code makes use of the same properties of binary search trees that cause an inorder traversal to print out the nodes in the tree from smallest to largest. There are three cases to consider when looking for the successor:</p> <ol> <li>If the node has a right child, then the successor is the smallest key in the right subtree.</li> <li>If the node has no right child and is the left child of its parent, then the parent is the successor.</li> <li>If the node is the right child of its parent, and itself has no right child, then the successor to this node is the successor of its parent, excluding this node.</li> </ol> <p>The first condition is the only one that matters for us when deleting a node from a binary search tree. However, the <code>find_successor</code> method has other uses that we will explore in the exercises at the end of this chapter.</p> <p>The <code>find_min</code> method is called to find the minimum key in a subtree. You should convince yourself that the minimum value key in any binary search tree is the leftmost child of the tree. Therefore the <code>find_min</code> method simply follows the <code>left_child</code> references in each node of the subtree until it reaches a node that does not have a left child.</p> Listing 12<pre><code>def find_successor(self):\n    successor = None\n    if self.right_child:\n        successor = self.right_child.find_min()\n    else:\n        if self.parent:\n            if self.is_left_child():\n                successor = self.parent\n            else:\n                self.parent.right_child = None\n                successor = self.parent.find_successor()\n                self.parent.right_child = self\n    return successor\n\ndef find_min(self):\n    current = self\n    while current.left_child:\n        current = current.left_child\n    return current\n\ndef splice_out(self):\n    if self.is_leaf():\n        if self.is_left_child():\n            self.parent.left_child = None\n        else:\n            self.parent.right_child = None\n    elif self.has_any_child():\n        if self.left_child:\n            if self.is_left_child():\n                self.parent.left_child = self.left_child\n            else:\n                self.parent.right_child = self.left_child\n            self.left_child.parent = self.parent\n        else:\n            if self.is_left_child():\n                self.parent.left_child = self.right_child\n            else:\n                self.parent.right_child = self.right_child\n            self.right_child.parent = self.parent\n</code></pre> <p>We can implement the <code>del</code> operator by writing a <code>__delete__</code> method for the <code>BinarySearchTree</code> as shown in <code>Listing 13</code>. It is a wrapper method that allows us to remove a key from the map by writing <code>del my_zip_tree[\"NYC\"]</code>.</p> Listing 13<pre><code>def __delitem__(self, key):\n    self.delete(key)\n</code></pre> <p>We need to look at one last interface method for the binary search tree. Suppose that we would like to simply iterate over all the keys in the tree in order. This is definitely something we have done with dictionaries, so why not trees? You already know how to traverse a binary tree in order, using the <code>inorder</code> traversal algorithm. However, writing an iterator requires a bit more work since an iterator should return only one node each time the iterator is called.</p> <p>Python provides us with a very powerful function to use when creating an iterator. The function is called <code>yield</code>. <code>yield</code> is similar to <code>return</code> in that it returns a value to the caller. However, <code>yield</code> also takes the additional step of freezing the state of the function so that the next time the function is called it continues executing from the exact point it left off earlier. Functions that create objects that can be iterated are called generator functions.</p> <p>The code for an <code>inorder</code> iterator of a binary tree is shown in the next listing. Look at this code carefully; at first glance you might think that the code is not recursive. However, remember that <code>__iter__</code> overrides the <code>for ... in</code> operation for iteration, so it really is recursive! Because it is recursive over <code>TreeNode</code> instances, the <code>__iter__</code> method is defined in the <code>TreeNode</code> class.</p> <pre><code>def __iter__(self):\n    if self:\n        if self.left_child:\n            for elem in self.left_child:\n                yield elem\n        yield self.key\n        if self.right_child:\n            for elem in self.right_child:\n                yield elem\n</code></pre> <p>At this point you may want to download the entire file containing the full version of the <code>BinarySearchTree</code> and <code>TreeNode</code> classes.</p> Activity: 6.14.2 ActiveCode<pre><code>class TreeNode:\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        self.parent = parent\n\n    def is_left_child(self):\n        return self.parent and self.parent.left_child is self\n\n    def is_right_child(self):\n        return self.parent and self.parent.right_child is self\n\n    def is_root(self):\n        return not self.parent\n\n    def is_leaf(self):\n        return not (self.right_child or self.left_child)\n\n    def has_any_child(self):\n        return self.right_child or self.left_child\n\n    def has_children(self):\n        return self.right_child and self.left_child\n\n    def replace_value(self, key, value, left, right):\n        self.key = key\n        self.value = value\n        self.left_child = left\n        self.right_child = right\n        if self.left_child:\n            self.left_child.parent = self\n        if self.right_child:\n            self.right_child.parent = self\n\n    def find_successor(self):\n        successor = None\n        if self.right_child:\n            successor = self.right_child.find_min()\n        else:\n            if self.parent:\n                if self.is_left_child():\n                    successor = self.parent\n                else:\n                    self.parent.right_child = None\n                    successor = self.parent.find_successor()\n                    self.parent.right_child = self\n        return successor\n\n    def find_min(self):\n        current = self\n        while current.left_child:\n            current = current.left_child\n        return current\n\n    def splice_out(self):\n        if self.is_leaf():\n            if self.is_left_child():\n                self.parent.left_child = None\n            else:\n                self.parent.right_child = None\n        elif self.has_any_child():\n            if self.left_child:\n                if self.is_left_child():\n                    self.parent.left_child = self.left_child\n                else:\n                    self.parent.right_child = self.left_child\n                self.left_child.parent = self.parent\n            else:\n                if self.is_left_child():\n                    self.parent.left_child = self.right_child\n                else:\n                    self.parent.right_child = self.right_child\n                self.right_child.parent = self.parent\n\n    def __iter__(self):\n        if self:\n            if self.left_child:\n                for elem in self.left_child:\n                    yield elem\n            yield self.key\n            if self.right_child:\n                for elem in self.right_child:\n                    yield elem\n\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, value):\n        if self.root:\n            self._put(key, value, self.root)\n        else:\n            self.root = TreeNode(key, value)\n        self.size = self.size + 1\n\n    def _put(self, key, value, current_node):\n        if key &lt; current_node.key:\n            if current_node.left_child:\n                self._put(key, value, current_node.left_child)\n            else:\n                current_node.left_child = TreeNode(\n                    key, value, parent=current_node\n                )\n        else:\n            if current_node.right_child:\n                self._put(key, value, current_node.right_child)\n            else:\n                current_node.right_child = TreeNode(\n                    key, value, parent=current_node\n                )\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def get(self, key):\n        if self.root:\n            result = self._get(key, self.root)\n            if result:\n                return result.value\n        return None\n\n    def _get(self, key, current_node):\n        if not current_node:\n            return None\n        if current_node.key == key:\n            return current_node\n        elif key &lt; current_node.key:\n            return self._get(key, current_node.left_child)\n        else:\n            return self._get(key, current_node.right_child)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        return bool(self._get(key, self.root))\n\n    def delete(self, key):\n        if self.size &gt; 1:\n            node_to_remove = self._get(key, self.root)\n            if node_to_remove:\n                self._delete(node_to_remove)\n                self.size = self.size - 1\n            else:\n                raise KeyError(\"Error, key not in tree\")\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n\n    def _delete(self, current_node):\n        if current_node.is_leaf():  # removing a leaf\n            if current_node == current_node.parent.left_child:\n                current_node.parent.left_child = None\n            else:\n                current_node.parent.right_child = None\n        elif current_node.has_children():  # removing a node with two children\n            successor = current_node.find_successor()\n            successor.splice_out()\n            current_node.key = successor.key\n            current_node.value = successor.value\n        else:  # removing a node with one child\n            if current_node.left_child:\n                if current_node.is_left_child():\n                    current_node.left_child.parent = current_node.parent\n                    current_node.parent.left_child = current_node.left_child\n                elif current_node.is_right_child():\n                    current_node.left_child.parent = current_node.parent\n                    current_node.parent.right_child = current_node.left_child\n                else:\n                    current_node.replace_value(\n                        current_node.left_child.key,\n                        current_node.left_child.value,\n                        current_node.left_child.left_child,\n                        current_node.left_child.right_child,\n                    )\n            else:\n                if current_node.is_left_child():\n                    current_node.right_child.parent = current_node.parent\n                    current_node.parent.left_child = current_node.right_child\n                elif current_node.is_right_child():\n                    current_node.right_child.parent = current_node.parent\n                    current_node.parent.right_child = current_node.right_child\n                else:\n                    current_node.replace_value(\n                        current_node.right_child.key,\n                        current_node.right_child.value,\n                        current_node.right_child.left_child,\n                        current_node.right_child.right_child,\n                    )\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n\nmy_tree = BinarySearchTree()\nmy_tree[\"a\"] = \"a\"\nmy_tree[\"q\"] = \"quick\"\nmy_tree[\"b\"] = \"brown\"\nmy_tree[\"f\"] = \"fox\"\nmy_tree[\"j\"] = \"jumps\"\nmy_tree[\"o\"] = \"over\"\nmy_tree[\"t\"] = \"the\"\nmy_tree[\"l\"] = \"lazy\"\nmy_tree[\"d\"] = \"dog\"\n\nprint(my_tree[\"q\"])\nprint(my_tree[\"l\"])\nprint(\"There are {} items in this tree\".format(len(my_tree)))\nmy_tree.delete(\"a\")\nprint(\"There are {} items in this tree\".format(len(my_tree)))\n\nfor node in my_tree:\n    print(my_tree[node], end=\" \")\nprint()\n</code></pre>"},{"location":"c6/s15/","title":"6.15. \u641c\u7d22\u6811\u5206\u6790","text":"<p>6.15. Search Tree Analysis</p> \u4e2d\u6587\u82f1\u6587 <p>With the implementation of a binary search tree now complete, we will do a quick analysis of the methods we have implemented. Let\u2019s first look at the <code>put</code> method. The limiting factor on its performance is the height of the binary tree. Recall from the vocabulary section that the height of a tree is the number of edges between the root and the deepest leaf node. The height is the limiting factor because when we are searching for the appropriate place to insert a node into the tree, we will need to do at most one comparison at each level of the tree.</p> <p>What is the height of a binary tree likely to be? The answer to this question depends on how the keys are added to the tree. If the keys are added in a random order, the height of the tree is going to be around \\(\\log_2{n}\\) where \\(n\\) is the number of nodes in the tree. This is because if the keys are randomly distributed, about half of them will be less than the root and about half will be greater than the root. Remember that in a binary tree there is one node at the root, two nodes in the next level, and four at the next. The number of nodes at any particular level is \\(2^d\\) where \\(d\\) is the depth of the level. The total number of nodes in a perfectly balanced binary tree is \\(2^{h+1}-1\\), where \\(h\\) represents the height of the tree.</p> <p>A perfectly balanced tree has the same number of nodes in the left subtree as the right subtree. In a balanced binary tree, the worst-case performance of <code>put</code> is \\(O(\\log_2{n})\\), where \\(n\\) is the number of nodes in the tree. Notice that this is the inverse relationship to the calculation in the previous paragraph. So \\(\\log_2{n}\\) gives us the height of the tree and represents the maximum number of comparisons that <code>put</code> will need to do as it searches for the proper place to insert a new node.</p> <p>Unfortunately it is possible to construct a search tree that has height \\(n\\) simply by inserting the keys in sorted order! An example of this is shown in <code>Figure 6</code>. In this case the performance of the <code>put</code> method is \\(O(n)\\).</p> <p> Figure 6: A skewed binary search tree would give poor performance </p> <p>Now that you understand that the performance of the <code>put</code> method is limited by the height of the tree, you can probably guess that other methods, <code>get</code>, <code>in</code>, and <code>del</code>, are limited as well. Since <code>get</code> searches the tree to find the key, in the worst case the tree is searched all the way to the bottom and no key is found. At first glance <code>del</code> might seem more complicated since it may need to search for the successor before the deletion operation can complete. But remember that the worst-case scenario to find the successor is also just the height of the tree which means that you would simply double the work. Since doubling is a constant factor, it does not change worst-case analysis of \\(O(n)\\) for an unbalanced tree.</p> <p>With the implementation of a binary search tree now complete, we will do a quick analysis of the methods we have implemented. Let\u2019s first look at the <code>put</code> method. The limiting factor on its performance is the height of the binary tree. Recall from the vocabulary section that the height of a tree is the number of edges between the root and the deepest leaf node. The height is the limiting factor because when we are searching for the appropriate place to insert a node into the tree, we will need to do at most one comparison at each level of the tree.</p> <p>What is the height of a binary tree likely to be? The answer to this question depends on how the keys are added to the tree. If the keys are added in a random order, the height of the tree is going to be around \\(\\log_2{n}\\) where \\(n\\) is the number of nodes in the tree. This is because if the keys are randomly distributed, about half of them will be less than the root and about half will be greater than the root. Remember that in a binary tree there is one node at the root, two nodes in the next level, and four at the next. The number of nodes at any particular level is \\(2^d\\) where \\(d\\) is the depth of the level. The total number of nodes in a perfectly balanced binary tree is \\(2^{h+1}-1\\), where \\(h\\) represents the height of the tree.</p> <p>A perfectly balanced tree has the same number of nodes in the left subtree as the right subtree. In a balanced binary tree, the worst-case performance of <code>put</code> is \\(O(\\log_2{n})\\), where \\(n\\) is the number of nodes in the tree. Notice that this is the inverse relationship to the calculation in the previous paragraph. So \\(\\log_2{n}\\) gives us the height of the tree and represents the maximum number of comparisons that <code>put</code> will need to do as it searches for the proper place to insert a new node.</p> <p>Unfortunately it is possible to construct a search tree that has height \\(n\\) simply by inserting the keys in sorted order! An example of this is shown in <code>Figure 6</code>. In this case the performance of the <code>put</code> method is \\(O(n)\\).</p> <p> Figure 6: A skewed binary search tree would give poor performance </p> <p>Now that you understand that the performance of the <code>put</code> method is limited by the height of the tree, you can probably guess that other methods, <code>get</code>, <code>in</code>, and <code>del</code>, are limited as well. Since <code>get</code> searches the tree to find the key, in the worst case the tree is searched all the way to the bottom and no key is found. At first glance <code>del</code> might seem more complicated since it may need to search for the successor before the deletion operation can complete. But remember that the worst-case scenario to find the successor is also just the height of the tree which means that you would simply double the work. Since doubling is a constant factor, it does not change worst-case analysis of \\(O(n)\\) for an unbalanced tree.</p>"},{"location":"c6/s16/","title":"6.16. \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811","text":"<p>6.16. Balanced Binary Search Trees</p> \u4e2d\u6587\u82f1\u6587 <p>In the previous section we looked at building a binary search tree. As we learned, the performance of the binary search tree can degrade to \\(O(n)\\) for operations like <code>get</code> and <code>put</code> when the tree becomes unbalanced. In this section we will look at a special kind of binary search tree that automatically makes sure that the tree remains balanced at all times. This tree is called an AVL tree and is named for its inventors: G.M. Adelson-Velskii and E.M. Landis.</p> <p>An AVL tree implements the Map abstract data type just like a regular binary search tree; the only difference is in how the tree performs. To implement our AVL tree we need to keep track of a balance factor for each node in the tree. We do this by looking at the heights of the left and right subtrees for each node. More formally, we define the balance factor for a node as the difference between the height of the left subtree and the height of the right subtree.</p> <p>\\(balance\\_factor = height(left\\_subtree) - height(right\\_subtree)\\)</p> <p>Using the definition for balance factor given above, we say that a subtree is left-heavy if the balance factor is greater than zero. If the balance factor is less than zero, then the subtree is right-heavy. If the balance factor is zero, then the tree is perfectly in balance. For purposes of implementing an AVL tree and gaining the benefit of having a balanced tree, we will define a tree to be in balance if the balance factor is -1, 0, or 1. Once the balance factor of a node in a tree is outside this range we will need to have a procedure to bring the tree back into balance. <code>Figure 1</code> shows an example of an unbalanced right-heavy tree and the balance factors of each node.</p> <p> Figure 1: An Unbalanced Right-Heavy Tree with Balance Factors </p> <p>In the previous section we looked at building a binary search tree. As we learned, the performance of the binary search tree can degrade to \\(O(n)\\) for operations like <code>get</code> and <code>put</code> when the tree becomes unbalanced. In this section we will look at a special kind of binary search tree that automatically makes sure that the tree remains balanced at all times. This tree is called an AVL tree and is named for its inventors: G.M. Adelson-Velskii and E.M. Landis.</p> <p>An AVL tree implements the Map abstract data type just like a regular binary search tree; the only difference is in how the tree performs. To implement our AVL tree we need to keep track of a balance factor for each node in the tree. We do this by looking at the heights of the left and right subtrees for each node. More formally, we define the balance factor for a node as the difference between the height of the left subtree and the height of the right subtree.</p> <p>\\(balance\\_factor = height(left\\_subtree) - height(right\\_subtree)\\)</p> <p>Using the definition for balance factor given above, we say that a subtree is left-heavy if the balance factor is greater than zero. If the balance factor is less than zero, then the subtree is right-heavy. If the balance factor is zero, then the tree is perfectly in balance. For purposes of implementing an AVL tree and gaining the benefit of having a balanced tree, we will define a tree to be in balance if the balance factor is -1, 0, or 1. Once the balance factor of a node in a tree is outside this range we will need to have a procedure to bring the tree back into balance. <code>Figure 1</code> shows an example of an unbalanced right-heavy tree and the balance factors of each node.</p> <p> Figure 1: An Unbalanced Right-Heavy Tree with Balance Factors </p>"},{"location":"c6/s17/","title":"6.17. AVL\u6811\u6027\u80fd","text":"<p>6.17. AVL Tree Performance</p> \u4e2d\u6587\u82f1\u6587 <p>Before we proceed any further let's look at the result of enforcing this new balance factor requirement. Our claim is that by ensuring that a tree always has a balance factor of -1, 0, or 1 we can get better Big-O performance of key operations. Let us start by thinking about how this balance condition changes the worst-case tree. There are two possibilities to consider, a left-heavy tree and a right-heavy tree. If we consider trees of heights 0, 1, 2, and 3, <code>Figure 2</code> illustrates the most unbalanced left-heavy tree possible under the new rules.</p> <p> Figure 2: Worst-Case Left-Heavy AVL Trees </p> <p>Looking at the total number of nodes in the tree we see that for a tree of height 0 there is 1 node, for a tree of height 1 there is \\(1 + 1 = 2\\) nodes, for a tree of height 2 there are \\(1 + 1 + 2 = 4\\), and for a tree of height 3 there are \\(1 + 2 + 4 = 7\\). More generally the pattern we see for the number of nodes in a tree of height \\(h\\) (\\(N_h\\)) is:</p> <p>\\(N_h = 1 + N_{h-1} + N_{h-2}\\)</p> <p>This recurrence may look familiar to you because it is very similar to the Fibonacci sequence. We can use this fact to derive a formula for the height of an AVL tree given the number of nodes in the tree. Recall that for the Fibonacci sequence the \\(i^{th}\\) Fibonacci number is given by:</p> <p>\\(\\begin{align} F_0 &amp; = 0 \\\\ F_1 &amp; = 1 \\\\ F_i &amp; = F_{i-1} + F_{i-2}  \\text{ for all } i \\ge 2 \\end{align}\\)</p> <p>An important mathematical result is that as the numbers of the Fibonacci sequence get larger and larger the ratio of \\(F_i / F_{i-1}\\) becomes closer and closer to approximating the golden ratio \\(\\Phi\\) which is defined as \\(\\Phi = \\frac{1 + \\sqrt{5}}{2}\\). You can consult a math text if you want to see a derivation of the previous equation. We will simply use this equation to approximate \\(F_i\\) as \\(F_i = \\Phi^i/\\sqrt{5}\\). If we make use of this approximation we can rewrite the equation for \\(N_h\\) as:</p> <p>\\(N_h = F_{h+3} - 1, h \\ge 1\\)</p> <p>By replacing the Fibonacci reference with its golden ratio approximation we get: </p> <p>\\(N_h = \\frac{\\Phi^{h+2}}{\\sqrt{5}} - 1\\)</p> <p>If we rearrange the terms, take the base 2 log of both sides, and then solve for \\(h\\), we get the following derivation:</p> <p>\\(\\begin{align}\\log{N_h+1} &amp;  = (h+2)\\log{\\Phi} - \\frac{1}{2} \\log{5} \\\\ h &amp; = \\frac{\\log{(N_h+1)} - 2 \\log{\\Phi} + \\frac{1}{2} \\log{5}}{\\log{\\Phi}} \\\\ h &amp;  = 1.44 \\log{N_h}\\end{align}\\)</p> <p>This derivation shows us that at any time the height of our AVL tree is equal to a constant (1.44) times the log of the number of nodes in the tree. This is great news for searching our AVL tree because it limits the search to \\(O(\\log{n})\\).</p> <p>Before we proceed any further let's look at the result of enforcing this new balance factor requirement. Our claim is that by ensuring that a tree always has a balance factor of -1, 0, or 1 we can get better Big-O performance of key operations. Let us start by thinking about how this balance condition changes the worst-case tree. There are two possibilities to consider, a left-heavy tree and a right-heavy tree. If we consider trees of heights 0, 1, 2, and 3, <code>Figure 2</code> illustrates the most unbalanced left-heavy tree possible under the new rules.</p> <p> Figure 2: Worst-Case Left-Heavy AVL Trees </p> <p>Looking at the total number of nodes in the tree we see that for a tree of height 0 there is 1 node, for a tree of height 1 there is \\(1 + 1 = 2\\) nodes, for a tree of height 2 there are \\(1 + 1 + 2 = 4\\), and for a tree of height 3 there are \\(1 + 2 + 4 = 7\\). More generally the pattern we see for the number of nodes in a tree of height \\(h\\) (\\(N_h\\)) is:</p> <p>\\(N_h = 1 + N_{h-1} + N_{h-2}\\)</p> <p>This recurrence may look familiar to you because it is very similar to the Fibonacci sequence. We can use this fact to derive a formula for the height of an AVL tree given the number of nodes in the tree. Recall that for the Fibonacci sequence the \\(i^{th}\\) Fibonacci number is given by:</p> <p>\\(F_0 &amp; = 0 \\\\ F_1 &amp; = 1 \\\\ F_i &amp; = F_{i-1} + F_{i-2}  \\text{ for all } i \\ge 2\\)</p> <p>An important mathematical result is that as the numbers of the Fibonacci sequence get larger and larger the ratio of \\(F_i / F_{i-1}\\) becomes closer and closer to approximating the golden ratio \\(\\Phi\\) which is defined as \\(\\Phi = \\frac{1 + \\sqrt{5}}{2}\\). You can consult a math text if you want to see a derivation of the previous equation. We will simply use this equation to approximate \\(F_i\\) as \\(F_i = \\Phi^i/\\sqrt{5}\\). If we make use of this approximation we can rewrite the equation for \\(N_h\\) as:</p> <p>\\(N_h = F_{h+3} - 1, h \\ge 1\\)</p> <p>By replacing the Fibonacci reference with its golden ratio approximation we get: </p> <p>\\(N_h = \\frac{\\Phi^{h+2}}{\\sqrt{5}} - 1\\)</p> <p>If we rearrange the terms, take the base 2 log of both sides, and then solve for \\(h\\), we get the following derivation:</p> <p>\\(\\log{N_h+1} &amp;  = (h+2)\\log{\\Phi} - \\frac{1}{2} \\log{5} \\\\ h &amp; = \\frac{\\log{(N_h+1)} - 2 \\log{\\Phi} + \\frac{1}{2} \\log{5}}{\\log{\\Phi}} \\\\ h &amp;  = 1.44 \\log{N_h}\\)</p> <p>This derivation shows us that at any time the height of our AVL tree is equal to a constant (1.44) times the log of the number of nodes in the tree. This is great news for searching our AVL tree because it limits the search to \\(O(\\log{n})\\).</p>"},{"location":"c6/s18/","title":"6.18. AVL\u6811\u5b9e\u73b0","text":"<p>6.18. AVL Tree Implementation</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have demonstrated that keeping an AVL tree in balance is going to be a big performance improvement, let's look at how we will augment the procedure to insert a new key into the tree. Since all new keys are inserted into the tree as leaf nodes and we know that the balance factor for a new leaf is zero, there are no new requirements for the node that has just been inserted. But once the new leaf is added, we must update the balance factor of its parent. How this new leaf affects the parent\u2019s balance factor depends on whether the leaf node is a left child or a right child. If the new node is a right child, the balance factor of the parent will be reduced by one. If the new node is a left child, then the balance factor of the parent will be increased by one. This rule can be applied recursively to the grandparent of the new node, and possibly to every ancestor, all the way up to the root of the tree. Since this is a recursive procedure, let's examine the two base cases for updating balance factors:</p> <ul> <li>The recursive call has reached the root of the tree.</li> <li>The balance factor of the parent has been adjusted to zero. You should convince yourself that once a subtree has a balance factor of zero, then the balance of its ancestor nodes does not change.</li> </ul> <p>We will implement the AVL tree as a subclass of <code>BinarySearchTree</code>. To begin, we will override the <code>_put</code> method and write a new <code>update_balance</code> helper method. These methods are shown in <code>Listing 1</code>. You will notice that the definition for <code>_put</code> is exactly the same as in simple binary search trees except for the addition of the calls to <code>update_balance</code> on lines\u00a09 and\u00a017.</p> Listing 1<pre><code>def _put(self, key, value, current_node):\n    if key &lt; current_node.key:\n        if current_node.left_child:\n            self._put(key, value, current_node.left_child)\n        else:\n            current_node.left_child = AVLTreeNode(\n                key, value, 0, parent=current_node\n            )\n            self.update_balance(current_node.left_child)\n    else:\n        if current_node.right_child:\n            self._put(key, value, current_node.right_child)\n        else:\n            current_node.right_child = AVLTreeNode(\n                key, value, 0, parent=current_node\n            )\n            self.update_balance(current_node.right_child)\n\ndef update_balance(self, node):\n    if node.balance_factor &gt; 1 or node.balance_factor &lt; -1:\n        self.rebalance(node)\n        return\n    if node.parent:\n        if node.is_left_child():\n            node.parent.balance_factor += 1\n        elif node.is_right_child():\n            node.parent.balance_factor -= 1\n\n        if node.parent.balance_factor != 0:\n            self.update_balance(node.parent)\n</code></pre> <p>The new <code>update_balance</code> method is where most of the work is done. This implements the recursive procedure we just described. It first checks to see if the current node is out of balance enough to require rebalancing (line\u00a020). If that is the case then the rebalancing is done and no further updating to parents is required. If the current node does not require rebalancing then the balance factor of the parent is adjusted. If the balance factor of the parent is nonzero then the algorithm continues to work its way up the tree toward the root by recursively calling <code>update_balance</code> on the parent.</p> <p>When a rebalancing of the tree is necessary, how do we do it? Efficient rebalancing is the key to making the AVL Tree work well without sacrificing performance. In order to bring an AVL Tree back into balance, we will perform one or more rotations on the tree.</p> <p>To understand what a rotation is, let's look at a very simple example. Consider the tree in the left half of <code>Figure 3</code>. This tree is out of balance with a balance factor of -2. To bring this tree into balance we will use a left rotation around the subtree rooted at node A.</p> <p> Figure 3: Transforming an Unbalanced Tree Using a Left Rotation </p> <p>To perform a left rotation we essentially do the following:</p> <ol> <li>Promote the right child (B) to be the root of the subtree.</li> <li>Move the old root (A) to be the left child of the new root.</li> <li>If new root (B) already has a left child, then make it the right child of the new left child (A). Note: since the new root (B) was the right child of A, the right child of A is guaranteed to be empty at this point. This allows us to add a new node as the right child without any further consideration.</li> </ol> <p>While this procedure is fairly easy in concept, the details of the code are a bit tricky since we need to move things around in just the right order so that all properties of a binary search tree are preserved. Furthermore, we need to make sure to update all of the parent pointers appropriately.</p> <p>Let's look at a slightly more complicated tree to illustrate the right rotation. The left side of <code>Figure 4</code> shows a tree that is left-heavy and with a balance factor of 2 at the root.</p> <p> Figure 4: Transforming an Unbalanced Tree Using a Right Rotation </p> <p>To perform a right rotation we essentially do the following:</p> <ol> <li>Promote the left child (C) to be the root of the subtree.</li> <li>Move the old root (E) to be the right child of the new root.</li> <li>If the new root (C) already has a right child (D) then make it the left child of the new right child (E). Note: since the new root (C) was the left child of E, the left child of E is guaranteed to be empty at this point. This allows us to add a new node as the left child without any further consideration.</li> </ol> <p>Now that you have seen the rotations and have the basic idea of how a rotation works let us look at the code. <code>Listing 2</code> shows the code for the left rotation (the <code>rotate_right</code> method is symmetrical to <code>rotate_left</code> so we will leave it to you to study the code for <code>rotate_right</code>). In line\u00a02 we create a temporary variable to keep track of the new root of the subtree. As we said before, the new root is the right child of the previous root. Now that a reference to the right child has been stored in this temporary variable, we replace the right child of the old root with the left child of the new.</p> <p>The next step is to adjust the parent pointers of the two nodes. If <code>new_root</code> has a left child then the new parent of the left child becomes the old root. The parent of the new root is set to the parent of the old root. If the old root was the root of the entire tree then we must set the root of the tree to point to this new root. Otherwise, if the old root is a left child then we change the parent of the left child to point to the new root; otherwise we change the parent of the right child to point to the new root. (lines\u00a010-13). Finally we set the parent of the old root to be the new root. This is a lot of complicated bookkeeping, so we encourage you to trace through this function while looking at <code>Figure 3</code>.</p> Listing 2<pre><code>def rotate_left(self, rotation_root):\n    new_root = rotation_root.right_child\n    rotation_root.right_child = new_root.left_child\n    if new_root.left_child:\n        new_root.left_child.parent = rotation_root\n    new_root.parent = rotation_root.parent\n    if rotation_root.is_root():\n        self._root = new_root\n    else:\n        if rotation_root.is_left_child():\n            rotation_root.parent.left_child = new_root\n        else:\n            rotation_root.parent.right_child = new_root\n    new_root.left_child = rotation_root\n    rotation_root.parent = new_root\n    rotation_root.balance_factor = (\n        rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n    )\n    new_root.balance_factor = (\n        new_root.balance_factor + 1 + max(rotation_root.balance_factor, 0)\n    )             \n</code></pre> <p>Finally, lines\u00a016-21 require some explanation. In these lines we update the balance factors of the old and the new root. Since all the other moves involve moving entire subtrees, the balance factors of all other nodes are unaffected by the rotation. But how can we update the balance factors without completely recalculating the heights of the new subtrees? <code>Figure 5</code> and the following derivation should convince you that these lines are correct.</p> <p> Figure 5: A Left Rotation </p> <p><code>Figure 5</code> shows a left rotation. B and D are the pivotal nodes and A, C, E are their subtrees. Let \\(h_x\\) denote the height of a particular subtree rooted at node \\(x\\). By definition we know the following:</p> <p>\\(\\begin{align} new\\_bal(B) &amp;= h_A - h_C \\\\ old\\_bal(B) &amp;= h_A - h_D \\end{align}\\)</p> <p>But we know that the old height of D can also be given by \\(1 + max(h_C, h_E)\\), that is, the height of D is one more than the maximum height of its two children. Remember that \\(h_C\\) and \\(h_E\\) have not changed. So, let us substitute that in to the second equation, which gives us </p> <p>\\(old\\_bal(B) = h_A - (1 + max(h_C,h_E))\\) </p> <p>and then subtract the two equations. The following steps do the subtraction and use some algebra to simplify the equation for \\(new\\_bal(B)\\).</p> <p>\\(\\begin{align} new\\_bal(B) - old\\_bal(B) &amp;= h_A - h_C - (h_A - (1 + max(h_C,h_E))) \\\\ new\\_bal(B) - old\\_bal(B) &amp;= h_A - h_C - h_A + (1 + max(h_C,h_E)) \\\\ new\\_bal(B) - old\\_bal(B) &amp;= h_A  - h_A + 1 + max(h_C,h_E) - h_C  \\\\ new\\_bal(B) - old\\_bal(B) &amp;=  1 + max(h_C,h_E) - h_C \\end{align}\\)</p> <p>Next we will move \\(old\\_bal(B)\\) to the right-hand side of the equation and make use of the fact that \\(max(a,b)-c = max(a-c, b-c)\\).</p> <p>\\(new\\_bal(B) = old\\_bal(B) + 1 + max(h_C - h_C ,h_E - h_C)\\)</p> <p>But \\(h_E - h_C\\) is the same as \\(-old\\_bal(D)\\). So we can use another identity that says \\(max(-a,-b) = -min(a,b)\\). So we can finish our derivation of \\(new\\_bal(B)\\) with the following steps:</p> <p>\\(\\begin{align} new\\_bal(B) &amp;= old\\_bal(B) + 1 + max(0 , -old\\_bal(D)) \\\\ new\\_bal(B) &amp;= old\\_bal(B) + 1 - min(0 , old\\_bal(D)) \\end{align}\\)</p> <p>Now we have all of the parts in terms that we readily know. If we remember that B is <code>rotation_root</code> and D is <code>new_root</code> then we can see this corresponds exactly to the statement on lines\u00a016-18 in <code>Listing 2</code>, or:</p> <pre><code>rotation_root.balance_factor = (\n    rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n)\n</code></pre> <p>A similar derivation gives us the equation for the updated node D as well as the balance factors after a right rotation. We leave these as an exercise for you.</p> <p>Now you might think that we are done. We know how to do our left and right rotations, and we know when we should do a left or right rotation.  But take a look at <code>Figure 6</code>. Since node A has a balance factor of -2 we should do a left rotation. But what happens when we do the left rotation around A?</p> <p> Figure 6: An Unbalanced Tree that is More Difficult to Balance </p> <p><code>Figure 7 &lt;fig_badrotate&gt;</code> shows us that after the left rotation we are now out of balance the other way. If we do a right rotation to correct the situation we are right back where we started.</p> <p> Figure 7: After a Left Rotation the Tree is Out of Balance in the Other Direction </p> <p>To correct this problem we must use the following set of rules:</p> <ol> <li>If a subtree needs a left rotation to bring it into balance, first check the balance factor of the right child. If the right child is left-heavy, then do a right rotation on right child followed by the original left rotation.</li> <li>If a subtree needs a right rotation to bring it into balance, first check the balance factor of the left child. If the left child is right-heavy, then do a left rotation on the left child followed by the original right rotation.</li> </ol> <p><code>Figure 8</code> shows how these rules solve the dilemma we encountered in <code>Figure 6</code> and <code>Figure 7</code>. Starting with a right rotation around node C puts the tree in a position where the left rotation around A brings the entire subtree back into balance.</p> <p> Figure 8: A Right Rotation Followed by a Left Rotation </p> <p>The code that implements these rules can be found in our <code>rebalance</code> method, which is shown in <code>Listing 3</code>. Rule number 1 from above is implemented by the <code>if</code> statement starting on line\u00a02. Rule number 2 is implemented by the <code>elif</code> statement starting on line 8.</p> Listing 3<pre><code>def rebalance(self, node):\n    if node.balance_factor &lt; 0:\n        if node.right_child.balance_factor &gt; 0:\n            self.rotate_right(node.right_child)\n            self.rotate_left(node)\n        else:\n            self.rotate_left(node)\n    elif node.balance_factor &gt; 0:\n        if node.left_child.balance_factor &lt; 0:\n            self.rotate_left(node.left_child)\n            self.rotate_right(node)\n        else:\n            self.rotate_right(node)\n</code></pre> <p>The <code>discussion questions</code> provide you the opportunity to rebalance a tree that requires a left rotation followed by a right. In addition the discussion questions provide you with the opportunity to rebalance some trees that are a little more complex than the tree in <code>Figure 8</code>.</p> <p>By keeping the tree in balance at all times, we can ensure that the <code>get</code> method will run in order \\(O(log_2(n))\\) time. But the question is at what cost to our <code>put</code> method? Let us break this down into the operations performed by <code>put</code>. Since a new node is inserted as a leaf, updating the balance factors of all the parents will require a maximum of \\(log_2(n)\\) operations, one for each level of the tree. If a subtree is found to be out of balance, a maximum of two rotations are required to bring the tree back into balance. But each of the rotations works in \\(O(1)\\) time, so even our <code>put</code> operation remains \\(O(log_2(n))\\).</p> <p>At this point we have implemented a functional AVL tree, unless you need the ability to delete a node. We leave the deletion of the node and subsequent updating and rebalancing as an exercise for you.</p> <p>Now that we have demonstrated that keeping an AVL tree in balance is going to be a big performance improvement, let's look at how we will augment the procedure to insert a new key into the tree. Since all new keys are inserted into the tree as leaf nodes and we know that the balance factor for a new leaf is zero, there are no new requirements for the node that has just been inserted. But once the new leaf is added, we must update the balance factor of its parent. How this new leaf affects the parent\u2019s balance factor depends on whether the leaf node is a left child or a right child. If the new node is a right child, the balance factor of the parent will be reduced by one. If the new node is a left child, then the balance factor of the parent will be increased by one. This rule can be applied recursively to the grandparent of the new node, and possibly to every ancestor, all the way up to the root of the tree. Since this is a recursive procedure, let's examine the two base cases for updating balance factors:</p> <ul> <li>The recursive call has reached the root of the tree.</li> <li>The balance factor of the parent has been adjusted to zero. You should convince yourself that once a subtree has a balance factor of zero, then the balance of its ancestor nodes does not change.</li> </ul> <p>We will implement the AVL tree as a subclass of <code>BinarySearchTree</code>. To begin, we will override the <code>_put</code> method and write a new <code>update_balance</code> helper method. These methods are shown in <code>Listing 1</code>. You will notice that the definition for <code>_put</code> is exactly the same as in simple binary search trees except for the addition of the calls to <code>update_balance</code> on lines\u00a09 and\u00a017.</p> Listing 1<pre><code>def _put(self, key, value, current_node):\n    if key &lt; current_node.key:\n        if current_node.left_child:\n            self._put(key, value, current_node.left_child)\n        else:\n            current_node.left_child = AVLTreeNode(\n                key, value, 0, parent=current_node\n            )\n            self.update_balance(current_node.left_child)\n    else:\n        if current_node.right_child:\n            self._put(key, value, current_node.right_child)\n        else:\n            current_node.right_child = AVLTreeNode(\n                key, value, 0, parent=current_node\n            )\n            self.update_balance(current_node.right_child)\n\ndef update_balance(self, node):\n    if node.balance_factor &gt; 1 or node.balance_factor &lt; -1:\n        self.rebalance(node)\n        return\n    if node.parent:\n        if node.is_left_child():\n            node.parent.balance_factor += 1\n        elif node.is_right_child():\n            node.parent.balance_factor -= 1\n\n        if node.parent.balance_factor != 0:\n            self.update_balance(node.parent)\n</code></pre> <p>The new <code>update_balance</code> method is where most of the work is done. This implements the recursive procedure we just described. It first checks to see if the current node is out of balance enough to require rebalancing (line\u00a020). If that is the case then the rebalancing is done and no further updating to parents is required. If the current node does not require rebalancing then the balance factor of the parent is adjusted. If the balance factor of the parent is nonzero then the algorithm continues to work its way up the tree toward the root by recursively calling <code>update_balance</code> on the parent.</p> <p>When a rebalancing of the tree is necessary, how do we do it? Efficient rebalancing is the key to making the AVL Tree work well without sacrificing performance. In order to bring an AVL Tree back into balance, we will perform one or more rotations on the tree.</p> <p>To understand what a rotation is, let's look at a very simple example. Consider the tree in the left half of <code>Figure 3</code>. This tree is out of balance with a balance factor of -2. To bring this tree into balance we will use a left rotation around the subtree rooted at node A.</p> <p> Figure 3: Transforming an Unbalanced Tree Using a Left Rotation </p> <p>To perform a left rotation we essentially do the following:</p> <ol> <li>Promote the right child (B) to be the root of the subtree.</li> <li>Move the old root (A) to be the left child of the new root.</li> <li>If new root (B) already has a left child, then make it the right child of the new left child (A). Note: since the new root (B) was the right child of A, the right child of A is guaranteed to be empty at this point. This allows us to add a new node as the right child without any further consideration.</li> </ol> <p>While this procedure is fairly easy in concept, the details of the code are a bit tricky since we need to move things around in just the right order so that all properties of a binary search tree are preserved. Furthermore, we need to make sure to update all of the parent pointers appropriately.</p> <p>Let's look at a slightly more complicated tree to illustrate the right rotation. The left side of <code>Figure 4</code> shows a tree that is left-heavy and with a balance factor of 2 at the root.</p> <p> Figure 4: Transforming an Unbalanced Tree Using a Right Rotation </p> <p>To perform a right rotation we essentially do the following:</p> <ol> <li>Promote the left child (C) to be the root of the subtree.</li> <li>Move the old root (E) to be the right child of the new root.</li> <li>If the new root (C) already has a right child (D) then make it the left child of the new right child (E). Note: since the new root (C) was the left child of E, the left child of E is guaranteed to be empty at this point. This allows us to add a new node as the left child without any further consideration.</li> </ol> <p>Now that you have seen the rotations and have the basic idea of how a rotation works let us look at the code. <code>Listing 2</code> shows the code for the left rotation (the <code>rotate_right</code> method is symmetrical to <code>rotate_left</code> so we will leave it to you to study the code for <code>rotate_right</code>). In line\u00a02 we create a temporary variable to keep track of the new root of the subtree. As we said before, the new root is the right child of the previous root. Now that a reference to the right child has been stored in this temporary variable, we replace the right child of the old root with the left child of the new.</p> <p>The next step is to adjust the parent pointers of the two nodes. If <code>new_root</code> has a left child then the new parent of the left child becomes the old root. The parent of the new root is set to the parent of the old root. If the old root was the root of the entire tree then we must set the root of the tree to point to this new root. Otherwise, if the old root is a left child then we change the parent of the left child to point to the new root; otherwise we change the parent of the right child to point to the new root. (lines\u00a010-13). Finally we set the parent of the old root to be the new root. This is a lot of complicated bookkeeping, so we encourage you to trace through this function while looking at <code>Figure 3</code>.</p> Listing 2<pre><code>def rotate_left(self, rotation_root):\n    new_root = rotation_root.right_child\n    rotation_root.right_child = new_root.left_child\n    if new_root.left_child:\n        new_root.left_child.parent = rotation_root\n    new_root.parent = rotation_root.parent\n    if rotation_root.is_root():\n        self._root = new_root\n    else:\n        if rotation_root.is_left_child():\n            rotation_root.parent.left_child = new_root\n        else:\n            rotation_root.parent.right_child = new_root\n    new_root.left_child = rotation_root\n    rotation_root.parent = new_root\n    rotation_root.balance_factor = (\n        rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n    )\n    new_root.balance_factor = (\n        new_root.balance_factor + 1 + max(rotation_root.balance_factor, 0)\n    )             \n</code></pre> <p>Finally, lines\u00a016-21 require some explanation. In these lines we update the balance factors of the old and the new root. Since all the other moves involve moving entire subtrees, the balance factors of all other nodes are unaffected by the rotation. But how can we update the balance factors without completely recalculating the heights of the new subtrees? <code>Figure 5</code> and the following derivation should convince you that these lines are correct.</p> <p> Figure 5: A Left Rotation </p> <p><code>Figure 5</code> shows a left rotation. B and D are the pivotal nodes and A, C, E are their subtrees. Let \\(h_x\\) denote the height of a particular subtree rooted at node \\(x\\). By definition we know the following:</p> <p>\\(\\begin{align} new\\_bal(B) &amp;= h_A - h_C \\\\ old\\_bal(B) &amp;= h_A - h_D \\end{align}\\)</p> <p>But we know that the old height of D can also be given by \\(1 + max(h_C, h_E)\\), that is, the height of D is one more than the maximum height of its two children. Remember that \\(h_C\\) and \\(h_E\\) have not changed. So, let us substitute that in to the second equation, which gives us </p> <p>\\(old\\_bal(B) = h_A - (1 + max(h_C,h_E))\\) </p> <p>and then subtract the two equations. The following steps do the subtraction and use some algebra to simplify the equation for \\(new\\_bal(B)\\).</p> <p>\\(\\begin{align} new\\_bal(B) - old\\_bal(B) &amp;= h_A - h_C - (h_A - (1 + max(h_C,h_E))) \\\\ new\\_bal(B) - old\\_bal(B) &amp;= h_A - h_C - h_A + (1 + max(h_C,h_E)) \\\\ new\\_bal(B) - old\\_bal(B) &amp;= h_A  - h_A + 1 + max(h_C,h_E) - h_C  \\\\ new\\_bal(B) - old\\_bal(B) &amp;=  1 + max(h_C,h_E) - h_C \\end{align}\\)</p> <p>Next we will move \\(old\\_bal(B)\\) to the right-hand side of the equation and make use of the fact that \\(max(a,b)-c = max(a-c, b-c)\\).</p> <p>\\(new\\_bal(B) = old\\_bal(B) + 1 + max(h_C - h_C ,h_E - h_C)\\)</p> <p>But \\(h_E - h_C\\) is the same as \\(-old\\_bal(D)\\). So we can use another identity that says \\(max(-a,-b) = -min(a,b)\\). So we can finish our derivation of \\(new\\_bal(B)\\) with the following steps:</p> <p>\\(\\begin{align} new\\_bal(B) &amp;= old\\_bal(B) + 1 + max(0 , -old\\_bal(D)) \\\\ new\\_bal(B) &amp;= old\\_bal(B) + 1 - min(0 , old\\_bal(D)) \\end{align}\\)</p> <p>Now we have all of the parts in terms that we readily know. If we remember that B is <code>rotation_root</code> and D is <code>new_root</code> then we can see this corresponds exactly to the statement on lines\u00a016-18 in <code>Listing 2</code>, or:</p> <pre><code>rotation_root.balance_factor = (\n    rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n)\n</code></pre> <p>A similar derivation gives us the equation for the updated node D as well as the balance factors after a right rotation. We leave these as an exercise for you.</p> <p>Now you might think that we are done. We know how to do our left and right rotations, and we know when we should do a left or right rotation.  But take a look at <code>Figure 6</code>. Since node A has a balance factor of -2 we should do a left rotation. But what happens when we do the left rotation around A?</p> <p> Figure 6: An Unbalanced Tree that is More Difficult to Balance </p> <p><code>Figure 7 &lt;fig_badrotate&gt;</code> shows us that after the left rotation we are now out of balance the other way. If we do a right rotation to correct the situation we are right back where we started.</p> <p> Figure 7: After a Left Rotation the Tree is Out of Balance in the Other Direction </p> <p>To correct this problem we must use the following set of rules:</p> <ol> <li>If a subtree needs a left rotation to bring it into balance, first check the balance factor of the right child. If the right child is left-heavy, then do a right rotation on right child followed by the original left rotation.</li> <li>If a subtree needs a right rotation to bring it into balance, first check the balance factor of the left child. If the left child is right-heavy, then do a left rotation on the left child followed by the original right rotation.</li> </ol> <p><code>Figure 8</code> shows how these rules solve the dilemma we encountered in <code>Figure 6</code> and <code>Figure 7</code>. Starting with a right rotation around node C puts the tree in a position where the left rotation around A brings the entire subtree back into balance.</p> <p> Figure 8: A Right Rotation Followed by a Left Rotation </p> <p>The code that implements these rules can be found in our <code>rebalance</code> method, which is shown in <code>Listing 3</code>. Rule number 1 from above is implemented by the <code>if</code> statement starting on line\u00a02. Rule number 2 is implemented by the <code>elif</code> statement starting on line 8.</p> Listing 3<pre><code>def rebalance(self, node):\n    if node.balance_factor &lt; 0:\n        if node.right_child.balance_factor &gt; 0:\n            self.rotate_right(node.right_child)\n            self.rotate_left(node)\n        else:\n            self.rotate_left(node)\n    elif node.balance_factor &gt; 0:\n        if node.left_child.balance_factor &lt; 0:\n            self.rotate_left(node.left_child)\n            self.rotate_right(node)\n        else:\n            self.rotate_right(node)\n</code></pre> <p>The <code>discussion questions</code> provide you the opportunity to rebalance a tree that requires a left rotation followed by a right. In addition the discussion questions provide you with the opportunity to rebalance some trees that are a little more complex than the tree in <code>Figure 8</code>.</p> <p>By keeping the tree in balance at all times, we can ensure that the <code>get</code> method will run in order \\(O(log_2(n))\\) time. But the question is at what cost to our <code>put</code> method? Let us break this down into the operations performed by <code>put</code>. Since a new node is inserted as a leaf, updating the balance factors of all the parents will require a maximum of \\(log_2(n)\\) operations, one for each level of the tree. If a subtree is found to be out of balance, a maximum of two rotations are required to bring the tree back into balance. But each of the rotations works in \\(O(1)\\) time, so even our <code>put</code> operation remains \\(O(log_2(n))\\).</p> <p>At this point we have implemented a functional AVL tree, unless you need the ability to delete a node. We leave the deletion of the node and subsequent updating and rebalancing as an exercise for you.</p>"},{"location":"c6/s19/","title":"6.19. Map ADT\u5b9e\u73b0\u603b\u7ed3","text":"<p>6.19. Summary of Map ADT Implementations</p> \u4e2d\u6587\u82f1\u6587 <p>Over the past two chapters we have looked at several data structures that can be used to implement the map abstract data type: a binary search on a list, a hash table, a binary search tree, and a balanced binary search tree. To conclude this section, let\u2019s summarize the performance of each data structure for the key operations defined by the map ADT (see <code>Table 1</code>).</p> <p>Table 1: Comparing the Performance of Different Map Implementations</p> operation Sorted List Hash Table Binary Search Tree AVL Tree <code>put</code> \\(O(n)\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>get</code> \\(O(\\log_2{n})\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>in</code> \\(O(\\log_2{n})\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>del</code> \\(O(n)\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <p>Over the past two chapters we have looked at several data structures that can be used to implement the map abstract data type: a binary search on a list, a hash table, a binary search tree, and a balanced binary search tree. To conclude this section, let\u2019s summarize the performance of each data structure for the key operations defined by the map ADT (see <code>Table 1</code>).</p> <p>Table 1: Comparing the Performance of Different Map Implementations</p> operation Sorted List Hash Table Binary Search Tree AVL Tree <code>put</code> \\(O(n)\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>get</code> \\(O(\\log_2{n})\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>in</code> \\(O(\\log_2{n})\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\) <code>del</code> \\(O(n)\\) \\(O(1)\\) \\(O(n)\\) \\(O(\\log_2{n})\\)"},{"location":"c6/s2/","title":"6.2. \u6811\u7684\u793a\u4f8b","text":"<p>6.2. Examples of Trees</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have studied linear data structures like stacks and queues and have some experience with recursion, we will look at a common data structure called the tree. Trees are used in many areas of computer science, including operating systems, graphics, database systems, and computer networking. Tree data structures have many things in common with their botanical cousins. A tree data structure has a root, branches, and leaves. The difference between a tree in nature and a tree in computer science is that a tree data structure has its root at the top and its leaves on the bottom.</p> <p>Before we begin our study of tree data structures, let\u2019s look at a few common examples. Our first example of a tree is a classification tree from biology. <code>Figure 1</code> shows an example of the biological classification of some animals. From this simple example, we can learn about several properties of trees. The first property this example demonstrates is that trees are hierarchical. By hierarchical, we mean that trees are structured in layers with the more general things near the top and the more specific things near the bottom. The top of the hierarchy is the kingdom, the next layer of the tree (the \u201cchildren\u201d of the layer above) is the phylum, then the class, and so on. However, no matter how deep we go in the classification tree, all the organisms are still animals.</p> <p> Figure 1: Taxonomy of Some Common Animals Shown as a Tree </p> <p>Notice that you can start at the top of the tree and follow a path made of circles and arrows all the way to the bottom. At each level of the tree we might ask ourselves a question and then follow the path that agrees with our answer. For example we might ask, \u201cIs this animal a chordate or an arthropod?\u201d If the answer is \u201cchordate,\u201d then we follow that path and ask, \u201cIs this chordate a mammal?\u201d If not, we are stuck (but only in this simplified example). When we are at the mammal level we ask, \u201cIs this mammal a primate or a carnivore?\u201d We can keep following paths until we get to the very bottom of the tree where we have the common name.</p> <p>A second property of trees is that all of the children of one node are independent of the children of another node. For example, the genus Thermobia has a children domestica. The genus Musca also has a child named domestica, but it is a different node and is independent of the domestica child of Thermobia. This means that we can change the node that is the child of Musca without affecting the child of Thermobia.</p> <p>A third property is that each leaf node is unique. We can specify a path from the root of the tree to a leaf that uniquely identifies each species in the animal kingdom, for example Animalia \\(\\rightarrow\\) Chordata \\(\\rightarrow\\) Mammalia \\(\\rightarrow\\) Carnivora \\(\\rightarrow\\) Felidae \\(\\rightarrow\\) Felis \\(\\rightarrow\\) catus.</p> <p>Another example of a tree structure that you probably use every day is a file system. In a file system, directories, or folders, are structured as a tree. <code>Figure 2 &lt;fig_filetree&gt;</code> illustrates a small part of a Unix file system hierarchy.</p> <p> Figure 2: A Small Part of the Unix File System Hierarchy </p> <p>Like the biological classification tree, the file system tree enables you to follow a path from the root to any directory. That path will  uniquely identify that subdirectory (and all the files in it). Another important property of trees, derived from their hierarchical nature, is that you can move entire sections of a tree (called a subtree) to a different position in the tree without affecting the lower levels of the hierarchy. For example, we could take the entire subtree staring with /etc/, detach etc/ from the root and reattach it under usr/. This would change the unique pathname to httpd from /etc/httpd to /usr/etc/httpd, but would not affect the contents or any children of the httpd directory.</p> <p>A final example of a tree is a web page. The code that precedes <code>Figure 3</code> is an example of a simple web page using HTML; <code>Figure 3</code> shows the tree  that corresponds to each of the HTML tags used to create the page.</p> <pre><code>&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=utf-8\" /&gt;\n        &lt;title&gt;simple&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;A simple web page&lt;/h1&gt;\n        &lt;ul&gt;\n            &lt;li&gt;List item one&lt;/li&gt;\n            &lt;li&gt;List item two&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;h2&gt;&lt;a href=\"https://www.luther.edu\"&gt;Luther College&lt;/a&gt;&lt;h2&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p> Figure 3: A Tree Corresponding to the Markup Elements of a Web Page </p> <p>The HTML source code and the tree accompanying the source illustrate another hierarchy. Notice that each level of the tree corresponds to a level of nesting inside the HTML tags. The first tag in the source is <code>&lt;html&gt;</code> and the last is <code>&lt;/html&gt;</code>. All the rest of the tags in the page are inside the pair. If you check, you will see that this nesting property is true at all levels of the tree.</p> <p>Now that we have studied linear data structures like stacks and queues and have some experience with recursion, we will look at a common data structure called the tree. Trees are used in many areas of computer science, including operating systems, graphics, database systems, and computer networking. Tree data structures have many things in common with their botanical cousins. A tree data structure has a root, branches, and leaves. The difference between a tree in nature and a tree in computer science is that a tree data structure has its root at the top and its leaves on the bottom.</p> <p>Before we begin our study of tree data structures, let\u2019s look at a few common examples. Our first example of a tree is a classification tree from biology. <code>Figure 1</code> shows an example of the biological classification of some animals. From this simple example, we can learn about several properties of trees. The first property this example demonstrates is that trees are hierarchical. By hierarchical, we mean that trees are structured in layers with the more general things near the top and the more specific things near the bottom. The top of the hierarchy is the kingdom, the next layer of the tree (the \u201cchildren\u201d of the layer above) is the phylum, then the class, and so on. However, no matter how deep we go in the classification tree, all the organisms are still animals.</p> <p> Figure 1: Taxonomy of Some Common Animals Shown as a Tree </p> <p>Notice that you can start at the top of the tree and follow a path made of circles and arrows all the way to the bottom. At each level of the tree we might ask ourselves a question and then follow the path that agrees with our answer. For example we might ask, \u201cIs this animal a chordate or an arthropod?\u201d If the answer is \u201cchordate,\u201d then we follow that path and ask, \u201cIs this chordate a mammal?\u201d If not, we are stuck (but only in this simplified example). When we are at the mammal level we ask, \u201cIs this mammal a primate or a carnivore?\u201d We can keep following paths until we get to the very bottom of the tree where we have the common name.</p> <p>A second property of trees is that all of the children of one node are independent of the children of another node. For example, the genus Thermobia has a children domestica. The genus Musca also has a child named domestica, but it is a different node and is independent of the domestica child of Thermobia. This means that we can change the node that is the child of Musca without affecting the child of Thermobia.</p> <p>A third property is that each leaf node is unique. We can specify a path from the root of the tree to a leaf that uniquely identifies each species in the animal kingdom, for example Animalia \\(\\rightarrow\\) Chordata \\(\\rightarrow\\) Mammalia \\(\\rightarrow\\) Carnivora \\(\\rightarrow\\) Felidae \\(\\rightarrow\\) Felis \\(\\rightarrow\\) catus.</p> <p>Another example of a tree structure that you probably use every day is a file system. In a file system, directories, or folders, are structured as a tree. <code>Figure 2 &lt;fig_filetree&gt;</code> illustrates a small part of a Unix file system hierarchy.</p> <p> Figure 2: A Small Part of the Unix File System Hierarchy </p> <p>Like the biological classification tree, the file system tree enables you to follow a path from the root to any directory. That path will  uniquely identify that subdirectory (and all the files in it). Another important property of trees, derived from their hierarchical nature, is that you can move entire sections of a tree (called a subtree) to a different position in the tree without affecting the lower levels of the hierarchy. For example, we could take the entire subtree staring with /etc/, detach etc/ from the root and reattach it under usr/. This would change the unique pathname to httpd from /etc/httpd to /usr/etc/httpd, but would not affect the contents or any children of the httpd directory.</p> <p>A final example of a tree is a web page. The code that precedes <code>Figure 3</code> is an example of a simple web page using HTML; <code>Figure 3</code> shows the tree  that corresponds to each of the HTML tags used to create the page.</p> <pre><code>&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=utf-8\" /&gt;\n        &lt;title&gt;simple&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;A simple web page&lt;/h1&gt;\n        &lt;ul&gt;\n            &lt;li&gt;List item one&lt;/li&gt;\n            &lt;li&gt;List item two&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;h2&gt;&lt;a href=\"https://www.luther.edu\"&gt;Luther College&lt;/a&gt;&lt;h2&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p> Figure 3: A Tree Corresponding to the Markup Elements of a Web Page </p> <p>The HTML source code and the tree accompanying the source illustrate another hierarchy. Notice that each level of the tree corresponds to a level of nesting inside the HTML tags. The first tag in the source is <code>&lt;html&gt;</code> and the last is <code>&lt;/html&gt;</code>. All the rest of the tags in the page are inside the pair. If you check, you will see that this nesting property is true at all levels of the tree.</p>"},{"location":"c6/s20/","title":"6.20. \u603b\u7ed3","text":"<p>6.20. Summary</p> \u4e2d\u6587\u82f1\u6587 <p>In this chapter we have looked at the tree data structure, which enables us to write many interesting algorithms. We have looked at algorithms that use various kinds of trees to do the following:</p> <ul> <li>A binary tree for parsing and evaluating expressions.</li> <li>A binary tree for implementing the map ADT.</li> <li>A balanced binary tree (AVL tree) for implementing the map ADT.</li> <li>A binary tree to implement a min heap.</li> <li>A min heap used to implement a priority queue.</li> </ul> <p>In this chapter we have looked at the tree data structure, which enables us to write many interesting algorithms. We have looked at algorithms that use various kinds of trees to do the following:</p> <ul> <li>A binary tree for parsing and evaluating expressions.</li> <li>A binary tree for implementing the map ADT.</li> <li>A balanced binary tree (AVL tree) for implementing the map ADT.</li> <li>A binary tree to implement a min heap.</li> <li>A min heap used to implement a priority queue.</li> </ul>"},{"location":"c6/s21/","title":"6.21. \u5173\u952e\u672f\u8bed","text":"<p>6.21. Key Terms</p> \u4e2d\u6587\u82f1\u6587 - - - AVL tree height postorder traversal balance factor inorder traversal preorder traversal binary heap leaf node priority queue binary search tree level root binary tree map rotation BST property min/max heap sibling child / children node subtree complete binary tree parent successor edge parse tree tree heap order property path tree traversal - - - AVL tree height postorder traversal balance factor inorder traversal preorder traversal binary heap leaf node priority queue binary search tree level root binary tree map rotation BST property min/max heap sibling child / children node subtree complete binary tree parent successor edge parse tree tree heap order property path tree traversal"},{"location":"c6/s22/","title":"6.22. \u7ec3\u4e60","text":"<p>6.22. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>Draw the tree structure resulting from the following set of tree function calls:</p> <pre><code>&gt;&gt;&gt; r = BinaryTree(3)\n&gt;&gt;&gt; insert_left(r, 4)\n[3, [4, [], []], []]\n&gt;&gt;&gt; insert_left(r, 5)\n[3, [5, [4, [], []], []], []]\n&gt;&gt;&gt; insert_right(r, 6)\n[3, [5, [4, [], []], []], [6, [], []]]\n&gt;&gt;&gt; insert_right(r, 7)\n[3, [5, [4, [], []], []], [7, [], [6, [], []]]]\n&gt;&gt;&gt; set_root_val(r, 9)\n&gt;&gt;&gt; insert_left(r, 11)\n[9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]]\n</code></pre> </li> <li> <p>Trace the algorithm for creating an expression tree for the expression :math:<code>(4 * 8) / 6 - 3</code>.</p> </li> <li>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show the binary search tree resulting from inserting the integers in the list.</li> <li>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show the binary search tree resulting from inserting the integers in the list.</li> <li>Generate a random list of integers. Show the binary heap tree resulting from inserting the integers on the list one at a time.</li> <li>Using the list from the previous question, show the binary heap tree resulting from using the list as a parameter to the <code>heapify</code> method. Show both the tree and list form.</li> <li>Draw the binary search tree that results from inserting the following keys in the order given: 68, 88, 61, 89, 94, 50, 4, 76, 66, and 82.</li> <li>Generate a random list of integers. Draw the binary search tree resulting from inserting the integers on the list.</li> <li>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show the binary heap resulting from inserting the integers one at a time.</li> <li>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show the binary heap resulting from inserting the integers one at a time.</li> <li> <p>Consider the two different techniques we used for implementing traversals of a binary tree. Why must we check before the call to <code>preorder</code> when implementing it as a method, whereas we could check inside the call when implementing it as a function?</p> </li> <li> <p>Show the function calls needed to build the following binary tree.</p> <p> </p> </li> <li> <p>Given the following tree, perform the appropriate rotations to bring it back into balance.</p> <p> </p> </li> <li> <p>Using the following as a starting point, derive the equation that gives the updated balance factor for node D.</p> <p> </p> </li> <li> <p>Extend the <code>build_parse_tree</code> function to handle mathematical expressions that do not have spaces between every character.</p> </li> <li>Modify the <code>build_parse_tree</code> and <code>evaluate</code> functions to handle Boolean statements (<code>and</code>, <code>or</code>, and <code>not</code>). Remember that <code>not</code> is a unary operator, so this will complicate your code somewhat.</li> <li>Using the <code>find_successor</code> method, write a non-recursive inorder traversal for a binary search tree.</li> <li>A threaded binary tree maintains a reference from each node to its successor. Modify the code for a binary search tree to make it threaded, then write a non-recursive inorder traversal method for the threaded binary search tree.</li> <li>Modify our implementation of the binary search tree so that it handles duplicate keys properly. That is, if a key is already in the tree then the new payload should replace the old rather than add another node with the same key.</li> <li>Create a binary heap with a limited heap size. In other words, the heap only keeps track of the :math:<code>n</code> most important items. If the heap grows in size to more than :math:<code>n</code> items the least important item is dropped.</li> <li>Clean up the <code>print_exp</code> function so that it does not include an extra set of parentheses around each number.</li> <li>Using the <code>heapify</code> method, write a sorting function that cansort a list in :math:<code>O(n\\log{n})</code> time.</li> <li>Write a function that takes a parse tree for a mathematical expression and calculates the derivative of the expression with respect to some variable.</li> <li>Implement a binary heap as a max heap.</li> <li>Using the <code>BinaryHeap</code> class, implement a new class called <code>PriorityQueue</code>. Your <code>PriorityQueue</code> class should implement the constructor plus the <code>enqueue</code> and <code>dequeue</code> methods.</li> <li>Implement the <code>delete</code> method for an AVL tree.</li> </ol> <ol> <li> <p>Draw the tree structure resulting from the following set of tree function calls:</p> <pre><code>&gt;&gt;&gt; r = BinaryTree(3)\n&gt;&gt;&gt; insert_left(r, 4)\n[3, [4, [], []], []]\n&gt;&gt;&gt; insert_left(r, 5)\n[3, [5, [4, [], []], []], []]\n&gt;&gt;&gt; insert_right(r, 6)\n[3, [5, [4, [], []], []], [6, [], []]]\n&gt;&gt;&gt; insert_right(r, 7)\n[3, [5, [4, [], []], []], [7, [], [6, [], []]]]\n&gt;&gt;&gt; set_root_val(r, 9)\n&gt;&gt;&gt; insert_left(r, 11)\n[9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]]\n</code></pre> </li> <li> <p>Trace the algorithm for creating an expression tree for the expression :math:<code>(4 * 8) / 6 - 3</code>.</p> </li> <li>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show the binary search tree resulting from inserting the integers in the list.</li> <li>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show the binary search tree resulting from inserting the integers in the list.</li> <li>Generate a random list of integers. Show the binary heap tree resulting from inserting the integers on the list one at a time.</li> <li>Using the list from the previous question, show the binary heap tree resulting from using the list as a parameter to the <code>heapify</code> method. Show both the tree and list form.</li> <li>Draw the binary search tree that results from inserting the following keys in the order given: 68, 88, 61, 89, 94, 50, 4, 76, 66, and 82.</li> <li>Generate a random list of integers. Draw the binary search tree resulting from inserting the integers on the list.</li> <li>Consider the following list of integers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Show the binary heap resulting from inserting the integers one at a time.</li> <li>Consider the following list of integers: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]. Show the binary heap resulting from inserting the integers one at a time.</li> <li> <p>Consider the two different techniques we used for implementing traversals of a binary tree. Why must we check before the call to <code>preorder</code> when implementing it as a method, whereas we could check inside the call when implementing it as a function?</p> </li> <li> <p>Show the function calls needed to build the following binary tree.</p> <p> </p> </li> <li> <p>Given the following tree, perform the appropriate rotations to bring it back into balance.</p> <p> </p> </li> <li> <p>Using the following as a starting point, derive the equation that gives the updated balance factor for node D.</p> <p> </p> </li> <li> <p>Extend the <code>build_parse_tree</code> function to handle mathematical expressions that do not have spaces between every character.</p> </li> <li>Modify the <code>build_parse_tree</code> and <code>evaluate</code> functions to handle Boolean statements (<code>and</code>, <code>or</code>, and <code>not</code>). Remember that <code>not</code> is a unary operator, so this will complicate your code somewhat.</li> <li>Using the <code>find_successor</code> method, write a non-recursive inorder traversal for a binary search tree.</li> <li>A threaded binary tree maintains a reference from each node to its successor. Modify the code for a binary search tree to make it threaded, then write a non-recursive inorder traversal method for the threaded binary search tree.</li> <li>Modify our implementation of the binary search tree so that it handles duplicate keys properly. That is, if a key is already in the tree then the new payload should replace the old rather than add another node with the same key.</li> <li>Create a binary heap with a limited heap size. In other words, the heap only keeps track of the :math:<code>n</code> most important items. If the heap grows in size to more than :math:<code>n</code> items the least important item is dropped.</li> <li>Clean up the <code>print_exp</code> function so that it does not include an extra set of parentheses around each number.</li> <li>Using the <code>heapify</code> method, write a sorting function that cansort a list in :math:<code>O(n\\log{n})</code> time.</li> <li>Write a function that takes a parse tree for a mathematical expression and calculates the derivative of the expression with respect to some variable.</li> <li>Implement a binary heap as a max heap.</li> <li>Using the <code>BinaryHeap</code> class, implement a new class called <code>PriorityQueue</code>. Your <code>PriorityQueue</code> class should implement the constructor plus the <code>enqueue</code> and <code>dequeue</code> methods.</li> <li>Implement the <code>delete</code> method for an AVL tree.</li> </ol>"},{"location":"c6/s3/","title":"6.3. \u8bcd\u6c47\u548c\u5b9a\u4e49","text":"<p>6.3. Vocabulary and Definitions</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have looked at examples of trees, we will formally define a tree and its components.</p> Node A node is a fundamental part of a tree. It can have a name, which we call the key. A node may also have additional information. We call this additional information the value or payload. While the payload information is not central to many tree algorithms, it is often critical in applications that make use of trees. Edge An edge is another fundamental part of a tree. An edge connects two nodes to show that there is a relationship between them. Every node (except the root) is connected by exactly one incoming edge from another node. Each node may have several outgoing edges. Root The root of the tree is the only node in the tree that has no incoming edges. In <code>Figure 2</code>, / is the root of the tree. Path A path is an ordered list of nodes that are connected by edges, for example, Mammalia \\(\\rightarrow\\) Carnivora \\(\\rightarrow\\) Felidae \\(\\rightarrow\\) Felis \\(\\rightarrow\\) catus is a path. Children The set of nodes that have incoming edges from the same node are said to be the children of that node. In <code>Figure 2</code>, nodes log/, spool/, and yp/ are the children of node var/. Parent A node is the parent of all the nodes it connects to with outgoing edges. In <code>Figure 2</code> the node var/ is the parent of nodes log/, spool/, and yp/. Sibling Nodes in the tree that are children of the same parent are said to be siblings. The nodes etc/ and usr/ are siblings in the file system tree shown in <code>Figure 2</code>. Subtree A subtree is a set of nodes and edges comprised of a parent and allthe descendants of that parent. Leaf Node A leaf node is a node that has no children. For example, Human and Chimpanzee are leaf nodes in <code>Figure 1</code>. Level The level of a node \\(n\\) is the number of edges on the path from the root node to \\(n\\). For example, the level of the Felis node in <code>Figure 1</code> is five. By definition, the level of the root node is zero. Height The height of a tree is equal to the maximum level of any node in the tree. The height of the tree in <code>Figure 2</code> is two. <p>With the basic vocabulary now defined, we can move on to a formal definition of a tree. In fact, we will provide two definitions of a tree. One definition involves nodes and edges. The second definition, which will prove to be very useful, is a recursive definition.</p> <p>Definition One: A tree consists of a set of nodes and a set of edges that connect pairs of nodes. A tree has the following properties:</p> <ul> <li>One node of the tree is designated as the root node.</li> <li>Every node \\(n\\), except the root node, is connected by an edge from exactly one other node \\(p\\), where \\(p\\) is the parent of \\(n\\).</li> <li>A unique path traverses from the root to each node.</li> <li>If each node in the tree has a maximum of two children, we say that the tree is a binary tree.</li> </ul> <p><code>Figure 3</code> illustrates a tree that fits definition one. The arrowheads on the edges indicate the direction of the connection.</p> <p> Figure 3: A Tree Consisting of a Set of Nodes and Edges </p> <p>Definition Two: A tree is either empty or consists of a root and zero or more subtrees, each of which is also a tree. The root of each subtree is connected to the root of the parent tree by an edge. <code>Figure 4</code> illustrates this recursive definition of a tree. Using the recursive definition of a tree, we know that the tree in <code>Figure 4</code> has at least four nodes since each of the triangles representing a subtree must have a root. It may have many more nodes than that, but we do not know unless we look deeper into the tree.</p> <p> Figure 4: A Recursive Definition of a Tree </p> <p>Now that we have looked at examples of trees, we will formally define a tree and its components.</p> Node A node is a fundamental part of a tree. It can have a name, which we call the key. A node may also have additional information. We call this additional information the value or payload. While the payload information is not central to many tree algorithms, it is often critical in applications that make use of trees. Edge An edge is another fundamental part of a tree. An edge connects two nodes to show that there is a relationship between them. Every node (except the root) is connected by exactly one incoming edge from another node. Each node may have several outgoing edges. Root The root of the tree is the only node in the tree that has no incoming edges. In <code>Figure 2</code>, / is the root of the tree. Path A path is an ordered list of nodes that are connected by edges, for example, Mammalia \\(\\rightarrow\\) Carnivora \\(\\rightarrow\\) Felidae \\(\\rightarrow\\) Felis \\(\\rightarrow\\) catus is a path. Children The set of nodes that have incoming edges from the same node are said to be the children of that node. In <code>Figure 2</code>, nodes log/, spool/, and yp/ are the children of node var/. Parent A node is the parent of all the nodes it connects to with outgoing edges. In <code>Figure 2</code> the node var/ is the parent of nodes log/, spool/, and yp/. Sibling Nodes in the tree that are children of the same parent are said to be siblings. The nodes etc/ and usr/ are siblings in the file system tree shown in <code>Figure 2</code>. Subtree A subtree is a set of nodes and edges comprised of a parent and allthe descendants of that parent. Leaf Node A leaf node is a node that has no children. For example, Human and Chimpanzee are leaf nodes in <code>Figure 1</code>. Level The level of a node \\(n\\) is the number of edges on the path from the root node to \\(n\\). For example, the level of the Felis node in <code>Figure 1</code> is five. By definition, the level of the root node is zero. Height The height of a tree is equal to the maximum level of any node in the tree. The height of the tree in `Figure 2$ is two. <p>With the basic vocabulary now defined, we can move on to a formal definition of a tree. In fact, we will provide two definitions of a tree. One definition involves nodes and edges. The second definition, which will prove to be very useful, is a recursive definition.</p> <p>Definition One: A tree consists of a set of nodes and a set of edges that connect pairs of nodes. A tree has the following properties:</p> <ul> <li>One node of the tree is designated as the root node.</li> <li>Every node \\(n\\), except the root node, is connected by an edge from exactly one other node \\(p\\), where \\(p\\) is the parent of \\(n\\).</li> <li>A unique path traverses from the root to each node.</li> <li>If each node in the tree has a maximum of two children, we say that the tree is a binary tree.</li> </ul> <p><code>Figure 3</code> illustrates a tree that fits definition one. The arrowheads on the edges indicate the direction of the connection.</p> <p> Figure 3: A Tree Consisting of a Set of Nodes and Edges </p> <p>Definition Two: A tree is either empty or consists of a root and zero or more subtrees, each of which is also a tree. The root of each subtree is connected to the root of the parent tree by an edge. <code>Figure 4</code> illustrates this recursive definition of a tree. Using the recursive definition of a tree, we know that the tree in <code>Figure 4</code> has at least four nodes since each of the triangles representing a subtree must have a root. It may have many more nodes than that, but we do not know unless we look deeper into the tree.</p> <p> Figure 4: A Recursive Definition of a Tree </p>"},{"location":"c6/s4/","title":"6.4. \u5b9e\u73b0","text":"<p>6.4. Implementation</p> \u4e2d\u6587\u82f1\u6587 <p>Keeping in mind the definitions from the previous section, we can use the following functions to create and manipulate a binary tree:</p> <ul> <li><code>BinaryTree()</code> creates a new instance of a binary tree.</li> <li><code>get_root_val()</code> returns the object stored in the current node.</li> <li><code>set_root_val(val)</code> stores the object in parameter <code>val</code> in the current node.</li> <li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node.</li> <li><code>get_right_child()</code> returns the binary tree corresponding to the right child of the current node.</li> <li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node.</li> <li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node.</li> </ul> <p>The key decision in implementing a tree is choosing a good internal storage technique. Python allows us two very interesting possibilities, and we will examine both before choosing one.  We call them list of lists and nodes and references.</p> <p>Keeping in mind the definitions from the previous section, we can use the following functions to create and manipulate a binary tree:</p> <ul> <li><code>BinaryTree()</code> creates a new instance of a binary tree.</li> <li><code>get_root_val()</code> returns the object stored in the current node.</li> <li><code>set_root_val(val)</code> stores the object in parameter <code>val</code> in the current node.</li> <li><code>get_left_child()</code> returns the binary tree corresponding to the left child of the current node.</li> <li><code>get_right_child()</code> returns the binary tree corresponding to the right child of the current node.</li> <li><code>insert_left(val)</code> creates a new binary tree and installs it as the left child of the current node.</li> <li><code>insert_right(val)</code> creates a new binary tree and installs it as the right child of the current node.</li> </ul> <p>The key decision in implementing a tree is choosing a good internal storage technique. Python allows us two very interesting possibilities, and we will examine both before choosing one.  We call them list of lists and nodes and references.</p>"},{"location":"c6/s5/","title":"6.5. \u5217\u8868\u8868\u793a\u6cd5","text":"<p>6.5. List of Lists Representation</p> \u4e2d\u6587\u82f1\u6587 <p>In a tree represented by a list of lists, we will begin with Python\u2019s list data structure and write the functions defined above. Although writing the interface as a set of operations on a list is a bit different from the other abstract data types we have implemented, it is interesting to do so because it provides us with a simple recursive data structure that we can look at and examine directly. In a list of lists tree, we will store the value of the root node as the first element of the list. The second element of the list will itself be a list that represents the left subtree. The third element of the list will be another list that represents the right subtree. To illustrate this storage technique, let\u2019s look at an example. <code>Figure 1</code> shows a simple tree and the corresponding list implementation.</p> <p> Figure 1: A Small Tree </p> <pre><code>my_tree = [\n    \"a\",  # root\n        [\"b\",  # left subtree\n            [\"d\", [], []],\n            [\"e\", [], []]\n        ],\n        [\"c\",  # right subtree\n            [\"f\", [], []], \n            []\n        ],\n    ]\n</code></pre> <p>Notice that we can access subtrees of the list using standard list indexing. The root of the tree is <code>my_tree[0]</code>, the left subtree of the root is <code>my_tree[1]</code>, and the right subtree is <code>my_tree[2]</code>. <code>ActiveCode 1</code> illustrates creating a simple tree using a list. Once the tree is constructed, we can access the root and the left and right subtrees. One very nice property of this list of lists approach is that the structure of a list representing a subtree adheres to the structure defined for a tree; the structure itself is recursive! A subtree that has a root value and two empty lists is a leaf node. Another nice feature of the list of lists approach is that it generalizes to a tree that has many subtrees. In the case where the tree is more than a binary tree, another subtree is just another list.</p> Activity: 6.5.1 Using Indexing to Access Subtrees<pre><code>my_tree = [\"a\", [\"b\", [\"d\", [], []], [\"e\", [], []]], [\"c\", [\"f\", [], []], []]]\nprint(my_tree)\nprint(\"left subtree = \", my_tree[1])\nprint(\"root = \", my_tree[0])\nprint(\"right subtree = \", my_tree[2])\n</code></pre> <p>Let\u2019s formalize this definition of the tree data structure by providing some functions that make it easy for us to use lists as trees. Note that we are not going to define a binary tree class. The functions we will write will just help us manipulate a standard list as though we are working with a tree.</p> <pre><code>    def make_binary_tree(root):\n        return [root, [], []]\n</code></pre> <p>The <code>make_binary_tree</code> function simply constructs a list with a root node and two empty sublists for the children. To add a left subtree to the root of a tree, we need to insert a new list into the second position of the root list. We must be careful, however. If the list already has something in the second position, we need to keep track of it and push it down the tree as the left child of the list we are adding. <code>Listing 1</code> shows the Python code for inserting a left child.</p> **Listing 1**<pre><code>def insert_left(root, new_child):\n    old_child = root.pop(1)\n    if len(old_child) &gt; 1:\n        root.insert(1, [new_child, old_child, []])\n    else:\n        root.insert(1, [new_child, [], []])\n    return root\n</code></pre> <p>Notice that to insert a left child, we first obtain the (possibly empty) list that corresponds to the current left child. We then add the new left child, installing the old left child as the left child of the new one. This allows us to splice a new node into the tree at any position. The code for <code>insert_right</code> is similar to <code>insert_left</code> and is shown in <code>Listing 2</code>.</p> **Listing 2**<pre><code>    def insert_right(root, new_child):\n        old_child = root.pop(2)\n        if len(old_child) &gt; 1:\n            root.insert(2, [new_child, [], old_child])\n        else:\n            root.insert(2, [new_child, [], []])\n        return root\n</code></pre> <p>To round out this set of tree-making functions, let\u2019s write a couple of access functions for getting and setting the root value, as well as getting the left or right subtrees. These functions can be seen in <code>Listing 3</code>.</p> **Listing 3**<pre><code>def get_root_val(root):\n    return root[0]\n\n\ndef set_root_val(root, new_value):\n    root[0] = new_value\n\n\ndef get_left_child(root):\n    return root[1]\n\n\ndef get_right_child(root):\n    return root[2]\n</code></pre> <p><code>ActiveCode 2</code> makes use of the tree functions we have just written. You should try it out for yourself. One of the exercises at the end of this chapter asks you to draw the tree structure resulting from this set of calls.</p> Activity: 6.5.2 A Python Session to Illustrate Basic Tree Functions<pre><code>def make_binary_tree(root):\n    return [root, [], []]\n\n\ndef insert_left(root, new_child):\n    old_child = root.pop(1)\n    if len(old_child) &gt; 1:\n        root.insert(1, [new_child, old_child, []])\n    else:\n        root.insert(1, [new_child, [], []])\n    return root\n\n\ndef insert_right(root, new_child):\n    old_child = root.pop(2)\n    if len(old_child) &gt; 1:\n        root.insert(2, [new_child, [], old_child])\n    else:\n        root.insert(2, [new_child, [], []])\n    return root\n\n\ndef get_root_val(root):\n    return root[0]\n\n\ndef set_root_val(root, new_value):\n    root[0] = new_value\n\n\ndef get_left_child(root):\n    return root[1]\n\n\ndef get_right_child(root):\n    return root[2]\n\n\na_tree = make_binary_tree(3)\ninsert_left(a_tree, 4)\ninsert_left(a_tree, 5)\ninsert_right(a_tree, 6)\ninsert_right(a_tree, 7)\nleft_child = get_left_child(a_tree)\nprint(left_child)\n\nset_root_val(left_child, 9)\nprint(a_tree)\ninsert_left(left_child, 11)\nprint(a_tree)\nprint(get_right_child(get_right_child(a_tree)))\n</code></pre> <p>Self Check</p> mctree_1mctree_2 <p>Given the following statments:</p> <pre><code>x = make_binary_tree(\"a\")\ninsert_left(x, \"b\")\ninsert_right(x, \"c\")\ninsert_right(get_right_child(x), \"d\")\ninsert_left(get_right_child(get_right_child(x)), \"e\")\n</code></pre> <p>Which of the answers is the correct representation of the tree?</p> <p>answer a: [\"a\", [\"b\", [], []], [\"c\", [], [\"d\", [], []]]] answer b: [\"a\", [\"c\", [], [\"d\", [\"e\", [], []], []]], [\"b\", [], []]] answer c: [\"a\", [\"b\", [], []], [\"c\", [], [\"d\", [\"e\", [], []], []]]] answer d: [\"a\", [\"b\", [], [\"d\", [\"e\", [], []], []]], [\"c\", [], []]]</p> <p>correct: c</p> <p>feedback a: Not quite, this tree is missing the \"e\" node. feedback b: This is close, but if you carefully you will see that the left and right children of the root are swapped. feedback c: Very good feedback d: This is close, but the left and right child names have been swapped along with the underlying structures.</p> <p>Write a function <code>build_tree</code> that returns a tree using the list of lists functions that looks like this:</p> <p> </p> Tip <pre><code>from test import testEqual\n\ndef build_tree():\n    pass\n\nttree = build_tree()\ntestEqual(get_root_val(get_right_child(ttree)), \"c\")\ntestEqual(get_root_val(get_right_child(get_left_child(ttree))), \"d\")      \ntestEqual(get_root_val(get_right_child(get_right_child(ttree))), \"f\")            \n</code></pre> <p>In a tree represented by a list of lists, we will begin with Python\u2019s list data structure and write the functions defined above. Although writing the interface as a set of operations on a list is a bit different from the other abstract data types we have implemented, it is interesting to do so because it provides us with a simple recursive data structure that we can look at and examine directly. In a list of lists tree, we will store the value of the root node as the first element of the list. The second element of the list will itself be a list that represents the left subtree. The third element of the list will be another list that represents the right subtree. To illustrate this storage technique, let\u2019s look at an example. <code>Figure 1</code> shows a simple tree and the corresponding list implementation.</p> <p> Figure 1: A Small Tree </p> <pre><code>my_tree = [\n    \"a\",  # root\n        [\"b\",  # left subtree\n            [\"d\", [], []],\n            [\"e\", [], []]\n        ],\n        [\"c\",  # right subtree\n            [\"f\", [], []], \n            []\n        ],\n    ]\n</code></pre> <p>Notice that we can access subtrees of the list using standard list indexing. The root of the tree is <code>my_tree[0]</code>, the left subtree of the root is <code>my_tree[1]</code>, and the right subtree is <code>my_tree[2]</code>. <code>ActiveCode 1</code> illustrates creating a simple tree using a list. Once the tree is constructed, we can access the root and the left and right subtrees. One very nice property of this list of lists approach is that the structure of a list representing a subtree adheres to the structure defined for a tree; the structure itself is recursive! A subtree that has a root value and two empty lists is a leaf node. Another nice feature of the list of lists approach is that it generalizes to a tree that has many subtrees. In the case where the tree is more than a binary tree, another subtree is just another list.</p> Activity: 6.5.1 Using Indexing to Access Subtrees<pre><code>my_tree = [\"a\", [\"b\", [\"d\", [], []], [\"e\", [], []]], [\"c\", [\"f\", [], []], []]]\nprint(my_tree)\nprint(\"left subtree = \", my_tree[1])\nprint(\"root = \", my_tree[0])\nprint(\"right subtree = \", my_tree[2])\n</code></pre> <p>Let\u2019s formalize this definition of the tree data structure by providing some functions that make it easy for us to use lists as trees. Note that we are not going to define a binary tree class. The functions we will write will just help us manipulate a standard list as though we are working with a tree.</p> <pre><code>    def make_binary_tree(root):\n        return [root, [], []]\n</code></pre> <p>The <code>make_binary_tree</code> function simply constructs a list with a root node and two empty sublists for the children. To add a left subtree to the root of a tree, we need to insert a new list into the second position of the root list. We must be careful, however. If the list already has something in the second position, we need to keep track of it and push it down the tree as the left child of the list we are adding. <code>Listing 1</code> shows the Python code for inserting a left child.</p> **Listing 1**<pre><code>def insert_left(root, new_child):\n    old_child = root.pop(1)\n    if len(old_child) &gt; 1:\n        root.insert(1, [new_child, old_child, []])\n    else:\n        root.insert(1, [new_child, [], []])\n    return root\n</code></pre> <p>Notice that to insert a left child, we first obtain the (possibly empty) list that corresponds to the current left child. We then add the new left child, installing the old left child as the left child of the new one. This allows us to splice a new node into the tree at any position. The code for <code>insert_right</code> is similar to <code>insert_left</code> and is shown in <code>Listing 2</code>.</p> **Listing 2**<pre><code>    def insert_right(root, new_child):\n        old_child = root.pop(2)\n        if len(old_child) &gt; 1:\n            root.insert(2, [new_child, [], old_child])\n        else:\n            root.insert(2, [new_child, [], []])\n        return root\n</code></pre> <p>To round out this set of tree-making functions, let\u2019s write a couple of access functions for getting and setting the root value, as well as getting the left or right subtrees. These functions can be seen in <code>Listing 3</code>.</p> **Listing 3**<pre><code>def get_root_val(root):\n    return root[0]\n\n\ndef set_root_val(root, new_value):\n    root[0] = new_value\n\n\ndef get_left_child(root):\n    return root[1]\n\n\ndef get_right_child(root):\n    return root[2]\n</code></pre> <p><code>ActiveCode 2</code> makes use of the tree functions we have just written. You should try it out for yourself. One of the exercises at the end of this chapter asks you to draw the tree structure resulting from this set of calls.</p> Activity: 6.5.2 A Python Session to Illustrate Basic Tree Functions<pre><code>def make_binary_tree(root):\n    return [root, [], []]\n\n\ndef insert_left(root, new_child):\n    old_child = root.pop(1)\n    if len(old_child) &gt; 1:\n        root.insert(1, [new_child, old_child, []])\n    else:\n        root.insert(1, [new_child, [], []])\n    return root\n\n\ndef insert_right(root, new_child):\n    old_child = root.pop(2)\n    if len(old_child) &gt; 1:\n        root.insert(2, [new_child, [], old_child])\n    else:\n        root.insert(2, [new_child, [], []])\n    return root\n\n\ndef get_root_val(root):\n    return root[0]\n\n\ndef set_root_val(root, new_value):\n    root[0] = new_value\n\n\ndef get_left_child(root):\n    return root[1]\n\n\ndef get_right_child(root):\n    return root[2]\n\n\na_tree = make_binary_tree(3)\ninsert_left(a_tree, 4)\ninsert_left(a_tree, 5)\ninsert_right(a_tree, 6)\ninsert_right(a_tree, 7)\nleft_child = get_left_child(a_tree)\nprint(left_child)\n\nset_root_val(left_child, 9)\nprint(a_tree)\ninsert_left(left_child, 11)\nprint(a_tree)\nprint(get_right_child(get_right_child(a_tree)))\n</code></pre> <p>Self Check</p> mctree_1mctree_2 <p>Given the following statments:</p> <pre><code>x = make_binary_tree(\"a\")\ninsert_left(x, \"b\")\ninsert_right(x, \"c\")\ninsert_right(get_right_child(x), \"d\")\ninsert_left(get_right_child(get_right_child(x)), \"e\")\n</code></pre> <p>Which of the answers is the correct representation of the tree?</p> <p>answer a: [\"a\", [\"b\", [], []], [\"c\", [], [\"d\", [], []]]] answer b: [\"a\", [\"c\", [], [\"d\", [\"e\", [], []], []]], [\"b\", [], []]] answer c: [\"a\", [\"b\", [], []], [\"c\", [], [\"d\", [\"e\", [], []], []]]] answer d: [\"a\", [\"b\", [], [\"d\", [\"e\", [], []], []]], [\"c\", [], []]]</p> <p>correct: c</p> <p>feedback a: Not quite, this tree is missing the \"e\" node. feedback b: This is close, but if you carefully you will see that the left and right children of the root are swapped. feedback c: Very good feedback d: This is close, but the left and right child names have been swapped along with the underlying structures.</p> <p>Write a function <code>build_tree</code> that returns a tree using the list of lists functions that looks like this:</p> <p> </p> Tip <pre><code>from test import testEqual\n\ndef build_tree():\n    pass\n\nttree = build_tree()\ntestEqual(get_root_val(get_right_child(ttree)), \"c\")\ntestEqual(get_root_val(get_right_child(get_left_child(ttree))), \"d\")      \ntestEqual(get_root_val(get_right_child(get_right_child(ttree))), \"f\")            \n</code></pre>"},{"location":"c6/s6/","title":"6.6. \u8282\u70b9\u4e0e\u5f15\u7528","text":"<p>6.6. Nodes and References</p> \u4e2d\u6587\u82f1\u6587 <p>Our second method to represent a tree uses nodes and references. In this case we will define a class that has attributes for the root value as well as the left and right subtrees. Using nodes and references, we might think of the tree as being structured like the one shown in <code>Figure 2</code>. Since this representation more closely follows the object-oriented programming paradigm, we will continue to use this representation for the remainder of the chapter.</p> <p> Figure 2: A Simple Tree Using a Nodes and References Approach </p> <p>We will start out with a simple class definition for the nodes and references approach as shown in <code>Listing 4</code>. The important thing to remember about this representation is that the attributes <code>left_child</code> and <code>right_child</code> will become references to other instances of the <code>BinaryTree</code> class. For example, when we insert a new left child into the tree, we create another instance of <code>BinaryTree</code> and modify <code>self.left_child</code> in the root to reference the new tree.</p> **Listing 4**<pre><code>class BinaryTree:\n    def __init__(self, root_obj):\n        self.key = root_obj\n        self.left_child = None\n        self.right_child = None\n</code></pre> <p>Notice that in <code>Listing 4</code>, the constructor function expects to get some kind of object to store in the root. Just as you can store any object you like in a list, the root object of a tree can be a reference to any object. For our early examples, we will store the name of the node as the root value. Using nodes and references to represent the tree in <code>Figure 2</code>, we would create six instances of the <code>BinaryTree</code> class.</p> <p>Next let\u2019s look at the functions we need to build the tree beyond the root node. To add a left child to the tree, we will create a new binary tree object and set the <code>left_child</code> attribute of the root to refer to this new object. The code for <code>insert_left</code> is shown in <code>Listing 5</code>.</p> **Listing 5**<pre><code>    def insert_left(self, new_node):\n        if self.left_child is None:\n            self.left_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.left_child = self.left_child\n            self.left_child = new_child\n</code></pre> <p>We must consider two cases for insertion. The first case is characterized by a node with no existing left child. When there is no left child, simply add a node to the tree. The second case is characterized by a node with an existing left child. In the second case, we insert a node and push the existing child down one level in the tree. The second case is handled by the <code>else</code> statement on line 4 of <code>Listing 5</code>.</p> <p>The code for <code>insert_right</code> must consider a symmetric set of cases. There will either be no right child, or we must insert the node between the root and an existing right child. The insertion code is shown in <code>Listing 6</code>.</p> **Listing 6**<pre><code>    def insert_right(self, new_node):\n        if self.right_child == None:\n            self.right_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.right_child = self.right_child\n            self.right_child = new_child\n</code></pre> <p>To round out the definition for a simple binary tree data structure, we will write accessor methods for the left and right children and for the root values (see <code>Listing 7</code>) .</p> **Listing 7**<pre><code>def get_root_val(self):\n    return self.key\n\ndef set_root_val(self, new_obj):\n    self.key = new_obj\n\ndef get_left_child(self):\n    return self.left_child\n\ndef get_right_child(self):\n    return self.right_child\n</code></pre> <p>Now that we have all the pieces to create and manipulate a binary tree, let\u2019s use them to check on the structure a bit more. Let\u2019s make a simple tree with node a as the root, and add nodes \"b\" and \"c\" as children. <code>ActiveCode 1</code> creates the tree and looks at the some of the values stored in <code>key</code>, <code>left_child</code>, and <code>right_child</code>. Notice that both the left and right children of the root are themselves distinct instances of the <code>BinaryTree</code> class. As we said in our original recursive definition for a tree, this allows us to treat any child of a binary tree as a binary tree itself.</p> Activity: 6.6.1 Exercising the Node and Reference Implementation<pre><code>class BinaryTree:\n    def __init__(self, root_obj):\n        self.key = root_obj\n        self.left_child = None\n        self.right_child = None\n\n    def insert_left(self, new_node):\n        if self.left_child is None:\n            self.left_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.left_child = self.left_child\n            self.left_child = new_child\n\n    def insert_right(self, new_node):\n        if self.right_child == None:\n            self.right_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.right_child = self.right_child\n            self.right_child = new_child\n\n    def get_root_val(self):\n        return self.key\n\n    def set_root_val(self, new_obj):\n        self.key = new_obj\n\n    def get_left_child(self):\n        return self.left_child\n\n    def get_right_child(self):\n        return self.right_child             \n\n\na_tree = BinaryTree(\"a\")\nprint(a_tree.get_root_val())\nprint(a_tree.get_left_child())\na_tree.insert_left(\"b\")\nprint(a_tree.get_left_child())\nprint(a_tree.get_left_child().get_root_val())\na_tree.insert_right(\"c\")\nprint(a_tree.get_right_child())\nprint(a_tree.get_right_child().get_root_val())\na_tree.get_right_child().set_root_val(\"hello\")\nprint(a_tree.get_right_child().get_root_val())\n</code></pre> <p>Self Check</p> mctree_3 <p>Write a function <code>build_tree</code> that returns a tree using the nodes and references implementation that looks like this:</p> <p> </p> Tip <pre><code>from test import testEqual\n\ndef build_tree():\n    pass\n\nttree = build_tree()\n\ntestEqual(ttree.get_right_child().get_root_val(), \"c\")\ntestEqual(ttree.get_left_child().get_right_child().get_root_val(), \"d\")\ntestEqual(ttree.get_right_child().get_left_child().get_root_val(), \"e\")\n</code></pre> <p>Our second method to represent a tree uses nodes and references. In this case we will define a class that has attributes for the root value as well as the left and right subtrees. Using nodes and references, we might think of the tree as being structured like the one shown in <code>Figure 2</code>. Since this representation more closely follows the object-oriented programming paradigm, we will continue to use this representation for the remainder of the chapter.</p> <p> Figure 2: A Simple Tree Using a Nodes and References Approach </p> <p>We will start out with a simple class definition for the nodes and references approach as shown in <code>Listing 4</code>. The important thing to remember about this representation is that the attributes <code>left_child</code> and <code>right_child</code> will become references to other instances of the <code>BinaryTree</code> class. For example, when we insert a new left child into the tree, we create another instance of <code>BinaryTree</code> and modify <code>self.left_child</code> in the root to reference the new tree.</p> **Listing 4**<pre><code>class BinaryTree:\n    def __init__(self, root_obj):\n        self.key = root_obj\n        self.left_child = None\n        self.right_child = None\n</code></pre> <p>Notice that in <code>Listing 4</code>, the constructor function expects to get some kind of object to store in the root. Just as you can store any object you like in a list, the root object of a tree can be a reference to any object. For our early examples, we will store the name of the node as the root value. Using nodes and references to represent the tree in <code>Figure 2</code>, we would create six instances of the <code>BinaryTree</code> class.</p> <p>Next let\u2019s look at the functions we need to build the tree beyond the root node. To add a left child to the tree, we will create a new binary tree object and set the <code>left_child</code> attribute of the root to refer to this new object. The code for <code>insert_left</code> is shown in <code>Listing 5</code>.</p> **Listing 5**<pre><code>    def insert_left(self, new_node):\n        if self.left_child is None:\n            self.left_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.left_child = self.left_child\n            self.left_child = new_child\n</code></pre> <p>We must consider two cases for insertion. The first case is characterized by a node with no existing left child. When there is no left child, simply add a node to the tree. The second case is characterized by a node with an existing left child. In the second case, we insert a node and push the existing child down one level in the tree. The second case is handled by the <code>else</code> statement on line 4 of <code>Listing 5</code>.</p> <p>The code for <code>insert_right</code> must consider a symmetric set of cases. There will either be no right child, or we must insert the node between the root and an existing right child. The insertion code is shown in <code>Listing 6</code>.</p> **Listing 6**<pre><code>    def insert_right(self, new_node):\n        if self.right_child == None:\n            self.right_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.right_child = self.right_child\n            self.right_child = new_child\n</code></pre> <p>To round out the definition for a simple binary tree data structure, we will write accessor methods for the left and right children and for the root values (see <code>Listing 7</code>) .</p> **Listing 7**<pre><code>def get_root_val(self):\n    return self.key\n\ndef set_root_val(self, new_obj):\n    self.key = new_obj\n\ndef get_left_child(self):\n    return self.left_child\n\ndef get_right_child(self):\n    return self.right_child\n</code></pre> <p>Now that we have all the pieces to create and manipulate a binary tree, let\u2019s use them to check on the structure a bit more. Let\u2019s make a simple tree with node a as the root, and add nodes \"b\" and \"c\" as children. <code>ActiveCode 1</code> creates the tree and looks at the some of the values stored in <code>key</code>, <code>left_child</code>, and <code>right_child</code>. Notice that both the left and right children of the root are themselves distinct instances of the <code>BinaryTree</code> class. As we said in our original recursive definition for a tree, this allows us to treat any child of a binary tree as a binary tree itself.</p> Activity: 6.6.1 Exercising the Node and Reference Implementation<pre><code>class BinaryTree:\n    def __init__(self, root_obj):\n        self.key = root_obj\n        self.left_child = None\n        self.right_child = None\n\n    def insert_left(self, new_node):\n        if self.left_child is None:\n            self.left_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.left_child = self.left_child\n            self.left_child = new_child\n\n    def insert_right(self, new_node):\n        if self.right_child == None:\n            self.right_child = BinaryTree(new_node)\n        else:\n            new_child = BinaryTree(new_node)\n            new_child.right_child = self.right_child\n            self.right_child = new_child\n\n    def get_root_val(self):\n        return self.key\n\n    def set_root_val(self, new_obj):\n        self.key = new_obj\n\n    def get_left_child(self):\n        return self.left_child\n\n    def get_right_child(self):\n        return self.right_child             \n\n\na_tree = BinaryTree(\"a\")\nprint(a_tree.get_root_val())\nprint(a_tree.get_left_child())\na_tree.insert_left(\"b\")\nprint(a_tree.get_left_child())\nprint(a_tree.get_left_child().get_root_val())\na_tree.insert_right(\"c\")\nprint(a_tree.get_right_child())\nprint(a_tree.get_right_child().get_root_val())\na_tree.get_right_child().set_root_val(\"hello\")\nprint(a_tree.get_right_child().get_root_val())\n</code></pre> <p>Self Check</p> mctree_3 <p>Write a function <code>build_tree</code> that returns a tree using the nodes and references implementation that looks like this:</p> <p> </p> Tip <pre><code>from test import testEqual\n\ndef build_tree():\n    pass\n\nttree = build_tree()\n\ntestEqual(ttree.get_right_child().get_root_val(), \"c\")\ntestEqual(ttree.get_left_child().get_right_child().get_root_val(), \"d\")\ntestEqual(ttree.get_right_child().get_left_child().get_root_val(), \"e\")\n</code></pre>"},{"location":"c6/s7/","title":"6.7. \u89e3\u6790\u6811","text":"<p>6.7. Parse Tree</p> \u4e2d\u6587\u82f1\u6587 <p>With the implementation of our tree data structure complete, we now look at an example of how a tree can be used to solve some real problems. In this section we will look at parse trees. Parse trees can be used to represent real-world constructions like sentences or mathematical expressions.</p> <p> Figure 1: A Parse Tree for a Simple Sentence </p> <p><code>Figure 1</code> shows the hierarchical structure of a simple sentence. Representing a sentence as a tree structure allows us to work with the individual parts of the sentence by using subtrees.</p> <p> Figure 2: Parse Tree for \\(((7 + 3) \\cdot (5 - 2))\\) </p> <p>We can also represent a mathematical expression such as \\(((7 + 3) \\cdot (5 - 2))\\) as a parse tree, as shown in <code>Figure 2</code>. We have already looked at fully parenthesized expressions, so what do we know about this expression? We know that multiplication has a higher precedence than either addition or subtraction. Because of the parentheses, we know that before we can do the multiplication we must evaluate the parenthesized addition and subtraction expressions. The hierarchy of the tree helps us understand the order of evaluation for the whole expression. Before we can evaluate the top-level multiplication, we must evaluate the addition and the subtraction in the subtrees. The addition, which is the left subtree, evaluates to 10. The subtraction, which is the right subtree, evaluates to 3. Using the hierarchical structure of trees, we can simply replace an entire subtree with one node once we have evaluated the expressions in the children. Applying this replacement procedure gives us the simplified tree shown in <code>Figure 3</code>.</p> <p> Figuer 3: A Simplified Parse Tree for \\(((7 + 3) \\cdot (5 - 2))\\) </p> <p>In the rest of this section we are going to examine parse trees in more detail. In particular we will look at</p> <ul> <li>How to build a parse tree from a fully parenthesized mathematical expression.</li> <li>How to evaluate the expression stored in a parse tree.</li> <li>How to recover the original mathematical expression from a parse tree.</li> </ul> <p>The first step in building a parse tree is to break up the expression string into a list of tokens. There are four different kinds of tokens to consider: left parentheses, right parentheses, operators, and operands. We know that whenever we read a left parenthesis we are starting a new expression, and hence we should create a new tree to correspond to that expression. Conversely, whenever we read a right parenthesis, we have finished an expression. We also know that operands are going to be leaf nodes and children of their operators. Finally, we know that every operator is going to have both a left and a right child.</p> <p>Using the information from above we can define four rules as follows:</p> <ol> <li>If the current token is a <code>\"(\"</code>, add a new node as the left child of the current node, and descend to the left child.</li> <li>If the current token is in the list <code>[\"+\", \"-\", \"/\", \"*\"]</code>, set the root value of the current node to the operator represented by the current token. Add a new node as the right child of the current node and descend to the right child.</li> <li>If the current token is a number, set the root value of the current node to the number and return to the parent.</li> <li>If the current token is a <code>\")\"</code>, go to the parent of the current node.</li> </ol> <p>Before writing the Python code, let\u2019s look at an example of the rules outlined above in action. We will use the expression \\((3 + (4 * 5))\\). We will parse this expression into the following list of character tokens: <code>[\"(\", \"3\", \"+\", \"(\", \"4\", \"*\", \"5\", \")\", \")\"]</code>. Initially we will start out with a parse tree that consists of an empty root node. <code>Figure 4</code> illustrates the structure and contents of the parse tree as each new token is processed.</p> <p> Figure 4: Tracing Parse Tree Construction$ </p> <p>Using <code>Figure 4</code> and the example expression from the previous paragraph, let\u2019s walk through the example step by step:</p> <p>a) Create an empty tree.</p> <p>b) Read <code>(</code> as the first token. By rule 1, create a new node as the left child of the root. Make the current node this new child.</p> <p>c) Read <code>3</code> as the next token. By rule 3, set the root value of the current node to 3 and go back up the tree to the parent.</p> <p>d) Read <code>+</code> as the next token. By rule 2, set the root value of the current node to + and add a new node as the right child. The new right child becomes the current node.</p> <p>e) Read <code>(</code> as the next token. By rule 1, create a new node as the left child of the current node. The new left child becomes the current node.</p> <p>f) Read <code>4</code> as the next token. By rule 3, set the value of the current node to 4. Make the parent of 4 the current node.</p> <p>g) Read <code>*</code> as the next token. By rule 2, set the root value of the current node to * and create a new right child. The new right child becomes the current node.</p> <p>h) Read <code>5</code> as the next token. By rule 3, set the root value of the current node to 5. Make the parent of 5 the current node.</p> <p>i) Read <code>)</code> as the next token. By rule 4 we make the parent of * the current node.</p> <p>j) Read <code>)</code> as the next token. By rule 4 we make the parent of + the current node. At this point there is no parent for +, so we are done.</p> <p>From the example above, it is clear that we need to keep track of the current node as well as the parent of the current node. The tree interface provides us with a way to get children of a node, through the <code>get_left_child</code> and <code>get_right_child</code> methods, but how can we keep track of the parent? A simple solution to keeping track of parents as we traverse the tree is to use a stack. Whenever we want to descend to a child of the current node, we first push the current node on the stack. When we want to return to the parent of the current node, we pop the parent off the stack.</p> <p>Using the rules described above, along with the <code>Stack</code> and <code>BinaryTree</code> operations, we are now ready to write a Python function to create a parse tree. The code for our parse tree builder is presented in <code>ActiveCode 1</code>.</p> Activity: 6.7.1 Building a Parse Tree<pre><code>from pythonds3.basic import Stack\nfrom pythonds3.trees import BinaryTree\n\n\ndef build_parse_tree(fp_expr):\n    fp_list = fp_expr.split()\n    p_stack = Stack()\n    expr_tree = BinaryTree(\"\")\n    p_stack.push(expr_tree)\n    current_tree = expr_tree\n\n    for i in fp_list:\n        if i == \"(\":\n            current_tree.insert_left(\"\")\n            p_stack.push(current_tree)\n            current_tree = current_tree.left_child\n        elif i in [\"+\", \"-\", \"*\", \"/\"]:\n            current_tree.root = i\n            current_tree.insert_right(\"\")\n            p_stack.push(current_tree)\n            current_tree = current_tree.right_child\n        elif i.isdigit():\n                current_tree.root = int(i)\n                parent = p_stack.pop()\n                current_tree = parent\n        elif i == \")\":\n                current_tree = p_stack.pop()\n        else:\n                raise ValueError(f\"Unknown operator '{i}'\")\n\n    return expr_tree\n\n\npt = build_parse_tree(\"( ( 10 + 5 ) * 3 )\")\npt.postorder()  # defined and explained in the next section\n</code></pre> <p>The four rules for building a parse tree are coded as the first four clauses of the <code>if..elif</code> statements on lines 13, 17, 22, and 26 of <code>ActiveCode 1</code>. In each case you can see that the code implements the rule, as described above, with a few calls to the <code>BinaryTree</code> or <code>Stack</code> methods. The only error checking we do in this function is in the <code>else</code> clause where a <code>ValueError</code> exception will be raised if we get a token from the list that we do not recognize.</p> <p>Now that we have built a parse tree, what can we do with it? As a first example, we will write a function to evaluate the parse tree and return the numerical result. To write this function, we will make use of the hierarchical nature of the tree. Look back at <code>Figure 2</code>. Recall that we can replace the original tree with the simplified tree shown in <code>Figure 3</code>. This suggests that we can write an algorithm that evaluates a parse tree by recursively evaluating each subtree.</p> <p>As we have done with past recursive algorithms, we will begin the design for the recursive evaluation function by identifying the base case. A natural base case for recursive algorithms that operate on trees is to check for a leaf node. In a parse tree, the leaf nodes will always be operands. Since numerical objects like integers and floating points require no further interpretation, the <code>evaluate</code> function can simply return the value stored in the leaf node. The recursive step that moves the function toward the base case is to call <code>evaluate</code> on both the left and the right children of the current node. The recursive call effectively moves us down the tree, toward a leaf node.</p> <p>To put the results of the two recursive calls together, we can simply apply the operator stored in the parent node to the results returned from evaluating both children. In the example from <code>Figure 3</code> we see that the two children of the root evaluate to themselves, namely 10 and 3. Applying the multiplication operator gives us a final result of 30.</p> <p>The code for a recursive <code>evaluate</code> function is shown in <code>Listing 1</code>. First, we obtain references to the left and the right children of the current node. If both the left and right children evaluate to <code>None</code>, then we know that the current node is really a leaf node. This check is on line 7. If the current node is not a leaf node, look up the operator in the current node and apply it to the results from recursively evaluating the left and right children.</p> **Listing 1**<pre><code>import operator\n\n\ndef evaluate(parse_tree):\n    operators = {\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n    }\n\n    left_child = parse_tree.left_child\n    right_child = parse_tree.right_child\n\n    if left_child and right_child:\n        fn = operators[parse_tree.root]\n        return fn(evaluate(left_child), evaluate(right_child))\n    else:\n        return parse_tree.root\n</code></pre> <p>To implement the arithmetic, we use a dictionary with the keys <code>\"+\"</code>, <code>\"-\"</code>, <code>\"*\"</code>, and <code>\"/\"</code>. The values stored in the dictionary are functions from Python\u2019s operator module. The operator module provides us with the function versions of many commonly used operators. When we look up an operator in the dictionary, the corresponding function object is retrieved. Since the retrieved object is a function, we can call it in the usual way: <code>function(param1, param2)</code>. So the lookup <code>operators[\"+\"](2, 2)</code> is equivalent to <code>operator.add(2, 2)</code>.</p> <p>Finally, we will trace the <code>evaluate</code> function on the parse tree we created in <code>Figure 4</code>. When we first call <code>evaluate</code>, we pass the root of the entire tree as the parameter <code>parse_tree</code>. Then we obtain references to the left and right children to make sure they exist. The recursive call takes place on line 17. We begin by looking up the operator in the root of the tree, which is <code>\"+\"</code>. The <code>\"+\"</code> operator maps to the <code>operator.add</code> function call, which takes two parameters. As usual for a Python function call, the first thing Python does is to evaluate the parameters that are passed to the function. In this case both parameters are recursive function calls to our <code>evaluate</code> function. Using left-to-right evaluation, the first recursive call goes to the left. In the first recursive call the <code>evaluate</code> function is given the left subtree. We find that the node has no left or right children, so we are in a leaf node. When we are in a leaf node, we just return the value stored in the leaf node as the result of the evaluation. In this case we return the integer 3.</p> <p>At this point we have one parameter evaluated for our top-level call to <code>operator.add</code>. But we are not done yet. Continuing the left-to-right evaluation of the parameters, we now make a recursive call to evaluate the right child of the root. We find that the node has both a left and a right child so we look up the operator stored in this node, <code>\"*\"</code>, and call this function using the left and right children as the parameters. At this point you can see that both recursive calls will be to leaf nodes, which will evaluate to the integers 4 and 5 respectively. With the two parameters evaluated, we return the result of <code>operator.mul(4, 5)</code>. At this point we have evaluated the operands for the top level <code>\"+\"</code> operator and all that is left to do is finish the call to <code>operator.add(3, 20)</code>. The result of the evaluation of the entire expression tree for \\((3 + (4 * 5))\\) is 23.</p> <p>With the implementation of our tree data structure complete, we now look at an example of how a tree can be used to solve some real problems. In this section we will look at parse trees. Parse trees can be used to represent real-world constructions like sentences or mathematical expressions.</p> <p> Figure 1: A Parse Tree for a Simple Sentence </p> <p><code>Figure 1</code> shows the hierarchical structure of a simple sentence. Representing a sentence as a tree structure allows us to work with the individual parts of the sentence by using subtrees.</p> <p> Figure 2: Parse Tree for \\(((7 + 3) \\cdot (5 - 2))\\) </p> <p>We can also represent a mathematical expression such as \\(((7 + 3) \\cdot (5 - 2))\\) as a parse tree, as shown in <code>Figure 2</code>. We have already looked at fully parenthesized expressions, so what do we know about this expression? We know that multiplication has a higher precedence than either addition or subtraction. Because of the parentheses, we know that before we can do the multiplication we must evaluate the parenthesized addition and subtraction expressions. The hierarchy of the tree helps us understand the order of evaluation for the whole expression. Before we can evaluate the top-level multiplication, we must evaluate the addition and the subtraction in the subtrees. The addition, which is the left subtree, evaluates to 10. The subtraction, which is the right subtree, evaluates to 3. Using the hierarchical structure of trees, we can simply replace an entire subtree with one node once we have evaluated the expressions in the children. Applying this replacement procedure gives us the simplified tree shown in <code>Figure 3</code>.</p> <p> Figuer 3: A Simplified Parse Tree for \\(((7 + 3) \\cdot (5 - 2))\\) </p> <p>In the rest of this section we are going to examine parse trees in more detail. In particular we will look at</p> <ul> <li>How to build a parse tree from a fully parenthesized mathematical expression.</li> <li>How to evaluate the expression stored in a parse tree.</li> <li>How to recover the original mathematical expression from a parse tree.</li> </ul> <p>The first step in building a parse tree is to break up the expression string into a list of tokens. There are four different kinds of tokens to consider: left parentheses, right parentheses, operators, and operands. We know that whenever we read a left parenthesis we are starting a new expression, and hence we should create a new tree to correspond to that expression. Conversely, whenever we read a right parenthesis, we have finished an expression. We also know that operands are going to be leaf nodes and children of their operators. Finally, we know that every operator is going to have both a left and a right child.</p> <p>Using the information from above we can define four rules as follows:</p> <ol> <li>If the current token is a <code>\"(\"</code>, add a new node as the left child of the current node, and descend to the left child.</li> <li>If the current token is in the list <code>[\"+\", \"-\", \"/\", \"*\"]</code>, set the root value of the current node to the operator represented by the current token. Add a new node as the right child of the current node and descend to the right child.</li> <li>If the current token is a number, set the root value of the current node to the number and return to the parent.</li> <li>If the current token is a <code>\")\"</code>, go to the parent of the current node.</li> </ol> <p>Before writing the Python code, let\u2019s look at an example of the rules outlined above in action. We will use the expression \\((3 + (4 * 5))\\). We will parse this expression into the following list of character tokens: <code>[\"(\", \"3\", \"+\", \"(\", \"4\", \"*\", \"5\", \")\", \")\"]</code>. Initially we will start out with a parse tree that consists of an empty root node. <code>Figure 4</code> illustrates the structure and contents of the parse tree as each new token is processed.</p> <p> Figure 4: Tracing Parse Tree Construction$ </p> <p>Using <code>Figure 4</code> and the example expression from the previous paragraph, let\u2019s walk through the example step by step:</p> <p>a) Create an empty tree.</p> <p>b) Read <code>(</code> as the first token. By rule 1, create a new node as the left child of the root. Make the current node this new child.</p> <p>c) Read <code>3</code> as the next token. By rule 3, set the root value of the current node to 3 and go back up the tree to the parent.</p> <p>d) Read <code>+</code> as the next token. By rule 2, set the root value of the current node to + and add a new node as the right child. The new right child becomes the current node.</p> <p>e) Read <code>(</code> as the next token. By rule 1, create a new node as the left child of the current node. The new left child becomes the current node.</p> <p>f) Read <code>4</code> as the next token. By rule 3, set the value of the current node to 4. Make the parent of 4 the current node.</p> <p>g) Read <code>*</code> as the next token. By rule 2, set the root value of the current node to * and create a new right child. The new right child becomes the current node.</p> <p>h) Read <code>5</code> as the next token. By rule 3, set the root value of the current node to 5. Make the parent of 5 the current node.</p> <p>i) Read <code>)</code> as the next token. By rule 4 we make the parent of * the current node.</p> <p>j) Read <code>)</code> as the next token. By rule 4 we make the parent of + the current node. At this point there is no parent for +, so we are done.</p> <p>From the example above, it is clear that we need to keep track of the current node as well as the parent of the current node. The tree interface provides us with a way to get children of a node, through the <code>get_left_child</code> and <code>get_right_child</code> methods, but how can we keep track of the parent? A simple solution to keeping track of parents as we traverse the tree is to use a stack. Whenever we want to descend to a child of the current node, we first push the current node on the stack. When we want to return to the parent of the current node, we pop the parent off the stack.</p> <p>Using the rules described above, along with the <code>Stack</code> and <code>BinaryTree</code> operations, we are now ready to write a Python function to create a parse tree. The code for our parse tree builder is presented in <code>ActiveCode 1</code>.</p> Activity: 6.7.1 Building a Parse Tree<pre><code>from pythonds3.basic import Stack\nfrom pythonds3.trees import BinaryTree\n\n\ndef build_parse_tree(fp_expr):\n    fp_list = fp_expr.split()\n    p_stack = Stack()\n    expr_tree = BinaryTree(\"\")\n    p_stack.push(expr_tree)\n    current_tree = expr_tree\n\n    for i in fp_list:\n        if i == \"(\":\n            current_tree.insert_left(\"\")\n            p_stack.push(current_tree)\n            current_tree = current_tree.left_child\n        elif i in [\"+\", \"-\", \"*\", \"/\"]:\n            current_tree.root = i\n            current_tree.insert_right(\"\")\n            p_stack.push(current_tree)\n            current_tree = current_tree.right_child\n        elif i.isdigit():\n                current_tree.root = int(i)\n                parent = p_stack.pop()\n                current_tree = parent\n        elif i == \")\":\n                current_tree = p_stack.pop()\n        else:\n                raise ValueError(f\"Unknown operator '{i}'\")\n\n    return expr_tree\n\n\npt = build_parse_tree(\"( ( 10 + 5 ) * 3 )\")\npt.postorder()  # defined and explained in the next section\n</code></pre> <p>The four rules for building a parse tree are coded as the first four clauses of the <code>if..elif</code> statements on lines 13, 17, 22, and 26 of <code>ActiveCode 1</code>. In each case you can see that the code implements the rule, as described above, with a few calls to the <code>BinaryTree</code> or <code>Stack</code> methods. The only error checking we do in this function is in the <code>else</code> clause where a <code>ValueError</code> exception will be raised if we get a token from the list that we do not recognize.</p> <p>Now that we have built a parse tree, what can we do with it? As a first example, we will write a function to evaluate the parse tree and return the numerical result. To write this function, we will make use of the hierarchical nature of the tree. Look back at <code>Figure 2</code>. Recall that we can replace the original tree with the simplified tree shown in <code>Figure 3</code>. This suggests that we can write an algorithm that evaluates a parse tree by recursively evaluating each subtree.</p> <p>As we have done with past recursive algorithms, we will begin the design for the recursive evaluation function by identifying the base case. A natural base case for recursive algorithms that operate on trees is to check for a leaf node. In a parse tree, the leaf nodes will always be operands. Since numerical objects like integers and floating points require no further interpretation, the <code>evaluate</code> function can simply return the value stored in the leaf node. The recursive step that moves the function toward the base case is to call <code>evaluate</code> on both the left and the right children of the current node. The recursive call effectively moves us down the tree, toward a leaf node.</p> <p>To put the results of the two recursive calls together, we can simply apply the operator stored in the parent node to the results returned from evaluating both children. In the example from <code>Figure 3</code> we see that the two children of the root evaluate to themselves, namely 10 and 3. Applying the multiplication operator gives us a final result of 30.</p> <p>The code for a recursive <code>evaluate</code> function is shown in <code>Listing 1</code>. First, we obtain references to the left and the right children of the current node. If both the left and right children evaluate to <code>None</code>, then we know that the current node is really a leaf node. This check is on line 7. If the current node is not a leaf node, look up the operator in the current node and apply it to the results from recursively evaluating the left and right children.</p> **Listing 1**<pre><code>import operator\n\n\ndef evaluate(parse_tree):\n    operators = {\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n    }\n\n    left_child = parse_tree.left_child\n    right_child = parse_tree.right_child\n\n    if left_child and right_child:\n        fn = operators[parse_tree.root]\n        return fn(evaluate(left_child), evaluate(right_child))\n    else:\n        return parse_tree.root\n</code></pre> <p>To implement the arithmetic, we use a dictionary with the keys <code>\"+\"</code>, <code>\"-\"</code>, <code>\"*\"</code>, and <code>\"/\"</code>. The values stored in the dictionary are functions from Python\u2019s operator module. The operator module provides us with the function versions of many commonly used operators. When we look up an operator in the dictionary, the corresponding function object is retrieved. Since the retrieved object is a function, we can call it in the usual way: <code>function(param1, param2)</code>. So the lookup <code>operators[\"+\"](2, 2)</code> is equivalent to <code>operator.add(2, 2)</code>.</p> <p>Finally, we will trace the <code>evaluate</code> function on the parse tree we created in <code>Figure 4</code>. When we first call <code>evaluate</code>, we pass the root of the entire tree as the parameter <code>parse_tree</code>. Then we obtain references to the left and right children to make sure they exist. The recursive call takes place on line 17. We begin by looking up the operator in the root of the tree, which is <code>\"+\"</code>. The <code>\"+\"</code> operator maps to the <code>operator.add</code> function call, which takes two parameters. As usual for a Python function call, the first thing Python does is to evaluate the parameters that are passed to the function. In this case both parameters are recursive function calls to our <code>evaluate</code> function. Using left-to-right evaluation, the first recursive call goes to the left. In the first recursive call the <code>evaluate</code> function is given the left subtree. We find that the node has no left or right children, so we are in a leaf node. When we are in a leaf node, we just return the value stored in the leaf node as the result of the evaluation. In this case we return the integer 3.</p> <p>At this point we have one parameter evaluated for our top-level call to <code>operator.add</code>. But we are not done yet. Continuing the left-to-right evaluation of the parameters, we now make a recursive call to evaluate the right child of the root. We find that the node has both a left and a right child so we look up the operator stored in this node, <code>\"*\"</code>, and call this function using the left and right children as the parameters. At this point you can see that both recursive calls will be to leaf nodes, which will evaluate to the integers 4 and 5 respectively. With the two parameters evaluated, we return the result of <code>operator.mul(4, 5)</code>. At this point we have evaluated the operands for the top level <code>\"+\"</code> operator and all that is left to do is finish the call to <code>operator.add(3, 20)</code>. The result of the evaluation of the entire expression tree for \\((3 + (4 * 5))\\) is 23.</p>"},{"location":"c6/s8/","title":"6.8. \u6811\u904d\u5386","text":"<p>6.8. Tree Traversals</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have examined the basic functionality of our tree data structure, it is time to look at some additional usage patterns for trees. These usage patterns can be divided into three commonly used patterns to visit all the nodes in a tree. The difference between these patterns is the order in which each node is visited. We call this visitation of the nodes a tree traversal. The three traversals we will look at are called preorder, inorder, and postorder. Let\u2019s start out by defining these three traversals more carefully, then look at some examples where these patterns are useful.</p> <p>Preorder</p> <p>In a preorder traversal, we visit the root node first, then recursively do a preorder traversal of the left subtree, followed by a recursive preorder traversal of the right subtree.</p> <p>Inorder</p> <p>In an inorder traversal, we recursively do an inorder traversal on the left subtree, visit the root node, and finally do a recursive inorder traversal of the right subtree.</p> <p>Postorder</p> <p>In a postorder traversal, we recursively do a postorder traversal of the left subtree and the right subtree followed by a visit to the root node.</p> <p>Let\u2019s look at some examples that illustrate each of these three kinds of traversals. First let\u2019s look at the preorder traversal using a book as an example tree. The book is the root of the tree, and each chapter is a child of the root. Each section within a chapter is a child of the chapter, each subsection is a child of its section, and so on. <code>Figure 5</code> shows a limited version of a book with only two chapters. Note that the traversal algorithm works for trees with any number of children, but we will stick with binary trees for now.</p> <p> Figure 5: Representing a Book as a Tree </p> <p>Suppose that you wanted to read this book from front to back. The preorder traversal gives you exactly that ordering. Starting at the root of the tree (the Book node) we will follow the preorder traversal instructions. We recursively call <code>preorder</code> on the left child, in this case Chapter1. We again recursively call <code>preorder</code> on the left child to get to Section 1.1. Since Section 1.1 has no children, we do not make any additional recursive calls. When we are finished with Section 1.1, we move up the tree to Chapter 1. At this point we still need to visit the right subtree of Chapter 1, which is Section 1.2. As before we visit the left subtree, which brings us to Section 1.2.1, then we visit the node for Section 1.2.2. With Section 1.2 finished, we return to Chapter 1. Then we return to the Book node and follow the same procedure for Chapter 2.</p> <p>The code for writing tree traversals is surprisingly elegant, largely because the traversals are written recursively. You may wonder,  what is the best way to write an algorithm like preorder traversal? Should it be a function that simply uses a tree as a data structure, or should it be a method of the tree data structure itself? <code>Listing 2</code> shows a version of the preorder traversal written as an external function that takes a binary tree as a parameter. The external function is particularly elegant because our base case is simply to check if the tree exists. If the tree parameter is <code>None</code>, then the function returns without taking any action.</p> Listing 2<pre><code>def preorder(tree):\n    if tree:\n        print(tree.key)\n        preorder(tree.left_child)\n        preorder(tree.right_child)\n</code></pre> <p>We can also implement <code>preorder</code> as a method of the <code>BinaryTree</code> class. The code for implementing <code>preorder</code> as an internal method is shown in <code>Listing 3</code>. Notice what happens when we move the code from external to internal. In general, we just replace <code>tree</code> with <code>self</code>. However, we also need to modify the base case. The internal method must check for the existence of the left and the right children before making the recursive call to <code>preorder</code>.</p> Listing 3<pre><code>def preorder(self):\n    print(self.key)\n    if self.left_child:\n        self.left_child.preorder()\n    if self.right_child:\n        self.right_child.preorder()\n</code></pre> <p>Which of these two ways to implement <code>preorder</code> is best? The answer is that implementing <code>preorder</code> as an external function is probably better in this case. The reason is that you very rarely want to just traverse the tree. In most cases you are going to want to accomplish something else while using one of the basic traversal patterns. In fact, we will see in the next example that the <code>postorder</code> traversal pattern follows very closely with the code we wrote earlier to evaluate a parse tree. Therefore we will write the rest of the traversals as external functions.</p> <p>The algorithm for the <code>postorder</code> traversal, shown in <code>Listing 4</code>, is nearly identical to <code>preorder</code> except that we move the call to print to the end of the function.</p> Listing 4<pre><code>def postorder(tree):\n    if tree:\n        postorder(tree.left_child)\n        postorder(tree.right_child)\n        print(tree.key)\n</code></pre> <p>We have already seen a common use for the postorder traversal, namely evaluating a parse tree. Look back at <code>Listing 1</code> again. The algorithm evaluates the left subtree, evaluates the right subtree,  and combines them in the root through the function call to an operator. Assuming our binary tree is going to store only expression tree data, rewrite the evaluation function, but model it even more closely on the postorder code in <code>Listing 4</code>.</p> Listing 5<pre><code>def postordereval(tree):\n    operators = {\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n    }\n    result_1 = None\n    result_2 = None\n    if tree:\n        result_1 = postordereval(tree.left_child)\n        result_2 = postordereval(tree.right_child)\n        if result_1 and result_2:\n            return operators[tree.key](result_1, result_2)\n        return tree.key\n</code></pre> <p>Notice that the form in <code>Listing 4</code> is the same as the form in <code>Listing 5</code>, except that instead of printing the key at the end of the function, we return it. This allows us to save the values returned from the recursive calls in lines 11 and 12. We then use these saved values along with the operator on line 14.</p> <p>The final traversal we will look at in this section is the inorder traversal. In the inorder traversal we visit the left subtree, followed by the root, and finally the right subtree. <code>Listing 6</code> shows our code for the inorder traversal. Notice that in all three of the traversal functions we are simply changing the position of the <code>print</code> function with respect to the two recursive function calls.</p> Listing 6<pre><code>def inorder(tree):\n    if tree:\n        inorder(tree.left_child)\n        print(tree.key)\n        inorder(tree.right_child)\n</code></pre> <p>If we perform a simple inorder traversal of a parse tree, we get our original expression back without any parentheses. Let\u2019s modify the basic inorder algorithm to allow us to recover the fully parenthesized version of the expression. The only modifications we will make to the basic template are as follows: print a left parenthesis before the recursive call to the left subtree, and print a right parenthesis after the recursive call to the right subtree. The modified code is shown in <code>Listing 7</code>.</p> Listing 7<pre><code>def print_exp(tree):\n    result = \"\"\n    if tree:\n        result = \"(\" + print_exp(tree.left_child)\n        result = result + str(tree.key)\n        result = result + print_exp(tree.right_child) + \")\"\n    return result\n</code></pre> <p>Notice that the <code>print_exp</code> function as we have implemented it puts parentheses around each number. While not incorrect, the parentheses are clearly not needed. In the exercises at the end of this chapter you are asked to modify the <code>print_exp</code> function to remove this set of parentheses.</p> <p>Now that we have examined the basic functionality of our tree data structure, it is time to look at some additional usage patterns for trees. These usage patterns can be divided into three commonly used patterns to visit all the nodes in a tree. The difference between these patterns is the order in which each node is visited. We call this visitation of the nodes a tree traversal. The three traversals we will look at are called preorder, inorder, and postorder. Let\u2019s start out by defining these three traversals more carefully, then look at some examples where these patterns are useful.</p> <p>Preorder</p> <p>In a preorder traversal, we visit the root node first, then recursively do a preorder traversal of the left subtree, followed by a recursive preorder traversal of the right subtree.</p> <p>Inorder</p> <p>In an inorder traversal, we recursively do an inorder traversal on the left subtree, visit the root node, and finally do a recursive inorder traversal of the right subtree.</p> <p>Postorder</p> <p>In a postorder traversal, we recursively do a postorder traversal of the left subtree and the right subtree followed by a visit to the root node.</p> <p>Let\u2019s look at some examples that illustrate each of these three kinds of traversals. First let\u2019s look at the preorder traversal using a book as an example tree. The book is the root of the tree, and each chapter is a child of the root. Each section within a chapter is a child of the chapter, each subsection is a child of its section, and so on. <code>Figure 5</code> shows a limited version of a book with only two chapters. Note that the traversal algorithm works for trees with any number of children, but we will stick with binary trees for now.</p> <p> Figure 5: Representing a Book as a Tree </p> <p>Suppose that you wanted to read this book from front to back. The preorder traversal gives you exactly that ordering. Starting at the root of the tree (the Book node) we will follow the preorder traversal instructions. We recursively call <code>preorder</code> on the left child, in this case Chapter1. We again recursively call <code>preorder</code> on the left child to get to Section 1.1. Since Section 1.1 has no children, we do not make any additional recursive calls. When we are finished with Section 1.1, we move up the tree to Chapter 1. At this point we still need to visit the right subtree of Chapter 1, which is Section 1.2. As before we visit the left subtree, which brings us to Section 1.2.1, then we visit the node for Section 1.2.2. With Section 1.2 finished, we return to Chapter 1. Then we return to the Book node and follow the same procedure for Chapter 2.</p> <p>The code for writing tree traversals is surprisingly elegant, largely because the traversals are written recursively. You may wonder,  what is the best way to write an algorithm like preorder traversal? Should it be a function that simply uses a tree as a data structure, or should it be a method of the tree data structure itself? <code>Listing 2</code> shows a version of the preorder traversal written as an external function that takes a binary tree as a parameter. The external function is particularly elegant because our base case is simply to check if the tree exists. If the tree parameter is <code>None</code>, then the function returns without taking any action.</p> Listing 2<pre><code>def preorder(tree):\n    if tree:\n        print(tree.key)\n        preorder(tree.left_child)\n        preorder(tree.right_child)\n</code></pre> <p>We can also implement <code>preorder</code> as a method of the <code>BinaryTree</code> class. The code for implementing <code>preorder</code> as an internal method is shown in <code>Listing 3</code>. Notice what happens when we move the code from external to internal. In general, we just replace <code>tree</code> with <code>self</code>. However, we also need to modify the base case. The internal method must check for the existence of the left and the right children before making the recursive call to <code>preorder</code>.</p> Listing 3<pre><code>def preorder(self):\n    print(self.key)\n    if self.left_child:\n        self.left_child.preorder()\n    if self.right_child:\n        self.right_child.preorder()\n</code></pre> <p>Which of these two ways to implement <code>preorder</code> is best? The answer is that implementing <code>preorder</code> as an external function is probably better in this case. The reason is that you very rarely want to just traverse the tree. In most cases you are going to want to accomplish something else while using one of the basic traversal patterns. In fact, we will see in the next example that the <code>postorder</code> traversal pattern follows very closely with the code we wrote earlier to evaluate a parse tree. Therefore we will write the rest of the traversals as external functions.</p> <p>The algorithm for the <code>postorder</code> traversal, shown in <code>Listing 4</code>, is nearly identical to <code>preorder</code> except that we move the call to print to the end of the function.</p> Listing 4<pre><code>def postorder(tree):\n    if tree:\n        postorder(tree.left_child)\n        postorder(tree.right_child)\n        print(tree.key)\n</code></pre> <p>We have already seen a common use for the postorder traversal, namely evaluating a parse tree. Look back at <code>Listing 1</code> again. The algorithm evaluates the left subtree, evaluates the right subtree,  and combines them in the root through the function call to an operator. Assuming our binary tree is going to store only expression tree data, rewrite the evaluation function, but model it even more closely on the postorder code in <code>Listing 4</code>.</p> Listing 5<pre><code>def postordereval(tree):\n    operators = {\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n    }\n    result_1 = None\n    result_2 = None\n    if tree:\n        result_1 = postordereval(tree.left_child)\n        result_2 = postordereval(tree.right_child)\n        if result_1 and result_2:\n            return operators[tree.key](result_1, result_2)\n        return tree.key\n</code></pre> <p>Notice that the form in <code>Listing 4</code> is the same as the form in <code>Listing 5</code>, except that instead of printing the key at the end of the function, we return it. This allows us to save the values returned from the recursive calls in lines 11 and 12. We then use these saved values along with the operator on line 14.</p> <p>The final traversal we will look at in this section is the inorder traversal. In the inorder traversal we visit the left subtree, followed by the root, and finally the right subtree. <code>Listing 6</code> shows our code for the inorder traversal. Notice that in all three of the traversal functions we are simply changing the position of the <code>print</code> function with respect to the two recursive function calls.</p> Listing 6<pre><code>def inorder(tree):\n    if tree:\n        inorder(tree.left_child)\n        print(tree.key)\n        inorder(tree.right_child)\n</code></pre> <p>If we perform a simple inorder traversal of a parse tree, we get our original expression back without any parentheses. Let\u2019s modify the basic inorder algorithm to allow us to recover the fully parenthesized version of the expression. The only modifications we will make to the basic template are as follows: print a left parenthesis before the recursive call to the left subtree, and print a right parenthesis after the recursive call to the right subtree. The modified code is shown in <code>Listing 7</code>.</p> Listing 7<pre><code>def print_exp(tree):\n    result = \"\"\n    if tree:\n        result = \"(\" + print_exp(tree.left_child)\n        result = result + str(tree.key)\n        result = result + print_exp(tree.right_child) + \")\"\n    return result\n</code></pre> <p>Notice that the <code>print_exp</code> function as we have implemented it puts parentheses around each number. While not incorrect, the parentheses are clearly not needed. In the exercises at the end of this chapter you are asked to modify the <code>print_exp</code> function to remove this set of parentheses.</p>"},{"location":"c6/s9/","title":"6.9. \u4f7f\u7528\u4e8c\u53c9\u5806\u7684\u4f18\u5148\u961f\u5217","text":"<p>6.9. Priority Queues with Binary Heaps</p> \u4e2d\u6587\u82f1\u6587 <p>In earlier sections you learned about the first in, first out data structure called a queue. One important variation of a queue is called a priority queue. A priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. The highest priority items are at the front of the queue and the lowest priority items are at the back. Thus when you enqueue an item on a priority queue, the new item may move all the way to the front. We will see that the priority queue is a useful data structure for some of the graph algorithms we will study in the next chapter.</p> <p>You can probably think of a couple of easy ways to implement a priority queue using sorting functions and lists. However, inserting into a list is \\(O(n)\\) and sorting a list is \\(O(n \\log{n})\\). We can do better. The classic way to implement a priority queue is using a data structure called a binary heap. A binary heap will allow us both to enqueue and dequeue items in \\(O(\\log{n})\\).</p> <p>The binary heap is interesting to study because when we diagram the heap it looks a lot like a tree, but when we implement it we use only a single list as an internal representation. The binary heap has two common variations: the min heap, in which the smallest key value is always at the front, and the max heap, in which the largest key value is always at the front. In this section we will implement the min heap. We leave a max heap implementation as an exercise.</p> <p>In earlier sections you learned about the first in, first out data structure called a queue. One important variation of a queue is called a priority queue. A priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. The highest priority items are at the front of the queue and the lowest priority items are at the back. Thus when you enqueue an item on a priority queue, the new item may move all the way to the front. We will see that the priority queue is a useful data structure for some of the graph algorithms we will study in the next chapter.</p> <p>You can probably think of a couple of easy ways to implement a priority queue using sorting functions and lists. However, inserting into a list is \\(O(n)\\) and sorting a list is \\(O(n \\log{n})\\). We can do better. The classic way to implement a priority queue is using a data structure called a binary heap. A binary heap will allow us both to enqueue and dequeue items in \\(O(\\log{n})\\).</p> <p>The binary heap is interesting to study because when we diagram the heap it looks a lot like a tree, but when we implement it we use only a single list as an internal representation. The binary heap has two common variations: the min heap, in which the smallest key value is always at the front, and the max heap, in which the largest key value is always at the front. In this section we will implement the min heap. We leave a max heap implementation as an exercise.</p>"},{"location":"c7/","title":"7. \u56fe\u548c\u56fe\u7b97\u6cd5","text":"<p>7. Graphs and Graphing Algorithms</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>7.1. \u76ee\u6807 </li> <li>7.2. \u8bcd\u6c47\u548c\u5b9a\u4e49 </li> <li>7.3. \u56fe\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b </li> <li>7.4. \u90bb\u63a5\u77e9\u9635 </li> <li>7.5. \u90bb\u63a5\u8868 </li> <li>7.6. \u5b9e\u73b0 </li> <li>7.7. \u5b57\u68af\u95ee\u9898 </li> <li>7.8. \u6784\u5efa\u5b57\u68af\u56fe </li> <li>7.9. \u5b9e\u73b0\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 </li> <li>7.10. \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790 </li> <li>7.11. \u9a91\u58eb\u5de1\u6e38\u95ee\u9898 </li> <li>7.12. \u6784\u5efa\u9a91\u58eb\u5de1\u6e38\u56fe </li> <li>7.13. \u5b9e\u73b0\u9a91\u58eb\u5de1\u6e38 </li> <li>7.14. \u9a91\u58eb\u5de1\u6e38\u5206\u6790 </li> <li>7.15. \u4e00\u822c\u7684\u6df1\u5ea6\u4f18\u5148\u641c\u7d22 </li> <li>7.16. \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790 </li> <li>7.17. \u62d3\u6251\u6392\u5e8f </li> <li>7.18. \u5f3a\u8fde\u901a\u5206\u91cf </li> <li>7.19. \u6700\u77ed\u8def\u5f84\u95ee\u9898 </li> <li>7.20. Dijkstra\u7b97\u6cd5 </li> <li>7.21. Dijkstra\u7b97\u6cd5\u5206\u6790 </li> <li>7.22. Prim\u751f\u6210\u6811\u7b97\u6cd5 </li> <li>7.23. \u603b\u7ed3 </li> <li>7.24. \u5173\u952e\u672f\u8bed </li> <li>7.25. \u7ec3\u4e60</li> </ul> <ul> <li>7.1. Objectives</li> <li>7.2. Vocabulary and Definitions</li> <li>7.3. The Graph Abstract Data Type</li> <li>7.4. An Adjacency Matrix</li> <li>7.5. An Adjacency List</li> <li>7.6. Implementation</li> <li>7.7. The Word Ladder Problem</li> <li>7.8. Building the Word Ladder Graph</li> <li>7.9. Implementing Breadth-First Search</li> <li>7.10. Breadth-First Search Analysis</li> <li>7.11. The Knight\u2019s Tour Problem</li> <li>7.12. Building the Knight\u2019s Tour Graph</li> <li>7.13. Implementing Knight\u2019s Tour</li> <li>7.14. Knight\u2019s Tour Analysis</li> <li>7.15. General Depth-First Search</li> <li>7.16. Depth-First Search Analysis</li> <li>7.17. Topological Sorting</li> <li>7.18. Strongly Connected Components</li> <li>7.19. Shortest Path Problems</li> <li>7.20. Dijkstra\u2019s Algorithm</li> <li>7.21. Analysis of Dijkstra\u2019s Algorithm</li> <li>7.22. Prim\u2019s Spanning Tree Algorithm</li> <li>7.23. Summary</li> <li>7.24. Key Terms</li> <li>7.25. Exercises</li> </ul>"},{"location":"c7/s1/","title":"7.1. \u76ee\u6807","text":"<p>7.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>To learn what a graph is and how it is used.</li> <li>To implement the graph abstract data type using multiple internal representations.</li> <li>To see how graphs can be used to solve a wide variety of problems.</li> </ul> <p>In this chapter we will study graphs. Graphs are a more general structure than the trees we studied in the last chapter; in fact, you can think of a tree as a special kind of graph. Graphs can be used to represent many interesting things about our world, including systems of roads, airline flights from city to city, how the internet is connected, or even the sequence of classes you must take to complete a major in computer science. We will see in this chapter that once we have a good representation for a problem, we can use some standard graph algorithms to solve what otherwise might seem to be a very difficult problem.</p> <p>While it is relatively easy for humans to look at a road map and understand the relationships between different places, a computer has no such knowledge. However, we can also think of a road map as a graph. When we do so we can have our computer do interesting things for us. If you have ever used one of the internet map sites, you know that a computer can find the shortest, quickest, or easiest path from one place to another.</p> <p>As a student of computer science you may wonder about the courses you must take for your major. A graph is good way to represent the prerequisites and other interdependencies among courses. <code>Figure 1</code> shows such a graph. It represents the courses and the order in which they must be taken to complete a major in computer science at Luther College.</p> <p> Figure 1: Prerequisites for a Computer Science Major </p> <ul> <li>To learn what a graph is and how it is used.</li> <li>To implement the graph abstract data type using multiple internal representations.</li> <li>To see how graphs can be used to solve a wide variety of problems.</li> </ul> <p>In this chapter we will study graphs. Graphs are a more general structure than the trees we studied in the last chapter; in fact, you can think of a tree as a special kind of graph. Graphs can be used to represent many interesting things about our world, including systems of roads, airline flights from city to city, how the internet is connected, or even the sequence of classes you must take to complete a major in computer science. We will see in this chapter that once we have a good representation for a problem, we can use some standard graph algorithms to solve what otherwise might seem to be a very difficult problem.</p> <p>While it is relatively easy for humans to look at a road map and understand the relationships between different places, a computer has no such knowledge. However, we can also think of a road map as a graph. When we do so we can have our computer do interesting things for us. If you have ever used one of the internet map sites, you know that a computer can find the shortest, quickest, or easiest path from one place to another.</p> <p>As a student of computer science you may wonder about the courses you must take for your major. A graph is good way to represent the prerequisites and other interdependencies among courses. <code>Figure 1</code> shows such a graph. It represents the courses and the order in which they must be taken to complete a major in computer science at Luther College.</p> <p> Figure 1: Prerequisites for a Computer Science Major </p>"},{"location":"c7/s10/","title":"7.10. \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790","text":"<p>7.10. Breadth-First Search Analysis</p> \u4e2d\u6587\u82f1\u6587 <p>Before we continue with other graph algorithms, let\u2019s analyze the run time performance of the breadth-first search algorithm. The first thing to observe is that the <code>while</code> loop is executed, at most, one time for each vertex in the graph (up to \\(|V|\\) iterations). You can see that this is true because a vertex must be white before it can be examined and added to the queue. This gives us \\(O(|V|)\\) for the <code>while</code> loop. The <code>for</code> loop, which is nested inside the <code>while</code>, is executed at most once for each edge in the graph (up to \\(|E|\\) iterations). The reason is that every vertex is dequeued at most once and we examine an edge from node \\(u\\) to node \\(v\\) only when node \\(u\\) is dequeued. This gives us \\(O(|E|)\\) for the <code>for</code> loop. Combining the two loops gives us \\(O(|V| + |E|)\\).</p> <p>Of course doing the breadth-first search is only part of the task. Following the links from the starting node to the goal node is the other part of the task. The worst case for this would be if the graph was a single long chain. In this case traversing through all of the vertices would be \\(O(|V|)\\). The normal case is going to be some fraction of \\(|V|\\) but we would still write \\(O(|V|)\\).</p> <p>Finally, at least for this problem, there is the time required to build the initial graph. We leave the analysis of the <code>build_graph</code> function as an exercise for you.</p> <p>Before we continue with other graph algorithms, let\u2019s analyze the run time performance of the breadth-first search algorithm. The first thing to observe is that the <code>while</code> loop is executed, at most, one time for each vertex in the graph (up to \\(|V|\\) iterations). You can see that this is true because a vertex must be white before it can be examined and added to the queue. This gives us \\(O(|V|)\\) for the <code>while</code> loop. The <code>for</code> loop, which is nested inside the <code>while</code>, is executed at most once for each edge in the graph (up to \\(|E|\\) iterations). The reason is that every vertex is dequeued at most once and we examine an edge from node \\(u\\) to node \\(v\\) only when node \\(u\\) is dequeued. This gives us \\(O(|E|)\\) for the <code>for</code> loop. Combining the two loops gives us \\(O(|V| + |E|)\\).</p> <p>Of course doing the breadth-first search is only part of the task. Following the links from the starting node to the goal node is the other part of the task. The worst case for this would be if the graph was a single long chain. In this case traversing through all of the vertices would be \\(O(|V|)\\). The normal case is going to be some fraction of \\(|V|\\) but we would still write \\(O(|V|)\\).</p> <p>Finally, at least for this problem, there is the time required to build the initial graph. We leave the analysis of the <code>build_graph</code> function as an exercise for you.</p>"},{"location":"c7/s11/","title":"7.11. \u9a91\u58eb\u5de1\u6e38\u95ee\u9898","text":"<p>7.11. The Knight\u2019s Tour Problem</p> \u4e2d\u6587\u82f1\u6587 <p>Another classic problem that we can use to illustrate a second common graph algorithm is called the knight\u2019s tour. The knight\u2019s tour puzzle is played on a chess board with a single chess piece, the knight. The object of the puzzle is to find a sequence of moves that allow the knight to visit every square on the board exactly once. One such sequence is called a tour. The knight\u2019s tour puzzle has fascinated chess players, mathematicians, and now, computer scientists, for over a thousand years. The upper bound on the number of possible legal tours for an \\(8 \\times 8\\) chessboard is known to be \\(1.305 \\times 10^{35}\\); however, there are even more possible dead ends. Clearly this is a problem that requires some real brains, some real computing power, or both.</p> <p>Although researchers have studied many different algorithms to solve the knight\u2019s tour problem, a graph search is one of the easiest to understand and program. Once again we will solve the problem using two main steps:</p> <ul> <li>Represent the legal moves of a knight on a chessboard as a graph.</li> <li>Use a graph algorithm to find a path of length \\(rows \\times columns - 1\\) where every vertex on the graph is visited exactly once.</li> </ul> <p>Another classic problem that we can use to illustrate a second common graph algorithm is called the knight\u2019s tour. The knight\u2019s tour puzzle is played on a chess board with a single chess piece, the knight. The object of the puzzle is to find a sequence of moves that allow the knight to visit every square on the board exactly once. One such sequence is called a tour. The knight\u2019s tour puzzle has fascinated chess players, mathematicians, and now, computer scientists, for over a thousand years. The upper bound on the number of possible legal tours for an \\(8 \\times 8\\) chessboard is known to be \\(1.305 \\times 10^{35}\\); however, there are even more possible dead ends. Clearly this is a problem that requires some real brains, some real computing power, or both.</p> <p>Although researchers have studied many different algorithms to solve the knight\u2019s tour problem, a graph search is one of the easiest to understand and program. Once again we will solve the problem using two main steps:</p> <ul> <li>Represent the legal moves of a knight on a chessboard as a graph.</li> <li>Use a graph algorithm to find a path of length \\(rows \\times columns - 1\\) where every vertex on the graph is visited exactly once.</li> </ul>"},{"location":"c7/s12/","title":"7.12. \u6784\u5efa\u9a91\u58eb\u5de1\u6e38\u56fe","text":"<p>7.12. Building the Knight\u2019s Tour Graph</p> \u4e2d\u6587\u82f1\u6587 <p>To represent the knight\u2019s tour problem as a graph we will use the following two ideas: each square on the chessboard can be represented as a node in the graph and each legal move by the knight can be represented as an edge in the graph. <code>Figure 1</code> illustrates the legal moves by a knight and the corresponding edges in a graph.</p> <p> Figure 1: Legal Moves for a Knight on Square 12 and the Corresponding Graph </p> <p>To build the full graph for an n-by-n board, we can use the Python function shown in <code>Listing 1</code>. The <code>knight_graph</code> function makes one pass over the entire board. At each square on the board the <code>knight_graph</code> function calls a helper, <code>gen_legal_moves</code>, to create a list of legal moves for that position on the board. All legal moves are then converted into edges in the graph. Each location on the board is converted into a linear vertex number similar to the vertex numbers shown in <code>Figure 1</code>.</p> Listing 1<pre><code>from pythonds3.graphs import Graph\n\n\ndef knight_graph(board_size):\n    kt_graph = Graph()\n    for row in range(board_size):\n        for col in range(board_size):\n            node_id = row * board_size + col\n            new_positions = gen_legal_moves(row, col, board_size)\n            for row2, col2 in new_positions:\n                other_node_id = row2 * board_size + col2\n                kt_graph.add_edge(node_id, other_node_id)\n    return kt_graph\n</code></pre> <p>The <code>gen_legal_moves</code> function (<code>Listing 2</code>) takes the position of the knight on the board and generates each of the eight possible moves, making sure those moves are still within the board.</p> Listing 2<pre><code>def gen_legal_moves(row, col, board_size):\n    new_moves = []\n    move_offsets = [\n        (-1, -2),  # left-down-down\n        (-1, 2),   # left-up-up\n        (-2, -1),  # left-left-down\n        (-2, 1),   # left-left-up\n        (1, -2),   # right-down-down\n        (1, 2),    # right-up-up\n        (2, -1),   # right-right-down \n        (2, 1),    # right-right-up\n    ]\n    for r_off, c_off in move_offsets:\n        if 0 &lt;= row + r_off &lt; board_size and 0 &lt;= col + c_off &lt; board_size:\n            new_moves.append((row + r_off, col + c_off))\n    return new_moves\n</code></pre> <p><code>Figure 2</code> shows the complete graph of possible moves on an \\(8 \\times 8\\) board. There are exactly 336 edges in the graph. Notice that the vertices corresponding to the edges of the board have fewer connections (legal moves) than the vertices in the middle of the board. Once again we can see how sparse the graph is. If the graph was fully connected there would be 4,096 edges. Since there are only 336 edges, the adjacency matrix would be only 8.2 percent full.</p> <p> Figure 2: All Legal Moves for a Knight on an :math:<code>8 \\times 8</code> Chessboard </p> <p>To represent the knight\u2019s tour problem as a graph we will use the following two ideas: each square on the chessboard can be represented as a node in the graph and each legal move by the knight can be represented as an edge in the graph. <code>Figure 1</code> illustrates the legal moves by a knight and the corresponding edges in a graph.</p> <p> Figure 1: Legal Moves for a Knight on Square 12 and the Corresponding Graph </p> <p>To build the full graph for an n-by-n board, we can use the Python function shown in <code>Listing 1</code>. The <code>knight_graph</code> function makes one pass over the entire board. At each square on the board the <code>knight_graph</code> function calls a helper, <code>gen_legal_moves</code>, to create a list of legal moves for that position on the board. All legal moves are then converted into edges in the graph. Each location on the board is converted into a linear vertex number similar to the vertex numbers shown in <code>Figure 1</code>.</p> Listing 1<pre><code>from pythonds3.graphs import Graph\n\n\ndef knight_graph(board_size):\n    kt_graph = Graph()\n    for row in range(board_size):\n        for col in range(board_size):\n            node_id = row * board_size + col\n            new_positions = gen_legal_moves(row, col, board_size)\n            for row2, col2 in new_positions:\n                other_node_id = row2 * board_size + col2\n                kt_graph.add_edge(node_id, other_node_id)\n    return kt_graph\n</code></pre> <p>The <code>gen_legal_moves</code> function (<code>Listing 2</code>) takes the position of the knight on the board and generates each of the eight possible moves, making sure those moves are still within the board.</p> Listing 2<pre><code>def gen_legal_moves(row, col, board_size):\n    new_moves = []\n    move_offsets = [\n        (-1, -2),  # left-down-down\n        (-1, 2),   # left-up-up\n        (-2, -1),  # left-left-down\n        (-2, 1),   # left-left-up\n        (1, -2),   # right-down-down\n        (1, 2),    # right-up-up\n        (2, -1),   # right-right-down \n        (2, 1),    # right-right-up\n    ]\n    for r_off, c_off in move_offsets:\n        if 0 &lt;= row + r_off &lt; board_size and 0 &lt;= col + c_off &lt; board_size:\n            new_moves.append((row + r_off, col + c_off))\n    return new_moves\n</code></pre> <p><code>Figure 2</code> shows the complete graph of possible moves on an \\(8 \\times 8\\) board. There are exactly 336 edges in the graph. Notice that the vertices corresponding to the edges of the board have fewer connections (legal moves) than the vertices in the middle of the board. Once again we can see how sparse the graph is. If the graph was fully connected there would be 4,096 edges. Since there are only 336 edges, the adjacency matrix would be only 8.2 percent full.</p> <p> Figure 2: All Legal Moves for a Knight on an :math:<code>8 \\times 8</code> Chessboard </p>"},{"location":"c7/s13/","title":"7.13. \u5b9e\u73b0\u9a91\u58eb\u5de1\u6e38","text":"<p>7.13. Implementing Knight\u2019s Tour</p> \u4e2d\u6587\u82f1\u6587 <p>The search algorithm we will use to solve the knight\u2019s tour problem is called depth-first search (DFS).  Whereas the breadth-first search algorithm builds a search tree one level at a time, a depth-first search creates a search tree by exploring one branch of the tree as deeply as possible. In this section we will look at two algorithms that implement a depth-first search. The first algorithm we will look at specifically solves the knight\u2019s tour problem by explicitly forbidding a node to be visited more than once. The second implementation is more general, but allows nodes to be visited more than once as the tree is constructed. The second version is used in subsequent sections to develop additional graph algorithms.</p> <p>The depth-first exploration of the graph is exactly what we need in order to find a path through 64 vertices (one for each square on the chessboard) and 63 edges. We will see that when the depth-first search algorithm finds a dead end (a place in the graph where there are no more moves possible) it backs up the tree to the next deepest vertex that allows it to make a legal move.</p> <p>The <code>knight_tour</code> function shown in <code>Listing 3</code> takes four parameters: <code>n</code>, the current depth in the search tree; <code>path</code>, a list of vertices visited up to this point; <code>u</code>, the vertex in the graph we wish to explore; and <code>limit</code>, the number of nodes in the path. The <code>knight_tour</code> function is recursive. When the <code>knight_tour</code> function is called, it first checks the base case condition. If we have a path that contains 64 vertices, we return from <code>knight_tour</code> with a status of <code>True</code>, indicating that we have found a successful tour. If the path is not long enough, we continue to explore one level deeper by choosing a new vertex to explore and calling <code>knight_tour</code> recursively for that vertex.</p> Listing 3<pre><code>from pythonds3.graphs import Graph\n\n\ndef knight_tour(n, path, u, limit):\n    u.color = \"gray\"\n    path.append(u)\n    if n &lt; limit:\n        neighbors = sorted(list(u.get_neighbors()))\n        i = 0\n        done = False\n        while i &lt; len(neighbors) and not done:\n            if neighbors[i].color == \"white\":\n                done = knight_tour(n + 1, path, neighbors[i], limit)\n            i = i + 1\n        if not done:  # prepare to backtrack\n            path.pop()\n            u.color = \"white\"\n    else:\n        done = True\n    return done\n</code></pre> <p>DFS also uses colors to keep track of which vertices in the graph have been visited. Unvisited vertices are colored white, and visited vertices are colored gray. If all neighbors of a particular vertex have been explored and we have not yet reached our goal length of 64 vertices, we have reached a dead end and must backtrack. Backtracking happens when we return from <code>knight_tour</code> with a status of <code>False</code>. In the breadth-first search we used a queue to keep track of which vertex to visit next. Since depth-first search is recursive, we are implicitly using a stack to help us with our backtracking. When we return from a call to <code>knight_tour</code> with a status of <code>False</code>, in line 11,  we remain inside the <code>while</code> loop and look at the next vertex in <code>neighbors</code>.</p> <p>Let's look at a simple example of <code>knight_tour</code> (<code>Listing 3</code>) in action. You can refer to the figures below to follow the steps of the search. For this example we will assume that the call to the <code>get_neighbors</code> method on line 6 orders the nodes in alphabetical order. We begin by calling <code>knight_tour(0, path, A, 6)</code>.</p> <p> Figure 3: Start with Node A </p> <p> Figure 4: Explore B </p> <p> Figure 5: Node C is a Dead End </p> <p> Figure 6: Backtrack to B </p> <p> Figure 7: Explore D </p> <p> Figure 8: Explore E </p> <p> Figure 9: Explore F </p> <p> Figure 10: Finish </p> <p><code>knight_tour</code> starts with node A in <code>Figure 3</code>. The nodes adjacent to A are B and D. Since B is before D alphabetically, DFS selects B to expand next as shown in <code>Figure 4</code>. Exploring B happens when <code>knight_tour</code> is called recursively. B is adjacent to C and D, so <code>knight_tour</code> elects to explore C next. However, as you can see in <code>Figure 5</code> node C is a dead end with no adjacent white nodes. At this point we change the color of node C back to white. The call to <code>knight_tour</code> returns a value of <code>False</code>. The return from the recursive call effectively backtracks the search to vertex B (see <code>Figure 6</code>). The next vertex on the list to explore is vertex D, so <code>knight_tour</code> makes a recursive call moving to node D (see <code>Figure 7</code>). From vertex D on, <code>knight_tour</code> can continue to make recursive calls until we get to node C again (see <code>Figure 8</code>, <code>Figure 9</code>, and  <code>Figure 10</code>).  However, this time when we get to node C the test <code>n &lt; limit</code> fails so we know that we have exhausted all the nodes in the graph. At this point we can return <code>True</code> to indicate that we have made a successful tour of the graph. When we return the list, <code>path</code> has the values <code>[A, B, D, E, F, C]</code>, which is the order we need to traverse the graph to visit each node exactly once.</p> <p><code>Figure 11</code> shows you what a complete tour around an \\(8 \\times 8\\) board looks like. There are many possible tours; some are symmetric. With some modification you can make circular tours that start and end at the same square.</p> <p> Figure 11: A Complete Tour of the Board Found by <code>knight_tour</code> </p> <p>The search algorithm we will use to solve the knight\u2019s tour problem is called depth-first search (DFS).  Whereas the breadth-first search algorithm builds a search tree one level at a time, a depth-first search creates a search tree by exploring one branch of the tree as deeply as possible. In this section we will look at two algorithms that implement a depth-first search. The first algorithm we will look at specifically solves the knight\u2019s tour problem by explicitly forbidding a node to be visited more than once. The second implementation is more general, but allows nodes to be visited more than once as the tree is constructed. The second version is used in subsequent sections to develop additional graph algorithms.</p> <p>The depth-first exploration of the graph is exactly what we need in order to find a path through 64 vertices (one for each square on the chessboard) and 63 edges. We will see that when the depth-first search algorithm finds a dead end (a place in the graph where there are no more moves possible) it backs up the tree to the next deepest vertex that allows it to make a legal move.</p> <p>The <code>knight_tour</code> function shown in <code>Listing 3</code> takes four parameters: <code>n</code>, the current depth in the search tree; <code>path</code>, a list of vertices visited up to this point; <code>u</code>, the vertex in the graph we wish to explore; and <code>limit</code>, the number of nodes in the path. The <code>knight_tour</code> function is recursive. When the <code>knight_tour</code> function is called, it first checks the base case condition. If we have a path that contains 64 vertices, we return from <code>knight_tour</code> with a status of <code>True</code>, indicating that we have found a successful tour. If the path is not long enough, we continue to explore one level deeper by choosing a new vertex to explore and calling <code>knight_tour</code> recursively for that vertex.</p> Listing 3<pre><code>from pythonds3.graphs import Graph\n\n\ndef knight_tour(n, path, u, limit):\n    u.color = \"gray\"\n    path.append(u)\n    if n &lt; limit:\n        neighbors = sorted(list(u.get_neighbors()))\n        i = 0\n        done = False\n        while i &lt; len(neighbors) and not done:\n            if neighbors[i].color == \"white\":\n                done = knight_tour(n + 1, path, neighbors[i], limit)\n            i = i + 1\n        if not done:  # prepare to backtrack\n            path.pop()\n            u.color = \"white\"\n    else:\n        done = True\n    return done\n</code></pre> <p>DFS also uses colors to keep track of which vertices in the graph have been visited. Unvisited vertices are colored white, and visited vertices are colored gray. If all neighbors of a particular vertex have been explored and we have not yet reached our goal length of 64 vertices, we have reached a dead end and must backtrack. Backtracking happens when we return from <code>knight_tour</code> with a status of <code>False</code>. In the breadth-first search we used a queue to keep track of which vertex to visit next. Since depth-first search is recursive, we are implicitly using a stack to help us with our backtracking. When we return from a call to <code>knight_tour</code> with a status of <code>False</code>, in line 11,  we remain inside the <code>while</code> loop and look at the next vertex in <code>neighbors</code>.</p> <p>Let's look at a simple example of <code>knight_tour</code> (<code>Listing 3</code>) in action. You can refer to the figures below to follow the steps of the search. For this example we will assume that the call to the <code>get_neighbors</code> method on line 6 orders the nodes in alphabetical order. We begin by calling <code>knight_tour(0, path, A, 6)</code>.</p> <p> Figure 3: Start with Node A </p> <p> Figure 4: Explore B </p> <p> Figure 5: Node C is a Dead End </p> <p> Figure 6: Backtrack to B </p> <p> Figure 7: Explore D </p> <p> Figure 8: Explore E </p> <p> Figure 9: Explore F </p> <p> Figure 10: Finish </p> <p><code>knight_tour</code> starts with node A in <code>Figure 3</code>. The nodes adjacent to A are B and D. Since B is before D alphabetically, DFS selects B to expand next as shown in <code>Figure 4</code>. Exploring B happens when <code>knight_tour</code> is called recursively. B is adjacent to C and D, so <code>knight_tour</code> elects to explore C next. However, as you can see in <code>Figure 5</code> node C is a dead end with no adjacent white nodes. At this point we change the color of node C back to white. The call to <code>knight_tour</code> returns a value of <code>False</code>. The return from the recursive call effectively backtracks the search to vertex B (see <code>Figure 6</code>). The next vertex on the list to explore is vertex D, so <code>knight_tour</code> makes a recursive call moving to node D (see <code>Figure 7</code>). From vertex D on, <code>knight_tour</code> can continue to make recursive calls until we get to node C again (see <code>Figure 8</code>, <code>Figure 9</code>, and  <code>Figure 10</code>).  However, this time when we get to node C the test <code>n &lt; limit</code> fails so we know that we have exhausted all the nodes in the graph. At this point we can return <code>True</code> to indicate that we have made a successful tour of the graph. When we return the list, <code>path</code> has the values <code>[A, B, D, E, F, C]</code>, which is the order we need to traverse the graph to visit each node exactly once.</p> <p><code>Figure 11</code> shows you what a complete tour around an \\(8 \\times 8\\) board looks like. There are many possible tours; some are symmetric. With some modification you can make circular tours that start and end at the same square.</p> <p> Figure 11: A Complete Tour of the Board Found by <code>knight_tour</code> </p>"},{"location":"c7/s14/","title":"7.14. \u9a91\u58eb\u5de1\u6e38\u5206\u6790","text":"<p>7.14. Knight\u2019s Tour Analysis</p> \u4e2d\u6587\u82f1\u6587 <p>There is one last interesting topic regarding the knight\u2019s tour problem, then we will move on to the general version of the depth-first search. The topic is performance. In particular, <code>knight_tour</code> is very sensitive to the method you use to select the next vertex to visit. For example, on a \\(5 \\times 5\\) board you can produce a path in about 1.5 seconds on a reasonably fast computer. But what happens if you try an \\(8 \\times 8\\) board? In this case, depending on the speed of your computer, you may have to wait up to a half hour to get the results! The reason for this is that the knight\u2019s tour problem as we have implemented it so far is an exponential algorithm of size \\(O(k^N)\\), where \\(N\\) is the number of squares on the chess board, and \\(k\\) is a small constant. <code>Figure 12</code> can help us visualize why this is so. The root of the tree represents the starting point of the search. From there the algorithm generates and checks each of the possible moves the knight can make. As we have noted before, the number of moves possible depends on the position of the knight on the board. In the corners there are only two legal moves, on the squares adjacent to the corners there are three, and in the middle of the board there are eight. <code>Figure 13</code> shows the number of moves possible for each position on a board. At the next level of the tree there are once again between two and eight possible next moves from the position we are currently exploring. The number of possible positions to examine corresponds to the number of nodes in the search tree.</p> <p> Figure 12: A Search Tree for the Knight\u2019s Tour  </p> <p> Figure 13: The Number of Possible Moves for Each Square </p> <p>We have already seen that the number of nodes in a binary tree of height \\(N\\) is \\(2^{N+1}-1\\). For a tree with nodes that may have up to eight children instead of two, the number of nodes is much larger. Because the branching factor of each node is variable, we could estimate the number of nodes using an average branching factor. The important thing to note is that this algorithm is exponential: \\(k^{N+1}-1\\), where \\(k\\) is the average branching factor for the board. Let\u2019s look at how rapidly this grows! For a board that is \\(5 \\times 5\\) the tree will be 25 levels deep, or \\(N = 24\\) counting the first level as level 0. The average branching factor is \\(k = 3.8\\) so the number of nodes in the search tree is \\(3.8^{25}-1\\) or \\(3.12 \\times 10^{14}\\). For a \\(6 \\times 6\\) board, \\(k = 4.4\\), there are \\(1.5 \\times 10^{23}\\) nodes, and for a regular \\(8 \\times 8\\) chess board, \\(k = 5.25\\), there are \\(1.3 \\times 10^{46}\\). Of course, since there are multiple solutions to the problem we won\u2019t have to explore every single node, but the fractional part of the nodes we do have to explore is just a constant multiplier which does not change the exponential nature of the problem. We will leave it as an exercise for you to see if you can express \\(k\\) as a function of the board size.</p> <p>Luckily there is a way to speed up the \\(8 \\times 8\\) case so that it runs in under one second. In the <code>Listing 4</code> we show the code that speeds up the <code>knight_tour</code>. This function, called <code>order_by_avail</code>, will be used in place of the call to <code>u.get_neighbors</code> at line 8 in <code>Listing 3</code>. The critical line in the <code>order_by_avail</code> function is line 10. This line ensures that we select the vertex that has the fewest available moves to go next. You might think this is really counterproductive; why not select the node that has the most available moves? You can try that approach easily by running the program yourself and inserting the line <code>res_list.reverse()</code> right after the sort.</p> <p>The problem with using the vertex with the most available moves as your next vertex on the path is that it tends to have the knight visit the middle squares early on in the tour. When this happens it is easy for the knight to get stranded on one side of the board where it cannot reach unvisited squares on the other side of the board. On the other hand, visiting the squares with the fewest available moves first pushes the knight to visit the squares around the edges of the board first. This ensures that the knight will visit the hard-to-reach corners early and can use the middle squares to hop across the board only when necessary.</p> <p>Utilizing this kind of knowledge to speed up an algorithm is called a heuristic. Humans use heuristics every day to help make decisions, and heuristic searches are often used in the field of artificial intelligence. This particular heuristic is called Warnsdorff\u2019s algorithm, named after H. C. von Warnsdorff who published his idea in 1823.</p> Listing 4<pre><code>def order_by_avail(n):\n    res_list = []\n    for v in n.get_neighbors():\n        if v.color == \"white\":\n            c = 0\n            for w in v.get_neighbors():\n                if w.color == \"white\":\n                    c = c + 1\n            res_list.append((c, v))\n    res_list.sort(key=lambda x: x[0])\n    return [y[1] for y in res_list]\n</code></pre> <p>There is one last interesting topic regarding the knight\u2019s tour problem, then we will move on to the general version of the depth-first search. The topic is performance. In particular, <code>knight_tour</code> is very sensitive to the method you use to select the next vertex to visit. For example, on a \\(5 \\times 5\\) board you can produce a path in about 1.5 seconds on a reasonably fast computer. But what happens if you try an \\(8 \\times 8\\) board? In this case, depending on the speed of your computer, you may have to wait up to a half hour to get the results! The reason for this is that the knight\u2019s tour problem as we have implemented it so far is an exponential algorithm of size \\(O(k^N)\\), where \\(N\\) is the number of squares on the chess board, and \\(k\\) is a small constant. <code>Figure 12</code> can help us visualize why this is so. The root of the tree represents the starting point of the search. From there the algorithm generates and checks each of the possible moves the knight can make. As we have noted before, the number of moves possible depends on the position of the knight on the board. In the corners there are only two legal moves, on the squares adjacent to the corners there are three, and in the middle of the board there are eight. <code>Figure 13</code> shows the number of moves possible for each position on a board. At the next level of the tree there are once again between two and eight possible next moves from the position we are currently exploring. The number of possible positions to examine corresponds to the number of nodes in the search tree.</p> <p> Figure 12: A Search Tree for the Knight\u2019s Tour  </p> <p> Figure 13: The Number of Possible Moves for Each Square </p> <p>We have already seen that the number of nodes in a binary tree of height \\(N\\) is \\(2^{N+1}-1\\). For a tree with nodes that may have up to eight children instead of two, the number of nodes is much larger. Because the branching factor of each node is variable, we could estimate the number of nodes using an average branching factor. The important thing to note is that this algorithm is exponential: \\(k^{N+1}-1\\), where \\(k\\) is the average branching factor for the board. Let\u2019s look at how rapidly this grows! For a board that is \\(5 \\times 5\\) the tree will be 25 levels deep, or \\(N = 24\\) counting the first level as level 0. The average branching factor is \\(k = 3.8\\) so the number of nodes in the search tree is \\(3.8^{25}-1\\) or \\(3.12 \\times 10^{14}\\). For a \\(6 \\times 6\\) board, \\(k = 4.4\\), there are \\(1.5 \\times 10^{23}\\) nodes, and for a regular \\(8 \\times 8\\) chess board, \\(k = 5.25\\), there are \\(1.3 \\times 10^{46}\\). Of course, since there are multiple solutions to the problem we won\u2019t have to explore every single node, but the fractional part of the nodes we do have to explore is just a constant multiplier which does not change the exponential nature of the problem. We will leave it as an exercise for you to see if you can express \\(k\\) as a function of the board size.</p> <p>Luckily there is a way to speed up the \\(8 \\times 8\\) case so that it runs in under one second. In the <code>Listing 4</code> we show the code that speeds up the <code>knight_tour</code>. This function, called <code>order_by_avail</code>, will be used in place of the call to <code>u.get_neighbors</code> at line 8 in <code>Listing 3</code>. The critical line in the <code>order_by_avail</code> function is line 10. This line ensures that we select the vertex that has the fewest available moves to go next. You might think this is really counterproductive; why not select the node that has the most available moves? You can try that approach easily by running the program yourself and inserting the line <code>res_list.reverse()</code> right after the sort.</p> <p>The problem with using the vertex with the most available moves as your next vertex on the path is that it tends to have the knight visit the middle squares early on in the tour. When this happens it is easy for the knight to get stranded on one side of the board where it cannot reach unvisited squares on the other side of the board. On the other hand, visiting the squares with the fewest available moves first pushes the knight to visit the squares around the edges of the board first. This ensures that the knight will visit the hard-to-reach corners early and can use the middle squares to hop across the board only when necessary.</p> <p>Utilizing this kind of knowledge to speed up an algorithm is called a heuristic. Humans use heuristics every day to help make decisions, and heuristic searches are often used in the field of artificial intelligence. This particular heuristic is called Warnsdorff\u2019s algorithm, named after H. C. von Warnsdorff who published his idea in 1823.</p> Listing 4<pre><code>def order_by_avail(n):\n    res_list = []\n    for v in n.get_neighbors():\n        if v.color == \"white\":\n            c = 0\n            for w in v.get_neighbors():\n                if w.color == \"white\":\n                    c = c + 1\n            res_list.append((c, v))\n    res_list.sort(key=lambda x: x[0])\n    return [y[1] for y in res_list]\n</code></pre>"},{"location":"c7/s15/","title":"7.15. \u4e00\u822c\u7684\u6df1\u5ea6\u4f18\u5148\u641c\u7d22","text":"<p>7.15. General Depth-First Search</p> \u4e2d\u6587\u82f1\u6587 <p>The knight\u2019s tour is a special case of a depth-first search where the goal is to create the deepest depth-first tree without any branches. The more general depth-first search is actually easier. Its goal is to search as deeply as possible, connecting as many nodes in the graph as possible and branching where necessary.</p> <p>It is even possible that a depth-first search will create more than one tree. When the depth-first search algorithm creates a group of trees we call this a depth-first forest. As with the breadth-first search, our depth-first search makes use of predecessor links to construct the tree. In addition, the depth-first search will make use of two additional instance variables in the <code>Vertex</code> class. The new instance variables are the discovery and closing times. The discovery time tracks the number of steps in the algorithm before a vertex is first encountered. The closing time is the number of steps in the algorithm before a vertex is colored black. As we will see after looking at the algorithm, the discovery and closing times of the nodes provide some interesting properties we can use in later algorithms.</p> <p>The code for our depth-first search is shown in <code>Listing 5 &lt;lst_dfsgeneral&gt;</code>. Since the two functions <code>dfs</code> and its helper <code>dfs_visit</code> use a variable to keep track of the time across calls to <code>dfs_visit</code>, we chose to implement the code as methods of a class that inherits from the <code>Graph</code> class. This implementation extends the graph class by adding a <code>time</code> instance variable and the two methods <code>dfs</code> and <code>dfs_visit</code>. Looking at line\u00a011 you will notice that the <code>dfs</code> method iterates over all of the vertices in the graph calling <code>dfs_visit</code> on the nodes that are white. The reason we iterate over all the nodes, rather than simply searching from a chosen starting node, is to make sure that all nodes in the graph are considered and that no vertices are left out of the depth-first forest. It may look unusual to see the statement <code>for vertex in self</code>, but remember that in this case <code>self</code> is an instance of the <code>DFSGraph</code> class, and iterating over all the vertices in an instance of a graph is a natural thing to do.</p> Listing 5<pre><code>from pythonds3.graphs import Graph\n\n\nclass DFSGraph(Graph):\n    def __init__(self):\n        super().__init__()\n        self.time = 0\n\n    def dfs(self):\n        for vertex in self:\n            vertex.color = \"white\"\n            vertex.previous = -1\n        for vertex in self:\n            if vertex.color == \"white\":\n                self.dfs_visit(vertex)\n\n    def dfs_visit(self, start_vertex):\n        start_vertex.color = \"gray\"\n        self.time = self.time + 1\n        start_vertex.discovery_time = self.time\n        for next_vertex in start_vertex.get_neighbors():\n            if next_vertex.color == \"white\":\n                next_vertex.previous = start_vertex\n                self.dfs_visit(next_vertex)\n        start_vertex.color = \"black\"\n        self.time = self.time + 1\n        start_vertex.closing_time = self.time\n</code></pre> <p>Although our implementation of <code>bfs</code> is only interested in considering nodes for which there is a path leading back to the start, it is possible to create a breadth-first forest that represents the shortest path between all pairs of nodes in the graph. We leave this as an exercise. In our next two algorithms we will see why keeping track of the depth-first forest is important.</p> <p>The <code>dfs_visit</code> method starts with a single vertex called <code>start_vertex</code> and explores all of the neighboring white vertices as deeply as possible. If you look carefully at the code for <code>dfs_visit</code> and compare it to breadth-first search, what you should notice is that the <code>dfs_visit</code> algorithm is almost identical to <code>bfs</code> except that on the last line of the inner <code>for</code> loop, <code>dfs_visit</code> calls itself recursively to continue the search at a deeper level, whereas <code>bfs</code> adds the node to a queue for later exploration. It is interesting to note that where <code>bfs</code> uses a queue, <code>dfs_visit</code> uses a stack. You don\u2019t see a stack in the code, but it is implicit in the recursive call to <code>dfs_visit</code>.</p> <p>The following sequence of figures illustrates the depth-first search algorithm in action for a small graph. In these figures, the dotted lines indicate edges that are checked, but the node at the other end of the edge has already been added to the depth-first tree. In the code this test is done by checking that the color of the other node is not white.</p> <p> Figure 14: Constructing the Depth-First Search Tree-10 </p> <p> Figure 15: Constructing the Depth-First Search Tree-11 </p> <p> Figure 16: Constructing the Depth-First Search Tree-12 </p> <p> Figure 17: Constructing the Depth-First Search Tree-13 </p> <p> Figure 18: Constructing the Depth-First Search Tree-14 </p> <p> Figure 19: Constructing the Depth-First Search Tree-15 </p> <p> Figure 20: Constructing the Depth-First Search Tree-16 </p> <p> Figure 21: Constructing the Depth-First Search Tree-17 </p> <p> Figure 22: Constructing the Depth-First Search Tree-18 </p> <p> Figure 23: Constructing the Depth-First Search Tree-19 </p> <p> Figure 24: Constructing the Depth-First Search Tree-20 </p> <p> Figure 25: Constructing the Depth-First Search Tree-21 </p> <p>The search begins at vertex A of the graph (<code>Figure 14</code>). Since all of the vertices are white at the beginning of the search the algorithm visits vertex A. The first step in visiting a vertex is to set the color to gray, which indicates that the vertex is being explored, and the discovery time is set to 1. Since vertex A has two adjacent vertices (B, D) each of those need to be visited as well. We\u2019ll make the arbitrary decision that we will visit the adjacent vertices in alphabetical order.</p> <p>Vertex B is visited next (<code>Figure 15</code>), so its color is set to gray and its discovery time is set to 2. Vertex B is also adjacent to two other nodes (C, D) so we will follow the alphabetical order and visit node C next.</p> <p>Visiting vertex C (<code>Figure 16</code>) brings us to the end of one branch of the tree. After coloring the node gray and setting its discovery time to 3, the algorithm also determines that there are no adjacent vertices to C. This means that we are done exploring node C and so we can color the vertex black and set the closing time to 4. You can see the state of our search at this point in <code>Figure 17</code>.</p> <p>Since vertex C is the end of one branch, we now return to vertex B and continue exploring the nodes adjacent to B. The only additional vertex to explore from B is D, so we can now visit D (<code>Figure 18</code>) and continue our search from vertex D. Vertex D quickly leads us to vertex E (<code>Figure 19</code>). Vertex E has two adjacent vertices, B and F. Normally we would explore these adjacent vertices alphabetically, but since B is already colored gray the algorithm recognizes that it should not visit B since doing so would put the algorithm in a loop! So exploration continues with the next vertex in the list, namely F (<code>Figure 20</code>).</p> <p>Vertex F has only one adjacent vertex, C, but since C is colored black there is nothing else to explore, and the algorithm has reached the end of another branch. From here on, you will see in <code>Figure 21</code> through <code>Figure 25</code> that the algorithm works its way back to the first node, setting closing times and coloring vertices black.</p> <p>The discovery and closing times for each node display a property called the parenthesis property. This property means that all the children of a particular node in the depth-first tree have a later discovery time and an earlier closing time than their parent. <code>Figure 26</code> shows the tree constructed by the depth-first search algorithm.</p> <p> Figure 26: The Resulting Depth-First Search Tree </p> <p>The knight\u2019s tour is a special case of a depth-first search where the goal is to create the deepest depth-first tree without any branches. The more general depth-first search is actually easier. Its goal is to search as deeply as possible, connecting as many nodes in the graph as possible and branching where necessary.</p> <p>It is even possible that a depth-first search will create more than one tree. When the depth-first search algorithm creates a group of trees we call this a depth-first forest. As with the breadth-first search, our depth-first search makes use of predecessor links to construct the tree. In addition, the depth-first search will make use of two additional instance variables in the <code>Vertex</code> class. The new instance variables are the discovery and closing times. The discovery time tracks the number of steps in the algorithm before a vertex is first encountered. The closing time is the number of steps in the algorithm before a vertex is colored black. As we will see after looking at the algorithm, the discovery and closing times of the nodes provide some interesting properties we can use in later algorithms.</p> <p>The code for our depth-first search is shown in <code>Listing 5 &lt;lst_dfsgeneral&gt;</code>. Since the two functions <code>dfs</code> and its helper <code>dfs_visit</code> use a variable to keep track of the time across calls to <code>dfs_visit</code>, we chose to implement the code as methods of a class that inherits from the <code>Graph</code> class. This implementation extends the graph class by adding a <code>time</code> instance variable and the two methods <code>dfs</code> and <code>dfs_visit</code>. Looking at line\u00a011 you will notice that the <code>dfs</code> method iterates over all of the vertices in the graph calling <code>dfs_visit</code> on the nodes that are white. The reason we iterate over all the nodes, rather than simply searching from a chosen starting node, is to make sure that all nodes in the graph are considered and that no vertices are left out of the depth-first forest. It may look unusual to see the statement <code>for vertex in self</code>, but remember that in this case <code>self</code> is an instance of the <code>DFSGraph</code> class, and iterating over all the vertices in an instance of a graph is a natural thing to do.</p> Listing 5<pre><code>from pythonds3.graphs import Graph\n\n\nclass DFSGraph(Graph):\n    def __init__(self):\n        super().__init__()\n        self.time = 0\n\n    def dfs(self):\n        for vertex in self:\n            vertex.color = \"white\"\n            vertex.previous = -1\n        for vertex in self:\n            if vertex.color == \"white\":\n                self.dfs_visit(vertex)\n\n    def dfs_visit(self, start_vertex):\n        start_vertex.color = \"gray\"\n        self.time = self.time + 1\n        start_vertex.discovery_time = self.time\n        for next_vertex in start_vertex.get_neighbors():\n            if next_vertex.color == \"white\":\n                next_vertex.previous = start_vertex\n                self.dfs_visit(next_vertex)\n        start_vertex.color = \"black\"\n        self.time = self.time + 1\n        start_vertex.closing_time = self.time\n</code></pre> <p>Although our implementation of <code>bfs</code> is only interested in considering nodes for which there is a path leading back to the start, it is possible to create a breadth-first forest that represents the shortest path between all pairs of nodes in the graph. We leave this as an exercise. In our next two algorithms we will see why keeping track of the depth-first forest is important.</p> <p>The <code>dfs_visit</code> method starts with a single vertex called <code>start_vertex</code> and explores all of the neighboring white vertices as deeply as possible. If you look carefully at the code for <code>dfs_visit</code> and compare it to breadth-first search, what you should notice is that the <code>dfs_visit</code> algorithm is almost identical to <code>bfs</code> except that on the last line of the inner <code>for</code> loop, <code>dfs_visit</code> calls itself recursively to continue the search at a deeper level, whereas <code>bfs</code> adds the node to a queue for later exploration. It is interesting to note that where <code>bfs</code> uses a queue, <code>dfs_visit</code> uses a stack. You don\u2019t see a stack in the code, but it is implicit in the recursive call to <code>dfs_visit</code>.</p> <p>The following sequence of figures illustrates the depth-first search algorithm in action for a small graph. In these figures, the dotted lines indicate edges that are checked, but the node at the other end of the edge has already been added to the depth-first tree. In the code this test is done by checking that the color of the other node is not white.</p> <p> Figure 14: Constructing the Depth-First Search Tree-10 </p> <p> Figure 15: Constructing the Depth-First Search Tree-11 </p> <p> Figure 16: Constructing the Depth-First Search Tree-12 </p> <p> Figure 17: Constructing the Depth-First Search Tree-13 </p> <p> Figure 18: Constructing the Depth-First Search Tree-14 </p> <p> Figure 19: Constructing the Depth-First Search Tree-15 </p> <p> Figure 20: Constructing the Depth-First Search Tree-16 </p> <p> Figure 21: Constructing the Depth-First Search Tree-17 </p> <p> Figure 22: Constructing the Depth-First Search Tree-18 </p> <p> Figure 23: Constructing the Depth-First Search Tree-19 </p> <p> Figure 24: Constructing the Depth-First Search Tree-20 </p> <p> Figure 25: Constructing the Depth-First Search Tree-21 </p> <p>The search begins at vertex A of the graph (<code>Figure 14</code>). Since all of the vertices are white at the beginning of the search the algorithm visits vertex A. The first step in visiting a vertex is to set the color to gray, which indicates that the vertex is being explored, and the discovery time is set to 1. Since vertex A has two adjacent vertices (B, D) each of those need to be visited as well. We\u2019ll make the arbitrary decision that we will visit the adjacent vertices in alphabetical order.</p> <p>Vertex B is visited next (<code>Figure 15</code>), so its color is set to gray and its discovery time is set to 2. Vertex B is also adjacent to two other nodes (C, D) so we will follow the alphabetical order and visit node C next.</p> <p>Visiting vertex C (<code>Figure 16</code>) brings us to the end of one branch of the tree. After coloring the node gray and setting its discovery time to 3, the algorithm also determines that there are no adjacent vertices to C. This means that we are done exploring node C and so we can color the vertex black and set the closing time to 4. You can see the state of our search at this point in <code>Figure 17</code>.</p> <p>Since vertex C is the end of one branch, we now return to vertex B and continue exploring the nodes adjacent to B. The only additional vertex to explore from B is D, so we can now visit D (<code>Figure 18</code>) and continue our search from vertex D. Vertex D quickly leads us to vertex E (<code>Figure 19</code>). Vertex E has two adjacent vertices, B and F. Normally we would explore these adjacent vertices alphabetically, but since B is already colored gray the algorithm recognizes that it should not visit B since doing so would put the algorithm in a loop! So exploration continues with the next vertex in the list, namely F (<code>Figure 20</code>).</p> <p>Vertex F has only one adjacent vertex, C, but since C is colored black there is nothing else to explore, and the algorithm has reached the end of another branch. From here on, you will see in <code>Figure 21</code> through <code>Figure 25</code> that the algorithm works its way back to the first node, setting closing times and coloring vertices black.</p> <p>The discovery and closing times for each node display a property called the parenthesis property. This property means that all the children of a particular node in the depth-first tree have a later discovery time and an earlier closing time than their parent. <code>Figure 26</code> shows the tree constructed by the depth-first search algorithm.</p> <p> Figure 26: The Resulting Depth-First Search Tree </p>"},{"location":"c7/s16/","title":"7.16. \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5206\u6790","text":"<p>7.16. Depth-First Search Analysis</p> \u4e2d\u6587\u82f1\u6587 <p>The general running time for depth-first search is as follows. The loops in <code>dfs</code> both run in \\(O(|V|)\\), not counting what happens in <code>dfs_visit</code>, since they are executed once for each vertex in the graph. In <code>dfs_visit</code> the loop is executed once for each edge in the adjacency list of the current vertex. Since <code>dfs_visit</code> is only called recursively if the vertex is white, the loop will execute a maximum of once for every edge in the graph, or \\(O(|E|)\\). Therefore, the total time for depth-first search is \\(O(|V| + |E|)\\).</p> <p>The general running time for depth-first search is as follows. The loops in <code>dfs</code> both run in \\(O(|V|)\\), not counting what happens in <code>dfs_visit</code>, since they are executed once for each vertex in the graph. In <code>dfs_visit</code> the loop is executed once for each edge in the adjacency list of the current vertex. Since <code>dfs_visit</code> is only called recursively if the vertex is white, the loop will execute a maximum of once for every edge in the graph, or \\(O(|E|)\\). Therefore, the total time for depth-first search is \\(O(|V| + |E|)\\).</p>"},{"location":"c7/s17/","title":"7.17. \u62d3\u6251\u6392\u5e8f","text":"<p>7.17. Topological Sorting</p> \u4e2d\u6587\u82f1\u6587 <p>To demonstrate that computer scientists can turn just about anything into a graph problem, let\u2019s consider the difficult problem of stirring up a batch of pancakes. The recipe is really quite simple: 1 egg, 1 cup of pancake mix, 1 tablespoon oil, and \\(3 \\over 4\\) cup of milk. To make pancakes you must heat the griddle, mix all the ingredients together, and spoon the mix onto a hot griddle. When the pancakes start to bubble you turn them over and let them cook until they are golden brown on the bottom. Before you eat your pancakes you are going to want to heat up some syrup. <code>Figure 27</code> illustrates this process as a dependency graph.</p> <p> Figure 27: The Steps for Making Pancakes   </p> <p>The difficult thing about making pancakes is knowing what to do first. As you can see from <code>Figure 27</code> you might start by heating the griddle or by adding any of the ingredients to the pancake mix. To help us decide the precise order in which we should do each of the steps required to make our pancakes, we turn to a graph algorithm called the topological sort.</p> <p>A topological sort takes a directed acyclic graph and produces a linear ordering of all its vertices such that if the graph \\(G\\) contains an edge \\((v, w)\\) then the vertex \\(v\\) comes before the vertex \\(w\\) in the ordering. Directed acyclic graphs are used in many applications to indicate the precedence of events. Making pancakes is just one example; other examples include software project schedules, precedence charts for optimizing database queries, and multiplying matrices.</p> <p>The topological sort is a simple but useful adaptation of a depth-first search. The algorithm for the topological sort is as follows:</p> <ol> <li>Call <code>dfs(g)</code> for some graph <code>g</code>. The main reason we want to call depth-first search is to compute the closing times for each of the vertices.</li> <li>Store the vertices in a list in decreasing order of the closing time.</li> <li>Return the ordered list as the result of the topological sort.</li> </ol> <p><code>Figure 28</code> shows the depth-first forest constructed by <code>dfs</code> on the pancake-making graph shown in <code>Figure 26</code>.</p> <p> Figure 28: Result of Depth-First Search on the Pancake Graph </p> <p>Finally, <code>Figure 29</code> shows the results of applying the topological sort algorithm to our graph. Now all the ambiguity has been removed and we know exactly the order in which to perform the pancake-making steps.</p> <p> Figure 29: Result of Topological Sort on Directed Acyclic Graph </p> <p>To demonstrate that computer scientists can turn just about anything into a graph problem, let\u2019s consider the difficult problem of stirring up a batch of pancakes. The recipe is really quite simple: 1 egg, 1 cup of pancake mix, 1 tablespoon oil, and \\(3 \\over 4\\) cup of milk. To make pancakes you must heat the griddle, mix all the ingredients together, and spoon the mix onto a hot griddle. When the pancakes start to bubble you turn them over and let them cook until they are golden brown on the bottom. Before you eat your pancakes you are going to want to heat up some syrup. <code>Figure 27</code> illustrates this process as a dependency graph.</p> <p> Figure 27: The Steps for Making Pancakes   </p> <p>The difficult thing about making pancakes is knowing what to do first. As you can see from <code>Figure 27</code> you might start by heating the griddle or by adding any of the ingredients to the pancake mix. To help us decide the precise order in which we should do each of the steps required to make our pancakes, we turn to a graph algorithm called the topological sort.</p> <p>A topological sort takes a directed acyclic graph and produces a linear ordering of all its vertices such that if the graph \\(G\\) contains an edge \\((v, w)\\) then the vertex \\(v\\) comes before the vertex \\(w\\) in the ordering. Directed acyclic graphs are used in many applications to indicate the precedence of events. Making pancakes is just one example; other examples include software project schedules, precedence charts for optimizing database queries, and multiplying matrices.</p> <p>The topological sort is a simple but useful adaptation of a depth-first search. The algorithm for the topological sort is as follows:</p> <ol> <li>Call <code>dfs(g)</code> for some graph <code>g</code>. The main reason we want to call depth-first search is to compute the closing times for each of the vertices.</li> <li>Store the vertices in a list in decreasing order of the closing time.</li> <li>Return the ordered list as the result of the topological sort.</li> </ol> <p><code>Figure 28</code> shows the depth-first forest constructed by <code>dfs</code> on the pancake-making graph shown in <code>Figure 26</code>.</p> <p> Figure 28: Result of Depth-First Search on the Pancake Graph </p> <p>Finally, <code>Figure 29</code> shows the results of applying the topological sort algorithm to our graph. Now all the ambiguity has been removed and we know exactly the order in which to perform the pancake-making steps.</p> <p> Figure 29: Result of Topological Sort on Directed Acyclic Graph </p>"},{"location":"c7/s18/","title":"7.18. \u5f3a\u8fde\u901a\u5206\u91cf","text":"<p>7.18. Strongly Connected Components</p> \u4e2d\u6587\u82f1\u6587 <p>For the remainder of this chapter we will turn our attention to some extremely large graphs. The graphs we will use to study some additional algorithms are the graphs produced by the connections between hosts on the internet and the links between web pages. We will begin with web pages.</p> <p>Search engines like Google and Bing exploit the fact that the pages on the web form a very large directed graph. To transform the World Wide Web into a graph, we will treat a page as a vertex, and the hyperlinks on the page as edges connecting one vertex to another. <code>Figure 30</code> shows a very small part of the graph produced by following the links from one page to the next, beginning at Luther College\u2019s Computer Science home page. Of course, this graph could be huge, so we have limited it to websites that are no more than 10 links away from the CS home page.</p> <p> Figure 30: The Graph Produced by Links from the Luther Computer Science Home Page </p> <p>If you study the graph in <code>Figure 30</code> you might make some interesting observations. First you might notice that many of the other websites on the graph are other Luther College websites. Second, you might notice that there are several links to other colleges in Iowa. Third, you might notice that there are several links to other liberal arts colleges. You might conclude from this that there is some underlying structure to the Web that clusters together websites that are similar on some level.</p> <p>One graph algorithm that can help find clusters of highly interconnected vertices in a graph is called the strongly connected components algorithm, or SCC. We formally define a strongly connected component, \\(C\\), of a graph \\(G\\), as the largest subset of vertices $C \\subset V<code>such that for every pair of vertices $v, w \\in C$ we have a path from $v$ to $w$ and a path from $w$ to $v$.</code>Figure 27` shows a simple graph with three strongly connected components that are identified by the different shaded areas.</p> <p> Figure 31: A Directed Graph with Three Strongly Connected Components </p> <p>Once the strongly connected components have been identified, we can show a simplified view of the graph by combining all the vertices in one strongly connected component into a single larger vertex. The simplified version of the graph in <code>Figure 31</code> is shown in <code>Figure\u00a032</code>.</p> <p> Figure 32: The Reduced Graph </p> <p>Once again we will see that we can create a very powerful and efficient algorithm by making use of a depth-first search. Before we tackle the main SCC algorithm we must look at one other definition. The transposition of a graph \\(G\\) is defined as the graph \\(G^T\\) where all the edges in the graph have been reversed. That is, if there is a directed edge from node A to node B in the original graph, then \\(G^T\\) will contain an edge from node B to node A. <code>Figure 33</code> and <code>Figure 34</code> show a simple graph and its transposition.</p> <p> Figure 33: A Graph \\(G\\) </p> <p> Figure 34: The Transposition of \\(G\\), \\(G^T\\) </p> <p>Look at the figures again. Notice that the graph in <code>Figure 33</code> has two strongly connected components. Now look at  <code>Figure 34</code>. Notice that it has the same two strongly connected components.</p> <p>We can now describe the algorithm to compute the strongly connected components for a graph.</p> <ol> <li>Call <code>dfs</code> for the graph \\(G\\) to compute the closing times for each vertex.</li> <li>Compute \\(G^T\\).</li> <li>Call <code>dfs</code> for the graph \\(G^T\\) but in the main loop of DFS explore each vertex in decreasing order of closing time.</li> <li>Each tree in the forest computed in step 3 is a strongly connected component. Output the vertex IDs for each vertex in each tree in the forest to identify the component.</li> </ol> <p>Let's trace the operation of the steps described above on the example graph in <code>Figure 31</code>. <code>Figure\u00a035</code> shows the starting and closing times computed for the original graph by the DFS algorithm. <code>Figure 36</code> shows the starting and closing times computed by running DFS on the transposed graph.</p> <p> Figure 35: Finishing Times for the Original Graph \\(G\\) </p> <p> Figure 36: Finishing Times for \\(G^T\\) </p> <p>Finally, <code>Figure 37</code> shows the forest of three trees produced in step 3 of the strongly connected components algorithm. You will notice that we do not provide you with the Python code for the SCC algorithm; we leave writing this program as an exercise.</p> <p> Figure 37: Strongly Connected Components </p> <p>For the remainder of this chapter we will turn our attention to some extremely large graphs. The graphs we will use to study some additional algorithms are the graphs produced by the connections between hosts on the internet and the links between web pages. We will begin with web pages.</p> <p>Search engines like Google and Bing exploit the fact that the pages on the web form a very large directed graph. To transform the World Wide Web into a graph, we will treat a page as a vertex, and the hyperlinks on the page as edges connecting one vertex to another. <code>Figure 30</code> shows a very small part of the graph produced by following the links from one page to the next, beginning at Luther College\u2019s Computer Science home page. Of course, this graph could be huge, so we have limited it to websites that are no more than 10 links away from the CS home page.</p> <p> Figure 30: The Graph Produced by Links from the Luther Computer Science Home Page </p> <p>If you study the graph in <code>Figure 30</code> you might make some interesting observations. First you might notice that many of the other websites on the graph are other Luther College websites. Second, you might notice that there are several links to other colleges in Iowa. Third, you might notice that there are several links to other liberal arts colleges. You might conclude from this that there is some underlying structure to the Web that clusters together websites that are similar on some level.</p> <p>One graph algorithm that can help find clusters of highly interconnected vertices in a graph is called the strongly connected components algorithm, or SCC. We formally define a strongly connected component, \\(C\\), of a graph \\(G\\), as the largest subset of vertices $C \\subset V<code>such that for every pair of vertices $v, w \\in C$ we have a path from $v$ to $w$ and a path from $w$ to $v$.</code>Figure 27` shows a simple graph with three strongly connected components that are identified by the different shaded areas.</p> <p> Figure 31: A Directed Graph with Three Strongly Connected Components </p> <p>Once the strongly connected components have been identified, we can show a simplified view of the graph by combining all the vertices in one strongly connected component into a single larger vertex. The simplified version of the graph in <code>Figure 31</code> is shown in <code>Figure\u00a032</code>.</p> <p> Figure 32: The Reduced Graph </p> <p>Once again we will see that we can create a very powerful and efficient algorithm by making use of a depth-first search. Before we tackle the main SCC algorithm we must look at one other definition. The transposition of a graph \\(G\\) is defined as the graph \\(G^T\\) where all the edges in the graph have been reversed. That is, if there is a directed edge from node A to node B in the original graph, then \\(G^T\\) will contain an edge from node B to node A. <code>Figure 33</code> and <code>Figure 34</code> show a simple graph and its transposition.</p> <p> Figure 33: A Graph \\(G\\) </p> <p> Figure 34: The Transposition of \\(G\\), \\(G^T\\) </p> <p>Look at the figures again. Notice that the graph in <code>Figure 33</code> has two strongly connected components. Now look at  <code>Figure 34</code>. Notice that it has the same two strongly connected components.</p> <p>We can now describe the algorithm to compute the strongly connected components for a graph.</p> <ol> <li>Call <code>dfs</code> for the graph \\(G\\) to compute the closing times for each vertex.</li> <li>Compute \\(G^T\\).</li> <li>Call <code>dfs</code> for the graph \\(G^T\\) but in the main loop of DFS explore each vertex in decreasing order of closing time.</li> <li>Each tree in the forest computed in step 3 is a strongly connected component. Output the vertex IDs for each vertex in each tree in the forest to identify the component.</li> </ol> <p>Let's trace the operation of the steps described above on the example graph in <code>Figure 31</code>. <code>Figure\u00a035</code> shows the starting and closing times computed for the original graph by the DFS algorithm. <code>Figure 36</code> shows the starting and closing times computed by running DFS on the transposed graph.</p> <p> Figure 35: Finishing Times for the Original Graph \\(G\\) </p> <p> Figure 36: Finishing Times for \\(G^T\\) </p> <p>Finally, <code>Figure 37</code> shows the forest of three trees produced in step 3 of the strongly connected components algorithm. You will notice that we do not provide you with the Python code for the SCC algorithm; we leave writing this program as an exercise.</p> <p> Figure 37: Strongly Connected Components </p>"},{"location":"c7/s19/","title":"7.19. \u6700\u77ed\u8def\u5f84\u95ee\u9898","text":"<p>7.19. Shortest Path Problems</p> \u4e2d\u6587\u82f1\u6587 <p>When you surf the web, send an email, or log in to a laboratory computer from another location on campus, a lot of work is going on behind the scenes to get the information on your computer transferred to another computer. The in-depth study of how information flows from one computer to another over the internet is the primary topic for a class in computer networking. However, we will talk about how the internet works just enough to understand another very important graph algorithm.</p> <p> Figure 1: Overview of Connectivity in the Internet </p> <p><code>Figure 1</code> shows you a high-level overview of how communication on the internet works. When you use your browser to request a web page from a server, the request must travel over your local area network and out onto the internet through a router. The request travels over the internet and eventually arrives at a router for the local area network where the server is located. The web page you requested then travels back through the same routers to get to your browser. Inside the cloud labeled \u201cInternet\u201d in <code>Figure 1</code> are additional routers. The job of all of these routers is to work together to get your information from place to place. You can see there are many routers for yourself if your computer supports the <code>traceroute</code> command. The text below shows the output of the <code>traceroute</code> command, which illustrates that there are 13 routers between the web server at Luther College and the mail server at the University of Minnesota.</p> <p>Each router on the internet is connected to one or more other routers. If you run the <code>traceroute</code> command at different times of the day, you are likely to see that your information flows through different routers at different times. This is because there is a cost associated with each connection between a pair of routers that depends on the volume of traffic, the time of day, and many other factors. By this time it will not surprise you to learn that we can represent the network of routers as a graph with weighted edges.</p> <pre><code>1  192.203.196.1  \n2  hilda.luther.edu (216.159.75.1)  \n3  ICN-Luther-Ether.icn.state.ia.us (207.165.237.137)\n4  ICN-ISP-1.icn.state.ia.us (209.56.255.1)  \n5  p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13)\n6  ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97)\n7  so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214)\n8  ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18) \n9  p1-0.minnesota.bbnplanet.net (4.24.226.74)\n10  TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37)\n11  TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1)\n12  TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158)\n13  baldrick.cs.umn.edu (128.101.80.129)(N!)  88.631 ms (N!)\n\n\nRouters from One Host to the Next over the Internet      \n</code></pre> <p><code>Figure 2</code> shows a small example of a weighted graph that represents the interconnection of routers in the internet. The problem that we want to solve is to find the shortest path, one with the smallest total weight along which to route any given message. This problem should sound familiar because it is similar to the problem we solved using a breadth-first search, except that here we are concerned with the total weight of the path rather than the number of hops in the path. It should be noted that if all the weights are equal, the problem is the same.</p> <p> Figure 2: Connections and Weights between Routers in the Internet </p> <p>When you surf the web, send an email, or log in to a laboratory computer from another location on campus, a lot of work is going on behind the scenes to get the information on your computer transferred to another computer. The in-depth study of how information flows from one computer to another over the internet is the primary topic for a class in computer networking. However, we will talk about how the internet works just enough to understand another very important graph algorithm.</p> <p> Figure 1: Overview of Connectivity in the Internet </p> <p><code>Figure 1</code> shows you a high-level overview of how communication on the internet works. When you use your browser to request a web page from a server, the request must travel over your local area network and out onto the internet through a router. The request travels over the internet and eventually arrives at a router for the local area network where the server is located. The web page you requested then travels back through the same routers to get to your browser. Inside the cloud labeled \u201cInternet\u201d in <code>Figure 1</code> are additional routers. The job of all of these routers is to work together to get your information from place to place. You can see there are many routers for yourself if your computer supports the <code>traceroute</code> command. The text below shows the output of the <code>traceroute</code> command, which illustrates that there are 13 routers between the web server at Luther College and the mail server at the University of Minnesota.</p> <p>Each router on the internet is connected to one or more other routers. If you run the <code>traceroute</code> command at different times of the day, you are likely to see that your information flows through different routers at different times. This is because there is a cost associated with each connection between a pair of routers that depends on the volume of traffic, the time of day, and many other factors. By this time it will not surprise you to learn that we can represent the network of routers as a graph with weighted edges.</p> <pre><code>1  192.203.196.1  \n2  hilda.luther.edu (216.159.75.1)  \n3  ICN-Luther-Ether.icn.state.ia.us (207.165.237.137)\n4  ICN-ISP-1.icn.state.ia.us (209.56.255.1)  \n5  p3-0.hsa1.chi1.bbnplanet.net (4.24.202.13)\n6  ae-1-54.bbr2.Chicago1.Level3.net (4.68.101.97)\n7  so-3-0-0.mpls2.Minneapolis1.Level3.net (64.159.4.214)\n8  ge-3-0.hsa2.Minneapolis1.Level3.net (4.68.112.18) \n9  p1-0.minnesota.bbnplanet.net (4.24.226.74)\n10  TelecomB-BR-01-V4002.ggnet.umn.edu (192.42.152.37)\n11  TelecomB-BN-01-Vlan-3000.ggnet.umn.edu (128.101.58.1)\n12  TelecomB-CN-01-Vlan-710.ggnet.umn.edu (128.101.80.158)\n13  baldrick.cs.umn.edu (128.101.80.129)(N!)  88.631 ms (N!)\n\n\nRouters from One Host to the Next over the Internet      \n</code></pre> <p><code>Figure 2</code> shows a small example of a weighted graph that represents the interconnection of routers in the internet. The problem that we want to solve is to find the shortest path, one with the smallest total weight along which to route any given message. This problem should sound familiar because it is similar to the problem we solved using a breadth-first search, except that here we are concerned with the total weight of the path rather than the number of hops in the path. It should be noted that if all the weights are equal, the problem is the same.</p> <p> Figure 2: Connections and Weights between Routers in the Internet </p>"},{"location":"c7/s2/","title":"7.2. \u8bcd\u6c47\u548c\u5b9a\u4e49","text":"<p>7.2. Vocabulary and Definitions</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have looked at an graph, we will more formally define a graph and its components. We already know some of these terms from our discussion of trees.</p> Vertex A vertex (also called a node) is a fundamental part of a graph. It can have a name, which we will call the key. A vertex may also have additional information. We will call this additional information the value or the payload. Edge An edge (also called an arc) is another fundamental part of a graph. An edge connects two vertices to show that there is a relationship between them. Edges may be one-way or two-way. If the edges in a graph are all one-way, we say that the graph is a directed graph, or a digraph. The class prerequisites graph shown above is clearly a digraph since you must take some classes before others. Weight Edges may be weighted to show that there is a cost to go from one vertex to another, which we call edge cost. For example, in a graph of roads that connect one city to another, the weight on the edge might represent the distance between the two cities. <p>With those definitions in hand, we can formally define a graph. A graph can be represented by \\(G\\) where \\(G =(V,E)\\). For the graph \\(G\\), \\(V\\) is a set of vertices and \\(E\\) is a set of edges. Each edge is a tuple \\((v, w)\\) where \\(v, w \\in V\\). We can add a third component to the edge tuple to represent a weight. A subgraph $s` is a set of edges \\(e\\) and vertices \\(v\\) such that \\(e \\subset E\\) and \\(v \\subset V\\).</p> <p><code>Figure\u00a0 2</code> shows another example of a simple weighted digraph. Formally we can represent this graph as the set of six vertices:</p> <p>\\(V = \\left\\{ v_0, v_1, v_2, v_3, v_4, v_5 \\right\\}\\)</p> <p>and the set of nine edges:</p> <p>\\(\\begin{align} E = \\left\\{ \\begin{array}{l}(v_0, v_1, 5), (v_1, v_2, 4), (v_2, v_3, 9), \\\\ (v_3, v_4, 7), (v_4, v_0, 1), (v_0, v_5, 2), \\\\ (v_5, v_4, 8), (v_3, v_5, 3), (v_5, v_2, 1) \\end{array} \\right\\} \\end{align}\\)</p> <p> Figure 2: A Simple Example of a Directed Graph </p> <p>The example graph in <code>Figure 2</code> helps illustrate two other key graph terms:</p> Path A path in a graph is a sequence of vertices that are connected by edges. Formally we would define a path as \\(w_1, w_2, ..., w_n\\) such that \\((w_i, w_{i+1}) \\in E\\) for all \\(1 \\le i \\le n-1\\). The unweighted path length is the number of edges in the path, specifically \\(n-1\\). The weighted path length is the sum of the weights of all the edges in the path. For example in <code>Figure 2</code> the path from \\(v_3\\) to \\(v_1\\) is the sequence of vertices \\((v_3, v_4, v_0, v_1)\\). The edges are \\(\\left\\{(v_3, v_4, 7), (v_4, v_0, 1), (v_0, v_1, 5) \\right\\}\\). Cycle A cycle in a directed graph is a path that starts and ends at the same vertex. For example, in <code>Figure 2</code> the path \\((v_5, v_2, v_3, v_5)\\) is a cycle. A graph with no cycles is called an acyclic graph. A directed graph with no cycles is called a directed acyclic graph or a DAG. We will see that we can solve several important problems if the problem can be represented as a DAG. <p>Now that we have looked at an graph, we will more formally define a graph and its components. We already know some of these terms from our discussion of trees.</p> Vertex A vertex (also called a node) is a fundamental part of a graph. It can have a name, which we will call the key. A vertex may also have additional information. We will call this additional information the value or the payload. Edge An edge (also called an arc) is another fundamental part of a graph. An edge connects two vertices to show that there is a relationship between them. Edges may be one-way or two-way. If the edges in a graph are all one-way, we say that the graph is a directed graph, or a digraph. The class prerequisites graph shown above is clearly a digraph since you must take some classes before others. Weight Edges may be weighted to show that there is a cost to go from one vertex to another, which we call edge cost. For example, in a graph of roads that connect one city to another, the weight on the edge might represent the distance between the two cities. <p>With those definitions in hand, we can formally define a graph. A graph can be represented by \\(G\\) where \\(G =(V,E)\\). For the graph \\(G\\), \\(V\\) is a set of vertices and \\(E\\) is a set of edges. Each edge is a tuple \\((v, w)\\) where \\(v, w \\in V\\). We can add a third component to the edge tuple to represent a weight. A subgraph $s` is a set of edges \\(e\\) and vertices \\(v\\) such that \\(e \\subset E\\) and \\(v \\subset V\\).</p> <p><code>Figure\u00a0 2</code> shows another example of a simple weighted digraph. Formally we can represent this graph as the set of six vertices:</p> <p>\\(V = \\left\\{ v_0, v_1, v_2, v_3, v_4, v_5 \\right\\}\\)</p> <p>and the set of nine edges:</p> <p>\\(\\begin{align} E = \\left\\{ \\begin{array}{l}(v_0, v_1, 5), (v_1, v_2, 4), (v_2, v_3, 9), \\\\ (v_3, v_4, 7), (v_4, v_0, 1), (v_0, v_5, 2), \\\\ (v_5, v_4, 8), (v_3, v_5, 3), (v_5, v_2, 1) \\end{array} \\right\\} \\end{align}\\)</p> <p> Figure 2: A Simple Example of a Directed Graph </p> <p>The example graph in <code>Figure 2</code> helps illustrate two other key graph terms:</p> Path A path in a graph is a sequence of vertices that are connected by edges. Formally we would define a path as \\(w_1, w_2, ..., w_n\\) such that \\((w_i, w_{i+1}) \\in E\\) for all \\(1 \\le i \\le n-1\\). The unweighted path length is the number of edges in the path, specifically \\(n-1\\). The weighted path length is the sum of the weights of all the edges in the path. For example in <code>Figure 2</code> the path from \\(v_3\\) to \\(v_1\\) is the sequence of vertices \\((v_3, v_4, v_0, v_1)\\). The edges are \\(\\left\\{(v_3, v_4, 7), (v_4, v_0, 1), (v_0, v_1, 5) \\right\\}\\). Cycle A cycle in a directed graph is a path that starts and ends at the same vertex. For example, in <code>Figure 2</code> the path \\((v_5, v_2, v_3, v_5)\\) is a cycle. A graph with no cycles is called an acyclic graph. A directed graph with no cycles is called a directed acyclic graph or a DAG. We will see that we can solve several important problems if the problem can be represented as a DAG."},{"location":"c7/s20/","title":"7.20. Dijkstra\u7b97\u6cd5","text":"<p>7.20. Dijkstra\u2019s Algorithm</p> \u4e2d\u6587\u82f1\u6587 <p>The algorithm we are going to use to determine the shortest path is called Dijkstra\u2019s algorithm. Dijkstra\u2019s algorithm is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph. Again this is similar to the results of a breadth-first search.</p> <p>To keep track of the total cost from the start node to each destination, we will make use of the <code>distance</code> instance variable in the <code>Vertex</code> class. The <code>distance</code> instance variable will contain the current total weight of the smallest weight path from the start to the vertex in question. The algorithm iterates once for every vertex in the graph; however, the order that it iterates over the vertices is controlled by a priority queue. The value that is used to determine the order of the objects in the priority queue is <code>distance</code>. When a vertex is first created, <code>distance</code> is set to a very large number. Theoretically you would set <code>distance</code> to infinity, but in practice we just set it to a number that is larger than any real distance we would have in the problem we are trying to solve.</p> <p>The code for Dijkstra\u2019s algorithm is shown in <code>Listing 1</code>. When the algorithm finishes, the distances are set correctly as are the predecessor links for each vertex in the graph.</p> Listing 1<pre><code>from pythonds3.graphs import PriorityQueue\n\ndef dijkstra(graph, start):\n    pq = PriorityQueue()\n    start.distance = 0\n    pq.heapify([(v.distance, v) for v in graph])\n    while pq:\n        distance, current_v = pq.delete()\n        for next_v in current_v.get_neighbors():\n            new_distance = current_v.distance + current_v.get_neighbor(next_v)\n            if new_distance &lt; next_v.distance:\n                next_v.distance = new_distance\n                next_v.previous = current_v\n                pq.change_priority(next_v, new_distance)\n</code></pre> <p>Dijkstra\u2019s algorithm uses a priority queue. You may recall that a priority queue is based on the heap that we implemented in Chapter 6.  There are a couple of differences between that simple implementation and the implementation we use for Dijkstra\u2019s algorithm, however. First, the <code>PriorityQueue</code> class stores tuples of (priority, key) pairs. This is an important point, because Dijkstra's algorithm requires the key in the priority queue to match the key of the vertex in the graph. The priority is used for deciding the position of the key in the priority queue. In this implementation we use the distance to the vertex as the priority because as we will see when we are exploring the next vertex, we always want to explore the vertex that has the smallest distance. The second difference is the addition of the <code>change_priority</code> method. As you can see in line 17, this method is used when the distance to a vertex that is already in the queue is reduced, and thus the vertex is moved toward the front of the queue.</p> <p>Let\u2019s walk through an application of Dijkstra\u2019s algorithm one vertex at a time using the following sequence of figures as our guide. We begin with the vertex \\(u\\). The three vertices adjacent to \\(u\\) are \\(v, w,\\) and \\(x\\). Since the initial distances to \\(v, w,\\) and \\(x\\) are all initialized to <code>sys.maxsize</code>, the new costs to get to them through the start node are all their direct costs. So we update the costs to each of these three nodes. We also set the predecessor for each node to \\(u\\) and we add each node to the priority queue. We use the distance as the key for the priority queue. The state of the algorithm is shown in <code>Figure 3</code>.</p> <p>In the next iteration of the <code>while</code> loop we examine the vertices that are adjacent to \\(x\\). The vertex \\(x\\) is next because it has the lowest overall cost and therefore bubbled its way to the beginning of the priority queue. At \\(x\\) we look at its neighbors \\(u, v, w,\\) and \\(y\\). For each neighboring vertex we check to see if the distance to that vertex through \\(x\\) is smaller than the previously known distance. Obviously this is the case for \\(y\\) since its distance was <code>sys.maxsize</code>. It is not the case for \\(u\\) or \\(v\\) since their distances are 0 and 2 respectively. However, we now learn that the distance to \\(w\\) is smaller if we go through \\(x\\) than from \\(u\\) directly to \\(w\\). Since that is the case we update \\(w\\) with a new distance and change the predecessor for \\(w\\) from \\(u\\) to \\(x\\). See <code>Figure 4</code> for the state of all the vertices.</p> <p>The next step is to look at the vertices neighboring \\(v\\) (see <code>Figure 5</code>). This step results in no changes to the graph, so we move on to node \\(y\\). At node \\(y\\) (see <code>Figure 6</code>) we discover that it is cheaper to get to both \\(w\\) and \\(z\\), so we adjust the distances and predecessor links accordingly. Finally we check nodes \\(w\\) and \\(z\\) (see <code>Figure 6</code> and <code>Figure 8</code>). However, no additional changes are found and so the priority queue is empty and Dijkstra\u2019s algorithm exits.</p> <p> Figure 3: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 4: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 5: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 6: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 7: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 8: Tracing Dijkstra\u2019s Algorithm </p> <p>It is important to note that Dijkstra\u2019s algorithm works only when the weights are all positive. You should convince yourself that if you introduced a negative weight on one of the edges of the graph in <code>Figure 2</code>, the algorithm would never exit.</p> <p>We will note that to route messages through the internet, other algorithms are used for finding the shortest path. One of the problems with using Dijkstra\u2019s algorithm on the internet is that you must have a complete representation of the graph in order for the algorithm to run. The implication of this is that every router has a complete map of all the routers in the internet. In practice this is not the case and other variations of the algorithm allow each router to discover the graph as they go. One such algorithm that you may want to read about is called the distance vector routing algorithm.</p> <p>The algorithm we are going to use to determine the shortest path is called Dijkstra\u2019s algorithm. Dijkstra\u2019s algorithm is an iterative algorithm that provides us with the shortest path from one particular starting node to all other nodes in the graph. Again this is similar to the results of a breadth-first search.</p> <p>To keep track of the total cost from the start node to each destination, we will make use of the <code>distance</code> instance variable in the <code>Vertex</code> class. The <code>distance</code> instance variable will contain the current total weight of the smallest weight path from the start to the vertex in question. The algorithm iterates once for every vertex in the graph; however, the order that it iterates over the vertices is controlled by a priority queue. The value that is used to determine the order of the objects in the priority queue is <code>distance</code>. When a vertex is first created, <code>distance</code> is set to a very large number. Theoretically you would set <code>distance</code> to infinity, but in practice we just set it to a number that is larger than any real distance we would have in the problem we are trying to solve.</p> <p>The code for Dijkstra\u2019s algorithm is shown in <code>Listing 1</code>. When the algorithm finishes, the distances are set correctly as are the predecessor links for each vertex in the graph.</p> Listing 1<pre><code>from pythonds3.graphs import PriorityQueue\n\ndef dijkstra(graph, start):\n    pq = PriorityQueue()\n    start.distance = 0\n    pq.heapify([(v.distance, v) for v in graph])\n    while pq:\n        distance, current_v = pq.delete()\n        for next_v in current_v.get_neighbors():\n            new_distance = current_v.distance + current_v.get_neighbor(next_v)\n            if new_distance &lt; next_v.distance:\n                next_v.distance = new_distance\n                next_v.previous = current_v\n                pq.change_priority(next_v, new_distance)\n</code></pre> <p>Dijkstra\u2019s algorithm uses a priority queue. You may recall that a priority queue is based on the heap that we implemented in Chapter 6.  There are a couple of differences between that simple implementation and the implementation we use for Dijkstra\u2019s algorithm, however. First, the <code>PriorityQueue</code> class stores tuples of (priority, key) pairs. This is an important point, because Dijkstra's algorithm requires the key in the priority queue to match the key of the vertex in the graph. The priority is used for deciding the position of the key in the priority queue. In this implementation we use the distance to the vertex as the priority because as we will see when we are exploring the next vertex, we always want to explore the vertex that has the smallest distance. The second difference is the addition of the <code>change_priority</code> method. As you can see in line 17, this method is used when the distance to a vertex that is already in the queue is reduced, and thus the vertex is moved toward the front of the queue.</p> <p>Let\u2019s walk through an application of Dijkstra\u2019s algorithm one vertex at a time using the following sequence of figures as our guide. We begin with the vertex \\(u\\). The three vertices adjacent to \\(u\\) are \\(v, w,\\) and \\(x\\). Since the initial distances to \\(v, w,\\) and \\(x\\) are all initialized to <code>sys.maxsize</code>, the new costs to get to them through the start node are all their direct costs. So we update the costs to each of these three nodes. We also set the predecessor for each node to \\(u\\) and we add each node to the priority queue. We use the distance as the key for the priority queue. The state of the algorithm is shown in <code>Figure 3</code>.</p> <p>In the next iteration of the <code>while</code> loop we examine the vertices that are adjacent to \\(x\\). The vertex \\(x\\) is next because it has the lowest overall cost and therefore bubbled its way to the beginning of the priority queue. At \\(x\\) we look at its neighbors \\(u, v, w,\\) and \\(y\\). For each neighboring vertex we check to see if the distance to that vertex through \\(x\\) is smaller than the previously known distance. Obviously this is the case for \\(y\\) since its distance was <code>sys.maxsize</code>. It is not the case for \\(u\\) or \\(v\\) since their distances are 0 and 2 respectively. However, we now learn that the distance to \\(w\\) is smaller if we go through \\(x\\) than from \\(u\\) directly to \\(w\\). Since that is the case we update \\(w\\) with a new distance and change the predecessor for \\(w\\) from \\(u\\) to \\(x\\). See <code>Figure 4</code> for the state of all the vertices.</p> <p>The next step is to look at the vertices neighboring \\(v\\) (see <code>Figure 5</code>). This step results in no changes to the graph, so we move on to node \\(y\\). At node \\(y\\) (see <code>Figure 6</code>) we discover that it is cheaper to get to both \\(w\\) and \\(z\\), so we adjust the distances and predecessor links accordingly. Finally we check nodes \\(w\\) and \\(z\\) (see <code>Figure 6</code> and <code>Figure 8</code>). However, no additional changes are found and so the priority queue is empty and Dijkstra\u2019s algorithm exits.</p> <p> Figure 3: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 4: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 5: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 6: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 7: Tracing Dijkstra\u2019s Algorithm </p> <p> Figure 8: Tracing Dijkstra\u2019s Algorithm </p> <p>It is important to note that Dijkstra\u2019s algorithm works only when the weights are all positive. You should convince yourself that if you introduced a negative weight on one of the edges of the graph in <code>Figure 2</code>, the algorithm would never exit.</p> <p>We will note that to route messages through the internet, other algorithms are used for finding the shortest path. One of the problems with using Dijkstra\u2019s algorithm on the internet is that you must have a complete representation of the graph in order for the algorithm to run. The implication of this is that every router has a complete map of all the routers in the internet. In practice this is not the case and other variations of the algorithm allow each router to discover the graph as they go. One such algorithm that you may want to read about is called the distance vector routing algorithm.</p>"},{"location":"c7/s21/","title":"7.21. Dijkstra\u7b97\u6cd5\u5206\u6790","text":"<p>7.21. Analysis of Dijkstra\u2019s Algorithm</p> \u4e2d\u6587\u82f1\u6587 <p>Finally, let\u2019s look at the running time of Dijkstra\u2019s algorithm. We first note that building the priority queue takes \\(O(|V|)\\) time since we initially add every vertex in the graph to the priority queue. Once the queue is constructed, the <code>while</code> loop  is executed once for every vertex since vertices are all added at the beginning and only removed after that. Within that loop each call to <code>delete</code> takes \\(O(\\log{|V|})\\) time. Taken together, that part of the loop and the calls to <code>delete</code> take \\(O(|V| \\times \\log{|V|})\\). The <code>for</code> loop is executed once for each edge in the graph, and within the <code>for</code> loop the call to <code>change_priority</code> takes \\(O(|E| \\times \\log{|V|})\\) time. So the combined running time is \\(O((|V|+|E|) \\times \\log{|V|})\\).</p> <p>Finally, let\u2019s look at the running time of Dijkstra\u2019s algorithm. We first note that building the priority queue takes \\(O(|V|)\\) time since we initially add every vertex in the graph to the priority queue. Once the queue is constructed, the <code>while</code> loop  is executed once for every vertex since vertices are all added at the beginning and only removed after that. Within that loop each call to <code>delete</code> takes \\(O(\\log{|V|})\\) time. Taken together, that part of the loop and the calls to <code>delete</code> take \\(O(|V| \\times \\log{|V|})\\). The <code>for</code> loop is executed once for each edge in the graph, and within the <code>for</code> loop the call to <code>change_priority</code> takes \\(O(|E| \\times \\log{|V|})\\) time. So the combined running time is \\(O((|V|+|E|) \\times \\log{|V|})\\).</p>"},{"location":"c7/s22/","title":"7.22. Prim\u751f\u6210\u6811\u7b97\u6cd5","text":"<p>7.22. Prim\u2019s Spanning Tree Algorithm</p> \u4e2d\u6587\u82f1\u6587 <p>For our last graph algorithm let\u2019s consider a problem that online game designers and internet radio providers face. The problem is that they want to efficiently transfer a piece of information to anyone and everyone who may be listening. This is important in gaming so that all the players know the very latest position of every other player. This is important for internet radio so that all the listeners that are tuned in are getting all the data they need to reconstruct the song they are listening to. <code>Figure 9</code> illustrates the broadcast problem.</p> <p> Figure 9: The Broadcast Problem </p> <p>There are some brute force solutions to this problem, so let\u2019s look at them first to help understand the broadcast problem better. This will also help you appreciate the solution that we will propose when we are done. To begin, the broadcast host has some information that the listeners all need to receive. The simplest solution is for the broadcasting host to keep a list of all of the listeners and send individual messages to each. In <code>Figure 9</code> we show a small network with a broadcaster and some listeners. Using this first approach, four copies of every message would be sent. Assuming that the least cost path is used, let\u2019s see how many times each router would handle the same message.</p> <p>All messages from the broadcaster go through router A, so A sees all four copies of every message. Router C sees only one copy of each message for its listener. However, routers B and D would see three copies of every message since routers B and D are on the cheapest path for listeners 1, 2, and 4. When you consider that the broadcast host must send hundreds of messages each second for a radio broadcast, that is a lot of extra traffic.</p> <p>A brute force solution is for the broadcast host to send a single copy of the broadcast message and let the routers sort things out. In this case, the easiest solution is a strategy called uncontrolled flooding. The flooding strategy works as follows. Each message starts with a time to live (<code>TTL</code>) value set to some number greater than or equal to the number of edges between the broadcast host and its most distant listener. Each router gets a copy of the message and passes the message on to all of its neighboring routers. When the message is passed on the <code>TTL</code> is decreased. Because each router continues to send copies of the message to all its neighbors until the <code>TTL</code> value reaches 0, it is easy to convince yourself that uncontrolled flooding generates many more unnecessary messages than our first strategy.</p> <p>The solution to this problem lies in the construction of a minimum weight spanning tree. Formally we define the minimum spanning tree \\(T\\) for a graph \\(G = (V,E)\\) as follows. \\(T\\) is an acyclic subset of \\(E\\) that connects all the vertices in \\(V\\). The sum of the weights of the edges in T is minimized.</p> <p><code>Figure 10</code> shows a simplified version of the broadcast graph and highlights the edges that form a minimum spanning tree for the graph. Now to solve our broadcast problem, the broadcast host simply sends a single copy of the broadcast message into the network. Each router forwards the message to any neighbor that is part of the spanning tree, excluding the neighbor that just sent it the message. In this example A forwards the message to B. B forwards the message to D and C. D forwards the message to E, which forwards it to F, which forwards it to G. No router sees more than one copy of any message, and all the listeners that are interested see a copy of the message.</p> <p> Figure 10: Minimum Spanning Tree for the Broadcast Graph  </p> <p>The algorithm we will use to solve this problem is called Prim\u2019s algorithm. Prim\u2019s algorithm belongs to a family of algorithms called the greedy algorithms because at each step it will choose the cheapest next step. In this case the cheapest next step is to follow the edge with the lowest weight.</p> <p>To develop Prim's algorithm, let\u2019s first examine the basic idea in constructing a spanning tree as follows:</p> <pre><code>While T is not yet a spanning tree\n    Find an edge that is safe to add to the tree\n    Add the new edge to T\n</code></pre> <p>The trick is in the step that directs us to \u201cfind an edge that is safe.\u201d We define a safe edge as any edge that connects a vertex that is in the spanning tree to a vertex that is not in the spanning tree. This ensures that the tree will always remain a tree and therefore have no cycles.</p> <p>The Python code to implement Prim\u2019s algorithm is shown in <code>Listing 2</code>. Prim\u2019s algorithm is similar to Dijkstra\u2019s algorithm in that they both use a priority queue to select the next vertex to add to the growing graph.</p> Listing 2<pre><code>import sys\nfrom pythonds3.graphs import PriorityQueue\n\n\ndef prim(graph, start):\n    pq = PriorityQueue()\n    for vertex in graph:\n        vertex.distance = sys.maxsize\n        vertex.previous = None\n    start.distance = 0\n    pq.heapify([(vertex.distance, vertex) for vertex in graph])\n    while not pq.is_empty():\n        distance, current_v = pq.delete()\n        for next_v in current_v.get_neighbors():\n            new_distance = current_v.get_neighbor(next_v)\n            if next_v in pq and new_distance &lt; next_v.distance:\n                next_v.previous = current_v\n                next_v.distance = new_distance\n                pq.change_priority(next_v, new_distance)\n</code></pre> <p>The following sequence of figures (<code>Figure 11</code>  through <code>Figure 17</code>) shows the algorithm in operation on our sample tree. We begin with the starting vertex as A. The distances to all the other vertices are initialized to infinity. Looking at the neighbors of A we can update distances to two of the additional vertices, B and C, because the distances to B and C through A are less than infinite. This moves B and C to the front of the priority queue. Update the predecessor links for B and C by setting them to point to A. It is important to note that we have not formally added B or C to the spanning tree yet. A node is not considered to be part of the spanning tree until it is removed from the priority queue.</p> <p> Figure 11: Tracing Prim\u2019s Algorithm </p> <p> Figure 12: Tracing Prim\u2019s Algorithm </p> <p> Figure 13: Tracing Prim\u2019s Algorithm </p> <p> Figure 14: Tracing Prim\u2019s Algorithm </p> <p> Figure 15: Tracing Prim\u2019s Algorithm </p> <p> Figure 16: Tracing Prim\u2019s Algorithm </p> <p> Figure 17: Tracing Prim\u2019s Algorithm </p> <p>Since B has the smallest distance we look at B next. Examining B\u2019s neighbors we see that D and E can be updated. Both D and E get new distance values and their predecessor links are updated. Moving on to the next node in the priority queue we find C. The only node that C is adjacent to that is still in the priority queue is F; thus we can update the distance to F and adjust F\u2019s position in the priority queue.</p> <p>Now we examine the vertices adjacent to node D. We find that we can update E and reduce the distance to E from 6 to 4. When we do this we change the predecessor link on E to point back to D, thus preparing it to be grafted into the spanning tree but in a different location. The rest of the algorithm proceeds as you would expect, adding each new node to the tree.</p> <p>For our last graph algorithm let\u2019s consider a problem that online game designers and internet radio providers face. The problem is that they want to efficiently transfer a piece of information to anyone and everyone who may be listening. This is important in gaming so that all the players know the very latest position of every other player. This is important for internet radio so that all the listeners that are tuned in are getting all the data they need to reconstruct the song they are listening to. <code>Figure 9</code> illustrates the broadcast problem.</p> <p> Figure 9: The Broadcast Problem </p> <p>There are some brute force solutions to this problem, so let\u2019s look at them first to help understand the broadcast problem better. This will also help you appreciate the solution that we will propose when we are done. To begin, the broadcast host has some information that the listeners all need to receive. The simplest solution is for the broadcasting host to keep a list of all of the listeners and send individual messages to each. In <code>Figure 9</code> we show a small network with a broadcaster and some listeners. Using this first approach, four copies of every message would be sent. Assuming that the least cost path is used, let\u2019s see how many times each router would handle the same message.</p> <p>All messages from the broadcaster go through router A, so A sees all four copies of every message. Router C sees only one copy of each message for its listener. However, routers B and D would see three copies of every message since routers B and D are on the cheapest path for listeners 1, 2, and 4. When you consider that the broadcast host must send hundreds of messages each second for a radio broadcast, that is a lot of extra traffic.</p> <p>A brute force solution is for the broadcast host to send a single copy of the broadcast message and let the routers sort things out. In this case, the easiest solution is a strategy called uncontrolled flooding. The flooding strategy works as follows. Each message starts with a time to live (<code>TTL</code>) value set to some number greater than or equal to the number of edges between the broadcast host and its most distant listener. Each router gets a copy of the message and passes the message on to all of its neighboring routers. When the message is passed on the <code>TTL</code> is decreased. Because each router continues to send copies of the message to all its neighbors until the <code>TTL</code> value reaches 0, it is easy to convince yourself that uncontrolled flooding generates many more unnecessary messages than our first strategy.</p> <p>The solution to this problem lies in the construction of a minimum weight spanning tree. Formally we define the minimum spanning tree \\(T\\) for a graph \\(G = (V,E)\\) as follows. \\(T\\) is an acyclic subset of \\(E\\) that connects all the vertices in \\(V\\). The sum of the weights of the edges in T is minimized.</p> <p><code>Figure 10</code> shows a simplified version of the broadcast graph and highlights the edges that form a minimum spanning tree for the graph. Now to solve our broadcast problem, the broadcast host simply sends a single copy of the broadcast message into the network. Each router forwards the message to any neighbor that is part of the spanning tree, excluding the neighbor that just sent it the message. In this example A forwards the message to B. B forwards the message to D and C. D forwards the message to E, which forwards it to F, which forwards it to G. No router sees more than one copy of any message, and all the listeners that are interested see a copy of the message.</p> <p> Figure 10: Minimum Spanning Tree for the Broadcast Graph  </p> <p>The algorithm we will use to solve this problem is called Prim\u2019s algorithm. Prim\u2019s algorithm belongs to a family of algorithms called the greedy algorithms because at each step it will choose the cheapest next step. In this case the cheapest next step is to follow the edge with the lowest weight.</p> <p>To develop Prim's algorithm, let\u2019s first examine the basic idea in constructing a spanning tree as follows:</p> <pre><code>While T is not yet a spanning tree\n    Find an edge that is safe to add to the tree\n    Add the new edge to T\n</code></pre> <p>The trick is in the step that directs us to \u201cfind an edge that is safe.\u201d We define a safe edge as any edge that connects a vertex that is in the spanning tree to a vertex that is not in the spanning tree. This ensures that the tree will always remain a tree and therefore have no cycles.</p> <p>The Python code to implement Prim\u2019s algorithm is shown in <code>Listing 2</code>. Prim\u2019s algorithm is similar to Dijkstra\u2019s algorithm in that they both use a priority queue to select the next vertex to add to the growing graph.</p> Listing 2<pre><code>import sys\nfrom pythonds3.graphs import PriorityQueue\n\n\ndef prim(graph, start):\n    pq = PriorityQueue()\n    for vertex in graph:\n        vertex.distance = sys.maxsize\n        vertex.previous = None\n    start.distance = 0\n    pq.heapify([(vertex.distance, vertex) for vertex in graph])\n    while not pq.is_empty():\n        distance, current_v = pq.delete()\n        for next_v in current_v.get_neighbors():\n            new_distance = current_v.get_neighbor(next_v)\n            if next_v in pq and new_distance &lt; next_v.distance:\n                next_v.previous = current_v\n                next_v.distance = new_distance\n                pq.change_priority(next_v, new_distance)\n</code></pre> <p>The following sequence of figures (<code>Figure 11</code>  through <code>Figure 17</code>) shows the algorithm in operation on our sample tree. We begin with the starting vertex as A. The distances to all the other vertices are initialized to infinity. Looking at the neighbors of A we can update distances to two of the additional vertices, B and C, because the distances to B and C through A are less than infinite. This moves B and C to the front of the priority queue. Update the predecessor links for B and C by setting them to point to A. It is important to note that we have not formally added B or C to the spanning tree yet. A node is not considered to be part of the spanning tree until it is removed from the priority queue.</p> <p> Figure 11: Tracing Prim\u2019s Algorithm </p> <p> Figure 12: Tracing Prim\u2019s Algorithm </p> <p> Figure 13: Tracing Prim\u2019s Algorithm </p> <p> Figure 14: Tracing Prim\u2019s Algorithm </p> <p> Figure 15: Tracing Prim\u2019s Algorithm </p> <p> Figure 16: Tracing Prim\u2019s Algorithm </p> <p> Figure 17: Tracing Prim\u2019s Algorithm </p> <p>Since B has the smallest distance we look at B next. Examining B\u2019s neighbors we see that D and E can be updated. Both D and E get new distance values and their predecessor links are updated. Moving on to the next node in the priority queue we find C. The only node that C is adjacent to that is still in the priority queue is F; thus we can update the distance to F and adjust F\u2019s position in the priority queue.</p> <p>Now we examine the vertices adjacent to node D. We find that we can update E and reduce the distance to E from 6 to 4. When we do this we change the predecessor link on E to point back to D, thus preparing it to be grafted into the spanning tree but in a different location. The rest of the algorithm proceeds as you would expect, adding each new node to the tree.</p>"},{"location":"c7/s23/","title":"7.23. \u603b\u7ed3","text":"<p>7.23. Summary</p> \u4e2d\u6587\u82f1\u6587 <p>In this chapter we have looked at the graph abstract data type and some implementations of a graph. A graph enables us to solve many problems\u2014 provided we can transform the original problem into something that can be represented by a graph. In particular, we have seen that graphs are useful to solve problems in the following general areas:</p> <ul> <li>Breadth-first search for finding the unweighted shortest path.</li> <li>Dijkstra\u2019s algorithm for the weighted shortest path.</li> <li>Depth-first search for graph exploration.</li> <li>Strongly connected components for simplifying a graph.</li> <li>Topological sort for ordering tasks.</li> <li>Minimum weight spanning trees for broadcasting messages.</li> </ul> <p>In this chapter we have looked at the graph abstract data type and some implementations of a graph. A graph enables us to solve many problems\u2014 provided we can transform the original problem into something that can be represented by a graph. In particular, we have seen that graphs are useful to solve problems in the following general areas:</p> <ul> <li>Breadth-first search for finding the unweighted shortest path.</li> <li>Dijkstra\u2019s algorithm for the weighted shortest path.</li> <li>Depth-first search for graph exploration.</li> <li>Strongly connected components for simplifying a graph.</li> <li>Topological sort for ordering tasks.</li> <li>Minimum weight spanning trees for broadcasting messages.</li> </ul>"},{"location":"c7/s24/","title":"7.24. \u5173\u952e\u672f\u8bed","text":"<p>7.24. Key Terms</p> \u4e2d\u6587\u82f1\u6587"},{"location":"c7/s24/#key-terms","title":"Key Terms","text":"- - acyclic graph edge adjacency list edge cost adjacency matrix graph adjacent parenthesis property breadth-first forest path breadth-first search (BFS) shortest path cycle spanning tree depth-first forest strongly connected components (SCC) depth-first search (DFS) topological sort digraph uncontrolled flooding directed acyclic graph (DAG) vertex directed graph weight"},{"location":"c7/s24/#key-terms_1","title":"Key Terms","text":"- - acyclic graph edge adjacency list edge cost adjacency matrix graph adjacent parenthesis property breadth-first forest path breadth-first search (BFS) shortest path cycle spanning tree depth-first forest strongly connected components (SCC) depth-first search (DFS) topological sort digraph uncontrolled flooding directed acyclic graph (DAG) vertex directed graph weight"},{"location":"c7/s25/","title":"7.25. \u7ec3\u4e60","text":"<p>7.25. Exercises</p> \u4e2d\u6587\u82f1\u6587 <ol> <li> <p>Draw the graph corresponding to the following adjacency matrix.</p> <p> </p> </li> <li> <p>Draw the graph corresponding to the following list of edges.</p> from to cost 1 2 10 1 3 15 1 6 5 2 3 7 3 4 7 3 6 10 4 5 7 6 4 5 5 6 13 </li> <li> <p>Ignoring the weights, perform a breadth-first search on the graph drawn for question 1 or 2.</p> <ul> <li>answer a: O(n)</li> <li>answer b: O(n<sup>2</sup>)</li> <li>answer c: O(1)</li> <li>answer d: O(n<sup>3</sup>)</li> </ul> <p>correct: b</p> <ul> <li>feedback a: O(n) would suggest that there is no nesting. There are several nested for loops.</li> <li>feedback b: Correct. The two consecutively nested for loops would dictate that this is in the realm of O(n<sup>2</sup>).</li> <li>feedback c: O(1) would suggest that the function is constant. Since there are multiple for loops intertwined, it is not in constant time.</li> <li>feedback d: O(n<sup>3</sup>) would suggest that there are three consecutively nested for loops. There are only two.</li> </ul> </li> <li> <p>What is the Big-O running time of the <code>build_graph</code> function?</p> <p>shortanswer:: BigO</p> </li> <li> <p>Derive the Big-O running time for the topological sort algorithm.</p> <p>shortanswer:: BigOTwo</p> </li> <li> <p>Derive the Big-O running time for the strongly connected components algorithm.</p> </li> <li>Show each step in applying Dijkstra\u2019s algorithm to the graph drawn for question 1 or 2.</li> <li>Using Prim\u2019s algorithm, find the minimum weight spanning tree for the graph drawn for question 1 or 2.</li> <li>Draw a dependency graph illustrating the steps needed to send an email. Perform a topological sort on your graph.</li> <li>Express branching factor \\(k\\) as a function of the board size \\(n\\).</li> <li> <p>Derive an expression for the base of the exponent used in expressing the  running time of the knights tour.</p> <p>shortanswer:: DFS</p> </li> <li> <p>Explain why the general DFS algorithm is not suitable for solving  the knight's tour problem.</p> <ul> <li>answer a: O(1)</li> <li>answer b: O(n<sup>3</sup>) </li> <li>answer c: O(n)</li> <li>answer d: O(n<sup>2</sup>)</li> </ul> <p>correct: d</p> <ul> <li>feedback a: O(1) would mean that the algorithm runs in constant time. This isn't true because there are several comparisons happening in the algorithm.</li> <li>feedback b: O(n<sup>3</sup>) suggests that there are three consecutively nested loops. If you look at the example algorithm, it is obvious that there are not three nested loops.</li> <li>feedback c: O(n) is linear time. The time it takes for this program to run doesn't grow linearly.</li> <li>feedback d: Correct. Since you are not only comparing the weight of a branch but also if the branch has already been connected to, this would make the Big-O of the algorithm O(n<sup>2</sup>)</li> </ul> </li> <li> <p>What is the Big-O running time for Prim\u2019s minimum  spanning tree algorithm?</p> </li> <li>Modify the depth-first search function to produce a topological sort.</li> <li>Modify the depth-first search to produce strongly connected components.</li> <li>Write the <code>transpose</code> method for the <code>Graph</code> class.</li> <li>Using breadth-first search write an algorithm that can determine the shortest path from each vertex to every other vertex. This is called the \u201call pairs shortest path problem.\u201d</li> <li>Using breadth-first search revise the maze program from the Chapter 4 (Recursion) to find the shortest path out of a maze.</li> <li>Write a program to solve the following problem: you have two jugs, a 4-gallon and a 3-gallon. Neither of the jugs has any markings. There is a pump that can be used to fill the jugs with water. How can you get exactly two gallons of water in the 4-gallon jug?</li> <li>Generalize the problem above so that the parameters to your solution include the size of each jug and the final amount of water to be left in the larger jug.</li> <li>Write a program that solves the following problem: three missionaries and three cannibals come to a river and find a boat that holds two people. Everyone must get across the river to continue on the journey. However, if the cannibals ever outnumber the missionaries on either bank, the missionaries will be eaten. Find a series of crossings that will get everyone safely to the other side of the river.</li> </ol> <ol> <li> <p>Draw the graph corresponding to the following adjacency matrix.</p> <p> </p> </li> <li> <p>Draw the graph corresponding to the following list of edges.</p> from to cost 1 2 10 1 3 15 1 6 5 2 3 7 3 4 7 3 6 10 4 5 7 6 4 5 5 6 13 </li> <li> <p>Ignoring the weights, perform a breadth-first search on the graph drawn for question 1 or 2.</p> <ul> <li>answer a: O(n)</li> <li>answer b: O(n<sup>2</sup>)</li> <li>answer c: O(1)</li> <li>answer d: O(n<sup>3</sup>)</li> </ul> <p>correct: b</p> <ul> <li>feedback a: O(n) would suggest that there is no nesting. There are several nested for loops.</li> <li>feedback b: Correct. The two consecutively nested for loops would dictate that this is in the realm of O(n<sup>2</sup>).</li> <li>feedback c: O(1) would suggest that the function is constant. Since there are multiple for loops intertwined, it is not in constant time.</li> <li>feedback d: O(n<sup>3</sup>) would suggest that there are three consecutively nested for loops. There are only two.</li> </ul> </li> <li> <p>What is the Big-O running time of the <code>build_graph</code> function?</p> <p>shortanswer:: BigO</p> </li> <li> <p>Derive the Big-O running time for the topological sort algorithm.</p> <p>shortanswer:: BigOTwo</p> </li> <li> <p>Derive the Big-O running time for the strongly connected components algorithm.</p> </li> <li>Show each step in applying Dijkstra\u2019s algorithm to the graph drawn for question 1 or 2.</li> <li>Using Prim\u2019s algorithm, find the minimum weight spanning tree for the graph drawn for question 1 or 2.</li> <li>Draw a dependency graph illustrating the steps needed to send an email. Perform a topological sort on your graph.</li> <li>Express branching factor \\(k\\) as a function of the board size \\(n\\).</li> <li> <p>Derive an expression for the base of the exponent used in expressing the  running time of the knights tour.</p> <p>shortanswer:: DFS</p> </li> <li> <p>Explain why the general DFS algorithm is not suitable for solving  the knight's tour problem.</p> <ul> <li>answer a: O(1)</li> <li>answer b: O(n<sup>3</sup>) </li> <li>answer c: O(n)</li> <li>answer d: O(n<sup>2</sup>)</li> </ul> <p>correct: d</p> <ul> <li>feedback a: O(1) would mean that the algorithm runs in constant time. This isn't true because there are several comparisons happening in the algorithm.</li> <li>feedback b: O(n<sup>3</sup>) suggests that there are three consecutively nested loops. If you look at the example algorithm, it is obvious that there are not three nested loops.</li> <li>feedback c: O(n) is linear time. The time it takes for this program to run doesn't grow linearly.</li> <li>feedback d: Correct. Since you are not only comparing the weight of a branch but also if the branch has already been connected to, this would make the Big-O of the algorithm O(n<sup>2</sup>)</li> </ul> </li> <li> <p>What is the Big-O running time for Prim\u2019s minimum  spanning tree algorithm?</p> </li> <li>Modify the depth-first search function to produce a topological sort.</li> <li>Modify the depth-first search to produce strongly connected components.</li> <li>Write the <code>transpose</code> method for the <code>Graph</code> class.</li> <li>Using breadth-first search write an algorithm that can determine the shortest path from each vertex to every other vertex. This is called the \u201call pairs shortest path problem.\u201d</li> <li>Using breadth-first search revise the maze program from the Chapter 4 (Recursion) to find the shortest path out of a maze.</li> <li>Write a program to solve the following problem: you have two jugs, a 4-gallon and a 3-gallon. Neither of the jugs has any markings. There is a pump that can be used to fill the jugs with water. How can you get exactly two gallons of water in the 4-gallon jug?</li> <li>Generalize the problem above so that the parameters to your solution include the size of each jug and the final amount of water to be left in the larger jug.</li> <li>Write a program that solves the following problem: three missionaries and three cannibals come to a river and find a boat that holds two people. Everyone must get across the river to continue on the journey. However, if the cannibals ever outnumber the missionaries on either bank, the missionaries will be eaten. Find a series of crossings that will get everyone safely to the other side of the river.</li> </ol>"},{"location":"c7/s3/","title":"7.3. \u56fe\u7684\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>7.3. The Graph Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>The graph abstract data type is defined as a collection of vertices and edges. Vertices may be either connected to each other or isolated. Edges join two vertices and may be weighted.</p> <ul> <li><code>Graph()</code> creates a new empty graph.</li> <li><code>add_vertex(vert)</code> adds an instance of <code>Vertex</code> to the graph.</li> <li><code>add_edge(from_vert, to_vert)</code> adds a new directed edge to the graph that connects two vertices.</li> <li><code>add_edge(from_vert, to_vert, weight)</code> adds a new weighted directed edge to the graph that connects two vertices.</li> <li><code>get_vertex(vert_key)</code> finds the vertex in the graph named <code>vert_key</code>.</li> <li><code>get_vertices()</code> returns the list of all vertices in the graph.</li> <li><code>in</code> returns <code>True</code> for a statement of the form <code>vertex in graph</code> if the given vertex is in the graph, <code>False</code> otherwise.</li> </ul> <p>Now that we have looked at the definition for the graph ADT, there are several ways we can implement it in Python. We will see that there are trade-offs in using different representations to implement the ADT described above. There are two well-known implementations of a graph, the adjacency matrix and the adjacency list. We will explain both of these options, and then implement one as a Python class.</p> <p>The graph abstract data type is defined as a collection of vertices and edges. Vertices may be either connected to each other or isolated. Edges join two vertices and may be weighted.</p> <ul> <li><code>Graph()</code> creates a new empty graph.</li> <li><code>add_vertex(vert)</code> adds an instance of <code>Vertex</code> to the graph.</li> <li><code>add_edge(from_vert, to_vert)</code> adds a new directed edge to the graph that connects two vertices.</li> <li><code>add_edge(from_vert, to_vert, weight)</code> adds a new weighted directed edge to the graph that connects two vertices.</li> <li><code>get_vertex(vert_key)</code> finds the vertex in the graph named <code>vert_key</code>.</li> <li><code>get_vertices()</code> returns the list of all vertices in the graph.</li> <li><code>in</code> returns <code>True</code> for a statement of the form <code>vertex in graph</code> if the given vertex is in the graph, <code>False</code> otherwise.</li> </ul> <p>Now that we have looked at the definition for the graph ADT, there are several ways we can implement it in Python. We will see that there are trade-offs in using different representations to implement the ADT described above. There are two well-known implementations of a graph, the adjacency matrix and the adjacency list. We will explain both of these options, and then implement one as a Python class.</p>"},{"location":"c7/s4/","title":"7.4. \u90bb\u63a5\u77e9\u9635","text":"<p>7.4. An Adjacency Matrix</p> \u4e2d\u6587\u82f1\u6587 <p>One of the easiest ways to implement a graph is to use a two-dimensional matrix. In this matrix implementation, each of the rows and columns represents a vertex in the graph. The value that is stored in the cell at the intersection of row \\(v\\) and column \\(w\\) indicates if there is an edge from vertex \\(v\\) to vertex \\(w\\). When two vertices are connected by an edge, we say that they are adjacent. <code>Figure 3</code> illustrates the adjacency matrix for the graph in <code>Figure 2</code>. The value in each cell represents the weight of the edge from vertex \\(v\\) to vertex \\(w\\).</p> <p> Figure 3: An Adjacency Matrix Representation for a Graph  </p> <p>The advantage of the adjacency matrix is that it is simple, and for small graphs it is easy to see which nodes are connected to other nodes. However, otice that most of the cells in the matrix are empty; we can say that this matrix is sparse. A matrix is not a very efficient way to store sparse data. In fact, in Python you must go out of your way to even create a matrix structure like the one in <code>Figure 3</code>.</p> <p>The adjacency matrix is a good implementation for a graph when the number of edges is large. But what do we mean by large? How many edges would be needed to fill the matrix? Since there is one row and one column for every vertex in the graph, the number of edges required to fill the matrix is \\(|V|^2\\). A matrix is full when every vertex is connected to every other vertex. There are few real problems that approach this sort of connectivity. The problems we will look at in this chapter all involve graphs that are sparsely connected.</p> <p>One of the easiest ways to implement a graph is to use a two-dimensional matrix. In this matrix implementation, each of the rows and columns represents a vertex in the graph. The value that is stored in the cell at the intersection of row \\(v\\) and column \\(w\\) indicates if there is an edge from vertex \\(v\\) to vertex \\(w\\). When two vertices are connected by an edge, we say that they are adjacent. <code>Figure 3</code> illustrates the adjacency matrix for the graph in <code>Figure 2</code>. The value in each cell represents the weight of the edge from vertex \\(v\\) to vertex \\(w\\).</p> <p> Figure 3: An Adjacency Matrix Representation for a Graph  </p> <p>The advantage of the adjacency matrix is that it is simple, and for small graphs it is easy to see which nodes are connected to other nodes. However, otice that most of the cells in the matrix are empty; we can say that this matrix is sparse. A matrix is not a very efficient way to store sparse data. In fact, in Python you must go out of your way to even create a matrix structure like the one in <code>Figure 3</code>.</p> <p>The adjacency matrix is a good implementation for a graph when the number of edges is large. But what do we mean by large? How many edges would be needed to fill the matrix? Since there is one row and one column for every vertex in the graph, the number of edges required to fill the matrix is \\(|V|^2\\). A matrix is full when every vertex is connected to every other vertex. There are few real problems that approach this sort of connectivity. The problems we will look at in this chapter all involve graphs that are sparsely connected.</p>"},{"location":"c7/s5/","title":"7.5. \u90bb\u63a5\u8868","text":"<p>7.5. An Adjacency List</p> \u4e2d\u6587\u82f1\u6587 <p>A more space-efficient way to implement a sparsely connected graph is to use an adjacency list. In an adjacency list implementation, we keep a master list of all the vertices in the <code>Graph</code> object, and each vertex object in the graph maintains a list of the other vertices that it is connected to. In our implementation of the <code>Vertex</code> class we will use a dictionary rather than a list, where the dictionary keys are the vertices and the values are the weights. <code>Figure 4</code> illustrates the adjacency list representation for the graph in <code>Figure 2</code>.</p> <p> Figure 4: An Adjacency List Representation of a Graph  </p> <p>The advantage of the adjacency list implementation is that it allows us to compactly represent a sparse graph. The adjacency list also allows us to easily find all the links that are directly connected to a particular vertex.</p> <p>A more space-efficient way to implement a sparsely connected graph is to use an adjacency list. In an adjacency list implementation, we keep a master list of all the vertices in the <code>Graph</code> object, and each vertex object in the graph maintains a list of the other vertices that it is connected to. In our implementation of the <code>Vertex</code> class we will use a dictionary rather than a list, where the dictionary keys are the vertices and the values are the weights. <code>Figure 4</code> illustrates the adjacency list representation for the graph in <code>Figure 2</code>.</p> <p> Figure 4: An Adjacency List Representation of a Graph  </p> <p>The advantage of the adjacency list implementation is that it allows us to compactly represent a sparse graph. The adjacency list also allows us to easily find all the links that are directly connected to a particular vertex.</p>"},{"location":"c7/s6/","title":"7.6. \u5b9e\u73b0","text":"<p>7.6. Implementation</p> \u4e2d\u6587\u82f1\u6587 <p>Using dictionaries, it is easy to implement the adjacency list in Python. In our implementation of the graph abstract data type we will create two classes:</p> <p><code>Vertex</code>, which will represent each vertex in the graph (see <code>Listing 1</code>) and <code>Graph</code>, which holds the master list of vertices (see <code>Listing 2</code>).</p> <p>Each <code>Vertex</code> uses a dictionary to keep track of the vertices to which it is connected and the weight of each edge. This dictionary is called <code>neighbors</code>. The listing below shows the code for the <code>Vertex</code> class. The constructor simply initializes the <code>key</code>, which will typically be a string, and the <code>neighbors</code> dictionary. The <code>set_neighbor</code> method is used to add a connection from this vertex to another. The <code>get_neighbors</code> method returns all of the vertices in the adjacency list, as represented by the <code>neighbors</code> instance variable. The <code>get_neighbor</code> method returns the weight of the edge from this vertex to the vertex passed as a parameter.</p> Listing 1<pre><code>class Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.neighbors = {}\n\n    def get_neighbor(self, other):\n        return self.neighbors.get(other, None)\n\n    def set_neighbor(self, other, weight=0):\n        self.neighbors[other] = weight\n\n    def __repr__(self):\n        return f\"Vertex({self.key})\"\n\n    def __str__(self):\n        return (\n            str(self.key)\n            + \" connected to: \"\n            + str([x.key for x in self.neighbors])\n        )\n\n    def get_neighbors(self):\n        return self.neighbors.keys()\n\n    def get_key(self):\n        return self.key\n</code></pre> <p>The <code>Graph</code> class, shown in the next listing, contains a dictionary that maps vertex names to vertex objects. In <code>Figure 4</code> this dictionary object is represented by the shaded gray box. <code>Graph</code> also provides methods for adding vertices to a graph and connecting one vertex to another. The <code>get_vertices</code> method returns the names of all of the vertices in the graph. In addition, we have implemented the <code>__iter__</code> method to make it easy to iterate over all the vertex objects in a particular graph. Together, the two methods allow you to iterate over the vertices in a graph by name, or by the objects themselves.</p> Listing 2<pre><code>class Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def set_vertex(self, key):\n        self.vertices[key] = Vertex(key)\n\n    def get_vertex(self, key):\n        return self.vertices.get(key, None)\n\n    def __contains__(self, key):\n        return key in self.vertices\n\n    def add_edge(self, from_vert, to_vert, weight=0):\n        if from_vert not in self.vertices:\n            self.set_vertex(from_vert)\n        if to_vert not in self.vertices:\n            self.set_vertex(to_vert)\n        self.vertices[from_vert].set_neighbor(self.vertices[to_vert], weight)\n\n    def get_vertices(self):\n        return self.vertices.keys()\n\n    def __iter__(self):\n        return iter(self.vertices.values())\n</code></pre> <p>Using the <code>Graph</code> and <code>Vertex</code> classes just defined, the following Python session creates the graph in <code>Figure 2</code>. First we create six vertices numbered 0 through 5. Then we display the vertex dictionary. Notice that for each key 0 through 5 we have created an instance of a <code>Vertex</code>. Next, we add the edges that connect the vertices together. Finally, a nested loop verifies that each edge in the graph is properly stored. You should check the output of the edge list at the end of this session against <code>Figure 2</code>.</p> <pre><code>&gt;&gt;&gt; g = Graph()\n&gt;&gt;&gt; for i in range(6):\n...     g.set_vertex(i)\n&gt;&gt;&gt; g.vertices\n{0: Vertex(0), 1: Vertex(1), 2: Vertex(2), 3: Vertex(3), 4: Vertex(4), 5: Vertex(5)}\n&gt;&gt;&gt; g.add_edge(0, 1, 5)\n&gt;&gt;&gt; g.add_edge(0, 5, 2)\n&gt;&gt;&gt; g.add_edge(1, 2, 4)\n&gt;&gt;&gt; g.add_edge(2, 3, 9)\n&gt;&gt;&gt; g.add_edge(3, 4, 7)\n&gt;&gt;&gt; g.add_edge(3, 5, 3)\n&gt;&gt;&gt; g.add_edge(4, 0, 1)\n&gt;&gt;&gt; g.add_edge(5, 4, 8)\n&gt;&gt;&gt; g.add_edge(5, 2, 1)\n&gt;&gt;&gt; for v in g:\n...     for w in v.get_neighbors():\n...         print(\"f({v.get_key()}, {w.get_key()})\")\n...\n(0, 1)\n(0, 5)\n(1, 2)\n(2, 3)\n(3, 4)\n(3, 5)\n(4, 0)\n(5, 4)\n(5, 2)\n</code></pre> <p>Using dictionaries, it is easy to implement the adjacency list in Python. In our implementation of the graph abstract data type we will create two classes:</p> <p><code>Vertex</code>, which will represent each vertex in the graph (see <code>Listing 1</code>) and <code>Graph</code>, which holds the master list of vertices (see <code>Listing 2</code>).</p> <p>Each <code>Vertex</code> uses a dictionary to keep track of the vertices to which it is connected and the weight of each edge. This dictionary is called <code>neighbors</code>. The listing below shows the code for the <code>Vertex</code> class. The constructor simply initializes the <code>key</code>, which will typically be a string, and the <code>neighbors</code> dictionary. The <code>set_neighbor</code> method is used to add a connection from this vertex to another. The <code>get_neighbors</code> method returns all of the vertices in the adjacency list, as represented by the <code>neighbors</code> instance variable. The <code>get_neighbor</code> method returns the weight of the edge from this vertex to the vertex passed as a parameter.</p> Listing 1<pre><code>class Vertex:\n    def __init__(self, key):\n        self.key = key\n        self.neighbors = {}\n\n    def get_neighbor(self, other):\n        return self.neighbors.get(other, None)\n\n    def set_neighbor(self, other, weight=0):\n        self.neighbors[other] = weight\n\n    def __repr__(self):\n        return f\"Vertex({self.key})\"\n\n    def __str__(self):\n        return (\n            str(self.key)\n            + \" connected to: \"\n            + str([x.key for x in self.neighbors])\n        )\n\n    def get_neighbors(self):\n        return self.neighbors.keys()\n\n    def get_key(self):\n        return self.key\n</code></pre> <p>The <code>Graph</code> class, shown in the next listing, contains a dictionary that maps vertex names to vertex objects. In <code>Figure 4</code> this dictionary object is represented by the shaded gray box. <code>Graph</code> also provides methods for adding vertices to a graph and connecting one vertex to another. The <code>get_vertices</code> method returns the names of all of the vertices in the graph. In addition, we have implemented the <code>__iter__</code> method to make it easy to iterate over all the vertex objects in a particular graph. Together, the two methods allow you to iterate over the vertices in a graph by name, or by the objects themselves.</p> Listing 2<pre><code>class Graph:\n    def __init__(self):\n        self.vertices = {}\n\n    def set_vertex(self, key):\n        self.vertices[key] = Vertex(key)\n\n    def get_vertex(self, key):\n        return self.vertices.get(key, None)\n\n    def __contains__(self, key):\n        return key in self.vertices\n\n    def add_edge(self, from_vert, to_vert, weight=0):\n        if from_vert not in self.vertices:\n            self.set_vertex(from_vert)\n        if to_vert not in self.vertices:\n            self.set_vertex(to_vert)\n        self.vertices[from_vert].set_neighbor(self.vertices[to_vert], weight)\n\n    def get_vertices(self):\n        return self.vertices.keys()\n\n    def __iter__(self):\n        return iter(self.vertices.values())\n</code></pre> <p>Using the <code>Graph</code> and <code>Vertex</code> classes just defined, the following Python session creates the graph in <code>Figure 2</code>. First we create six vertices numbered 0 through 5. Then we display the vertex dictionary. Notice that for each key 0 through 5 we have created an instance of a <code>Vertex</code>. Next, we add the edges that connect the vertices together. Finally, a nested loop verifies that each edge in the graph is properly stored. You should check the output of the edge list at the end of this session against <code>Figure 2</code>.</p> <pre><code>&gt;&gt;&gt; g = Graph()\n&gt;&gt;&gt; for i in range(6):\n...     g.set_vertex(i)\n&gt;&gt;&gt; g.vertices\n{0: Vertex(0), 1: Vertex(1), 2: Vertex(2), 3: Vertex(3), 4: Vertex(4), 5: Vertex(5)}\n&gt;&gt;&gt; g.add_edge(0, 1, 5)\n&gt;&gt;&gt; g.add_edge(0, 5, 2)\n&gt;&gt;&gt; g.add_edge(1, 2, 4)\n&gt;&gt;&gt; g.add_edge(2, 3, 9)\n&gt;&gt;&gt; g.add_edge(3, 4, 7)\n&gt;&gt;&gt; g.add_edge(3, 5, 3)\n&gt;&gt;&gt; g.add_edge(4, 0, 1)\n&gt;&gt;&gt; g.add_edge(5, 4, 8)\n&gt;&gt;&gt; g.add_edge(5, 2, 1)\n&gt;&gt;&gt; for v in g:\n...     for w in v.get_neighbors():\n...         print(\"f({v.get_key()}, {w.get_key()})\")\n...\n(0, 1)\n(0, 5)\n(1, 2)\n(2, 3)\n(3, 4)\n(3, 5)\n(4, 0)\n(5, 4)\n(5, 2)\n</code></pre>"},{"location":"c7/s7/","title":"7.7. \u5b57\u68af\u95ee\u9898","text":"<p>7.7. The Word Ladder Problem</p> \u4e2d\u6587\u82f1\u6587 <p>To begin our study of graph algorithms let\u2019s consider the following puzzle called a word ladder: transform the word FOOL into the word SAGE. In a word ladder puzzle you must make the change occur gradually by changing one letter at a time. At each step you must transform one word into another word; you are not allowed to transform a word into a non-word. The word ladder puzzle was invented in 1878 by Lewis Carroll, the author of Alice in Wonderland. The following sequence of words shows one possible solution to the problem posed above.</p> <pre><code>FOOL\nPOOL\nPOLL\nPOLE\nPALE\nSALE\nSAGE        \n</code></pre> <p>There are many variations of the word ladder puzzle. For example you might be given a particular number of steps in which to accomplish the transformation, or you might need to use a particular word. In this section we are interested in figuring out the smallest number of transformations needed to turn the starting word into the ending word.</p> <p>Not surprisingly, since this chapter is on graphs, we can solve this problem using a graph algorithm. Here is an outline of where we are going:</p> <ul> <li>Represent the relationships between the words as a graph.</li> </ul> <p>To begin our study of graph algorithms let\u2019s consider the following puzzle called a word ladder: transform the word FOOL into the word SAGE. In a word ladder puzzle you must make the change occur gradually by changing one letter at a time. At each step you must transform one word into another word; you are not allowed to transform a word into a non-word. The word ladder puzzle was invented in 1878 by Lewis Carroll, the author of Alice in Wonderland. The following sequence of words shows one possible solution to the problem posed above.</p> <pre><code>FOOL\nPOOL\nPOLL\nPOLE\nPALE\nSALE\nSAGE        \n</code></pre> <p>There are many variations of the word ladder puzzle. For example you might be given a particular number of steps in which to accomplish the transformation, or you might need to use a particular word. In this section we are interested in figuring out the smallest number of transformations needed to turn the starting word into the ending word.</p> <p>Not surprisingly, since this chapter is on graphs, we can solve this problem using a graph algorithm. Here is an outline of where we are going:</p> <ul> <li>Represent the relationships between the words as a graph.</li> <li>Use the graph algorithm known as breadth-first search to find an efficient path from the starting word to the ending word.</li> </ul>"},{"location":"c7/s8/","title":"7.8. \u6784\u5efa\u5b57\u68af\u56fe","text":"<p>7.8. Building the Word Ladder Graph</p> \u4e2d\u6587\u82f1\u6587 <p>Our first problem is to figure out how to turn a large collection of words into a graph. What we would like is to have an edge from one word to another if the two words are only different by a single letter. If we can create such a graph, then any path from one word to another is a solution to the word ladder puzzle. <code>Figure 1</code> shows a small graph of some words that solve the FOOL to SAGE word ladder problem. Notice that the graph is an undirected graph and that the edges are unweighted.</p> <p> Figure 1: A Small Word Ladder Graph </p> <p>We could use several different approaches to create the graph we need to solve this problem. Let\u2019s start with the assumption that we have a list of words that are all the same length. As a starting point, we can create a vertex in the graph for every word in the list. To figure out how to connect the words, we could compare each word in the list with every other. When we compare we are looking to see how many letters are different. If the two words in question are different by only one letter, we can create an edge between them in the graph. For a small set of words that approach would work fine; however, let\u2019s suppose we have a list of 5,110 words. Roughly speaking, comparing one word to every other word on the list is an \\(O(n^2)\\) algorithm. For 5,110 words, \\(n^2\\) is more than 26\u00a0million comparisons.</p> <p>We can do much better by using the approach shown in <code>Figure 2</code>. Suppose that we have a number of buckets, each labeled with a four-letter word, except that one of the letters on the label has been replaced by an underscore. As we process a list of words, we compare each word with each bucket using the underscore (_) as a wildcard. Every time we find a matching bucket we put the word in that bucket, so that both POPE and POPS would both go into the POP_ bucket. Once we have all the words in the appropriate buckets, we know that all the words in each bucket must be connected.</p> <p> Figure 2: Word Buckets for Words That Differ by One Letter </p> <p>In Python, we can implement the scheme we have just described by using a dictionary. The labels on the buckets we have just described are the keys in our dictionary. The value stored for each key is a list of words. Once we have the dictionary built, we can create the graph. We start our graph by creating a vertex for each word in the graph. Then we create edges between all the vertices we find for words found under the same key in the dictionary. <code>Listing 1</code> shows the Python code required to build the graph.</p> Listing 1<pre><code>from pythonds3.graphs import Graph\n\n\ndef build_graph(filename):\n    buckets = {}\n    the_graph = Graph()\n    with open(filename, \"r\", encoding=\"utf8\") as file_in:\n        all_words = file_in.readlines()\n    # create buckets of words that differ by 1 letter\n    for line in all_words:\n        word = line.strip()\n        for i, _ in enumerate(word):\n            bucket = f\"{word[:i]}_{word[i + 1 :]}\"\n            buckets.setdefault(bucket, set()).add(word)\n\n    # add edges between different words in the same bucket\n    for similar_words in buckets.values():\n        for word1 in similar_words:\n            for word2 in similar_words - {word1}:\n                the_graph.add_edge(word1, word2)\n    return the_graph\n</code></pre> <p>Since this is our first real-world graph problem, you might be wondering how sparse the graph is. The list of four-letter words we have for this problem is 5,110 words long. If we were to use an a</p> <p>Our first problem is to figure out how to turn a large collection of words into a graph. What we would like is to have an edge from one word to another if the two words are only different by a single letter. If we can create such a graph, then any path from one word to another is a solution to the word ladder puzzle. <code>Figure 1</code> shows a small graph of some words that solve the FOOL to SAGE word ladder problem. Notice that the graph is an undirected graph and that the edges are unweighted.</p> <p> Figure 1: A Small Word Ladder Graph </p> <p>We could use several different approaches to create the graph we need to solve this problem. Let\u2019s start with the assumption that we have a list of words that are all the same length. As a starting point, we can create a vertex in the graph for every word in the list. To figure out how to connect the words, we could compare each word in the list with every other. When we compare we are looking to see how many letters are different. If the two words in question are different by only one letter, we can create an edge between them in the graph. For a small set of words that approach would work fine; however, let\u2019s suppose we have a list of 5,110 words. Roughly speaking, comparing one word to every other word on the list is an \\(O(n^2)\\) algorithm. For 5,110 words, \\(n^2\\) is more than 26\u00a0million comparisons.</p> <p>We can do much better by using the approach shown in <code>Figure 2</code>. Suppose that we have a number of buckets, each labeled with a four-letter word, except that one of the letters on the label has been replaced by an underscore. As we process a list of words, we compare each word with each bucket using the underscore (_) as a wildcard. Every time we find a matching bucket we put the word in that bucket, so that both POPE and POPS would both go into the POP_ bucket. Once we have all the words in the appropriate buckets, we know that all the words in each bucket must be connected.</p> <p> Figure 2: Word Buckets for Words That Differ by One Letter </p> <p>In Python, we can implement the scheme we have just described by using a dictionary. The labels on the buckets we have just described are the keys in our dictionary. The value stored for each key is a list of words. Once we have the dictionary built, we can create the graph. We start our graph by creating a vertex for each word in the graph. Then we create edges between all the vertices we find for words found under the same key in the dictionary. <code>Listing 1</code> shows the Python code required to build the graph.</p> Listing 1<pre><code>from pythonds3.graphs import Graph\n\n\ndef build_graph(filename):\n    buckets = {}\n    the_graph = Graph()\n    with open(filename, \"r\", encoding=\"utf8\") as file_in:\n        all_words = file_in.readlines()\n    # create buckets of words that differ by 1 letter\n    for line in all_words:\n        word = line.strip()\n        for i, _ in enumerate(word):\n            bucket = f\"{word[:i]}_{word[i + 1 :]}\"\n            buckets.setdefault(bucket, set()).add(word)\n\n    # add edges between different words in the same bucket\n    for similar_words in buckets.values():\n        for word1 in similar_words:\n            for word2 in similar_words - {word1}:\n                the_graph.add_edge(word1, word2)\n    return the_graph\n</code></pre> <p>Since this is our first real-world graph problem, you might be wondering how sparse the graph is. The list of four-letter words we have for this problem is 5,110 words long. If we were to use an adjacency matrix, the matrix would have \\(5,110 \\cdot 5,110\\) = 26,112,100 cells. The graph constructed by the <code>build_graph</code> function has exactly 53,286 edges, so the matrix would have only 0.20% of the cells filled! That is a very sparse matrix indeed.</p>"},{"location":"c7/s9/","title":"7.9. \u5b9e\u73b0\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22","text":"<p>7.9. Implementing Breadth-First Search</p> \u4e2d\u6587\u82f1\u6587 <p>With the graph constructed we can now turn our attention to the algorithm we will use to find the shortest solution to the word ladder problem. The graph algorithm we are going to use is called the breadth-first search (BFS), and it is one of the easiest algorithms for searching a graph. It also serves as a prototype for several other important graph algorithms that we will study later.</p> <p>Given a starting vertex \\(s\\) of a graph \\(G\\), a breadth first search proceeds by exploring edges in the graph to find all the vertices in \\(G\\) for which there is a path from \\(s\\). The remarkable thing about a breadth-first search is that it finds all the vertices that are a distance \\(k\\) from \\(s\\) before it finds any vertices that are a distance \\(k+1\\). One good way to visualize what the breadth-first search algorithm does is to imagine that it is building a tree, one level of the tree at a time. A breadth first search adds all children of the starting vertex before it begins to discover any of the grandchildren.</p> <p>To keep track of its progress, BFS colors each of the vertices white, gray, or black. All the vertices are initialized to white when they are constructed. A white vertex is an undiscovered vertex. When a vertex is initially discovered it is colored gray, and when BFS has completely explored a vertex it is colored black. This means that once a vertex is colored black, it has no white vertices adjacent to it. A gray node, on the other hand, may have some white vertices adjacent to it, indicating that there are still additional vertices to explore.</p> <p>The breadth-first search algorithm shown in <code>Listing 2</code> below uses the adjacency list graph representation we developed earlier. In addition it uses a <code>Queue</code>, a crucial point as we will see, to decide which vertex to explore next.</p> Listing 2<pre><code>from pythonds3.basic import Queue\nfrom pythonds3.graphs import Graph\n\n\ndef bfs(start):\n    start.distance = 0\n    start.previous = None\n    vert_queue = Queue()\n    vert_queue.enqueue(start)\n    while vert_queue.size() &gt; 0:\n        current = vert_queue.dequeue()\n        for neighbor in current.get_neighbors():\n            if neighbor.color == \"white\":\n                neighbor.color = \"gray\"\n                neighbor.distance = current.distance + 1\n                neighbor.previous = current\n                vert_queue.enqueue(neighbor)\n        current.color = \"black\"\n</code></pre> <p>The BFS algorithm uses an extended version of the <code>Vertex</code> class that adds three new instance variables: <code>distance</code>, <code>previous</code>, and <code>color</code>. Each of these instance variables also has the appropriate getter and setter methods. The code for this expanded <code>Vertex</code> class is included in the <code>pythonds3</code> package, but we will not show it to you here as there is nothing new to learn by seeing the additional instance variables.</p> <p>BFS begins at the starting vertex <code>start</code> and paints it gray to show that it is currently being explored. Two other values, the <code>distance</code> and the <code>previous</code>, are initialized to 0 and <code>None</code> respectively for the starting vertex. Finally, <code>start</code> is placed on a <code>Queue</code>. The next step is to begin to systematically explore vertices at the front of the queue. We explore each new node at the front of the queue by iterating over its adjacency list. As each node on the adjacency list is examined, its color is checked. If it is white, the vertex is unexplored, and four things happen:</p> <ol> <li>The new unexplored vertex <code>neighbor</code> is colored gray.</li> <li>The predecessor of <code>neighbor</code> is set to the current node <code>current</code>.</li> <li>The distance to <code>neighbor</code> is set to the distance to <code>current + 1</code>.</li> <li><code>neighbor</code> is added to the end of a queue. Adding <code>neighbor</code> to the end of the queue effectively schedules this node for further exploration, but not until all the other vertices on the adjacency list of <code>current</code> have been explored.</li> </ol> <p>Let\u2019s look at how the <code>bfs</code> function would construct the breadth-first tree corresponding to the graph in <code>Figure 1</code>. Starting from FOOL we take all nodes that are adjacent to FOOL and add them to the tree. The adjacent nodes include POOL, FOIL, FOUL, and COOL. Each of these nodes are added to the queue of new nodes to expand. <code>Figure 3</code> shows the state of the in-progress tree along with the queue after this step.</p> <p> Figure 3: The First Step in the Breadth-First Search </p> <p>In the next step <code>bfs</code> removes the next node (POOL) from the front of the queue and repeats the process for all of its adjacent nodes. However, when <code>bfs</code> examines the node COOL, it finds that the color of COOL has already been changed to gray. This indicates that there is a shorter path to COOL and that COOL is already on the queue for further expansion. The only new node added to the queue while examining POOL is POLL. The new state of the tree and queue is shown in <code>Figure 4</code>.</p> <p> Figure 4: The Second Step in the Breadth-First Search </p> <p>The next vertex on the queue is FOIL. The only new node that FOIL can add to the tree is FAIL. As <code>bfs</code> continues to process the queue, neither of the next two nodes adds anything new to the queue or the tree. <code>Figure 5</code> shows the tree and the queue after expanding all the vertices on the second level of the tree.</p> <p> Figure 5: Breadth-First Search Tree After Completing One Level </p> <p> FIgure 6: Final Breadth-First Search Tree  </p> <p>You should continue to work through the algorithm on your own so that you are comfortable with how it works. <code>Figure 6</code> shows the final breadth-first search tree after all the vertices in <code>Figure 3</code> have been expanded. The amazing thing about the breadth-first search solution is that we have not only solved the FOOL\u2013SAGE problem we started out with, but we have solved many other problems along the way. We can start at any vertex in the breadth-first search tree and follow the predecessor arrows back to the root to find the shortest word ladder from any word back to FOOL. The function below (<code>Listing 3</code>) shows how to follow the predecessor links to print out the word ladder.</p> Listing 3<pre><code>def traverse(starting_vertex):\n    current = starting_vertex\n    while current:\n        print(current.key)\n        current = current.previous\n\ntraverse(g.get_vertex(\"sage\"))\n</code></pre> <p>With the graph constructed we can now turn our attention to the algorithm we will use to find the shortest solution to the word ladder problem. The graph algorithm we are going to use is called the breadth-first search (BFS), and it is one of the easiest algorithms for searching a graph. It also serves as a prototype for several other important graph algorithms that we will study later.</p> <p>Given a starting vertex \\(s\\) of a graph \\(G\\), a breadth first search proceeds by exploring edges in the graph to find all the vertices in \\(G\\) for which there is a path from \\(s\\). The remarkable thing about a breadth-first search is that it finds all the vertices that are a distance \\(k\\) from \\(s\\) before it finds any vertices that are a distance \\(k+1\\). One good way to visualize what the breadth-first search algorithm does is to imagine that it is building a tree, one level of the tree at a time. A breadth first search adds all children of the starting vertex before it begins to discover any of the grandchildren.</p> <p>To keep track of its progress, BFS colors each of the vertices white, gray, or black. All the vertices are initialized to white when they are constructed. A white vertex is an undiscovered vertex. When a vertex is initially discovered it is colored gray, and when BFS has completely explored a vertex it is colored black. This means that once a vertex is colored black, it has no white vertices adjacent to it. A gray node, on the other hand, may have some white vertices adjacent to it, indicating that there are still additional vertices to explore.</p> <p>The breadth-first search algorithm shown in <code>Listing 2</code> below uses the adjacency list graph representation we developed earlier. In addition it uses a <code>Queue</code>, a crucial point as we will see, to decide which vertex to explore next.</p> Listing 2<pre><code>from pythonds3.basic import Queue\nfrom pythonds3.graphs import Graph\n\n\ndef bfs(start):\n    start.distance = 0\n    start.previous = None\n    vert_queue = Queue()\n    vert_queue.enqueue(start)\n    while vert_queue.size() &gt; 0:\n        current = vert_queue.dequeue()\n        for neighbor in current.get_neighbors():\n            if neighbor.color == \"white\":\n                neighbor.color = \"gray\"\n                neighbor.distance = current.distance + 1\n                neighbor.previous = current\n                vert_queue.enqueue(neighbor)\n        current.color = \"black\"\n</code></pre> <p>The BFS algorithm uses an extended version of the <code>Vertex</code> class that adds three new instance variables: <code>distance</code>, <code>previous</code>, and <code>color</code>. Each of these instance variables also has the appropriate getter and setter methods. The code for this expanded <code>Vertex</code> class is included in the <code>pythonds3</code> package, but we will not show it to you here as there is nothing new to learn by seeing the additional instance variables.</p> <p>BFS begins at the starting vertex <code>start</code> and paints it gray to show that it is currently being explored. Two other values, the <code>distance</code> and the <code>previous</code>, are initialized to 0 and <code>None</code> respectively for the starting vertex. Finally, <code>start</code> is placed on a <code>Queue</code>. The next step is to begin to systematically explore vertices at the front of the queue. We explore each new node at the front of the queue by iterating over its adjacency list. As each node on the adjacency list is examined, its color is checked. If it is white, the vertex is unexplored, and four things happen:</p> <ol> <li>The new unexplored vertex <code>neighbor</code> is colored gray.</li> <li>The predecessor of <code>neighbor</code> is set to the current node <code>current</code>.</li> <li>The distance to <code>neighbor</code> is set to the distance to <code>current + 1</code>.</li> <li><code>neighbor</code> is added to the end of a queue. Adding <code>neighbor</code> to the end of the queue effectively schedules this node for further exploration, but not until all the other vertices on the adjacency list of <code>current</code> have been explored.</li> </ol> <p>Let\u2019s look at how the <code>bfs</code> function would construct the breadth-first tree corresponding to the graph in <code>Figure 1</code>. Starting from FOOL we take all nodes that are adjacent to FOOL and add them to the tree. The adjacent nodes include POOL, FOIL, FOUL, and COOL. Each of these nodes are added to the queue of new nodes to expand. <code>Figure 3</code> shows the state of the in-progress tree along with the queue after this step.</p> <p> Figure 3: The First Step in the Breadth-First Search </p> <p>In the next step <code>bfs</code> removes the next node (POOL) from the front of the queue and repeats the process for all of its adjacent nodes. However, when <code>bfs</code> examines the node COOL, it finds that the color of COOL has already been changed to gray. This indicates that there is a shorter path to COOL and that COOL is already on the queue for further expansion. The only new node added to the queue while examining POOL is POLL. The new state of the tree and queue is shown in <code>Figure 4</code>.</p> <p> Figure 4: The Second Step in the Breadth-First Search </p> <p>The next vertex on the queue is FOIL. The only new node that FOIL can add to the tree is FAIL. As <code>bfs</code> continues to process the queue, neither of the next two nodes adds anything new to the queue or the tree. <code>Figure 5</code> shows the tree and the queue after expanding all the vertices on the second level of the tree.</p> <p> Figure 5: Breadth-First Search Tree After Completing One Level </p> <p> FIgure 6: Final Breadth-First Search Tree  </p> <p>You should continue to work through the algorithm on your own so that you are comfortable with how it works. <code>Figure 6</code> shows the final breadth-first search tree after all the vertices in <code>Figure 3</code> have been expanded. The amazing thing about the breadth-first search solution is that we have not only solved the FOOL\u2013SAGE problem we started out with, but we have solved many other problems along the way. We can start at any vertex in the breadth-first search tree and follow the predecessor arrows back to the root to find the shortest word ladder from any word back to FOOL. The function below (<code>Listing 3</code>) shows how to follow the predecessor links to print out the word ladder.</p> Listing 3<pre><code>def traverse(starting_vertex):\n    current = starting_vertex\n    while current:\n        print(current.key)\n        current = current.previous\n\ntraverse(g.get_vertex(\"sage\"))\n</code></pre>"},{"location":"c8/","title":"8. \u9ad8\u7ea7\u4e3b\u9898","text":"<p>8. Advanced Topics</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>8.1. \u76ee\u6807</li> <li>8.2. Python\u5217\u8868\u518d\u63a2</li> <li>8.3. \u9012\u5f52\u518d\u63a2<ul> <li>8.3.1. \u6a21\u8fd0\u7b97\u5b9a\u7406</li> <li>8.3.2. \u6a21\u5e42\u8fd0\u7b97</li> <li>8.3.3. \u6700\u5927\u516c\u7ea6\u6570\u4e0e\u4e58\u6cd5\u9006\u5143</li> <li>8.3.4. RSA\u7b97\u6cd5</li> </ul> </li> <li>8.4. \u5b57\u5178\u518d\u63a2\uff1a\u8df3\u8868<ul> <li>8.4.1. Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b</li> <li>8.4.2. \u7528Python\u5b9e\u73b0\u5b57\u5178</li> </ul> </li> <li>8.5. \u6811\u518d\u63a2\uff1a\u56fe\u50cf\u91cf\u5316<ul> <li>8.5.1. \u6570\u5b57\u56fe\u50cf\u5feb\u901f\u56de\u987e</li> <li>8.5.2. \u56fe\u50cf\u91cf\u5316</li> <li>8.5.3. \u4f7f\u7528\u516b\u53c9\u6811\u7684\u6539\u8fdb\u91cf\u5316\u7b97\u6cd5</li> </ul> </li> <li>8.6. \u56fe\u518d\u63a2\uff1a\u6a21\u5f0f\u5339\u914d<ul> <li>8.6.1. \u751f\u7269\u5b57\u7b26\u4e32</li> <li>8.6.2. \u7b80\u5355\u6bd4\u8f83</li> <li>8.6.3. \u4f7f\u7528\u56fe\uff1a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a</li> <li>8.6.4. \u4f7f\u7528\u56fe\uff1aKnuth-Morris-Pratt\u7b97\u6cd5</li> </ul> </li> </ul> <ul> <li>8.1. Objectives</li> <li>8.2. Python Lists Revisited</li> <li>8.3. Recursion Revisited<ul> <li>8.3.1. Modular Arithmetic Theorems</li> <li>8.3.2. Modular Exponentiation</li> <li>8.3.3. The Greatest Common Divisor and Multiplicative Inverses</li> <li>8.3.4. RSA Algorithm</li> </ul> </li> <li>8.4. Dictionaries Revisited: Skip Lists<ul> <li>8.4.1. The Map Abstract Data Type</li> <li>8.4.2. Implementing a Dictionary in Python</li> </ul> </li> <li>8.5. Trees Revisited: Quantizing Images<ul> <li>8.5.1. A Quick Review of Digital Images</li> <li>8.5.2. Quantizing an Image</li> <li>8.5.3. An Improved Quantization Algorithm Using Octrees</li> </ul> </li> <li>8.6. Graphs Revisited: Pattern Matching<ul> <li>8.6.1. Biological Strings</li> <li>8.6.2. Simple Comparison</li> <li>8.6.3. Using Graphs: Finite State Automata</li> <li>8.6.4. Using Graphs: Knuth-Morris-Pratt</li> </ul> </li> </ul>"},{"location":"c8/s1/","title":"8.1. \u76ee\u6807","text":"<p>8.1. Objectives</p> \u4e2d\u6587\u82f1\u6587 <ul> <li>To further explore and expand a number of the ideas presented earlier.</li> <li>To be able to implement a linked list.</li> <li>To understand the RSA algorithm for public key encryption using some recursive mathematical functions.</li> <li>To understand the expected behavior of a skip list as an alternative implementation for dictionaries.</li> <li>To understand octrees and their use in image processing.</li> <li>To understand string-matching as a graph problem.</li> </ul> <ul> <li>To further explore and expand a number of the ideas presented earlier.</li> <li>To be able to implement a linked list.</li> <li>To understand the RSA algorithm for public key encryption using some recursive mathematical functions.</li> <li>To understand the expected behavior of a skip list as an alternative implementation for dictionaries.</li> <li>To understand octrees and their use in image processing.</li> <li>To understand string-matching as a graph problem.</li> </ul>"},{"location":"c8/s2/","title":"8.2. Python\u5217\u8868\u518d\u63a2","text":"<p>8.2. Python Lists Revisited</p> \u4e2d\u6587\u82f1\u6587 <p>In Chapter\u00a0analysis we introduced some Big-O performance limits on Python\u2019s list data type. However, we did not yet have the knowledge necessary to understand how Python implements its list data type. in Chapter\u00a0basic-data-structures you learned how to implement a linked list using the nodes and references pattern. However, the nodes and references implementation still did not match the performance of the Python list. In this section we will look at the principles behind the Python list implementation. It is important to recognize that this implementation is not going to be the same as Python\u2019s since the real Python list is implemented in the C programming language. The idea in this section is to use Python to demonstrate the key ideas, not to replace the C implementation.</p> <p>The key to Python\u2019s implementation of a list is to use a data type called an array common to C, C++, Java, and many other programming languages. The array is very simple and is only capable of storing one kind of data. For example, you could have an array of integers or an array of floating point numbers, but you cannot mix the two in a single array. The array only supports two operations: indexing and assignment to an array index.</p> <p>The best way to think about an array is that it is one continuous block of bytes in the computer\u2019s memory. This block is divided up into \\(n\\)-byte chunks where \\(n\\) is based on the data type that is stored in the array. <code>Figure\u00a01</code> illustrates the idea of an array that is sized to hold six floating point values.</p> <p> Figure\u00a01: An Array of Floating Point Numbers </p> <p>In Python, each floating point number uses 16 <sup>1</sup> bytes of memory. So the array in <code>Figure\u00a01</code> uses a total of 96 <sup>2</sup> bytes. The base address is the location in memory where the array starts. You have seen addresses before in Python for different objects that you have defined. For example: <code>&lt;__main__.Foo object at 0x5eca30&gt;</code> shows that the object <code>Foo</code> is stored at memory address <code>0x5eca30</code>. The address is very important because an array implements the index operator using a very simple calculation:</p> <pre><code>item_address = base_address + index * size_of_object\n</code></pre> <p>For example, suppose that our array starts at location <code>0x000040</code>, which is 64 in decimal. To calculate the location of the object at position 4 in the array we simply do the arithmetic: \\(64 + 4 \\cdot 8 = 96\\). Clearly this kind of calculation is \\(O(1)\\). Of course this comes with some risks. First, since the size of an array is fixed, one cannot just add things on to the end of the array indefinitely without some serious consequences. Second, in some languages, like C, the bounds of the array are not even checked, so even though your array has only six elements in it, assigning a value to index 7 will not result in a runtime error. As you might imagine this can cause big problems that are hard to track down. In the Linux operating system, accessing a value that is beyond the boundaries of an array will often produce the rather uninformative error message \u201csegmentation violation.\u201d</p> <p>The general strategy that Python uses to implement a linked list using an array is as follows:</p> <ul> <li> <p>Python uses an array that holds references (called pointers in C) to other objects.</p> </li> <li> <p>Python uses a strategy called over-allocation to allocate an array with space for more objects than is needed initially.</p> </li> <li> <p>When the initial array is finally filled up, a new, bigger array is over-allocated and the contents of the old array are copied to the new array.</p> </li> </ul> <p>The implications of this strategy are pretty amazing. Let\u2019s look at what they are first before we dive into the implementation or prove anything.</p> <ul> <li>Accessing an itema at a specific location is \\(O(1)\\).</li> <li>Appending to the list is \\(O(1)\\) on average, but \\(O(n)\\) in the worst case.</li> <li>Popping from the end of the list is \\(O(1)\\).</li> <li>Deleting an item from the list is \\(O(n)\\).</li> <li>Inserting an item into an arbitrary position is \\(O(n)\\).</li> </ul> <p>Let\u2019s look at how the strategy outlined above works for a very simple implementation. To begin, we will only implement the constructor, a <code>__resize</code> method, and the <code>append</code> method. We will call this class <code>ArrayList</code>. In the constructor we will need to initialize two instance variables. The first will keep track of the size of the current array; we will call this <code>max_size</code>. The second instance variable will keep track of the current end of the list; we will call this one <code>last_index</code>. Since Python does not have an array data type, we will use a list to simulate an array. Listing\u00a0<code>[lst_arraylistinit]</code> contains the code for the first three methods of <code>ArrayList</code>. Notice that the constructor method initializes the two instance variables described above and then creates a zero element array called <code>my_array</code>. The constructor also creates an instance variable called <code>size_exponent</code>. We will understand how this variable is used shortly.</p> <pre><code>class ArrayList:\n    def __init__(self):\n        self.size_exponent = 0\n        self.max_size = 0\n        self.last_index = 0\n        self.my_array = []\n\n    def append(self, val):\n        if self.last_index &gt; self.max_size - 1:\n            self.__resize()\n        self.my_array[self.last_index] = val\n        self.last_index += 1\n\n    def __resize(self):\n        new_size = 2 ** self.size_exponent\n        print(\"new_size = \", new_size)\n        new_array = [0] * new_size\n        for i in range(self.max_size):  \n            new_array[i] = self.my_array[i]\n\n        self.max_size = new_size\n        self.my_array = new_array\n        self.size_exponent += 1\n</code></pre> <p>Next, we will implement the <code>append</code> method. The first thing <code>append</code> does is test for the condition where <code>last_index</code> is greater than the number of available index positions in the array (line\u00a0<code>[line:9]</code>). If this is the case then <code>__resize</code> is called. Notice that we are using the double underscore convention to make the <code>resize</code> method private. Once the array is resized the new value is added to the list at <code>last_index</code>, and <code>last_index</code> is incremented by one.</p> <p>The <code>resize</code> method calculates a new size for the array using \\(2 ^ {size\\_exponent}\\). There are many methods that could be used for resizing the array. Some implementations double the size of the array every time as we do here, some use a multiplier of 1.5, and some use powers of two. Python uses a multiplier of 1.125 plus a constant. The Python developers designed this strategy as a good tradeoff for computers of varying CPU and memory speeds. The Python strategy leads to a sequence of array sizes of \\(0, 4, 8, 16, 24, 32, 40, 52, 64, 76\\ldots\\) . Doubling the array size leads to a bit more wasted space at any one time, but is much easier to analyze. Once a new array has been allocated, the values from the old list must be copied into the new array; this is done in the loop starting on line\u00a0<code>[line:19]</code>. Finally the values <code>max_size</code> and <code>last_index</code> must be updated, <code>size_exponent</code> must be incremented, and <code>new_array</code> is saved as <code>self.my_array</code>. In a language like C the old block of memory referenced by <code>self.my_array</code> would be explicitly returned to the system for reuse. However, recall that in Python objects that are no longer referenced are automatically cleaned up by the garbage collection algorithm.</p> <p>Before we move on let\u2019s analyze why this strategy gives us an average \\(O(1)\\) performance for <code>append</code>. The key is to notice that most of the time the cost to append an item \\(c_i\\) is 1. The only time that the operation is more expensive is when <code>last_index</code> is a power of 2. When <code>last_index</code> is a power of 2 then the cost to append an item is \\(O(last\\_index)\\). We can summarize the cost to insert the \\(i_{th}\\) item as follows:</p> \\[    c_i =    \\begin{cases}      i \\text{ if } i \\text{ is a power of 2} \\\\      1 \\text{ otherwise}    \\end{cases} \\] <p>Since the expensive cost of copying <code>last_index</code> items occurs relatively infrequently we spread the cost out, or amortize, the cost of insertion over all of the appends. When we do this the cost of any one insertion averages out to \\(O(1)\\). For example, consider the case where you have already appended four items. Each of these four appends costs you just one operation to store in the array that was already allocated to hold four items. When the fifth item is added a new array of size 8 is allocated and the four old items are copied. But now you have room in the array for four additional low cost appends. Mathematically we can show this as follows:</p> \\[    \\begin{aligned}      cost_{total} &amp;= n + \\sum_{j=0}^{\\log_2{n}}{2^j}  \\\\                &amp;= n + 2n \\\\                &amp;= 3n\\end{aligned} \\] <p>The summation in the previous equation may not be obvious to you, so let\u2019s think about that a bit more. The sum goes from zero to \\(\\log_2{n}\\). The upper bound on the summation tells us how many times we need to double the size of the array. The term \\(2^j\\) accounts for the copies that we need to do when the array is doubled. Since the total cost to append n items is \\(3n\\), the cost for a single item is \\(3n/n = 3\\). Because the cost is a constant we say that it is \\(O(1)\\). This kind of analysis is called amortized analysis and is very useful in analyzing more advanced algorithms.</p> <p>Next, let us turn to the index operators. Listing\u00a0<code>[lst_arrindex]</code> shows our Python implementation for index and assignment to an array location. Recall that we discussed above that the calculation required to find the memory location of the \\(i_{th}\\) item in an array is a simple \\(O(1)\\) arithmetic expression. Even languages like C hide that calculation behind a nice array index operator, so in this case the C and the Python look very much the same. In fact, in Python it is very difficult to get the actual memory location of an object for use in a calculation like this so we will just rely on list\u2019s built-in index operator. To confirm this, you can always get the Python source code and look at the file <code>listobject.c</code>.</p> <pre><code>def __getitem__(self, idx):\n    if idx &lt; self.last_index:\n        return self.my_array[idx]\n    raise LookupError(\"index out of bounds\")\n\ndef __setitem__(self, idx, val):\n    if idx &lt; self.last_index:\n        self.my_array[idx] = val\n    raise LookupError(\"index out of bounds\")\n</code></pre> <p>Finally, let\u2019s take a look at one of the more expensive list operations, insertion. When we insert an item into an <code>ArrayList</code> we will need to first shift everything in the list at the insertion point and beyond ahead by one index position in order to make room for the item we are inserting. The process is illustrated in <code>Figure\u00a02</code>.</p> <p> Figure\u00a02: Inserting 27.1 at Index 2 in an ArrayList </p> <p>The key to implementing <code>insert</code> correctly is to realize that as you are shifting values in the array you do not want to overwrite any important data. The way to do this is to work from the end of the list back toward the insertion point, copying data forward. Our implementation of <code>insert</code> is shown in Listing\u00a0<code>[lst_arrlistins]</code>. Note how the <code>range</code> is set up on line\u00a0<code>[line:4]</code> to ensure that we are copying existing data into the unused part of the array first, and then subsequent values are copied over old values that have already been shifted. If the loop had started at the insertion point and copied that value to the next larger index position in the array, the old value would have been lost forever.</p> <pre><code>def insert(self, idx, val):\n    if self.last_index &gt; self.max_size - 1:\n        self.__resize()\n    for i in range(self.last_index, idx - 1, -1):\n        self.my_array[i + 1] = self.my_array[i]\n    self.last_index += 1\n    self.my_array[idx] = val\n</code></pre> <p>The performance of the insert is \\(O(n)\\) since in the worst case we want to insert something at index 0 and we have to shift the entire array forward by one. On average we will only need to shift half of the array, but this is still \\(O(n)\\). You may want to go back to Chapter\u00a0basicds and remind yourself how all of these list operations are done using nodes and references. Neither implementation is right or wrong; they just have different performance guarantees that may be better or worse depending on the kind of application you are writing. In particular, do you intend to add items to the beginning of the list most often, or does your application add items to the end of the list? Will you be deleting items from the list or only adding new items to the list?</p> <p>There are several other interesting operations that we have not yet implemented for our <code>ArrayList</code> including: <code>pop</code>, <code>del</code>, <code>index</code>, and making the <code>ArrayList</code> iterable. We leave these enhancements to the <code>ArrayList</code> as an exercise for you.</p> <p>In Chapter\u00a0analysis we introduced some Big-O performance limits on Python\u2019s list data type. However, we did not yet have the knowledge necessary to understand how Python implements its list data type. in Chapter\u00a0basic-data-structures you learned how to implement a linked list using the nodes and references pattern. However, the nodes and references implementation still did not match the performance of the Python list. In this section we will look at the principles behind the Python list implementation. It is important to recognize that this implementation is not going to be the same as Python\u2019s since the real Python list is implemented in the C programming language. The idea in this section is to use Python to demonstrate the key ideas, not to replace the C implementation.</p> <p>The key to Python\u2019s implementation of a list is to use a data type called an array common to C, C++, Java, and many other programming languages. The array is very simple and is only capable of storing one kind of data. For example, you could have an array of integers or an array of floating point numbers, but you cannot mix the two in a single array. The array only supports two operations: indexing and assignment to an array index.</p> <p>The best way to think about an array is that it is one continuous block of bytes in the computer\u2019s memory. This block is divided up into \\(n\\)-byte chunks where \\(n\\) is based on the data type that is stored in the array. <code>Figure\u00a01</code> illustrates the idea of an array that is sized to hold six floating point values.</p> <p> Figure\u00a01: An Array of Floating Point Numbers </p> <p>In Python, each floating point number uses 16 <sup>1</sup> bytes of memory. So the array in <code>Figure\u00a01</code> uses a total of 96 <sup>2</sup> bytes. The base address is the location in memory where the array starts. You have seen addresses before in Python for different objects that you have defined. For example: <code>&lt;__main__.Foo object at 0x5eca30&gt;</code> shows that the object <code>Foo</code> is stored at memory address <code>0x5eca30</code>. The address is very important because an array implements the index operator using a very simple calculation:</p> <pre><code>item_address = base_address + index * size_of_object\n</code></pre> <p>For example, suppose that our array starts at location <code>0x000040</code>, which is 64 in decimal. To calculate the location of the object at position 4 in the array we simply do the arithmetic: \\(64 + 4 \\cdot 8 = 96\\). Clearly this kind of calculation is \\(O(1)\\). Of course this comes with some risks. First, since the size of an array is fixed, one cannot just add things on to the end of the array indefinitely without some serious consequences. Second, in some languages, like C, the bounds of the array are not even checked, so even though your array has only six elements in it, assigning a value to index 7 will not result in a runtime error. As you might imagine this can cause big problems that are hard to track down. In the Linux operating system, accessing a value that is beyond the boundaries of an array will often produce the rather uninformative error message \u201csegmentation violation.\u201d</p> <p>The general strategy that Python uses to implement a linked list using an array is as follows:</p> <ul> <li> <p>Python uses an array that holds references (called pointers in C) to other objects.</p> </li> <li> <p>Python uses a strategy called over-allocation to allocate an array with space for more objects than is needed initially.</p> </li> <li> <p>When the initial array is finally filled up, a new, bigger array is over-allocated and the contents of the old array are copied to the new array.</p> </li> </ul> <p>The implications of this strategy are pretty amazing. Let\u2019s look at what they are first before we dive into the implementation or prove anything.</p> <ul> <li>Accessing an itema at a specific location is \\(O(1)\\).</li> <li>Appending to the list is \\(O(1)\\) on average, but \\(O(n)\\) in the worst case.</li> <li>Popping from the end of the list is \\(O(1)\\).</li> <li>Deleting an item from the list is \\(O(n)\\).</li> <li>Inserting an item into an arbitrary position is \\(O(n)\\).</li> </ul> <p>Let\u2019s look at how the strategy outlined above works for a very simple implementation. To begin, we will only implement the constructor, a <code>__resize</code> method, and the <code>append</code> method. We will call this class <code>ArrayList</code>. In the constructor we will need to initialize two instance variables. The first will keep track of the size of the current array; we will call this <code>max_size</code>. The second instance variable will keep track of the current end of the list; we will call this one <code>last_index</code>. Since Python does not have an array data type, we will use a list to simulate an array. Listing\u00a0<code>[lst_arraylistinit]</code> contains the code for the first three methods of <code>ArrayList</code>. Notice that the constructor method initializes the two instance variables described above and then creates a zero element array called <code>my_array</code>. The constructor also creates an instance variable called <code>size_exponent</code>. We will understand how this variable is used shortly.</p> <pre><code>class ArrayList:\n    def __init__(self):\n        self.size_exponent = 0\n        self.max_size = 0\n        self.last_index = 0\n        self.my_array = []\n\n    def append(self, val):\n        if self.last_index &gt; self.max_size - 1:\n            self.__resize()\n        self.my_array[self.last_index] = val\n        self.last_index += 1\n\n    def __resize(self):\n        new_size = 2 ** self.size_exponent\n        print(\"new_size = \", new_size)\n        new_array = [0] * new_size\n        for i in range(self.max_size):\n            new_array[i] = self.my_array[i]\n\n        self.max_size = new_size\n        self.my_array = new_array\n        self.size_exponent += 1\n</code></pre> <p>Next, we will implement the <code>append</code> method. The first thing <code>append</code> does is test for the condition where <code>last_index</code> is greater than the number of available index positions in the array (line\u00a0<code>[line:9]</code>). If this is the case then <code>__resize</code> is called. Notice that we are using the double underscore convention to make the <code>resize</code> method private. Once the array is resized the new value is added to the list at <code>last_index</code>, and <code>last_index</code> is incremented by one.</p> <p>The <code>resize</code> method calculates a new size for the array using \\(2 ^ {size\\_exponent}\\). There are many methods that could be used for resizing the array. Some implementations double the size of the array every time as we do here, some use a multiplier of 1.5, and some use powers of two. Python uses a multiplier of 1.125 plus a constant. The Python developers designed this strategy as a good tradeoff for computers of varying CPU and memory speeds. The Python strategy leads to a sequence of array sizes of \\(0, 4, 8, 16, 24, 32, 40, 52, 64, 76\\ldots\\) . Doubling the array size leads to a bit more wasted space at any one time, but is much easier to analyze. Once a new array has been allocated, the values from the old list must be copied into the new array; this is done in the loop starting on line\u00a0<code>[line:19]</code>. Finally the values <code>max_size</code> and <code>last_index</code> must be updated, <code>size_exponent</code> must be incremented, and <code>new_array</code> is saved as <code>self.my_array</code>. In a language like C the old block of memory referenced by <code>self.my_array</code> would be explicitly returned to the system for reuse. However, recall that in Python objects that are no longer referenced are automatically cleaned up by the garbage collection algorithm.</p> <p>Before we move on let\u2019s analyze why this strategy gives us an average \\(O(1)\\) performance for <code>append</code>. The key is to notice that most of the time the cost to append an item \\(c_i\\) is 1. The only time that the operation is more expensive is when <code>last_index</code> is a power of 2. When <code>last_index</code> is a power of 2 then the cost to append an item is \\(O(last\\_index)\\). We can summarize the cost to insert the \\(i_{th}\\) item as follows:</p> \\[    c_i =    \\begin{cases}      i \\text{ if } i \\text{ is a power of 2} \\\\      1 \\text{ otherwise}    \\end{cases} \\] <p>Since the expensive cost of copying <code>last_index</code> items occurs relatively infrequently we spread the cost out, or amortize, the cost of insertion over all of the appends. When we do this the cost of any one insertion averages out to \\(O(1)\\). For example, consider the case where you have already appended four items. Each of these four appends costs you just one operation to store in the array that was already allocated to hold four items. When the fifth item is added a new array of size 8 is allocated and the four old items are copied. But now you have room in the array for four additional low cost appends. Mathematically we can show this as follows:</p> \\[    \\begin{aligned}      cost_{total} &amp;= n + \\sum_{j=0}^{\\log_2{n}}{2^j}  \\\\                &amp;= n + 2n \\\\                &amp;= 3n\\end{aligned} \\] <p>The summation in the previous equation may not be obvious to you, so let\u2019s think about that a bit more. The sum goes from zero to \\(\\log_2{n}\\). The upper bound on the summation tells us how many times we need to double the size of the array. The term \\(2^j\\) accounts for the copies that we need to do when the array is doubled. Since the total cost to append n items is \\(3n\\), the cost for a single item is \\(3n/n = 3\\). Because the cost is a constant we say that it is \\(O(1)\\). This kind of analysis is called amortized analysis and is very useful in analyzing more advanced algorithms.</p> <p>Next, let us turn to the index operators. Listing\u00a0<code>[lst_arrindex]</code> shows our Python implementation for index and assignment to an array location. Recall that we discussed above that the calculation required to find the memory location of the \\(i_{th}\\) item in an array is a simple \\(O(1)\\) arithmetic expression. Even languages like C hide that calculation behind a nice array index operator, so in this case the C and the Python look very much the same. In fact, in Python it is very difficult to get the actual memory location of an object for use in a calculation like this so we will just rely on list\u2019s built-in index operator. To confirm this, you can always get the Python source code and look at the file <code>listobject.c</code>.</p> <pre><code>def __getitem__(self, idx):\n    if idx &lt; self.last_index:\n        return self.my_array[idx]\n    raise LookupError(\"index out of bounds\")\n\ndef __setitem__(self, idx, val):\n    if idx &lt; self.last_index:\n        self.my_array[idx] = val\n    raise LookupError(\"index out of bounds\")\n</code></pre> <p>Finally, let\u2019s take a look at one of the more expensive list operations, insertion. When we insert an item into an <code>ArrayList</code> we will need to first shift everything in the list at the insertion point and beyond ahead by one index position in order to make room for the item we are inserting. The process is illustrated in <code>Figure\u00a02</code>.</p> <p> Figure\u00a02: Inserting 27.1 at Index 2 in an ArrayList </p> <p>The key to implementing <code>insert</code> correctly is to realize that as you are shifting values in the array you do not want to overwrite any important data. The way to do this is to work from the end of the list back toward the insertion point, copying data forward. Our implementation of <code>insert</code> is shown in Listing\u00a0<code>[lst_arrlistins]</code>. Note how the <code>range</code> is set up on line\u00a0<code>[line:4]</code> to ensure that we are copying existing data into the unused part of the array first, and then subsequent values are copied over old values that have already been shifted. If the loop had started at the insertion point and copied that value to the next larger index position in the array, the old value would have been lost forever.</p> <pre><code>def insert(self, idx, val):\n    if self.last_index &gt; self.max_size - 1:\n        self.__resize()\n    for i in range(self.last_index, idx - 1, -1):\n        self.my_array[i + 1] = self.my_array[i]\n    self.last_index += 1\n    self.my_array[idx] = val\n</code></pre> <p>The performance of the insert is \\(O(n)\\) since in the worst case we want to insert something at index 0 and we have to shift the entire array forward by one. On average we will only need to shift half of the array, but this is still \\(O(n)\\). You may want to go back to Chapter\u00a0basicds and remind yourself how all of these list operations are done using nodes and references. Neither implementation is right or wrong; they just have different performance guarantees that may be better or worse depending on the kind of application you are writing. In particular, do you intend to add items to the beginning of the list most often, or does your application add items to the end of the list? Will you be deleting items from the list or only adding new items to the list?</p> <p>There are several other interesting operations that we have not yet implemented for our <code>ArrayList</code> including: <code>pop</code>, <code>del</code>, <code>index</code>, and making the <code>ArrayList</code> iterable. We leave these enhancements to the <code>ArrayList</code> as an exercise for you.</p> <ol> <li> <p>8 bytes reference count + 8 bytes pointer to the type object + 8 bytes of data = 24\u00a0\u21a9\u21a9</p> </li> <li> <p>sys.getsizeof([3.1415, 2.189, 0.0, 0.0, 9.87]) is 104\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"c8/s3/","title":"8.3. \u9012\u5f52\u518d\u63a2","text":"<p>8.3. Recursion Revisited</p> \u4e2d\u6587\u82f1\u6587 <p>One of the most common uses of numerical computing today is in the field of cryptography. Each time you check your bank account, sign on to a secure website to purchase something, or sign on to your computer, you are using cryptography. In a general sense, cryptography is concerned with encrypting and decrypting information that you do not want other people to see. In this section we will look at some functions that are used in everyday cryptographic programming. In practice there may be faster ways to implement these functions, but each of them has an interesting recursive implementation.</p> <p>The algorithms in this section make use of Python\u2019s modulo operator (%). Remember that \\(a \\% b\\)` is what is left over after \\(a\\) is divided by \\(b\\), for example \\(10 \\% 7 = 3\\). When we compute the result of any mathematical expression modulo 10, the only possible results are 0\u20139.</p> <p>One of the earliest forms of cryptography used only simple modular arithmetic. Take the string <code>\"uryybjbeyq\"</code>, for example. Can you guess what message is encrypted? <code>Listing\u00a0lst_enc</code> shows you the function that produced the message. Look at the listing and see if you can figure it out.</p> Listing\u00a0lst_enc<pre><code>def encrypt(m):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    n = \"\"\n    for i in m:\n        j = (s.find(i) + 13) % 26\n        n = n + s[j]\n    return n\n</code></pre> <p>The <code>encrypt</code> function illustrates a form of encryption known as the Caesar Cipher. It also goes by the name ROT13, which is a bit more descriptive. <code>encrypt</code> simply takes each letter in the message and adds 13 to its ordinal position in the alphabet. If the position goes past the end of the alphabet, it wraps around. This wraparound function is easily accomplished using the modulo operator. In addition, since there are 26 letters in the alphabet, this function is symmetric. The symmetry allows us to use the function to encrypt and decrypt the same message. If you pass the string <code>\"uryybjbeyg\"</code> to the <code>encrypt</code> function, it returns <code>\"helloworld\"</code>.</p> <p>Rotations by amounts other than 13 are possible; however, they are not symmetric with respect to encrypting and decrypting. Asymmetry would require us to write a separate decryption algorithm that subtracts the amount to rotate. In that case, we could generalize both the <code>encrypt</code> and <code>decrypt</code> functions to take the amount of rotation as a parameter. In cryptographic terms, the rotation parameter is called the key and would be the number of positions to rotate. Given the message and the key, the encryption and decryption algorithms can do their jobs. <code>Listing\u00a0lst_dec_key</code> shows the decryption algorithm that takes the amount of rotation as a parameter. As an exercise you should be able to modify <code>Listing\u00a0lst_enc</code> to accept a parameter that specifies a key.</p> Listing lst_dec_key<pre><code>   def decrypt(m, k):\n       s = \"abcdefghijklmnopqrstuvwxyz\"\n       n = \"\"\n       for i in m:\n           j = (s.find(i) + 26 - k) % 26\n           n = n + s[j]\n       return n\n</code></pre> <p>Even if you keep the number <code>k</code> from everyone except the person you are sending the message to, this simple form of encryption is not going to stop anyone from stealing your secrets for very long. In the remainder of this section, we will build up to a much more secure form of encryption, the RSA public key encryption algorithm.</p> <p>One of the most common uses of numerical computing today is in the field of cryptography. Each time you check your bank account, sign on to a secure website to purchase something, or sign on to your computer, you are using cryptography. In a general sense, cryptography is concerned with encrypting and decrypting information that you do not want other people to see. In this section we will look at some functions that are used in everyday cryptographic programming. In practice there may be faster ways to implement these functions, but each of them has an interesting recursive implementation.</p> <p>The algorithms in this section make use of Python\u2019s modulo operator (%). Remember that \\(a \\% b\\)` is what is left over after \\(a\\) is divided by \\(b\\), for example \\(10 \\% 7 = 3\\). When we compute the result of any mathematical expression modulo 10, the only possible results are 0\u20139.</p> <p>One of the earliest forms of cryptography used only simple modular arithmetic. Take the string <code>\"uryybjbeyq\"</code>, for example. Can you guess what message is encrypted? <code>Listing\u00a0lst_enc</code> shows you the function that produced the message. Look at the listing and see if you can figure it out.</p> Listing\u00a0lst_enc<pre><code>def encrypt(m):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    n = \"\"\n    for i in m:\n        j = (s.find(i) + 13) % 26\n        n = n + s[j]\n    return n\n</code></pre> <p>The <code>encrypt</code> function illustrates a form of encryption known as the Caesar Cipher. It also goes by the name ROT13, which is a bit more descriptive. <code>encrypt</code> simply takes each letter in the message and adds 13 to its ordinal position in the alphabet. If the position goes past the end of the alphabet, it wraps around. This wraparound function is easily accomplished using the modulo operator. In addition, since there are 26 letters in the alphabet, this function is symmetric. The symmetry allows us to use the function to encrypt and decrypt the same message. If you pass the string <code>\"uryybjbeyg\"</code> to the <code>encrypt</code> function, it returns <code>\"helloworld\"</code>.</p> <p>Rotations by amounts other than 13 are possible; however, they are not symmetric with respect to encrypting and decrypting. Asymmetry would require us to write a separate decryption algorithm that subtracts the amount to rotate. In that case, we could generalize both the <code>encrypt</code> and <code>decrypt</code> functions to take the amount of rotation as a parameter. In cryptographic terms, the rotation parameter is called the key and would be the number of positions to rotate. Given the message and the key, the encryption and decryption algorithms can do their jobs. <code>Listing\u00a0lst_dec_key</code> shows the decryption algorithm that takes the amount of rotation as a parameter. As an exercise you should be able to modify <code>Listing\u00a0lst_enc</code> to accept a parameter that specifies a key.</p> Listing lst_dec_key<pre><code>   def decrypt(m, k):\n       s = \"abcdefghijklmnopqrstuvwxyz\"\n       n = \"\"\n       for i in m:\n           j = (s.find(i) + 26 - k) % 26\n           n = n + s[j]\n       return n\n</code></pre> <p>Even if you keep the number <code>k</code> from everyone except the person you are sending the message to, this simple form of encryption is not going to stop anyone from stealing your secrets for very long. In the remainder of this section, we will build up to a much more secure form of encryption, the RSA public key encryption algorithm.</p>"},{"location":"c8/s3/#831-\u6a21\u8fd0\u7b97\u5b9a\u7406","title":"8.3.1. \u6a21\u8fd0\u7b97\u5b9a\u7406","text":"<p>8.3.1. Modular Arithmetic Theorems</p> \u4e2d\u6587\u82f1\u6587 <p>If two numbers, \\(a\\) and \\(b\\), give the same remainder when divided by \\(n\\), we say that \\(a\\) and \\(b\\) are \u201ccongruent modulo \\(n\\).\u201d In shorthand we write \\(a \\equiv~b~\\pmod{n}\\). The algorithms in this section make use of three important theorems:</p> <ol> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall c, a + c \\equiv b + c \\pmod{n}\\).</li> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall c, ac \\equiv bc \\pmod{n}\\).</li> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall p, p &gt; 0, a^p \\equiv b^p \\pmod{n}\\).</li> </ol> <p>If two numbers, \\(a\\) and \\(b\\), give the same remainder when divided by \\(n\\), we say that \\(a\\) and \\(b\\) are \u201ccongruent modulo \\(n\\).\u201d In shorthand we write \\(a \\equiv~b~\\pmod{n}\\). The algorithms in this section make use of three important theorems:</p> <ol> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall c, a + c \\equiv b + c \\pmod{n}\\).</li> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall c, ac \\equiv bc \\pmod{n}\\).</li> <li>If \\(a \\equiv b \\pmod{n}\\) then \\(\\forall p, p &gt; 0, a^p \\equiv b^p \\pmod{n}\\).</li> </ol>"},{"location":"c8/s3/#832-\u6a21\u5e42\u8fd0\u7b97","title":"8.3.2. \u6a21\u5e42\u8fd0\u7b97","text":"<p>8.3.2. Modular Exponentiation</p> \u4e2d\u6587\u82f1\u6587 <p>Suppose we wanted to know the last digit of \\(3^{1,254,906}\\). Not only is that a large computation problem, but using Python\u2019s arbitrary-precision integers the number has 598,743 digits! All we want to know is the value of the rightmost digit. There are really two problems here. First, how do we compute \\(x^n\\) efficiently? Second, how can we compute \\(x^n \\pmod{p}\\) without first calculating all 598,743 digits and then looking at the last one?</p> <p>The answer to the second question is easy, given the third theorem from above.</p> <ol> <li>Initialize result to 1.</li> <li> <p>Repeat \\(n\\) times:</p> </li> <li> <p>Multiply result by \\(x\\).</p> </li> <li>Apply modulo operation to result.</li> </ol> <p>The above approach makes the computation simpler because we are keeping the result smaller rather than following it out to its full precision. However, we can do even better using a recursive approach.</p> <p>\\(x^n = \\begin{cases} (x \\cdot x)^{ n/2 } &amp; \\text{if} \\space  n \\space  \\text{is even} \\\\ (x \\cdot x^{n-1}) = x \\cdot (x \\cdot x)^{\\lfloor n/2 \\rfloor} &amp; \\text{if} \\space  n \\space  \\text{is odd} \\end{cases} \\label{eqn:pow}\\)</p> <p>Remember that for a floating point number \\(n\\) the floor operation, \\(\\lfloor n \\rfloor\\), results in the largest integer smaller than \\(n\\). Python\u2019s integer division operator returns the floor of the result of the division, so we do not need to do anything special in our code to achieve the results we want. The above equation gives us a very nice recursive definition for computing \\(x^n\\). All we need now is a base case. Recall that for any number \\(x\\), \\(x^0 = 1\\). Since we are reducing the size of our exponent in each recursive call, checking for the condition \\(n = 0\\) is a good base case.</p> Listing lst_pow<pre><code>   def modexp(x, n, p):\n       if n == 0:\n           return 1\n       t = (x * x) % p\n       tmp = modexp(t, n // 2, p)\n       if n % 2 != 0:\n           tmp = (tmp * x) % p\n       return tmp\n</code></pre> <p>Notice that in the above equation both the even and odd cases include a factor of \\((x \\cdot x)^{\\lfloor n/2 \\rfloor}\\), so we compute that unconditionally and store it in the variable <code>tmp</code>. Also note that since we are computing modulo <code>p</code> we still apply the modulo operator at each step of the calculation. The solution in <code>Listing\u00a0lst_pow</code> keeps the result size small and uses many fewer multiplications than a purely iterative approach.</p> <p>Suppose we wanted to know the last digit of \\(3^{1,254,906}\\). Not only is that a large computation problem, but using Python\u2019s arbitrary-precision integers the number has 598,743 digits! All we want to know is the value of the rightmost digit. There are really two problems here. First, how do we compute \\(x^n\\) efficiently? Second, how can we compute \\(x^n \\pmod{p}\\) without first calculating all 598,743 digits and then looking at the last one?</p> <p>The answer to the second question is easy, given the third theorem from above.</p> <ol> <li>Initialize result to 1.</li> <li> <p>Repeat \\(n\\) times:</p> </li> <li> <p>Multiply result by \\(x\\).</p> </li> <li>Apply modulo operation to result.</li> </ol> <p>The above approach makes the computation simpler because we are keeping the result smaller rather than following it out to its full precision. However, we can do even better using a recursive approach.</p> <p>\\(x^n = \\begin{cases} (x \\cdot x)^{ n/2 } &amp; \\text{if} \\space  n \\space  \\text{is even} \\\\ (x \\cdot x^{n-1}) = x \\cdot (x \\cdot x)^{\\lfloor n/2 \\rfloor} &amp; \\text{if} \\space  n \\space  \\text{is odd} \\end{cases} \\label{eqn:pow}\\)</p> <p>Remember that for a floating point number \\(n\\) the floor operation, \\(\\lfloor n \\rfloor\\), results in the largest integer smaller than \\(n\\). Python\u2019s integer division operator returns the floor of the result of the division, so we do not need to do anything special in our code to achieve the results we want. The above equation gives us a very nice recursive definition for computing \\(x^n\\). All we need now is a base case. Recall that for any number \\(x\\), \\(x^0 = 1\\). Since we are reducing the size of our exponent in each recursive call, checking for the condition \\(n = 0\\) is a good base case.</p> Listing lst_pow<pre><code>   def modexp(x, n, p):\n       if n == 0:\n           return 1\n       t = (x * x) % p\n       tmp = modexp(t, n // 2, p)\n       if n % 2 != 0:\n           tmp = (tmp * x) % p\n       return tmp\n</code></pre> <p>Notice that in the above equation both the even and odd cases include a factor of \\((x \\cdot x)^{\\lfloor n/2 \\rfloor}\\), so we compute that unconditionally and store it in the variable <code>tmp</code>. Also note that since we are computing modulo <code>p</code> we still apply the modulo operator at each step of the calculation. The solution in <code>Listing\u00a0lst_pow</code> keeps the result size small and uses many fewer multiplications than a purely iterative approach.</p>"},{"location":"c8/s3/#833-\u6700\u5927\u516c\u7ea6\u6570\u4e0e\u4e58\u6cd5\u9006\u5143","title":"8.3.3. \u6700\u5927\u516c\u7ea6\u6570\u4e0e\u4e58\u6cd5\u9006\u5143","text":"<p>8.3.3. The Greatest Common Divisor and Multiplicative Inverses</p> \u4e2d\u6587\u82f1\u6587 <p>A multiplicative inverse of a positive integer \\(x\\) modulo \\(m\\) is any number \\(a\\) such that \\(ax \\equiv 1 \\pmod{m}\\). For example, let \\(x = 3\\), \\(m = 7\\), and \\(a = 5\\); \\(3 \\times 5 = 15\\) and \\(15\\ \\%\\ 7 = 1\\), so 5 is a multiplicative inverse of 3 modulo 7.</p> <p>The idea of multiplicative inverses in the world of modulo arithmetic may seem very confusing at first. How did we select 5 in the previous example? Is 5 the only multiplicative inverse of 3 modulo 7? Do all numbers \\(a\\) have a multiplicative inverse for any given \\(m\\)?</p> <p>Let\u2019s look at an example that may shed some light on the first question: how did we select 5 as the multiplicative inverse of 3 modulo 7? Look at the following Python session:</p> <pre><code>&gt;&gt;&gt; for i in range(1, 40):\n...    if (3 * i) % 7 == 1:\n...        print i\n...\n5\n12\n19\n26\n33\n</code></pre> <p>This little experiment tells us that there are many multiplicative inverses (modulo 7) for \\(x=3\\) and \\(m = 7\\), namely \\(5, 12, 19, 26, 33\\), and so on. Do you notice anything interesting about the sequence? Each number in the sequence is two less than a multiple of seven.</p> <p>Do all pairs of numbers \\(x\\) and \\(m\\) have a multiplicative inverse? Let\u2019s look at another example. Consider \\(x=4\\) and \\(m=8\\). Plugging 4 and 8 into the loop in the previous example gives us no output. If we take out the conditional and print out the results of \\((4 \\cdot i)\\ \\%\\ 8\\), we get the sequence \\((0, 4, 0, 4, 0, 4\\dots)\\). Here we have a case where the remainder alternates between 0 and 4 repeatedly. Clearly the result is never going to be 1. How can we know that ahead of time?</p> <p>The answer is that a number \\(x\\) has a multiplicative inverse, modulo \\(m\\), if and only if \\(m\\) and \\(x\\) are relatively prime. Two numbers are relatively prime if \\(gcd(m,x) = 1\\). Recall that the greatest common divisor (GCD) is the largest integer that divides both numbers. The next question is how can we compute the greatest common divisor for a pair of numbers?</p> <p>Given two numbers \\(a\\) and \\(b\\) we can find the GCD by repeatedly subtracting \\(b\\) from \\(a\\) until \\(a &lt; b\\). When \\(a &lt; b\\), we switch roles for \\(a\\) and \\(b\\). At some point \\(a - b\\) becomes 0, so we swap \\(a\\) and \\(b\\) one more time. At that point we have $gcd(a, 0) = a`. This algorithm was first described more than 2,000 years ago and is called Euclid\u2019s algorithm.</p> <p>In terms of recursive algorithm design, Euclid\u2019s algorithm is very straightforward. The base case is when \\(b = 0\\). There are two possibilities for a recursive call: when \\(a &lt; b\\), we swap \\(a\\) and \\(b\\) and make a recursive call. Otherwise, we can make a recursive call passing \\(a - b\\) in place of \\(a\\). Euclid\u2019s algorithm is shown in <code>Listing lst_gcd1</code>.</p> Listing lst_gcd1<pre><code>def gcd(a, b):\n    if b == 0:\n        return a\n    elif a &lt; b:\n        return gcd(b, a)\n    return gcd(a - b, b)\n</code></pre> <p>Although Euclid\u2019s algorithm is quite easy to understand and program, it is not as efficient as we would like, particularly if \\(a &gt;&gt; b\\). Once again, modular arithmetic comes to our rescue. Notice that the result of the last subtraction (when \\(a - b &lt; b\\)) is really the same as the remainder of $a<code>divided by $b$. With that in mind, we can cut out all of the subtractions and combine the swap of $a$ and $b$ in one recursive call. A revised algorithm is shown in</code>Listing lst_gcd2`.</p> Listing lst_gcd2<pre><code>   def gcd(a, b):\n       if b == 0:\n           return a\n       return gcd(b, a % b)\n</code></pre> <p>Now that we have a way to know whether two numbers \\(x\\) and \\(m\\) will have a multiplicative inverse, our next task is to write an efficient algorithm to compute the inverse. Suppose that for any pair of numbers \\(x\\) and \\(y\\) we could compute both \\(gcd(x,y)\\) and a pair of integers \\(a\\) and \\(b\\) such that \\(d = gcd(x, y) = ax + by\\). For example, \\(1 = gcd(3, 7) = -2 \\times 3 + 1 \\times 7\\), so here \\(a = -2\\) and \\(b = 1\\) are possible values for \\(a\\) and \\(b\\). Rather than any numbers \\(x\\) and \\(y\\), let\u2019s use \\(m\\) and \\(x\\) from our previous examples. Now we have \\(1 = gcd(m, x) = am + bx\\). From the discussion at the beginning of this section we know that \\(bx = 1 \\mod{m}\\), so \\(b\\) is a multiplicative inverse of \\(x\\) modulo \\(m\\).</p> <p>We have reduced the problem of computing inverses to the problem of finding integers \\(a\\) and \\(b\\) that satisfy the equation \\(d = gcd(x, y) = ax + by\\). Since we started this problem with the GCD algorithm, we can finish it with an extension of this algorithm as well. We will take two numbers \\(x &gt;= y\\) and return a tuple \\((d, a, b)\\) such that \\(d = gcd(x, y)\\) and \\(d = ax + by\\). The extension to Euclid\u2019s algorithm is shown in <code>Listing lst_gcd3</code>.</p> Listing lst_gcd3<pre><code>   def ext_gcd(x, y):\n       if y == 0:\n           return (x, 1, 0)\n       else:\n           (d, a, b) = ext_gcd(y, x % y)\n           return (d, b, a - (x // y) * b)\n</code></pre> <p>Notice that when we get the base case \\(y = 0\\), we return \\(d = x\\) just like the original Euclid\u2019s algorithm. However, we return two additional values \\(a =1\\) and \\(b = 0\\). Together these three values satisfy the equation \\(d = ax + by\\). If \\(y &gt; 0\\), then we recursively compute values \\((d, a, b)\\) such that \\(d = gcd(y, x \\mod{y})\\) and \\(d = ay + b(x \\mod{y})\\). As with the original algorithm, \\(d = gcd(x, y)\\). But what about the other two values, \\(a\\) and \\(b\\)? We know that \\(a\\) and \\(b\\) must be integers, so let\u2019s call them \\(A\\) and \\(B\\). Further, we know that \\(d = Ax + By\\). To figure out what \\(A\\) and \\(B\\) should be, let\u2019s rearrange the equation as follows:</p> <p>\\(\\begin{aligned} d = &amp; ay + b(x \\mod{y}) \\\\   = &amp; ay + b(x - \\lfloor x / y \\rfloor y) \\\\   = &amp; bx + (a - \\lfloor x / y \\rfloor b)y\\end{aligned}\\)</p> <p>Note the substitution made in the second line, \\(x \\mod{y} = x - \\lfloor x / y \\rfloor\\). This is legal because this is how we would normally calculate the remainder of x / y (\\(x \\mod{y}\\)). Looking at the rearranged equation, we can see that \\(A = b\\) and \\(B = a - \\lfloor x / y \\rfloor b\\). Notice that this is exactly what line <code>[line:6]</code> does! To check this, note that at each return step in the algorithm the return values satisfy the equation \\(d = ax + by\\). To understand how our extended GCD algorithm works, let\u2019s start with an example: let \\(x = 25\\) and \\(y = 9\\). <code>Figure\u00a01</code> illustrates the call and return values for the recursive function.</p> <p> Figure\u00a01: FiguCall Tree for Extended GCD Algorithm </p> <p>A multiplicative inverse of a positive integer \\(x\\) modulo \\(m\\) is any number \\(a\\) such that \\(ax \\equiv 1 \\pmod{m}\\). For example, let \\(x = 3\\), \\(m = 7\\), and \\(a = 5\\); \\(3 \\times 5 = 15\\) and \\(15\\ \\%\\ 7 = 1\\), so 5 is a multiplicative inverse of 3 modulo 7.</p> <p>The idea of multiplicative inverses in the world of modulo arithmetic may seem very confusing at first. How did we select 5 in the previous example? Is 5 the only multiplicative inverse of 3 modulo 7? Do all numbers \\(a\\) have a multiplicative inverse for any given \\(m\\)?</p> <p>Let\u2019s look at an example that may shed some light on the first question: how did we select 5 as the multiplicative inverse of 3 modulo 7? Look at the following Python session:</p> <pre><code>&gt;&gt;&gt; for i in range(1, 40):\n...    if (3 * i) % 7 == 1:\n...        print i\n...\n5\n12\n19\n26\n33\n</code></pre> <p>This little experiment tells us that there are many multiplicative inverses (modulo 7) for \\(x=3\\) and \\(m = 7\\), namely \\(5, 12, 19, 26, 33\\), and so on. Do you notice anything interesting about the sequence? Each number in the sequence is two less than a multiple of seven.</p> <p>Do all pairs of numbers \\(x\\) and \\(m\\) have a multiplicative inverse? Let\u2019s look at another example. Consider \\(x=4\\) and \\(m=8\\). Plugging 4 and 8 into the loop in the previous example gives us no output. If we take out the conditional and print out the results of \\((4 \\cdot i)\\ \\%\\ 8\\), we get the sequence \\((0, 4, 0, 4, 0, 4\\dots)\\). Here we have a case where the remainder alternates between 0 and 4 repeatedly. Clearly the result is never going to be 1. How can we know that ahead of time?</p> <p>The answer is that a number \\(x\\) has a multiplicative inverse, modulo \\(m\\), if and only if \\(m\\) and \\(x\\) are relatively prime. Two numbers are relatively prime if \\(gcd(m,x) = 1\\). Recall that the greatest common divisor (GCD) is the largest integer that divides both numbers. The next question is how can we compute the greatest common divisor for a pair of numbers?</p> <p>Given two numbers \\(a\\) and \\(b\\) we can find the GCD by repeatedly subtracting \\(b\\) from \\(a\\) until \\(a &lt; b\\). When \\(a &lt; b\\), we switch roles for \\(a\\) and \\(b\\). At some point \\(a - b\\) becomes 0, so we swap \\(a\\) and \\(b\\) one more time. At that point we have $gcd(a, 0) = a`. This algorithm was first described more than 2,000 years ago and is called Euclid\u2019s algorithm.</p> <p>In terms of recursive algorithm design, Euclid\u2019s algorithm is very straightforward. The base case is when \\(b = 0\\). There are two possibilities for a recursive call: when \\(a &lt; b\\), we swap \\(a\\) and \\(b\\) and make a recursive call. Otherwise, we can make a recursive call passing \\(a - b\\) in place of \\(a\\). Euclid\u2019s algorithm is shown in <code>Listing lst_gcd1</code>.</p> Listing lst_gcd1<pre><code>def gcd(a, b):\n    if b == 0:\n        return a\n    elif a &lt; b:\n        return gcd(b, a)\n    return gcd(a - b, b)\n</code></pre> <p>Although Euclid\u2019s algorithm is quite easy to understand and program, it is not as efficient as we would like, particularly if \\(a &gt;&gt; b\\). Once again, modular arithmetic comes to our rescue. Notice that the result of the last subtraction (when \\(a - b &lt; b\\)) is really the same as the remainder of $a<code>divided by $b$. With that in mind, we can cut out all of the subtractions and combine the swap of $a$ and $b$ in one recursive call. A revised algorithm is shown in</code>Listing lst_gcd2`.</p> Listing lst_gcd2<pre><code>   def gcd(a, b):\n       if b == 0:\n           return a\n       return gcd(b, a % b)\n</code></pre> <p>Now that we have a way to know whether two numbers \\(x\\) and \\(m\\) will have a multiplicative inverse, our next task is to write an efficient algorithm to compute the inverse. Suppose that for any pair of numbers \\(x\\) and \\(y\\) we could compute both \\(gcd(x,y)\\) and a pair of integers \\(a\\) and \\(b\\) such that \\(d = gcd(x, y) = ax + by\\). For example, \\(1 = gcd(3, 7) = -2 \\times 3 + 1 \\times 7\\), so here \\(a = -2\\) and \\(b = 1\\) are possible values for \\(a\\) and \\(b\\). Rather than any numbers \\(x\\) and \\(y\\), let\u2019s use \\(m\\) and \\(x\\) from our previous examples. Now we have \\(1 = gcd(m, x) = am + bx\\). From the discussion at the beginning of this section we know that \\(bx = 1 \\mod{m}\\), so \\(b\\) is a multiplicative inverse of \\(x\\) modulo \\(m\\).</p> <p>We have reduced the problem of computing inverses to the problem of finding integers \\(a\\) and \\(b\\) that satisfy the equation \\(d = gcd(x, y) = ax + by\\). Since we started this problem with the GCD algorithm, we can finish it with an extension of this algorithm as well. We will take two numbers \\(x &gt;= y\\) and return a tuple \\((d, a, b)\\) such that \\(d = gcd(x, y)\\) and \\(d = ax + by\\). The extension to Euclid\u2019s algorithm is shown in <code>Listing lst_gcd3</code>.</p> Listing lst_gcd3<pre><code>   def ext_gcd(x, y):\n       if y == 0:\n           return (x, 1, 0)\n       else:\n           (d, a, b) = ext_gcd(y, x % y)\n           return (d, b, a - (x // y) * b)\n</code></pre> <p>Notice that when we get the base case \\(y = 0\\), we return \\(d = x\\) just like the original Euclid\u2019s algorithm. However, we return two additional values \\(a =1\\) and \\(b = 0\\). Together these three values satisfy the equation \\(d = ax + by\\). If \\(y &gt; 0\\), then we recursively compute values \\((d, a, b)\\) such that \\(d = gcd(y, x \\mod{y})\\) and \\(d = ay + b(x \\mod{y})\\). As with the original algorithm, \\(d = gcd(x, y)\\). But what about the other two values, \\(a\\) and \\(b\\)? We know that \\(a\\) and \\(b\\) must be integers, so let\u2019s call them \\(A\\) and \\(B\\). Further, we know that \\(d = Ax + By\\). To figure out what \\(A\\) and \\(B\\) should be, let\u2019s rearrange the equation as follows:</p> <p>\\(\\begin{aligned} d = &amp; ay + b(x \\mod{y}) \\\\   = &amp; ay + b(x - \\lfloor x / y \\rfloor y) \\\\   = &amp; bx + (a - \\lfloor x / y \\rfloor b)y\\end{aligned}\\)</p> <p>Note the substitution made in the second line, \\(x \\mod{y} = x - \\lfloor x / y \\rfloor\\). This is legal because this is how we would normally calculate the remainder of x / y (\\(x \\mod{y}\\)). Looking at the rearranged equation, we can see that \\(A = b\\) and \\(B = a - \\lfloor x / y \\rfloor b\\). Notice that this is exactly what line <code>[line:6]</code> does! To check this, note that at each return step in the algorithm the return values satisfy the equation \\(d = ax + by\\). To understand how our extended GCD algorithm works, let\u2019s start with an example: let \\(x = 25\\) and \\(y = 9\\). <code>Figure\u00a01</code> illustrates the call and return values for the recursive function.</p> <p> Figure\u00a01: FiguCall Tree for Extended GCD Algorithm </p>"},{"location":"c8/s3/#834-rsa\u7b97\u6cd5","title":"8.3.4. RSA\u7b97\u6cd5","text":"<p>8.3.4. RSA Algorithm</p> \u4e2d\u6587\u82f1\u6587 <p>Now we have all the tools we need to write the RSA encryption algorithm. The RSA algorithm is perhaps the easiest to understand of all the public key encryption algorithms. Public key cryptography was invented by Whitfield Diffie and Martin Hellman and independently by Ralph Merkle. The major contribution of public key cryptography was the idea that keys could come in pairs: an encryption key to convert the plaintext message to ciphertext, and a decryption key to convert the ciphertext back to plaintext. The keys only work one way so that a message encrypted with the private key can only be decrypted with the public key, and vice versa.</p> <p>RSA gets its security from the difficulty of factoring large numbers. The public and private keys are derived from a pair of large (100\u2013200 digit) prime numbers. Since long integers are native to Python, this is a fun and easy algorithm to implement.</p> <p>To generate the two keys, choose two large prime numbers \\(p\\) and \\(q\\). Then compute the product</p> <p>\\(n = p \\times q\\)</p> <p>The next step is to randomly choose the encryption key \\(e\\) such that \\(e\\) and \\((p - 1) \\times (q - 1)\\) are relatively prime; that is</p> <p>\\(gcd(e, (p - 1) \\times (q-1)) = 1\\)</p> <p>Finally, the decryption key \\(d\\) is simply the multiplicative inverse of \\(e\\) modulo \\((p - 1) \\times (q - 1)\\). For this we can use our extended version of Euclid\u2019s algorithm.</p> <p>The numbers \\(e\\) and \\(n\\) taken together are the public key. The number \\(d\\) is the private key. Once we have computed \\(n, e\\), and \\(d\\), the original primes \\(p\\) and \\(q\\) are no longer needed. However, they should not be revealed.</p> <p>To encrypt a message we simply use the equation \\(c = m^e \\pmod{n}\\). To decrypt the message we use \\(m = c^d \\pmod{n}\\).</p> <p>It is easy to see that this works when you remember that \\(d\\) is the multiplicative inverse of \\(e \\pmod{n}\\).</p> <p>\\(\\begin{aligned}   c^d &amp; = (m^e)^d  \\pmod{n} \\\\       &amp; = m^{ed}   \\pmod{n} \\\\       &amp; = m^1  \\pmod{n} \\\\       &amp; = m \\pmod{n} \\end{aligned}\\)</p> <p>Before we turn all these equations into Python code, we need to talk about a couple of other details. First, how do we take a text message like \"hello world\" and turn it into a number? The easiest way is to simply use the ASCII values associated with each character and concatenate all the numbers together. However, since the decimal versions of the numbers of the ASCII values vary in the number of digits needed to represent them, we will use the hexadecimal numbers where we know very reliably that two hexadecimal digits represent a single byte or character.</p> h e l l o w o r l d 104 101 108 108 111 32 119 111 114 108 100 68 65 6c 6c 6f 20 77 6f 72 6c 64 <p>Putting all the hexadecimal digits together we could convert that large hex number into a decimal integer:</p> <p>\\(m = 126207244316550804821666916\\)</p> <p>Python can handle this large number just fine. However, there are two reasons that real programs using RSA encryption break the message up into smaller chunks and encrypt each chunk. The first reason is performance. Even a relatively short email message, say 1k of text, will generate a number with 2,000 to 3,000 digits! If we raise that to a power of \\(d\\) which has 10 digits, we are talking about a very long number indeed.</p> <p>The second reason for breaking the message into chunks is the restriction that \\(m \\le n\\). We must be sure that the message has a unique representation modulo \\(n\\). With binary data, choose the largest power of two that is less than \\(n\\). For example, let\u2019s choose \\(p\\) and \\(q\\) to be 5563 and 8191. So \\(n = 5563 \\times 8191 = 45,566,533\\). To keep the integer value of our chunks less than \\(m\\), we will divide up our word into chunks that use less than the number of bytes needed to represent \\(n\\). This is easy to find in Python using the integer method <code>bit_length</code>. Given the number of bits needed to represent a number, we can divide by eight to find the number of bytes. Since each character in the message can be represented by a single byte, this division tells us the number of bytes we can put in each chunk. Conveniently, this lets us simply break the message up into chunks of \\(n\\) characters and convert the hexadecimal representation of each chunk into an integer. For this example we can represent \\(45,566,533\\) using 26 bits. Using integer division and dividing by eight tells us that we should break our message into chunks of three characters.</p> <p>The characters \u201ch,\u201d \u201ce,\u201d and \u201cl\u201d have the hexadecimal values of \\(68\\), \\(65\\), and \\(6c\\), respectively. Concatenating those together gives us \\(68656c\\) and converting that to a decimal gives us \\(6841708\\).</p> - - - - \\(m_1 = 6841708\\) \\(m_2 = 7106336\\) \\(m_3 = 7827314\\) \\(m_4 = 27748\\) <p>Note that breaking the message into chunks can be very tricky, in particular when the result of applying the RSA transformation to a chunk produces a number that is less than seven digits long. In this case we need to be careful to add a leading zero to the result when we glue our chunks back together again. You can see how this might happen in \\(m_1\\) and \\(m_4\\) above.</p> <p>Now let\u2019s choose a value for \\(e\\). We can select values randomly and use the GCD algorithm to test them against \\((p - 1) \\times (q - 1) = 45552780\\). Remember that we are looking for an \\(e\\) that is relatively prime to 45,552,780. The number 1,471 will work nicely for this example.</p> <p>\\(\\begin{aligned}d &amp; = ext\\_gcd(45552780, 1471) \\\\    &amp; = -11705609  \\\\    &amp; = 45552780-11705609  \\\\    &amp; = 33847171\\end{aligned}\\)</p> <p>Let\u2019s use this information to encrypt the first chunk of our message:</p> <p>\\(c = 6841708^{1471} \\pmod{45566533} = 16310024\\)</p> <p>To check our work, let\u2019s decrypt \\(c\\) to make sure we recover the original value:</p> <p>\\(m = 16310024^{33847171} \\pmod{45566533} = 6841708\\)</p> <p>The remaining chunks of the message can be encrypted using the same procedure and sent all together as the encrypted message.</p> <p>Finally, let\u2019s look at three Python functions.</p> <ul> <li><code>gen_keys</code> creates a public and private key, given \\(p\\) and \\(q\\).</li> <li><code>encrypt</code> takes a message, the public key, and \\(n\\) and returns  an encrypted version of the message.</li> <li><code>decrypt</code> takes the encrypted message, the private key, and \\(n\\) and    returns the original message.</li> </ul> <pre><code>def gen_keys(p, q):\n    n = p * q\n    m = (p - 1) * (q - 1)\n    e = int(random.random() * n)\n    while gcd(m, e) != 1:\n        e = int(random.random() * n)\n    d, a, b = ext_gcd(m, e)\n    if b &lt; 0:\n        d = m + b\n    else:\n        d = b\n    return (e, d, n)\n\ndef encrypt(msg, e, n):\n    chunk_size = n.bit_length() // 8\n    all_chunks = str_to_chunks(msg, chunk_size)\n    return [\n        modexp(msg_chunk, e, n)\n        for msg_chunk in all_chunks\n    ]\n\ndef decrypt(cipher_chunks, d, n):\n    chunk_size = n.bit_length() // 8\n    plain_chunks = [\n        modexp(cipher_chunk, d, n)\n        for cipher_chunk in cipher_chunks\n    ]\n    return chunks_to_str(plain_chunks, chunk_size)\n</code></pre> <p>Here is a session that uses these functions to create public and private keys, encrypt, and decrypt as we did in the example above.</p> <pre><code>&gt;&gt;&gt; msg = \"Python\"\n&gt;&gt;&gt; e, d, n = gen_keys(5563, 8191)\n&gt;&gt;&gt; print(e, d, n)\n2646697 33043453 45566533\n&gt;&gt;&gt; c = encrypt(msg, e, n)\n&gt;&gt;&gt; print(c)\n[22810070, 18852325, 34390906, 22805081]\n&gt;&gt;&gt; m = decrypt(c, d, n)\n&gt;&gt;&gt; print(m)\nPython\n&gt;&gt;&gt;\n</code></pre> <p>The last thing to look at is the two helper functions that break our string into chunks and merge chunks into a string (<code>Listing\u00a0lst_chunk</code>). These functions make use of Python <code>bytearray</code> objects, which allow us to store any string as a sequence of bytes.  This makes it very convenient for us to convert a string to a sequence of hexadecimal digits and allows us to convert a sequence of hexadecimal digits back to a string.</p> Listing\u00a0lst_chunk<pre><code>def str_to_chunks(msg, chunk_size):\n    msg_bytes = bytes(msg, \"utf-8\")\n    hex_str = \"\".join([f\"{b:02x}\" for b in msg_bytes])\n    num_chunks = len(hex_str) // chunk_size\n    chunk_list = []\n    for i in range(\n        0, num_chunks * chunk_size + 1, chunk_size\n    ):\n        chunk_list.append(hex_str[i : i + chunk_size])\n    chunk_list = [\n        eval(\"0x\" + x) for x in chunk_list if x\n    ]\n    return chunk_list\n\n\ndef chunks_to_str(chunk_list, chunk_size):\n    hex_list = []\n    for chunk in chunk_list:\n        hex_str = hex(chunk)[2:]\n        clen = len(hex_str)\n        hex_list.append(\n            \"0\" * ((chunk_size - clen) % 2) + hex_str\n        )\n\n    hstring = \"\".join(hex_list)\n    msg_array = bytearray.fromhex(hstring)\n    return msg_array.decode(\"utf-8\")\n</code></pre> <p>In <code>Listing\u00a0lst_chunk</code> we see the procedure for turning a string into a list of chunks. One important thing to note is that we must always make sure that our hexadecimal number corresponds to a character that is exactly two digits long. This means that sometimes we may need to add a leading zero. We can do this easily by using the string formatting expression <code>f\"{b:02x}\"</code>. This expression creates a string that is exactly two characters long, with a leading zero at the beginning if necessary. Once we have created a single long hexadecimal string out of the entire message, we can then break up that long string into <code>num_chunks</code> chunks of hexadecimal numbers. This is what is happening in the <code>for</code> loop (starting on line\u00a06). Finally, we can transform each hexadecimal number into an integer using the <code>eval</code> function and the list comprehension.</p> <p>Transforming the decrypted chunks back to a string is as easy as creating a single long hex string and turning that hexadecimal string into a <code>bytearray</code>. The <code>bytearray</code> has a built-in <code>decode</code> function to turn the <code>bytearray</code> into a string. The only tricky part of this procedure is that after the transformation process the number represented by the chunk may end up significantly smaller than the original. If this is the case we may need to add a leading zero to make sure that all of the chunks are the same length when we concatenate them back together again. The extra zeros are prepended to any chunk by using the string repetition operator in the expression <code>\"0\" * ((chunk_size) - clen) % 2)</code> where <code>chunk_size</code> represents the number of digits that should be present in the string and <code>clen</code> represents the actual number.</p> <p>Now we have all the tools we need to write the RSA encryption algorithm. The RSA algorithm is perhaps the easiest to understand of all the public key encryption algorithms. Public key cryptography was invented by Whitfield Diffie and Martin Hellman and independently by Ralph Merkle. The major contribution of public key cryptography was the idea that keys could come in pairs: an encryption key to convert the plaintext message to ciphertext, and a decryption key to convert the ciphertext back to plaintext. The keys only work one way so that a message encrypted with the private key can only be decrypted with the public key, and vice versa.</p> <p>RSA gets its security from the difficulty of factoring large numbers. The public and private keys are derived from a pair of large (100\u2013200 digit) prime numbers. Since long integers are native to Python, this is a fun and easy algorithm to implement.</p> <p>To generate the two keys, choose two large prime numbers \\(p\\) and \\(q\\). Then compute the product</p> <p>\\(n = p \\times q\\)</p> <p>The next step is to randomly choose the encryption key \\(e\\) such that \\(e\\) and \\((p - 1) \\times (q - 1)\\) are relatively prime; that is</p> <p>\\(gcd(e, (p - 1) \\times (q-1)) = 1\\)</p> <p>Finally, the decryption key \\(d\\) is simply the multiplicative inverse of \\(e\\) modulo \\((p - 1) \\times (q - 1)\\). For this we can use our extended version of Euclid\u2019s algorithm.</p> <p>The numbers \\(e\\) and \\(n\\) taken together are the public key. The number \\(d\\) is the private key. Once we have computed \\(n, e\\), and \\(d\\), the original primes \\(p\\) and \\(q\\) are no longer needed. However, they should not be revealed.</p> <p>To encrypt a message we simply use the equation \\(c = m^e \\pmod{n}\\). To decrypt the message we use \\(m = c^d \\pmod{n}\\).</p> <p>It is easy to see that this works when you remember that \\(d\\) is the multiplicative inverse of \\(e \\pmod{n}\\).</p> <p>\\(\\begin{aligned}   c^d &amp; = (m^e)^d  \\pmod{n} \\\\       &amp; = m^{ed}   \\pmod{n} \\\\       &amp; = m^1  \\pmod{n} \\\\       &amp; = m \\pmod{n} \\end{aligned}\\)</p> <p>Before we turn all these equations into Python code, we need to talk about a couple of other details. First, how do we take a text message like \"hello world\" and turn it into a number? The easiest way is to simply use the ASCII values associated with each character and concatenate all the numbers together. However, since the decimal versions of the numbers of the ASCII values vary in the number of digits needed to represent them, we will use the hexadecimal numbers where we know very reliably that two hexadecimal digits represent a single byte or character.</p> h e l l o w o r l d 104 101 108 108 111 32 119 111 114 108 100 68 65 6c 6c 6f 20 77 6f 72 6c 64 <p>Putting all the hexadecimal digits together we could convert that large hex number into a decimal integer:</p> <p>\\(m = 126207244316550804821666916\\)</p> <p>Python can handle this large number just fine. However, there are two reasons that real programs using RSA encryption break the message up into smaller chunks and encrypt each chunk. The first reason is performance. Even a relatively short email message, say 1k of text, will generate a number with 2,000 to 3,000 digits! If we raise that to a power of \\(d\\) which has 10 digits, we are talking about a very long number indeed.</p> <p>The second reason for breaking the message into chunks is the restriction that \\(m \\le n\\). We must be sure that the message has a unique representation modulo \\(n\\). With binary data, choose the largest power of two that is less than \\(n\\). For example, let\u2019s choose \\(p\\) and \\(q\\) to be 5563 and 8191. So \\(n = 5563 \\times 8191 = 45,566,533\\). To keep the integer value of our chunks less than \\(m\\), we will divide up our word into chunks that use less than the number of bytes needed to represent \\(n\\). This is easy to find in Python using the integer method <code>bit_length</code>. Given the number of bits needed to represent a number, we can divide by eight to find the number of bytes. Since each character in the message can be represented by a single byte, this division tells us the number of bytes we can put in each chunk. Conveniently, this lets us simply break the message up into chunks of \\(n\\) characters and convert the hexadecimal representation of each chunk into an integer. For this example we can represent \\(45,566,533\\) using 26 bits. Using integer division and dividing by eight tells us that we should break our message into chunks of three characters.</p> <p>The characters \u201ch,\u201d \u201ce,\u201d and \u201cl\u201d have the hexadecimal values of \\(68\\), \\(65\\), and \\(6c\\), respectively. Concatenating those together gives us \\(68656c\\) and converting that to a decimal gives us \\(6841708\\).</p> - - - - \\(m_1 = 6841708\\) \\(m_2 = 7106336\\) \\(m_3 = 7827314\\) \\(m_4 = 27748\\) <p>Note that breaking the message into chunks can be very tricky, in particular when the result of applying the RSA transformation to a chunk produces a number that is less than seven digits long. In this case we need to be careful to add a leading zero to the result when we glue our chunks back together again. You can see how this might happen in \\(m_1\\) and \\(m_4\\) above.</p> <p>Now let\u2019s choose a value for \\(e\\). We can select values randomly and use the GCD algorithm to test them against \\((p - 1) \\times (q - 1) = 45552780\\). Remember that we are looking for an \\(e\\) that is relatively prime to 45,552,780. The number 1,471 will work nicely for this example.</p> <p>\\(\\begin{aligned}d &amp; = ext\\_gcd(45552780, 1471) \\\\    &amp; = -11705609  \\\\    &amp; = 45552780-11705609  \\\\    &amp; = 33847171\\end{aligned}\\)</p> <p>Let\u2019s use this information to encrypt the first chunk of our message:</p> <p>\\(c = 6841708^{1471} \\pmod{45566533} = 16310024\\)</p> <p>To check our work, let\u2019s decrypt \\(c\\) to make sure we recover the original value:</p> <p>\\(m = 16310024^{33847171} \\pmod{45566533} = 6841708\\)</p> <p>The remaining chunks of the message can be encrypted using the same procedure and sent all together as the encrypted message.</p> <p>Finally, let\u2019s look at three Python functions.</p> <ul> <li><code>gen_keys</code> creates a public and private key, given \\(p\\) and \\(q\\).</li> <li><code>encrypt</code> takes a message, the public key, and \\(n\\) and returns  an encrypted version of the message.</li> <li><code>decrypt</code> takes the encrypted message, the private key, and \\(n\\) and    returns the original message.</li> </ul> <pre><code>def gen_keys(p, q):\n    n = p * q\n    m = (p - 1) * (q - 1)\n    e = int(random.random() * n)\n    while gcd(m, e) != 1:\n        e = int(random.random() * n)\n    d, a, b = ext_gcd(m, e)\n    if b &lt; 0:\n        d = m + b\n    else:\n        d = b\n    return (e, d, n)\n\ndef encrypt(msg, e, n):\n    chunk_size = n.bit_length() // 8\n    all_chunks = str_to_chunks(msg, chunk_size)\n    return [\n        modexp(msg_chunk, e, n)\n        for msg_chunk in all_chunks\n    ]\n\ndef decrypt(cipher_chunks, d, n):\n    chunk_size = n.bit_length() // 8\n    plain_chunks = [\n        modexp(cipher_chunk, d, n)\n        for cipher_chunk in cipher_chunks\n    ]\n    return chunks_to_str(plain_chunks, chunk_size)\n</code></pre> <p>Here is a session that uses these functions to create public and private keys, encrypt, and decrypt as we did in the example above.</p> <pre><code>&gt;&gt;&gt; msg = \"Python\"\n&gt;&gt;&gt; e, d, n = gen_keys(5563, 8191)\n&gt;&gt;&gt; print(e, d, n)\n2646697 33043453 45566533\n&gt;&gt;&gt; c = encrypt(msg, e, n)\n&gt;&gt;&gt; print(c)\n[22810070, 18852325, 34390906, 22805081]\n&gt;&gt;&gt; m = decrypt(c, d, n)\n&gt;&gt;&gt; print(m)\nPython\n&gt;&gt;&gt;\n</code></pre> <p>The last thing to look at is the two helper functions that break our string into chunks and merge chunks into a string (<code>Listing\u00a0lst_chunk</code>). These functions make use of Python <code>bytearray</code> objects, which allow us to store any string as a sequence of bytes.  This makes it very convenient for us to convert a string to a sequence of hexadecimal digits and allows us to convert a sequence of hexadecimal digits back to a string.</p> Listing\u00a0lst_chunk<pre><code>def str_to_chunks(msg, chunk_size):\n    msg_bytes = bytes(msg, \"utf-8\")\n    hex_str = \"\".join([f\"{b:02x}\" for b in msg_bytes])\n    num_chunks = len(hex_str) // chunk_size\n    chunk_list = []\n    for i in range(\n        0, num_chunks * chunk_size + 1, chunk_size\n    ):\n        chunk_list.append(hex_str[i : i + chunk_size])\n    chunk_list = [\n        eval(\"0x\" + x) for x in chunk_list if x\n    ]\n    return chunk_list\n\n\ndef chunks_to_str(chunk_list, chunk_size):\n    hex_list = []\n    for chunk in chunk_list:\n        hex_str = hex(chunk)[2:]\n        clen = len(hex_str)\n        hex_list.append(\n            \"0\" * ((chunk_size - clen) % 2) + hex_str\n        )\n\n    hstring = \"\".join(hex_list)\n    msg_array = bytearray.fromhex(hstring)\n    return msg_array.decode(\"utf-8\")\n</code></pre> <p>In <code>Listing\u00a0lst_chunk</code> we see the procedure for turning a string into a list of chunks. One important thing to note is that we must always make sure that our hexadecimal number corresponds to a character that is exactly two digits long. This means that sometimes we may need to add a leading zero. We can do this easily by using the string formatting expression <code>f\"{b:02x}\"</code>. This expression creates a string that is exactly two characters long, with a leading zero at the beginning if necessary. Once we have created a single long hexadecimal string out of the entire message, we can then break up that long string into <code>num_chunks</code> chunks of hexadecimal numbers. This is what is happening in the <code>for</code> loop (starting on line\u00a06). Finally, we can transform each hexadecimal number into an integer using the <code>eval</code> function and the list comprehension.</p> <p>Transforming the decrypted chunks back to a string is as easy as creating a single long hex string and turning that hexadecimal string into a <code>bytearray</code>. The <code>bytearray</code> has a built-in <code>decode</code> function to turn the <code>bytearray</code> into a string. The only tricky part of this procedure is that after the transformation process the number represented by the chunk may end up significantly smaller than the original. If this is the case we may need to add a leading zero to make sure that all of the chunks are the same length when we concatenate them back together again. The extra zeros are prepended to any chunk by using the string repetition operator in the expression <code>\"0\" * ((chunk_size) - clen) % 2)</code> where <code>chunk_size</code> represents the number of digits that should be present in the string and <code>clen</code> represents the actual number.</p>"},{"location":"c8/s4/","title":"8.4. \u5b57\u5178\u518d\u63a2\uff1a\u8df3\u8868","text":"<p>8.4. Dictionaries Revisited: Skip Lists</p> \u4e2d\u6587\u82f1\u6587 <p>One of the most versatile collections available in Python is the dictionary. Dictionaries, often referred to as maps, store a collection of key-value pairs. The key, which must be unique, is assigned an association with a particular data value. Given a key, it is possible to ask the map for the corresponding associated data value. The abilities to put a key-value pair into the map and then look up a data value associated with a given key are the fundamental operations that all maps must provide.</p> <p>For example, <code>Figure 1</code> shows a map containing key-value pairs. In this case, the keys are integers and the values are small, two-character words. From a logical perspective, there is no inherent order or organization within the pairs themselves. However, as the example shows, if a key (93) is provided to the map, the associated value (be) is returned.</p> <p> Figure 1: An Example Map </p> <p>One of the most versatile collections available in Python is the dictionary. Dictionaries, often referred to as maps, store a collection of key-value pairs. The key, which must be unique, is assigned an association with a particular data value. Given a key, it is possible to ask the map for the corresponding associated data value. The abilities to put a key-value pair into the map and then look up a data value associated with a given key are the fundamental operations that all maps must provide.</p> <p>For example, <code>Figure 1</code> shows a map containing key-value pairs. In this case, the keys are integers and the values are small, two-character words. From a logical perspective, there is no inherent order or organization within the pairs themselves. However, as the example shows, if a key (93) is provided to the map, the associated value (be) is returned.</p> <p> Figure 1: An Example Map </p>"},{"location":"c8/s4/#841-map\u62bd\u8c61\u6570\u636e\u7c7b\u578b","title":"8.4.1. Map\u62bd\u8c61\u6570\u636e\u7c7b\u578b","text":"<p>8.4.1. The Map Abstract Data Type</p> \u4e2d\u6587\u82f1\u6587 <p>The map abstract data type is defined by the following structure and operations. The structure of a map, as described above, is a collection of key-value pairs where values can be accessed via their associated key. The map operations are given below:</p> <ul> <li><code>Map()</code> creates a new map that is empty. It needs no parameters and returns an empty map.</li> <li><code>put(key,value)</code> adds a new key-value pair to the map. It needs the key and the associated value and returns nothing. Assume the key is not already in the map.</li> <li><code>get(key)</code> searches for the key in the map and returns the associated value. It needs the key and returns a value.</li> </ul> <p>It should be noted that there are a number of other possible operations that we could add to the map abstract data type. We will explore these in the exercises.</p> <p>The map abstract data type is defined by the following structure and operations. The structure of a map, as described above, is a collection of key-value pairs where values can be accessed via their associated key. The map operations are given below:</p> <ul> <li><code>Map()</code> creates a new map that is empty. It needs no parameters and returns an empty map.</li> <li><code>put(key,value)</code> adds a new key-value pair to the map. It needs the key and the associated value and returns nothing. Assume the key is not already in the map.</li> <li><code>get(key)</code> searches for the key in the map and returns the associated value. It needs the key and returns a value.</li> </ul> <p>It should be noted that there are a number of other possible operations that we could add to the map abstract data type. We will explore these in the exercises.</p>"},{"location":"c8/s4/#842-\u7528python\u5b9e\u73b0\u5b57\u5178","title":"8.4.2. \u7528Python\u5b9e\u73b0\u5b57\u5178","text":"<p>8.4.2. Implementing a Dictionary in Python</p> \u4e2d\u6587\u82f1\u6587 <p>We have already seen a number of interesting ways to implement the map idea. In Chapter\u00a0sorting-and-searching we considered the hash table as a means of providing map behavior. Given a set of keys and a hash function, we could place the keys in a collection that allowed us to search and retrieve the associated data value. Our analysis showed that this technique could potentially yield an \\(O(1)\\) search. However, performance degraded due to issues such as table size, collisions, and collision resolution strategy.</p> <p>In Chapter\u00a0trees we considered a binary search tree as a way to store such a collection. In this case the keys were placed in the tree such that searching could be done in \\(O(\\log n)\\). However, this was only true if the tree was balanced; that is, the left and the right subtrees were all of similar size. Unfortunately, depending on the order of insertion, the keys could end up being skewed to the right or to the left. In this case the search again degrades.</p> <p>The problem we would like to address here is to come up with an implementation that has the advantages of an efficient search without the drawbacks described above. One such possibility is called a skip list. <code>Figure\u00a02</code> shows a possible skip list for the collection of key-value pairs shown in <code>Figure\u00a01</code> (the reason for saying \u201cpossible\u201d will become apparent later). As you can see, a skip list is basically a two-dimensional linked list where the links all go forward (to the right) or down. The head of the list can be seen in the upper left corner. Note that this is the only entry point into the skip list structure.</p> <p> Figure\u00a02 An Example Skip List </p> <p>Before moving on to the details of skip-list processing it will be useful to explain some vocabulary. <code>Figure\u00a03</code> shows that the majority of the skip list structure consists of a collection of data nodes, each of which holds a key and an associated value. In addition, there are two references from each data node. <code>Figure\u00a04</code> shows a detailed view of a single data node.</p> <p> Figure\u00a03: The Body of the Skip List Is Made Up of Data Nodes </p> <p> Figure\u00a04: A Single Data Node </p> <p><code>Figure\u00a05</code> shows two different vertical columns. The leftmost column consists of a linked list of header nodes. Each header node holds two references called <code>down</code> and <code>next</code>. The <code>next</code> reference refers to a linked list of data nodes. The <code>down</code> reference refers to the next lower header node. A detailed view of a header node can be seen in <code>Figure\u00a06</code>.</p> <p> Figure\u00a05: Header Nodes and Towers </p> <p> Figure\u00a06: Each Header Node Holds Two References </p> <p>The columns of data nodes are known as towers. Towers are linked together by the <code>down</code> reference in the data node. We can see that each tower corresponds to a particular key-value pair, and towers can have different heights. We will explain how the height of the tower is determined later when we consider how to add data to the skip list.</p> <p>Finally, <code>Figure\u00a07</code> shows a horizontal collection of nodes. If you look closely, you will notice that each level is actually an ordered linked list of data nodes where the order is maintained by the key. Each linked list is given a name, commonly referred to as its level. Levels are named starting with 0 at the lowest row. Level 0 consists of the entire collection of nodes. Every key-value pair must be present in the level-0 linked list. However, as we move up to higher levels, we see that the number of nodes decreases. This is one of the important characteristics of a skip list and will lead to an efficient search. Again, it can be seen that the number of nodes at each level is directly related to the height of the towers.</p> <p> Figure\u00a07: Each Horizontal Group of Data Nodes Is a Level </p> <p>Classes for the two types of nodes described above can easily be constructed in the same fashion as for simple linked lists in the previous section. A header node consists of two references, <code>next</code> and <code>down</code>, both of which are initialized to <code>None</code> in the constructor (see <code>Listing lst_headnode</code>).</p> Listing lst_headnode<pre><code>   class HeaderNode:\n       def __init__(self):\n           self._next = None\n           self._down = None\n\n       @property\n       def next(self):\n           return self._next\n\n       @next.setter\n       def next(self, value):\n           self._next = value\n\n       @property\n       def down(self):\n           return self._down\n\n       @down.setter\n       def down(self, value):\n           self._down = value\n</code></pre> <p>A data node has four fields: two for the key and value, and two additional for the references <code>next</code> and <code>down</code>. Again, the references are initialized to <code>None</code> and wrapped into <code>properties</code> for data manipulation (see <code>Listing lst_datanode</code>).</p> Listing lst_datanode<pre><code>class DataNode:\n    def __init__(self, key, value):\n        self._key = key\n        self._data = value\n        self._next = None\n        self._down = None\n\n    @property\n    def key(self):\n        return self._key\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, value):\n        self._data = value\n\n    @property\n    def next(self):\n        return self._next\n\n    @next.setter\n    def next(self, value):\n        self._next = value\n\n    @property\n    def down(self):\n        return self._down\n\n    @down.setter\n    def down(self, value):\n        self._down = value\n</code></pre> <p>The constructor for the entire skip list is shown in <code>Listing lst_constructor</code>. When a skip list is created, there are no data and therefore no header nodes. The head of the skip list is set to <code>None</code>. As key-value pairs are added to the structure, the list head refers to the first header node which in turn provides access to a linked list of data nodes as well as access to lower levels.</p> Listing lst_constructor<pre><code>   class SkipList:\n       def __init__(self):\n           self._head = None\n</code></pre> <p>We have already seen a number of interesting ways to implement the map idea. In Chapter\u00a0sorting-and-searching we considered the hash table as a means of providing map behavior. Given a set of keys and a hash function, we could place the keys in a collection that allowed us to search and retrieve the associated data value. Our analysis showed that this technique could potentially yield an \\(O(1)\\) search. However, performance degraded due to issues such as table size, collisions, and collision resolution strategy.</p> <p>In Chapter\u00a0trees we considered a binary search tree as a way to store such a collection. In this case the keys were placed in the tree such that searching could be done in \\(O(\\log n)\\). However, this was only true if the tree was balanced; that is, the left and the right subtrees were all of similar size. Unfortunately, depending on the order of insertion, the keys could end up being skewed to the right or to the left. In this case the search again degrades.</p> <p>The problem we would like to address here is to come up with an implementation that has the advantages of an efficient search without the drawbacks described above. One such possibility is called a skip list. <code>Figure\u00a02</code> shows a possible skip list for the collection of key-value pairs shown in <code>Figure\u00a01</code> (the reason for saying \u201cpossible\u201d will become apparent later). As you can see, a skip list is basically a two-dimensional linked list where the links all go forward (to the right) or down. The head of the list can be seen in the upper left corner. Note that this is the only entry point into the skip list structure.</p> <p> Figure\u00a02 An Example Skip List </p> <p>Before moving on to the details of skip-list processing it will be useful to explain some vocabulary. <code>Figure\u00a03</code> shows that the majority of the skip list structure consists of a collection of data nodes, each of which holds a key and an associated value. In addition, there are two references from each data node. <code>Figure\u00a04</code> shows a detailed view of a single data node.</p> <p> Figure\u00a03: The Body of the Skip List Is Made Up of Data Nodes </p> <p> Figure\u00a04: A Single Data Node </p> <p><code>Figure\u00a05</code> shows two different vertical columns. The leftmost column consists of a linked list of header nodes. Each header node holds two references called <code>down</code> and <code>next</code>. The <code>next</code> reference refers to a linked list of data nodes. The <code>down</code> reference refers to the next lower header node. A detailed view of a header node can be seen in <code>Figure\u00a06</code>.</p> <p> Figure\u00a05: Header Nodes and Towers </p> <p> Figure\u00a06: Each Header Node Holds Two References </p> <p>The columns of data nodes are known as towers. Towers are linked together by the <code>down</code> reference in the data node. We can see that each tower corresponds to a particular key-value pair, and towers can have different heights. We will explain how the height of the tower is determined later when we consider how to add data to the skip list.</p> <p>Finally, <code>Figure\u00a07</code> shows a horizontal collection of nodes. If you look closely, you will notice that each level is actually an ordered linked list of data nodes where the order is maintained by the key. Each linked list is given a name, commonly referred to as its level. Levels are named starting with 0 at the lowest row. Level 0 consists of the entire collection of nodes. Every key-value pair must be present in the level-0 linked list. However, as we move up to higher levels, we see that the number of nodes decreases. This is one of the important characteristics of a skip list and will lead to an efficient search. Again, it can be seen that the number of nodes at each level is directly related to the height of the towers.</p> <p> Figure\u00a07: Each Horizontal Group of Data Nodes Is a Level </p> <p>Classes for the two types of nodes described above can easily be constructed in the same fashion as for simple linked lists in the previous section. A header node consists of two references, <code>next</code> and <code>down</code>, both of which are initialized to <code>None</code> in the constructor (see <code>Listing lst_headnode</code>).</p> Listing lst_headnode<pre><code>   class HeaderNode:\n       def __init__(self):\n           self._next = None\n           self._down = None\n\n       @property\n       def next(self):\n           return self._next\n\n       @next.setter\n       def next(self, value):\n           self._next = value\n\n       @property\n       def down(self):\n           return self._down\n\n       @down.setter\n       def down(self, value):\n           self._down = value\n</code></pre> <p>A data node has four fields: two for the key and value, and two additional for the references <code>next</code> and <code>down</code>. Again, the references are initialized to <code>None</code> and wrapped into <code>properties</code> for data manipulation (see <code>Listing lst_datanode</code>).</p> Listing lst_datanode<pre><code>class DataNode:\n    def __init__(self, key, value):\n        self._key = key\n        self._data = value\n        self._next = None\n        self._down = None\n\n    @property\n    def key(self):\n        return self._key\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, value):\n        self._data = value\n\n    @property\n    def next(self):\n        return self._next\n\n    @next.setter\n    def next(self, value):\n        self._next = value\n\n    @property\n    def down(self):\n        return self._down\n\n    @down.setter\n    def down(self, value):\n        self._down = value\n</code></pre> <p>The constructor for the entire skip list is shown in <code>Listing lst_constructor</code>. When a skip list is created, there are no data and therefore no header nodes. The head of the skip list is set to <code>None</code>. As key-value pairs are added to the structure, the list head refers to the first header node which in turn provides access to a linked list of data nodes as well as access to lower levels.</p> Listing lst_constructor<pre><code>   class SkipList:\n       def __init__(self):\n           self._head = None\n</code></pre>"},{"location":"c8/s4/#8421-searching-a-skip-list","title":"8.4.2.1. Searching a Skip List","text":"<p>8.4.2.1. Searching a Skip List</p> \u4e2d\u6587\u82f1\u6587 <p>The search operation for a skip list will require a key. It will find a data node containing that key and return the corresponding value that is stored in the node. <code>Figure\u00a08</code> shows the search process as it proceeds through the skip list looking for the key 77. The nodes marked by stars represent those that are considered during the search process.</p> <p> Figure 8: Searching for the Key 77 </p> <p>As we search for 77, we begin at the head of the skip list. The first header node refers to the data node holding 31. Since 31 is less than 77, we move forward. Now since there is no next data node from 31 at that level (level 3), we must drop down to level 2. This time, when we look to the right, we see a data node with the key 77. Our search is successful and the word of is returned. It is important to note that our first comparison, data node 31, allowed us to skip over 17 and 26. Likewise, from 31 we were able to go directly to 77, bypassing 54.</p> <p><code>Listing\u00a0lst_skiplistsearchcode</code> shows the Python implementation of the <code>search</code> method. The search starts at the head of the list and searches through nodes until either the key is found or there are no more nodes to check. The basic idea is to start at the header node of the highest level and begin to look to the right. If no data node is present, the search continues on the next lower level (lines <code>[check1 line:4]</code>\u2013<code>[down1 line:5]</code>). On the other hand, if a data node exists, we compare the keys. If there is a match, we have found a data node with the key we are looking for and we can return its value (lines <code>[check2 line:7]</code>\u2013<code>[found line:8]</code>).</p> Listing lst_skiplistsearchcode<pre><code>def search(self, key):\n    current = self._head\n    while current:\n        if current.next is None:          # check1\n            current = current.down        # down1\n        else:\n            if current.next.key == key:   # check2\n                return current.next.data  # found\n            if key &lt; current.next.key:    # check3\n                current = current.down    # down2\n            else:\n                current = current.next    # \n    return None\n</code></pre> <p>Since each level is an ordered linked list, a key mismatch provides us with very useful information. If the key we are looking for is less than the key contained in the data node (line <code>[check3 line:9]</code>), we know that no other data node on that level can contain our key since everything to the right has to be greater. In that case, we drop down one level in that tower (line <code>[down2 line:10]</code>). If no such level exists (we drop to <code>None</code>), we have discovered that the key is not present in our skip list. We break out of the loop and return <code>None</code>. On the other hand, as long as there are data nodes on the current level with key values less than the key we are looking for, we continue moving to the next node (line <code>[next1 line:12]</code>).</p> <p>Once we enter a lower level, we repeat the process of checking to see if there is a next node. Each level lower in the skip list has the potential to provide additional data nodes. If the key is present, it will have to be discovered no later than level 0 since level 0 is the complete ordered linked list. Our hope is that we will find it sooner.</p> <p>The search operation for a skip list will require a key. It will find a data node containing that key and return the corresponding value that is stored in the node. <code>Figure\u00a08</code> shows the search process as it proceeds through the skip list looking for the key 77. The nodes marked by stars represent those that are considered during the search process.</p> <p> Figure 8: Searching for the Key 77 </p> <p>As we search for 77, we begin at the head of the skip list. The first header node refers to the data node holding 31. Since 31 is less than 77, we move forward. Now since there is no next data node from 31 at that level (level 3), we must drop down to level 2. This time, when we look to the right, we see a data node with the key 77. Our search is successful and the word of is returned. It is important to note that our first comparison, data node 31, allowed us to skip over 17 and 26. Likewise, from 31 we were able to go directly to 77, bypassing 54.</p> <p><code>Listing\u00a0lst_skiplistsearchcode</code> shows the Python implementation of the <code>search</code> method. The search starts at the head of the list and searches through nodes until either the key is found or there are no more nodes to check. The basic idea is to start at the header node of the highest level and begin to look to the right. If no data node is present, the search continues on the next lower level (lines <code>[check1 line:4]</code>\u2013<code>[down1 line:5]</code>). On the other hand, if a data node exists, we compare the keys. If there is a match, we have found a data node with the key we are looking for and we can return its value (lines <code>[check2 line:7]</code>\u2013<code>[found line:8]</code>).</p> Listing lst_skiplistsearchcode<pre><code>def search(self, key):\n    current = self._head\n    while current:\n        if current.next is None:          # check1\n            current = current.down        # down1\n        else:\n            if current.next.key == key:   # check2\n                return current.next.data  # found\n            if key &lt; current.next.key:    # check3\n                current = current.down    # down2\n            else:\n                current = current.next    # \n    return None\n</code></pre> <p>Since each level is an ordered linked list, a key mismatch provides us with very useful information. If the key we are looking for is less than the key contained in the data node (line <code>[check3 line:9]</code>), we know that no other data node on that level can contain our key since everything to the right has to be greater. In that case, we drop down one level in that tower (line <code>[down2 line:10]</code>). If no such level exists (we drop to <code>None</code>), we have discovered that the key is not present in our skip list. We break out of the loop and return <code>None</code>. On the other hand, as long as there are data nodes on the current level with key values less than the key we are looking for, we continue moving to the next node (line <code>[next1 line:12]</code>).</p> <p>Once we enter a lower level, we repeat the process of checking to see if there is a next node. Each level lower in the skip list has the potential to provide additional data nodes. If the key is present, it will have to be discovered no later than level 0 since level 0 is the complete ordered linked list. Our hope is that we will find it sooner.</p>"},{"location":"c8/s4/#8422-adding-key-value-pairs-to-a-skip-list","title":"8.4.2.2. Adding Key-Value Pairs to a Skip List","text":"<p>8.4.2.2. Adding Key-Value Pairs to a Skip List</p> \u4e2d\u6587\u82f1\u6587 <p>If we are given a skip list, the <code>search</code> method is fairly easy to implement. Our task here is to understand how the skip list structure was built in the first place and how it is possible that the same set of keys, added in the same order, can give us different skip lists.</p> <p>Adding a new key-value pair to the skip list is essentially a two-step process. First, we search the skip list looking for the position where the key should have been. Remember that we are assuming the key is not already present. <code>Figure\u00a09</code> shows this process as we look to add the key 65 (data value \u201chi\u201d) to the collection. We have used the stars once again to show the path of the search process as it proceeds through the skip list.</p> <p> Figure\u00a09: Searching for the Key 65 </p> <p>As we proceed using the same search strategy as in the previous section, we find that 65 is greater than 31. Since there are no more nodes on level 3, we drop to level 2. Here we find 77, which is greater than 65. Again, we drop, this time to level 1. Now the next node is 54, which is less than 65. Continuing to the right, we hit 77, which again causes us to drop down until eventually we hit the <code>None</code> at the base of the tower.</p> <p>The second step in the process is to create a new data node and add it to the level 0 linked list (<code>Figure\u00a010</code>). However, if we stop at that point, the best we will ever have is a single linked list of key-value pairs. We also need to build a tower for the new entry, and this is where the skip list gets very interesting. How high should the tower be? The height of the tower for the new entry will not be predetermined but instead will be completely probabilistic. In essence, we will flip a coin to decide whether to add another level to the tower. Each time the coin comes up heads, we will add one more level to the current tower.</p> <p> Figure\u00a010: Adding the Data Node and Tower for 65 </p> <p>It is easy to use a random number generator to simulate a coin flip. We can use <code>randrange</code> from the <code>random</code> module and interpret 1 as heads.</p> <p><code>Listing\u00a0lst_insert</code> shows the <code>insert</code> method. You will note immediately in line\u00a02 that we need to check to see if this is the first node being added to the skip list. This is the same question we asked for simple linked lists. If we are adding to the head of the list, a new header node as well as data node must be created. The iteration in lines\u00a07--14 continues as long as the <code>randrange</code> function returns a 1 (the coin toss returns heads). Each time a new level is added to the tower, a new data node and a new header node are created.</p> <p>In the case of a non-empty skip list (line\u00a015), we need to search for the insert position as described above. Since we have no way of knowing how many data nodes will be added to the tower, we need to save the insert points for every level that we enter as part of the search process. These insert points will be processed in reverse order, so a stack will work nicely to allow us to back up through the linked lists inserting tower data nodes as necessary. The stars in <code>Figure\u00a010</code> show the insert points that would be stacked in the example. These points represent only those places where we dropped down during the search.</p> <p>Starting at line\u00a034, we flip our coin to determine the number of levels for the tower. This time we pop the insert stack to get the next higher insertion point as the tower grows. Only after the stack becomes empty will we need to return to creating new header nodes. We leave the remaining details of the implementation for you to trace.</p> Listing\u00a0lst_insert<pre><code>def insert(self, key, value):\n    if self._head is None:\n        self._head = HeaderNode()\n        temp = DataNode(key, value)\n        self._head.next = temp\n        top = temp\n        while randrange(2) == 1:\n            newhead = HeaderNode()\n            temp = DataNode(key, value)\n            temp.down = top\n            newhead.next = temp\n            newhead.down = self._head\n            self._head = newhead\n            top = temp\n    else:\n        tower = Stack()\n        current = self._head\n        while current:\n            if current.next is None:\n                tower.push(current)\n                current = current.down\n            else:\n                if current.next.key &gt; key:\n                    tower.push(current)\n                    current = current.down\n                else:\n                    current = current.next\n\n        lowest_level = tower.pop()\n        temp = DataNode(key, value)\n        temp.next = lowest_level.next\n        lowest_level.next = temp\n        top = temp\n        while randrange(2) == 1:\n            if tower.is_empty():\n                newhead = HeaderNode()\n                temp = DataNode(key, value)\n                temp.down = top\n                newhead.next = temp\n                newhead.down = self._head\n                self._head = newhead\n                top = temp\n            else:\n                next_level = tower.pop()\n                temp = DataNode(key, value)\n                temp.down = top\n                temp.next = next_level.next\n                next_level.next = temp\n                top = temp\n</code></pre> <p>We should make one final note about the structure of the skip list. We had mentioned earlier that there are many possible skip lists for a set of keys, even if they are inserted in the same order. Now we see why. Depending on the random nature of the coin flip, the height of the towers for any particular key is bound to change each time we build the skip list.</p> <p>If we are given a skip list, the <code>search</code> method is fairly easy to implement. Our task here is to understand how the skip list structure was built in the first place and how it is possible that the same set of keys, added in the same order, can give us different skip lists.</p> <p>Adding a new key-value pair to the skip list is essentially a two-step process. First, we search the skip list looking for the position where the key should have been. Remember that we are assuming the key is not already present. <code>Figure\u00a09</code> shows this process as we look to add the key 65 (data value \u201chi\u201d) to the collection. We have used the stars once again to show the path of the search process as it proceeds through the skip list.</p> <p> Figure\u00a09: Searching for the Key 65 </p> <p>As we proceed using the same search strategy as in the previous section, we find that 65 is greater than 31. Since there are no more nodes on level 3, we drop to level 2. Here we find 77, which is greater than 65. Again, we drop, this time to level 1. Now the next node is 54, which is less than 65. Continuing to the right, we hit 77, which again causes us to drop down until eventually we hit the <code>None</code> at the base of the tower.</p> <p>The second step in the process is to create a new data node and add it to the level 0 linked list (<code>Figure\u00a010</code>). However, if we stop at that point, the best we will ever have is a single linked list of key-value pairs. We also need to build a tower for the new entry, and this is where the skip list gets very interesting. How high should the tower be? The height of the tower for the new entry will not be predetermined but instead will be completely probabilistic. In essence, we will flip a coin to decide whether to add another level to the tower. Each time the coin comes up heads, we will add one more level to the current tower.</p> <p> Figure\u00a010: Adding the Data Node and Tower for 65 </p> <p>It is easy to use a random number generator to simulate a coin flip. We can use <code>randrange</code> from the <code>random</code> module and interpret 1 as heads.</p> <p><code>Listing\u00a0lst_insert</code> shows the <code>insert</code> method. You will note immediately in line\u00a02 that we need to check to see if this is the first node being added to the skip list. This is the same question we asked for simple linked lists. If we are adding to the head of the list, a new header node as well as data node must be created. The iteration in lines\u00a07--14 continues as long as the <code>randrange</code> function returns a 1 (the coin toss returns heads). Each time a new level is added to the tower, a new data node and a new header node are created.</p> <p>In the case of a non-empty skip list (line\u00a015), we need to search for the insert position as described above. Since we have no way of knowing how many data nodes will be added to the tower, we need to save the insert points for every level that we enter as part of the search process. These insert points will be processed in reverse order, so a stack will work nicely to allow us to back up through the linked lists inserting tower data nodes as necessary. The stars in <code>Figure\u00a010</code> show the insert points that would be stacked in the example. These points represent only those places where we dropped down during the search.</p> <p>Starting at line\u00a034, we flip our coin to determine the number of levels for the tower. This time we pop the insert stack to get the next higher insertion point as the tower grows. Only after the stack becomes empty will we need to return to creating new header nodes. We leave the remaining details of the implementation for you to trace.</p> Listing\u00a0lst_insert<pre><code>def insert(self, key, value):\n    if self._head is None:\n        self._head = HeaderNode()\n        temp = DataNode(key, value)\n        self._head.next = temp\n        top = temp\n        while randrange(2) == 1:\n            newhead = HeaderNode()\n            temp = DataNode(key, value)\n            temp.down = top\n            newhead.next = temp\n            newhead.down = self._head\n            self._head = newhead\n            top = temp\n    else:\n        tower = Stack()\n        current = self._head\n        while current:\n            if current.next is None:\n                tower.push(current)\n                current = current.down\n            else:\n                if current.next.key &gt; key:\n                    tower.push(current)\n                    current = current.down\n                else:\n                    current = current.next\n\n        lowest_level = tower.pop()\n        temp = DataNode(key, value)\n        temp.next = lowest_level.next\n        lowest_level.next = temp\n        top = temp\n        while randrange(2) == 1:\n            if tower.is_empty():\n                newhead = HeaderNode()\n                temp = DataNode(key, value)\n                temp.down = top\n                newhead.next = temp\n                newhead.down = self._head\n                self._head = newhead\n                top = temp\n            else:\n                next_level = tower.pop()\n                temp = DataNode(key, value)\n                temp.down = top\n                temp.next = next_level.next\n                next_level.next = temp\n                top = temp\n</code></pre> <p>We should make one final note about the structure of the skip list. We had mentioned earlier that there are many possible skip lists for a set of keys, even if they are inserted in the same order. Now we see why. Depending on the random nature of the coin flip, the height of the towers for any particular key is bound to change each time we build the skip list.</p>"},{"location":"c8/s4/#8423-building-the-map","title":"8.4.2.3. Building the Map","text":"<p>8.4.2.3. Building the Map</p> \u4e2d\u6587\u82f1\u6587 <p>Now that we have implemented the skip list behavior allowing us to add data to the list and search for data that is present, we are in a position to finally implement the map abstract data type. As we discussed above, maps must provide two operations, <code>put</code> and <code>get</code>. <code>Listing lst_mapclass</code> shows that these operations can easily be implemented by constructing an internal skip list collection (line <code>[init:3]</code>__) and using the <code>insert</code> and <code>search</code> operations shown in the previous two sections.</p> Listing lst_mapclass<pre><code>class Map:\n    def __init__(self):\n        self.collection = SkipList()\n\n    def put(self, key, value):\n        self.collection.insert(key, value)\n\n    def get(self, key):\n        return self.collection.search(key)\n</code></pre> <p>Now that we have implemented the skip list behavior allowing us to add data to the list and search for data that is present, we are in a position to finally implement the map abstract data type. As we discussed above, maps must provide two operations, <code>put</code> and <code>get</code>. <code>Listing lst_mapclass</code> shows that these operations can easily be implemented by constructing an internal skip list collection (line <code>[init:3]</code>__) and using the <code>insert</code> and <code>search</code> operations shown in the previous two sections.</p> Listing lst_mapclass<pre><code>class Map:\n    def __init__(self):\n        self.collection = SkipList()\n\n    def put(self, key, value):\n        self.collection.insert(key, value)\n\n    def get(self, key):\n        return self.collection.search(key)\n</code></pre>"},{"location":"c8/s4/#8424-analysis-of-a-skip-list","title":"8.4.2.4. Analysis of a Skip List","text":"<p>8.4.2.4. Analysis of a Skip List</p> \u4e2d\u6587\u82f1\u6587 <p>If we had simply stored the key-value pairs in an ordered linked list, we know that the search method would be \\(O(n)\\). Can we expect better performance from the skip list? Recall that the skip list is a probabilistic data structure. This means that the analysis will be dependent upon the probability of some event, in this case, the flip of a coin. Although a rigorous analysis of this structure is beyond the scope of this text, we can make a strong informal argument.</p> <p>Assume that we are building a skip list for \\(n\\) keys. We know that each tower starts off with a height of 1. As we add data nodes to the tower, assuming the probability of getting heads is \\(\\frac{1}{2}\\), we can say that \\(\\frac{n}{2}\\) of the keys have towers of height 2. As we flip the coin again, \\(\\frac{n}{4}\\) of the keys have a tower of height 3. This corresponds to the probability of flipping two heads in a row. Continuing this argument shows \\(\\frac{n}{8}\\) keys have a tower of height 4 and so on. This means that we expect the height of the tallest tower to be \\(\\log_{2}(n) + 1\\). Using our Big-O notation, we would say that the height of the skip list is \\(O(\\log (n))\\).</p> <p>To analyze the <code>search</code> method, recall that there are two scans that need to be considered as we look for a given key. The first is the down direction. The previous result suggests that in the worst case we will expect to consider \\(O(\\log (n))\\) levels to find a key. In addition, we need to include the number of forward links that need to be scanned on each level. We drop down a level when one of two events occurs. Either we find a data node with a key that is greater than the key we are looking for or we find the end of a level. If we are currently looking at some data node, the probability that one of those two events will happen in the next link is \\(\\frac{1}{2}\\). This means that after looking at two links, we would expect to drop to the next lower level (we expect to get heads after two coin flips). In any case, the number of nodes that we need to look at on any given level is constant. The entire result then becomes \\(O(\\log (n))\\). Since inserting a new node is dominated by searching for its location, the <code>insert</code> operation will also have \\(O(\\log(n))\\) performance.</p> <p>If we had simply stored the key-value pairs in an ordered linked list, we know that the search method would be \\(O(n)\\). Can we expect better performance from the skip list? Recall that the skip list is a probabilistic data structure. This means that the analysis will be dependent upon the probability of some event, in this case, the flip of a coin. Although a rigorous analysis of this structure is beyond the scope of this text, we can make a strong informal argument.</p> <p>Assume that we are building a skip list for \\(n\\) keys. We know that each tower starts off with a height of 1. As we add data nodes to the tower, assuming the probability of getting heads is \\(\\frac{1}{2}\\), we can say that \\(\\frac{n}{2}\\) of the keys have towers of height 2. As we flip the coin again, \\(\\frac{n}{4}\\) of the keys have a tower of height 3. This corresponds to the probability of flipping two heads in a row. Continuing this argument shows \\(\\frac{n}{8}\\) keys have a tower of height 4 and so on. This means that we expect the height of the tallest tower to be \\(\\log_{2}(n) + 1\\). Using our Big-O notation, we would say that the height of the skip list is \\(O(\\log (n))\\).</p> <p>To analyze the <code>search</code> method, recall that there are two scans that need to be considered as we look for a given key. The first is the down direction. The previous result suggests that in the worst case we will expect to consider \\(O(\\log (n))\\) levels to find a key. In addition, we need to include the number of forward links that need to be scanned on each level. We drop down a level when one of two events occurs. Either we find a data node with a key that is greater than the key we are looking for or we find the end of a level. If we are currently looking at some data node, the probability that one of those two events will happen in the next link is \\(\\frac{1}{2}\\). This means that after looking at two links, we would expect to drop to the next lower level (we expect to get heads after two coin flips). In any case, the number of nodes that we need to look at on any given level is constant. The entire result then becomes \\(O(\\log (n))\\). Since inserting a new node is dominated by searching for its location, the <code>insert</code> operation will also have \\(O(\\log(n))\\) performance.</p>"},{"location":"c8/s5/","title":"8.5. \u6811\u518d\u63a2\uff1a\u56fe\u50cf\u91cf\u5316","text":"<p>8.5. Trees Revisited: Quantizing Images</p> \u4e2d\u6587\u82f1\u6587 <p>Next to text, digital images are the most common element found on the internet. However, the internet would feel much slower if every advertisement-sized image required 196,560\u00a0bytes of memory. Instead, a banner ad image requires only 14,246, just 7.2% of what it could take. Where do these numbers come from? How is such a phenomenal savings achieved? The answers to these questions are the topic of this section.</p> <p>Next to text, digital images are the most common element found on the internet. However, the internet would feel much slower if every advertisement-sized image required 196,560\u00a0bytes of memory. Instead, a banner ad image requires only 14,246, just 7.2% of what it could take. Where do these numbers come from? How is such a phenomenal savings achieved? The answers to these questions are the topic of this section.</p>"},{"location":"c8/s5/#851-\u6570\u5b57\u56fe\u50cf\u5feb\u901f\u56de\u987e","title":"8.5.1. \u6570\u5b57\u56fe\u50cf\u5feb\u901f\u56de\u987e","text":"<p>8.5.1. A Quick Review of Digital Images</p> \u4e2d\u6587\u82f1\u6587 <p>A digital image is composed of thousands of individual components called pixels. The pixels are arranged as a rectangle that forms the image. Each pixel in an image represents a particular color in the image. On a computer, the color of each pixel is determined by a mixture of three primary colors: red, green, and blue. A simple example of how pixels are arranged to form a picture is shown in <code>Figure\u00a01</code>.</p> <p> Figure\u00a01: A Simple Image Composed of Pixels </p> <p>In the physical world colors are not discrete quantities. The colors in our physical world have an infinite amount of variation to them. Just as computers must approximate floating point numbers, they also must approximate the colors in an image. The human eye can distinguish between 200 different levels in each of the three primary colors, or a total of about 8 million individual colors. In practice we use one byte (8 bits) of memory for each color component of a pixel. Eight bits gives us 256 different levels for each of the red, green, and blue components, for a total of 16.7 million different possible colors for each pixel. While the huge number of colors allows artists and graphic designers to create wonderfully detailed images, the downside of all of these color possibilities is that image size grows very rapidly. For example, a single image from a one-megapixel camera would take 3 megabytes of memory.</p> <p>In Python we might represent an image using a list of a list of tuples, where the tuples consist of three numbers between 0 and 255, one for each of the red, green, and blue components. In other languages, such as C++ and Java, an image could be represented as a two-dimensional array. The list of lists representation of the first two rows of the image in <code>Figure\u00a01</code> is shown below:</p> <pre><code>im = [[(255,255,255),(255,255,255),(255,255,255),(12,28,255),\n        (12,28,255),(255,255,255),(255,255,255),(255,255,255),],\n        [(255,255,255),(255,255,255),(12,28,255),(255,255,255),\n        (255,255,255),(12,28,255),(255,255,255),(255,255,255)],\n... ]\n</code></pre> <p>The color white is represented by the tuple \\((255, 255, 255)\\). A bluish color is represented by the tuple \\((12, 28, 255)\\). You can obtain the color value for any pixel in the image by simply using list indices, for example:</p> <pre><code>&gt;&gt;&gt; im[3][2]\n(255, 18, 39)\n</code></pre> <p>With this representation for an image in mind, you can imagine that it would be easy to store an image to a file just by writing a tuple for each pixel. You might start by writing the number of rows and columns in the image and then by writing three integer values per line. In practice, the Python package <code>Pillow</code> provides us with some powerful classes. Using the <code>Image</code> class we can get and set pixels using <code>getpixel((col, row))</code> and <code>putpixel((col, row), color)</code>. Note that the parameters for the image methods are in the traditional \\(x, y\\) order but many people forget and think in terms of row, column order.</p> <p>A digital image is composed of thousands of individual components called pixels. The pixels are arranged as a rectangle that forms the image. Each pixel in an image represents a particular color in the image. On a computer, the color of each pixel is determined by a mixture of three primary colors: red, green, and blue. A simple example of how pixels are arranged to form a picture is shown in <code>Figure\u00a01</code>.</p> <p> Figure\u00a01: A Simple Image Composed of Pixels </p> <p>In the physical world colors are not discrete quantities. The colors in our physical world have an infinite amount of variation to them. Just as computers must approximate floating point numbers, they also must approximate the colors in an image. The human eye can distinguish between 200 different levels in each of the three primary colors, or a total of about 8 million individual colors. In practice we use one byte (8 bits) of memory for each color component of a pixel. Eight bits gives us 256 different levels for each of the red, green, and blue components, for a total of 16.7 million different possible colors for each pixel. While the huge number of colors allows artists and graphic designers to create wonderfully detailed images, the downside of all of these color possibilities is that image size grows very rapidly. For example, a single image from a one-megapixel camera would take 3 megabytes of memory.</p> <p>In Python we might represent an image using a list of a list of tuples, where the tuples consist of three numbers between 0 and 255, one for each of the red, green, and blue components. In other languages, such as C++ and Java, an image could be represented as a two-dimensional array. The list of lists representation of the first two rows of the image in <code>Figure\u00a01</code> is shown below:</p> <pre><code>im = [[(255,255,255),(255,255,255),(255,255,255),(12,28,255),\n        (12,28,255),(255,255,255),(255,255,255),(255,255,255),],\n        [(255,255,255),(255,255,255),(12,28,255),(255,255,255),\n        (255,255,255),(12,28,255),(255,255,255),(255,255,255)],\n... ]\n</code></pre> <p>The color white is represented by the tuple \\((255, 255, 255)\\). A bluish color is represented by the tuple \\((12, 28, 255)\\). You can obtain the color value for any pixel in the image by simply using list indices, for example:</p> <pre><code>&gt;&gt;&gt; im[3][2]\n(255, 18, 39)\n</code></pre> <p>With this representation for an image in mind, you can imagine that it would be easy to store an image to a file just by writing a tuple for each pixel. You might start by writing the number of rows and columns in the image and then by writing three integer values per line. In practice, the Python package <code>Pillow</code> provides us with some powerful classes. Using the <code>Image</code> class we can get and set pixels using <code>getpixel((col, row))</code> and <code>putpixel((col, row), color)</code>. Note that the parameters for the image methods are in the traditional \\(x, y\\) order but many people forget and think in terms of row, column order.</p>"},{"location":"c8/s5/#852-\u56fe\u50cf\u91cf\u5316","title":"8.5.2. \u56fe\u50cf\u91cf\u5316","text":"<p>8.5.2. Quantizing an Image</p> \u4e2d\u6587\u82f1\u6587 <p>There are many ways of reducing the storage requirements for an image. One of the easiest ways is to simply use fewer colors. Fewer color choices means fewer bits for each red, green, and blue component, which means reduced memory requirements. In fact, one of the most popular image formats used for images on the World Wide Web uses only 256 colors for an image. Using 256 colors reduces the storage requirements from three bytes per pixel to one byte per pixel.</p> <p>Right now you are probably asking yourself how to take an image that  may have as many as 16 million colors and reduce it to just 256? The answer is a process called quantization. To understand the process of quantization let\u2019s think about colors as a three-dimensional space. Each color can be represented by a point in space where the red component is the x axis, the green component is the y axis, and the blue component is the z axis. We can think of the space of all possible colors as a \\(256 \\times 256 \\times 256\\) cube. The colors closest to the vertex at \\((0, 0, 0)\\) are going to be black and dark color shades. The colors closest to the vertex at \\((255, 255, 255)\\) are bright and close to white. The colors closest to \\((255, 0, 0)\\) are red and so forth.</p> <p>The simplest way to think about quantizing an image is to imagine taking the \\(256 \\times 256 \\times 256\\) cube and turning it into an \\(8 \\times 8 \\times 8\\) cube. The overall size of the cube stays the same, but now many colors in the old cube are represented by a single color in the new cube. <code>Figure\u00a02</code> shows an example of the quantization just described.</p> <p> Figure\u00a02: Color Quantization </p> <p>We can turn this simple idea of color quantization into the Python program shown in <code>Listing\u00a0lst_simplequant</code>. The <code>simple_quant</code> algorithm works by mapping the color components for each pixel represented by its full 256 bits to the color at the center of the cube in its area. This is easy to do using integer division in Python. In the <code>simple_quant</code> algorithm there are seven distinct values in the red dimension and six distinct values in the green and blue dimensions.</p> Listing\u00a0lst_simplequant<pre><code>from PIL import Image\n\n\ndef simple_quant(filename):\n    im = Image.open(filename)\n    w, h = im.size\n    for row in range(h):\n        for col in range(w):\n            r, g, b = im.getpixel((col, row))\n            r = r // 36 * 36\n            g = g // 42 * 42\n            b = b // 42 * 42\n            im.putpixel((col, row), (r, g, b))\n    im.show()\n\nsimple_quant(\"bubbles.jpg\")\n</code></pre> <p><code>Figure\u00a02</code> shows a before and after comparison of original and quantized images. Of course, these are color pictures that have been converted to gray scale for publication. You can use any JPEG color image from your collection and run the program to see the real difference in full color. Notice how much detail is lost in the quantized picture. The grass has lost nearly all its detail and is uniformly green, and the skin tones have been reduced to two shades of tan.</p> <p>There are many ways of reducing the storage requirements for an image. One of the easiest ways is to simply use fewer colors. Fewer color choices means fewer bits for each red, green, and blue component, which means reduced memory requirements. In fact, one of the most popular image formats used for images on the World Wide Web uses only 256 colors for an image. Using 256 colors reduces the storage requirements from three bytes per pixel to one byte per pixel.</p> <p>Right now you are probably asking yourself how to take an image that  may have as many as 16 million colors and reduce it to just 256? The answer is a process called quantization. To understand the process of quantization let\u2019s think about colors as a three-dimensional space. Each color can be represented by a point in space where the red component is the x axis, the green component is the y axis, and the blue component is the z axis. We can think of the space of all possible colors as a \\(256 \\times 256 \\times 256\\) cube. The colors closest to the vertex at \\((0, 0, 0)\\) are going to be black and dark color shades. The colors closest to the vertex at \\((255, 255, 255)\\) are bright and close to white. The colors closest to \\((255, 0, 0)\\) are red and so forth.</p> <p>The simplest way to think about quantizing an image is to imagine taking the \\(256 \\times 256 \\times 256\\) cube and turning it into an \\(8 \\times 8 \\times 8\\) cube. The overall size of the cube stays the same, but now many colors in the old cube are represented by a single color in the new cube. <code>Figure\u00a02</code> shows an example of the quantization just described.</p> <p> Figure\u00a02: Color Quantization </p> <p>We can turn this simple idea of color quantization into the Python program shown in <code>Listing\u00a0lst_simplequant</code>. The <code>simple_quant</code> algorithm works by mapping the color components for each pixel represented by its full 256 bits to the color at the center of the cube in its area. This is easy to do using integer division in Python. In the <code>simple_quant</code> algorithm there are seven distinct values in the red dimension and six distinct values in the green and blue dimensions.</p> Listing\u00a0lst_simplequant<pre><code>from PIL import Image\n\n\ndef simple_quant(filename):\n    im = Image.open(filename)\n    w, h = im.size\n    for row in range(h):\n        for col in range(w):\n            r, g, b = im.getpixel((col, row))\n            r = r // 36 * 36\n            g = g // 42 * 42\n            b = b // 42 * 42\n            im.putpixel((col, row), (r, g, b))\n    im.show()\n\nsimple_quant(\"bubbles.jpg\")\n</code></pre> <p><code>Figure\u00a02</code> shows a before and after comparison of original and quantized images. Of course, these are color pictures that have been converted to gray scale for publication. You can use any JPEG color image from your collection and run the program to see the real difference in full color. Notice how much detail is lost in the quantized picture. The grass has lost nearly all its detail and is uniformly green, and the skin tones have been reduced to two shades of tan.</p>"},{"location":"c8/s5/#853-\u4f7f\u7528\u516b\u53c9\u6811\u7684\u6539\u8fdb\u91cf\u5316\u7b97\u6cd5","title":"8.5.3. \u4f7f\u7528\u516b\u53c9\u6811\u7684\u6539\u8fdb\u91cf\u5316\u7b97\u6cd5","text":"<p>8.5.3. An Improved Quantization Algorithm Using Octrees</p> \u4e2d\u6587\u82f1\u6587 <p>The problem with the simple method of quantization just described is that the colors in most pictures are not evenly distributed throughout the color cube. Many colors may not appear in the image, so parts of the cube may go completely unused. Allocating an unused color to the quantized image is a waste. <code>Figure\u00a03</code> shows the distribution of the colors that are used in the example image. Notice how little of the color cube space is actually used.</p> <p> Figure\u00a03: Plot of Colors Used in Image as Points in Color Cube </p> <p>To make a better quantized image we need to find a way to do a better job of selecting the set of colors we want to use to represent our image. There are several algorithms for dividing the color cube in different ways to allow for the better use of colors. In this section we are going to look at a tree-based solution. The tree solution we will use makes use of an octree. An octree is similar to a binary tree; however, each node in an octree has eight children. Here is the interface we will implement for our octree abstract data type:</p> <ul> <li><code>Octree()</code> creates a new empty octree.</li> <li><code>insert(r, g, b)</code> adds a new node to the octree using the red, green, and blue color values as the key.</li> <li><code>find(r, g, b)</code> finds an existing node, or the closest approximation, using the red, green, and blue color values as the search key.</li> <li><code>reduce(n)</code> reduces the size of the octree so that there are \\(n\\) or fewer leaf nodes.</li> </ul> <p>Here is how an octree is used to divide the color cube:</p> <ul> <li>The root of the octree represents the entire cube.</li> <li>The second level of the octree represents a single slice through each dimension (\\(x\\), \\(y\\), and \\(z\\)) that evenly divides the cube into eight pieces.</li> <li>The next level of the tree divides each of the eight sub-cubes into eight additional cubes for a total of 64 cubes. Notice that the cube represented by the parent node totally contains all of the sub-cubes represented by the children. As we follow any path down the tree we are staying within the boundary of the parent, but getting progressively more specific about the portion of the cube.</li> <li>The eighth level of the tree represents the full resolution of 16.7 million colors in our color cube.</li> </ul> <p>Now that you know how we can represent the color cube using an octree, you may be thinking that the octree is just another way to divide up the color cube into even parts. You are correct. However, because the octree is hierarchical, we can take advantage of the hierarchy to use larger cubes to represent unused portions of the color cube and smaller cubes to represent the popular colors. Here is an overview of how we will use an octree to do a better job of selecting a subset of the colors in an image:</p> <ol> <li> <p>For each pixel in the image:</p> <ol> <li>Search for the color of this pixel in the octree. The colo will be a leaf node at the eighth level.</li> <li>If the color is not found create a new leaf node at the eighth level (and possibly some internal nodes above the leaf).</li> <li>If the color is already present in the tree increment the counter in the leaf node to keep track of how many pixels are this color.</li> </ol> </li> <li> <p>Repeat until the number of leaf nodes is less than or equal to the target number of colors.</p> <ol> <li>Find the deepest leaf node with the smallest number of uses.</li> <li>Merge the leaf node and all of its siblings together to form a new leaf node.</li> </ol> </li> <li> <p>The remaining leaf nodes form the color set for this image.</p> </li> <li> <p>To map an original color to its quantized value simply search down the tree until you get to a leaf node. Return the color values stored in the leaf.</p> </li> </ol> <p>The ideas outlined above are encoded as a Python function to read, quantize, and display an image in the function <code>build_and_display()</code> in <code>Listing\u00a0lst_bad</code>.</p> Listing\u00a0lst_bad<pre><code>def build_and_display(filename):\n    img = Image.open(filename)\n    w, h = img.size\n    ot = Octree()\n    for row in range(h):\n        for col in range(w):\n            r, g, b = img.getpixel((col, row))\n            ot.insert(r, g, b)\n    ot.reduce(256)\n\n    for row in range(h):\n        for col in range(w):\n            r, g, b = img.getpixel((col, row))\n            nr, ng, nb = ot.find(r, g, b)\n            img.putpixel((col, row), (nr, ng, nb))\n    img.show()\n</code></pre> <p>The <code>build_and_display</code> function follows the basic process just described. First, the loops in lines 5\u20138 read each pixel and add it to the octree. Second, the number of leaf nodes is reduced by the <code>reduce</code> method on line 9. Finally, the image is updated by searching for a color, using <code>find</code>, in the reduced octree on line 14.</p> <p>We are using the Python image library to open an existing image file (<code>Image.open</code>), read a pixel (<code>getpixel</code>), write a pixel (<code>putpixel</code>), and display the result to the screen (<code>show</code>). <code>build_and_display</code> interacts with the octree using an instance of the <code>Octree</code> class (<code>Listing\u00a0lst_octreedef</code>).</p> Listing\u00a0lst_octreedef<pre><code>class octree:\n    def __init__(self):\n        self.root = None\n        self.max_level = 5\n        self.num_leaves = 0\n        self.all_leaves = []\n\n    def insert(self, r, g, b):\n        if not self.root:\n            self.root = self.OTNode(outer=self)\n        self.root.insert(r, g, b, 0, self)\n\n    def find(self, r, g, b):\n        if self.root:\n            return self.root.find(r, g, b, 0)\n\n    def reduce(self, max_cubes):   # line_otreduce\n        while len(self.all_leaves) &gt; max_cubes:\n            smallest = self.find_min_cube()\n            smallest.parent.merge()  # line_otredmerge\n            self.all_leaves.append(smallest.parent)\n            self.num_leaves = self.num_leaves + 1\n\n    def find_min_cube(self):\n        min_count = sys.maxsize\n        max_level = 0\n        min_cube = None\n        for i in self.all_leaves:\n            if (\n                i.count &lt;= min_count\n                and i.level &gt;= max_level\n            ):\n                min_cube = i\n                min_count = i.count\n                max_level = i.level\n        return min_cube\n</code></pre> <p>First notice that the constructor for an <code>Octree</code> initializes the root node to <code>None</code>. Then it sets up three important attributes that all the nodes of an octree may need to access. Those attributes are <code>max_level</code>, <code>num_leaves</code>, and <code>all_leaves</code>. The <code>max_level</code> attribute limits the total depth of the tree. Notice that in our implementation we have initialized <code>max_level</code> to five. This is a small optimization that simply allows us to ignore the two least significant bits of color information. It keeps the overall size of the tree much smaller and doesn\u2019t hurt the quality of the final image at all. The <code>num_leaves</code> and <code>all_leaves</code> attributes allow us to keep track of the number of leaf nodes and allow us direct access to the leaves without traversing all the way down the tree. We will see why this is important shortly.</p> <p>The <code>insert</code> and <code>find</code> methods behave exactly like their cousins in chapter chap_tree. They each check to see if a root node exists, and then call the corresponding method in the root node. Notice that <code>insert</code> and <code>find</code> both use the red, green, and blue components (<code>(r, g, b)</code>) to identify a node in the tree.</p> <p>The <code>reduce</code> method is defined on line <code>[lst_octreedef:line_otreduce]</code> of <code>Listing\u00a0lst_octreedef</code>. This method simply loops until the number of leaves in the leaf list is less than the total number of colors we want to have in the final image (defined by the parameter <code>max_cubes</code>). <code>reduce</code> makes use of a helper function <code>find_min_cube</code> to find the node in the octree with the smallest reference count. Once the node with the smallest reference count is found, that node is merged into a single node with all of its siblings (see line <code>[lst_octreedef:line_otredmerge]</code>).</p> <p>The <code>find_min_cube</code> method is implemented using the <code>all_leaves</code> and a simple find minimum loop pattern. When the number of leaf nodes is large, and it could be as large is 16.7 million, this approach is not very efficient. In one of the exercises you are asked to modify the <code>Octree</code> class and improve the efficiency of <code>find_min_cube</code>.</p> <p>One of the things to mention about the <code>Octree</code> class is that it uses an instance of the class <code>OTNode</code> which is defined inside the the <code>Octree</code> class. A class that is defined inside another class is called an inner class. We define <code>OTNode</code> inside <code>Octree</code> because each node of an octree needs to have access to some information that is stored in an instance of the <code>Octree</code> class. Another reason for making <code>OTNode</code> an inner class is that there is no reason for any code outside of the <code>Octree</code> class to use it. The way that an octree is implemented is really a private detail that nobody else needs to know about. This is a good software engineering practice known as information hiding.</p> <p>Now let\u2019s look at the class definition for the nodes in an octree (<code>Listing\u00a0lst_otnodedef</code>). The constructor for the <code>OTNode</code> class has three optional parameters: <code>parent</code>, <code>level</code>, and <code>outer</code>. These parameters allow the <code>Octree</code> methods to construct new nodes under a variety of circumstances. As we did with binary search trees, we will keep track of the parent of a node explicitly. The level of the node simply indicates its depth in the tree. The most interesting of these three parameters is the <code>outer</code> parameter, which is a reference to the instance of the <code>octree</code> class that created this node. <code>outer</code> will function like <code>self</code> in that it will allow the instances of <code>OTNode</code> to access attributes of an instance of <code>Octree</code>.</p> <p>The other attributes that we want to remember about each node in an <code>octree</code> include the reference <code>count</code> and the red, green, and blue components of the color represented by this tree. As you will note in the <code>insert</code> function, only a leaf node of the tree will have values for <code>red</code>, <code>green</code>, <code>blue</code>, and <code>count</code>. Also note that since each node can have up to eight children we initialize a list of eight references to keep track of them all. Rather than a left and right child as in binary trees, an octree has 0\u20137 children.</p> Listing\u00a0lst_otnodedef<pre><code>class OTNode:\n    def __init__(self, parent=None, level=0, outer=None):\n        self.red = 0\n        self.green = 0\n        self.blue = 0\n        self.count = 0\n        self.parent = parent\n        self.level = level\n        self.oTree = outer\n        self.children = [None] * 8\n</code></pre> <p>Now we get into the really interesting parts of the octree implementation. The Python code for inserting a new node into an octree is shown in <code>Listing\u00a0lst_otninsert</code>. The first problem we need to solve is how to figure out where to place a new node in the tree. In a binary search tree we used the rule that a new node with a key less than its parent went in the left subtree, and a new node with a key greater than its parent went in the right subtree. But with eight possible children for each node it is not that simple. In addition, when indexing colors it is not obvious what the key for each node should be. In an <code>octree</code> we will use the information from the three color components. <code>Figure\u00a04</code> shows how we can use the red, green, and blue color values to compute an index for the position of the new node at each level of the tree. The corresponding Python code for computing the index is on line\u00a0<code>line_otci</code> of <code>Listing\u00a0lst_otninsert</code>.</p> Listing\u00a0lst_otninsert<pre><code>def insert(self, r, g, b, level, outer):\n    if level &lt; self.oTree.max_level:\n        idx = self.compute_index(\n            r, g, b, level\n        )\n        if self.children[idx] == None:\n            self.children[idx] = outer.OTNode(\n                parent=self,\n                level=level + 1,\n                outer=outer,\n            )\n        self.children[idx].insert(\n            r, g, b, level + 1, outer\n        )\n    else:\n        if self.count == 0:\n            self.oTree.num_leaves = (\n                self.oTree.num_leaves + 1\n            )\n            self.oTree.all_leaves.append(self)\n        self.red += r\n        self.green += g\n        self.blue += b\n        self.count = self.count + 1\n\ndef compute_index(self, r, g, b, l):  # line_otci\n    shift = 8 - l\n    rc = r &gt;&gt; shift - 2 &amp; 0x4\n    gc = g &gt;&gt; shift - 1 &amp; 0x2\n    bc = b &gt;&gt; shift &amp; 0x1\n    return rc | gc | bc\n</code></pre> <p>The computation of the index combines bits from each of the red, green, and blue color components, starting at the top of the tree with the highest order bits. <code>Figure\u00a04</code> shows the binary representation of the red, green, and blue components of 163, 98, 231. At the root of the tree we start with the most significant bit from each of the three color components; in this case the three bits are 1, 0, and 1. Putting these bits together we get binary 101 or decimal 5. You can see the binary manipulation of the red, green, and blue numbers in the <code>compute_index</code> method on line\u00a0<code>line_otci</code> in <code>Listing\u00a0lst_otninsert</code>.</p> <p>The operators used in the <code>compute_index</code> may be unfamiliar to you. The <code>&gt;&gt;</code> operator is the right shift operation. The <code>&amp;</code> is bitwise <code>and</code>, and <code>|</code> is logical <code>or</code>. The bitwise <code>or</code> and bitwise <code>and</code> operations work just like the logical operations used in conditionals, except that they work on the individual bits of a number. The shift operation simply moves the bits \\(n\\) places to the right, filling in with zeros on the left and dropping the bits as they go off the right.</p> <p>Once we have computed the index appropriate for the current level of the tree, we traverse down into the subtree. In the example in <code>Figure\u00a04</code> we follow the link at position\u00a05 in the <code>children</code> array. If there is no node at position\u00a05, we create one. We keep traversing down the tree until we get to <code>max_level</code>. At <code>max_level</code> we stop searching and store the data. Notice that we do not overwrite the data in the leaf node, but rather we add the color components to any existing components and increment the reference counter. This allows us to compute the average of any color below the current node in the color cube. In this way, a leaf node in the <code>octree</code> may represent a number of similar colors in the color cube.</p> <p> Figure 4: Computing an Index to Insert a Node in an octree </p> <p>The <code>find</code> method, shown in <code>Listing\u00a0lst_otnfind</code>, uses the same method of index computation as the <code>insert</code> method to traverse the tree in search of a node matching the red, green, and blue components. </p> Listing\u00a0lst_otnfind<pre><code>def find(self, r, g, b, level):\n    if level &lt; self.oTree.max_level:\n        idx = self.compute_index(r, g, b, level)\n        if self.children[idx]:\n            return self.children[idx].find(\n                r, g, b, level + 1\n            )\n        elif self.count &gt; 0:\n            return (\n                self.red // self.count,\n                self.green // self.count,\n                self.blue // self.count,\n            )\n        else:\n            print(\"No leaf node to represent this color\")\n    else:\n        return (\n            self.red // self.count,\n            self.green // self.count,\n            self.blue // self.count,\n        )\n</code></pre> <p>The <code>find</code> method has three exit conditions:</p> <ol> <li>We have reached the maximum level of the tree and so we return the average of the color information stored in this leaf node (see lines\u00a017--21).</li> <li>We have found a leaf node at a height less than <code>max_level</code> (see lines\u00a09--13). This is possible only after the tree has been reduced. See below.</li> <li>We try to follow a path into a nonexistent subtree, which is an error.</li> </ol> <p>The final aspect of the <code>OTNode</code> class is the <code>merge</code> method. It allows a parent to subsume all of its children and become a leaf node itself. If you remember back to the structure of the <code>octree</code> where each parent cube fully encloses all the cubes represented by the children, you will see why this makes sense. When we merge a group of siblings we are effectively taking a weighted average of the colors represented by each of those siblings. Since all the siblings are relatively close to each other in color space, the average is a good representation of all of them. <code>Figure\u00a05</code> illustrates the merge process for some sibling nodes.</p> <p> Figure 5: Merging Four Leaf Nodes of an <code>octree</code> </p> <p><code>Figure\u00a05</code> shows the red, green, and blue components represented by the four leaf nodes whose identifying color values are (101, 122, 167), (100, 122, 183), (123, 108, 163), and (126, 113, 166). As you can see in <code>Listing\u00a0lst_otnfind</code>the identifying values are calculated dividing the color values by the count. Notice how close they are in the overall color space. The leaf node that gets created from all of these has an ID of (112, 115, 168). This is close to the average of the four, but weighted more towards the third color tuple due to the fact that it had a reference count of 12.</p> <pre><code>def merge(self):\n    for child in [c for c in self.children if c]:\n        if child.count &gt; 0:\n            self.o_tree.all_leaves.remove(child)\n            self.o_tree.num_leaves -= 1\n        else:\n            print(\"Recursively merging non-leaf...\")\n            child.merge()\n        self.count += child.count\n        self.red += child.red\n        self.green += child.green\n        self.blue += child.blue\n    for i in range(8):\n        self.children[i] = None\n</code></pre> <p>Because the <code>octree</code> uses only colors that are really present in the image and faithfully preserves colors that are often used, the final quantized image from the <code>octree</code> is much higher quality than the simple method we used to start this section. <code>Figure 2</code> shows a comparison of the original image with the quantized image.</p> <p>There are many additional ways to compress images using techniques such as run-length encoding, discrete cosine transform, and Huffman coding. Any of these algorithms are within your grasp and we encourage you to look them up and read about them. In addition, quantized images can be improved by using a technique known as dithering. Dithering is a process by which different colors are placed near each other so that the eye blends the colors together, forming a more realistic image. This is an old trick used by newspapers for doing color printing using just black plus three different colors of ink. Again you can research dithering and try to apply it to some images on your own.</p> <p>The problem with the simple method of quantization just described is that the colors in most pictures are not evenly distributed throughout the color cube. Many colors may not appear in the image, so parts of the cube may go completely unused. Allocating an unused color to the quantized image is a waste. <code>Figure\u00a03</code> shows the distribution of the colors that are used in the example image. Notice how little of the color cube space is actually used.</p> <p> Figure\u00a03: Plot of Colors Used in Image as Points in Color Cube </p> <p>To make a better quantized image we need to find a way to do a better job of selecting the set of colors we want to use to represent our image. There are several algorithms for dividing the color cube in different ways to allow for the better use of colors. In this section we are going to look at a tree-based solution. The tree solution we will use makes use of an octree. An octree is similar to a binary tree; however, each node in an octree has eight children. Here is the interface we will implement for our octree abstract data type:</p> <ul> <li><code>Octree()</code> creates a new empty octree.</li> <li><code>insert(r, g, b)</code> adds a new node to the octree using the red, green, and blue color values as the key.</li> <li><code>find(r, g, b)</code> finds an existing node, or the closest approximation, using the red, green, and blue color values as the search key.</li> <li><code>reduce(n)</code> reduces the size of the octree so that there are \\(n\\) or fewer leaf nodes.</li> </ul> <p>Here is how an octree is used to divide the color cube:</p> <ul> <li>The root of the octree represents the entire cube.</li> <li>The second level of the octree represents a single slice through each dimension (\\(x\\), \\(y\\), and \\(z\\)) that evenly divides the cube into eight pieces.</li> <li>The next level of the tree divides each of the eight sub-cubes into eight additional cubes for a total of 64 cubes. Notice that the cube represented by the parent node totally contains all of the sub-cubes represented by the children. As we follow any path down the tree we are staying within the boundary of the parent, but getting progressively more specific about the portion of the cube.</li> <li>The eighth level of the tree represents the full resolution of 16.7 million colors in our color cube.</li> </ul> <p>Now that you know how we can represent the color cube using an octree, you may be thinking that the octree is just another way to divide up the color cube into even parts. You are correct. However, because the octree is hierarchical, we can take advantage of the hierarchy to use larger cubes to represent unused portions of the color cube and smaller cubes to represent the popular colors. Here is an overview of how we will use an octree to do a better job of selecting a subset of the colors in an image:</p> <ol> <li> <p>For each pixel in the image:</p> <ol> <li>Search for the color of this pixel in the octree. The colo will be a leaf node at the eighth level.</li> <li>If the color is not found create a new leaf node at the eighth level (and possibly some internal nodes above the leaf).</li> <li>If the color is already present in the tree increment the counter in the leaf node to keep track of how many pixels are this color.</li> </ol> </li> <li> <p>Repeat until the number of leaf nodes is less than or equal to the target number of colors.</p> <ol> <li>Find the deepest leaf node with the smallest number of uses.</li> <li>Merge the leaf node and all of its siblings together to form a new leaf node.</li> </ol> </li> <li> <p>The remaining leaf nodes form the color set for this image.</p> </li> <li> <p>To map an original color to its quantized value simply search down the tree until you get to a leaf node. Return the color values stored in the leaf.</p> </li> </ol> <p>The ideas outlined above are encoded as a Python function to read, quantize, and display an image in the function <code>build_and_display()</code> in <code>Listing\u00a0lst_bad</code>.</p> Listing\u00a0lst_bad<pre><code>def build_and_display(filename):\n    img = Image.open(filename)\n    w, h = img.size\n    ot = Octree()\n    for row in range(h):\n        for col in range(w):\n            r, g, b = img.getpixel((col, row))\n            ot.insert(r, g, b)\n    ot.reduce(256)\n\n    for row in range(h):\n        for col in range(w):\n            r, g, b = img.getpixel((col, row))\n            nr, ng, nb = ot.find(r, g, b)\n            img.putpixel((col, row), (nr, ng, nb))\n    img.show()\n</code></pre> <p>The <code>build_and_display</code> function follows the basic process just described. First, the loops in lines 5\u20138 read each pixel and add it to the octree. Second, the number of leaf nodes is reduced by the <code>reduce</code> method on line 9. Finally, the image is updated by searching for a color, using <code>find</code>, in the reduced octree on line 14.</p> <p>We are using the Python image library to open an existing image file (<code>Image.open</code>), read a pixel (<code>getpixel</code>), write a pixel (<code>putpixel</code>), and display the result to the screen (<code>show</code>). <code>build_and_display</code> interacts with the octree using an instance of the <code>Octree</code> class (<code>Listing\u00a0lst_octreedef</code>).</p> Listing\u00a0lst_octreedef<pre><code>class octree:\n    def __init__(self):\n        self.root = None\n        self.max_level = 5\n        self.num_leaves = 0\n        self.all_leaves = []\n\n    def insert(self, r, g, b):\n        if not self.root:\n            self.root = self.OTNode(outer=self)\n        self.root.insert(r, g, b, 0, self)\n\n    def find(self, r, g, b):\n        if self.root:\n            return self.root.find(r, g, b, 0)\n\n    def reduce(self, max_cubes):   # line_otreduce\n        while len(self.all_leaves) &gt; max_cubes:\n            smallest = self.find_min_cube()\n            smallest.parent.merge()  # line_otredmerge\n            self.all_leaves.append(smallest.parent)\n            self.num_leaves = self.num_leaves + 1\n\n    def find_min_cube(self):\n        min_count = sys.maxsize\n        max_level = 0\n        min_cube = None\n        for i in self.all_leaves:\n            if (\n                i.count &lt;= min_count\n                and i.level &gt;= max_level\n            ):\n                min_cube = i\n                min_count = i.count\n                max_level = i.level\n        return min_cube\n</code></pre> <p>First notice that the constructor for an <code>Octree</code> initializes the root node to <code>None</code>. Then it sets up three important attributes that all the nodes of an octree may need to access. Those attributes are <code>max_level</code>, <code>num_leaves</code>, and <code>all_leaves</code>. The <code>max_level</code> attribute limits the total depth of the tree. Notice that in our implementation we have initialized <code>max_level</code> to five. This is a small optimization that simply allows us to ignore the two least significant bits of color information. It keeps the overall size of the tree much smaller and doesn\u2019t hurt the quality of the final image at all. The <code>num_leaves</code> and <code>all_leaves</code> attributes allow us to keep track of the number of leaf nodes and allow us direct access to the leaves without traversing all the way down the tree. We will see why this is important shortly.</p> <p>The <code>insert</code> and <code>find</code> methods behave exactly like their cousins in chapter chap_tree. They each check to see if a root node exists, and then call the corresponding method in the root node. Notice that <code>insert</code> and <code>find</code> both use the red, green, and blue components (<code>(r, g, b)</code>) to identify a node in the tree.</p> <p>The <code>reduce</code> method is defined on line <code>[lst_octreedef:line_otreduce]</code> of <code>Listing\u00a0lst_octreedef</code>. This method simply loops until the number of leaves in the leaf list is less than the total number of colors we want to have in the final image (defined by the parameter <code>max_cubes</code>). <code>reduce</code> makes use of a helper function <code>find_min_cube</code> to find the node in the octree with the smallest reference count. Once the node with the smallest reference count is found, that node is merged into a single node with all of its siblings (see line <code>[lst_octreedef:line_otredmerge]</code>).</p> <p>The <code>find_min_cube</code> method is implemented using the <code>all_leaves</code> and a simple find minimum loop pattern. When the number of leaf nodes is large, and it could be as large is 16.7 million, this approach is not very efficient. In one of the exercises you are asked to modify the <code>Octree</code> class and improve the efficiency of <code>find_min_cube</code>.</p> <p>One of the things to mention about the <code>Octree</code> class is that it uses an instance of the class <code>OTNode</code> which is defined inside the the <code>Octree</code> class. A class that is defined inside another class is called an inner class. We define <code>OTNode</code> inside <code>Octree</code> because each node of an octree needs to have access to some information that is stored in an instance of the <code>Octree</code> class. Another reason for making <code>OTNode</code> an inner class is that there is no reason for any code outside of the <code>Octree</code> class to use it. The way that an octree is implemented is really a private detail that nobody else needs to know about. This is a good software engineering practice known as information hiding.</p> <p>Now let\u2019s look at the class definition for the nodes in an octree (<code>Listing\u00a0lst_otnodedef</code>). The constructor for the <code>OTNode</code> class has three optional parameters: <code>parent</code>, <code>level</code>, and <code>outer</code>. These parameters allow the <code>Octree</code> methods to construct new nodes under a variety of circumstances. As we did with binary search trees, we will keep track of the parent of a node explicitly. The level of the node simply indicates its depth in the tree. The most interesting of these three parameters is the <code>outer</code> parameter, which is a reference to the instance of the <code>octree</code> class that created this node. <code>outer</code> will function like <code>self</code> in that it will allow the instances of <code>OTNode</code> to access attributes of an instance of <code>Octree</code>.</p> <p>The other attributes that we want to remember about each node in an <code>octree</code> include the reference <code>count</code> and the red, green, and blue components of the color represented by this tree. As you will note in the <code>insert</code> function, only a leaf node of the tree will have values for <code>red</code>, <code>green</code>, <code>blue</code>, and <code>count</code>. Also note that since each node can have up to eight children we initialize a list of eight references to keep track of them all. Rather than a left and right child as in binary trees, an octree has 0\u20137 children.</p> Listing\u00a0lst_otnodedef<pre><code>class OTNode:\n    def __init__(self, parent=None, level=0, outer=None):\n        self.red = 0\n        self.green = 0\n        self.blue = 0\n        self.count = 0\n        self.parent = parent\n        self.level = level\n        self.oTree = outer\n        self.children = [None] * 8\n</code></pre> <p>Now we get into the really interesting parts of the octree implementation. The Python code for inserting a new node into an octree is shown in <code>Listing\u00a0lst_otninsert</code>. The first problem we need to solve is how to figure out where to place a new node in the tree. In a binary search tree we used the rule that a new node with a key less than its parent went in the left subtree, and a new node with a key greater than its parent went in the right subtree. But with eight possible children for each node it is not that simple. In addition, when indexing colors it is not obvious what the key for each node should be. In an <code>octree</code> we will use the information from the three color components. <code>Figure\u00a04</code> shows how we can use the red, green, and blue color values to compute an index for the position of the new node at each level of the tree. The corresponding Python code for computing the index is on line\u00a0<code>line_otci</code> of <code>Listing\u00a0lst_otninsert</code>.</p> Listing\u00a0lst_otninsert<pre><code>def insert(self, r, g, b, level, outer):\n    if level &lt; self.oTree.max_level:\n        idx = self.compute_index(\n            r, g, b, level\n        )\n        if self.children[idx] == None:\n            self.children[idx] = outer.OTNode(\n                parent=self,\n                level=level + 1,\n                outer=outer,\n            )\n        self.children[idx].insert(\n            r, g, b, level + 1, outer\n        )\n    else:\n        if self.count == 0:\n            self.oTree.num_leaves = (\n                self.oTree.num_leaves + 1\n            )\n            self.oTree.all_leaves.append(self)\n        self.red += r\n        self.green += g\n        self.blue += b\n        self.count = self.count + 1\n\ndef compute_index(self, r, g, b, l):  # line_otci\n    shift = 8 - l\n    rc = r &gt;&gt; shift - 2 &amp; 0x4\n    gc = g &gt;&gt; shift - 1 &amp; 0x2\n    bc = b &gt;&gt; shift &amp; 0x1\n    return rc | gc | bc\n</code></pre> <p>The computation of the index combines bits from each of the red, green, and blue color components, starting at the top of the tree with the highest order bits. <code>Figure\u00a04</code> shows the binary representation of the red, green, and blue components of 163, 98, 231. At the root of the tree we start with the most significant bit from each of the three color components; in this case the three bits are 1, 0, and 1. Putting these bits together we get binary 101 or decimal 5. You can see the binary manipulation of the red, green, and blue numbers in the <code>compute_index</code> method on line\u00a0<code>line_otci</code> in <code>Listing\u00a0lst_otninsert</code>.</p> <p>The operators used in the <code>compute_index</code> may be unfamiliar to you. The <code>&gt;&gt;</code> operator is the right shift operation. The <code>&amp;</code> is bitwise <code>and</code>, and <code>|</code> is logical <code>or</code>. The bitwise <code>or</code> and bitwise <code>and</code> operations work just like the logical operations used in conditionals, except that they work on the individual bits of a number. The shift operation simply moves the bits \\(n\\) places to the right, filling in with zeros on the left and dropping the bits as they go off the right.</p> <p>Once we have computed the index appropriate for the current level of the tree, we traverse down into the subtree. In the example in <code>Figure\u00a04</code> we follow the link at position\u00a05 in the <code>children</code> array. If there is no node at position\u00a05, we create one. We keep traversing down the tree until we get to <code>max_level</code>. At <code>max_level</code> we stop searching and store the data. Notice that we do not overwrite the data in the leaf node, but rather we add the color components to any existing components and increment the reference counter. This allows us to compute the average of any color below the current node in the color cube. In this way, a leaf node in the <code>octree</code> may represent a number of similar colors in the color cube.</p> <p> Figure 4: Computing an Index to Insert a Node in an octree </p> <p>The <code>find</code> method, shown in <code>Listing\u00a0lst_otnfind</code>, uses the same method of index computation as the <code>insert</code> method to traverse the tree in search of a node matching the red, green, and blue components. </p> Listing\u00a0lst_otnfind<pre><code>def find(self, r, g, b, level):\n    if level &lt; self.oTree.max_level:\n        idx = self.compute_index(r, g, b, level)\n        if self.children[idx]:\n            return self.children[idx].find(\n                r, g, b, level + 1\n            )\n        elif self.count &gt; 0:\n            return (\n                self.red // self.count,\n                self.green // self.count,\n                self.blue // self.count,\n            )\n        else:\n            print(\"No leaf node to represent this color\")\n    else:\n        return (\n            self.red // self.count,\n            self.green // self.count,\n            self.blue // self.count,\n        )\n</code></pre> <p>The <code>find</code> method has three exit conditions:</p> <ol> <li>We have reached the maximum level of the tree and so we return the average of the color information stored in this leaf node (see lines\u00a017--21).</li> <li>We have found a leaf node at a height less than <code>max_level</code> (see lines\u00a09--13). This is possible only after the tree has been reduced. See below.</li> <li>We try to follow a path into a nonexistent subtree, which is an error.</li> </ol> <p>The final aspect of the <code>OTNode</code> class is the <code>merge</code> method. It allows a parent to subsume all of its children and become a leaf node itself. If you remember back to the structure of the <code>octree</code> where each parent cube fully encloses all the cubes represented by the children, you will see why this makes sense. When we merge a group of siblings we are effectively taking a weighted average of the colors represented by each of those siblings. Since all the siblings are relatively close to each other in color space, the average is a good representation of all of them. <code>Figure\u00a05</code> illustrates the merge process for some sibling nodes.</p> <p> Figure 5: Merging Four Leaf Nodes of an <code>octree</code> </p> <p><code>Figure\u00a05</code> shows the red, green, and blue components represented by the four leaf nodes whose identifying color values are (101, 122, 167), (100, 122, 183), (123, 108, 163), and (126, 113, 166). As you can see in <code>Listing\u00a0lst_otnfind</code>the identifying values are calculated dividing the color values by the count. Notice how close they are in the overall color space. The leaf node that gets created from all of these has an ID of (112, 115, 168). This is close to the average of the four, but weighted more towards the third color tuple due to the fact that it had a reference count of 12.</p> <pre><code>def merge(self):\n    for child in [c for c in self.children if c]:\n        if child.count &gt; 0:\n            self.o_tree.all_leaves.remove(child)\n            self.o_tree.num_leaves -= 1\n        else:\n            print(\"Recursively merging non-leaf...\")\n            child.merge()\n        self.count += child.count\n        self.red += child.red\n        self.green += child.green\n        self.blue += child.blue\n    for i in range(8):\n        self.children[i] = None\n</code></pre> <p>Because the <code>octree</code> uses only colors that are really present in the image and faithfully preserves colors that are often used, the final quantized image from the <code>octree</code> is much higher quality than the simple method we used to start this section. <code>Figure 2</code> shows a comparison of the original image with the quantized image.</p> <p>There are many additional ways to compress images using techniques such as run-length encoding, discrete cosine transform, and Huffman coding. Any of these algorithms are within your grasp and we encourage you to look them up and read about them. In addition, quantized images can be improved by using a technique known as dithering. Dithering is a process by which different colors are placed near each other so that the eye blends the colors together, forming a more realistic image. This is an old trick used by newspapers for doing color printing using just black plus three different colors of ink. Again you can research dithering and try to apply it to some images on your own.</p>"},{"location":"c8/s6/","title":"8.6. \u56fe\u518d\u63a2\uff1a\u6a21\u5f0f\u5339\u914d","text":"<p>8.6. Graphs Revisited: Pattern Matching</p> \u4e2d\u6587\u82f1\u6587 <p>Even with the growing interest in computer graphics, processing textual information is still an important area of study. Of particular interest here is the problem of finding patterns, often referred to as substrings, that exist in long strings of characters. The task is to perform some type of search that can identify at least the first occurrence of the pattern. We can also consider an extension of this problem to find all such occurrences.</p> <p>Python includes a built-in substring method called <code>find</code> that returns the location of the first occurrence of a pattern in a given string. For example,</p> <pre><code>&gt;&gt;&gt; \"ccabababcab\".find(\"ab\")\n2\n&gt;&gt;&gt; \"ccabababcab\".find(\"xyz\")\n-1\n&gt;&gt;&gt;\n</code></pre> <p>shows that the substring <code>\"ab\"</code> occurs for the first time starting at index position <code>2</code> in the string <code>\"ccabababcab\"</code>. <code>find</code> also returns a <code>-1</code> if the pattern does not occur.</p> <p>Even with the growing interest in computer graphics, processing textual information is still an important area of study. Of particular interest here is the problem of finding patterns, often referred to as substrings, that exist in long strings of characters. The task is to perform some type of search that can identify at least the first occurrence of the pattern. We can also consider an extension of this problem to find all such occurrences.</p> <p>Python includes a built-in substring method called <code>find</code> that returns the location of the first occurrence of a pattern in a given string. For example,</p> <pre><code>&gt;&gt;&gt; \"ccabababcab\".find(\"ab\")\n2\n&gt;&gt;&gt; \"ccabababcab\".find(\"xyz\")\n-1\n&gt;&gt;&gt;\n</code></pre> <p>shows that the substring <code>\"ab\"</code> occurs for the first time starting at index position <code>2</code> in the string <code>\"ccabababcab\"</code>. <code>find</code> also returns a <code>-1</code> if the pattern does not occur.</p>"},{"location":"c8/s6/#861-\u751f\u7269\u5b57\u7b26\u4e32","title":"8.6.1. \u751f\u7269\u5b57\u7b26\u4e32","text":"<p>8.6.1. Biological Strings</p> \u4e2d\u6587\u82f1\u6587 <p>Some of the most exciting work in algorithm development is currently taking place in the domain of bioinformatics; in particular, finding ways to manage and process large quantities of biological data. Much of this data takes the form of coded genetic material stored in the chromosomes of individual organisms. Deoxyribonucleic acid, more commonly known as DNA, is a very simple organic molecule that provides the blueprint for protein synthesis.</p> <p>DNA is basically a long sequence consisting of four chemical bases: adenine(A), thymine(T), guanine(G), and cytosine(C). These four symbols are often referred to as the genetic alphabet and we represent a piece of DNA as a string or sequence of these base symbols. For example, the DNA string ATCGTAGAGTCAGTAGAGACTADTGGTACGA might code a very small part of a DNA strand. It turns out that within these long strings, perhaps thousands and thousands of base symbols long, small pieces exist that provide extensive information as to the meaning of this genetic code. We can see then that having methods for searching out these pieces is a very important tool for the bioinformatics researcher.</p> <p>Our problem then reduces to the following ideas. Given a string of symbols from the underlying alphabet A, T, G, and C, develop an algorithm that will allow us to locate a particular pattern within that string. We will often refer to the DNA string as the text. If the pattern does not exist, we would like to know that as well. Further, since these strings are typically quite long, we need to be sure that the algorithm is efficient.</p> <p>Some of the most exciting work in algorithm development is currently taking place in the domain of bioinformatics; in particular, finding ways to manage and process large quantities of biological data. Much of this data takes the form of coded genetic material stored in the chromosomes of individual organisms. Deoxyribonucleic acid, more commonly known as DNA, is a very simple organic molecule that provides the blueprint for protein synthesis.</p> <p>DNA is basically a long sequence consisting of four chemical bases: adenine(A), thymine(T), guanine(G), and cytosine(C). These four symbols are often referred to as the genetic alphabet and we represent a piece of DNA as a string or sequence of these base symbols. For example, the DNA string ATCGTAGAGTCAGTAGAGACTADTGGTACGA might code a very small part of a DNA strand. It turns out that within these long strings, perhaps thousands and thousands of base symbols long, small pieces exist that provide extensive information as to the meaning of this genetic code. We can see then that having methods for searching out these pieces is a very important tool for the bioinformatics researcher.</p> <p>Our problem then reduces to the following ideas. Given a string of symbols from the underlying alphabet A, T, G, and C, develop an algorithm that will allow us to locate a particular pattern within that string. We will often refer to the DNA string as the text. If the pattern does not exist, we would like to know that as well. Further, since these strings are typically quite long, we need to be sure that the algorithm is efficient.</p>"},{"location":"c8/s6/#862-\u7b80\u5355\u6bd4\u8f83","title":"8.6.2. \u7b80\u5355\u6bd4\u8f83","text":"<p>8.6.2. Simple Comparison</p> \u4e2d\u6587\u82f1\u6587 <p>Our first approach is likely the solution that comes immediately to your mind for solving the DNA string pattern-matching problem. We will simply try all possibilities for matching the pattern to the text. <code>Figure\u00a01</code> shows how the algorithm will work. We will start out comparing the pattern from left to right with the text, starting at the first character in both. If there is a match, then we proceed to check the second character. Whenever a mismatch occurs, we simply slide the pattern one position to the right and start over.</p> <p> Figure\u00a01: A Simple Pattern-Matching Algorithm </p> <p>In this example, we have found a match on the sixth attempt, starting at position 5. The shaded characters denote the partial matches that occurred as we moved the pattern. <code>Listing\u00a0lst_simplematcher</code> shows the Python implementation for this method. It takes the pattern and the text as parameters. If there is a pattern match, it returns the position of the starting text character. Otherwise, it returns <code>-1</code> to signal that the search failed.</p> Listing\u00a0lst_simplematcher<pre><code>def simple_matcher(pattern, text):\n    i = j = 0\n\n    while True:\n        if text[i] == pattern[j]:\n            j = j + 1\n        else:\n            j = 0\n        i = i + 1\n\n        if i == len(text):\n            return -1\n        if j == len(pattern):\n            return i - j\n</code></pre> <p>The variables <code>i</code> and <code>j</code> serve as indices into the text and pattern respectively. The loop repeats until either the text or the pattern ends.</p> <p>Line\u00a05 checks for a match between the current text character and the current pattern character. If the match occurs, pattern index is incremented. If the match fails, we reset the pattern back to its beginning (line\u00a04). In both cases we move to the next position in the text. At every iteration of the loop we check if there is more text to process (line\u00a011) and return -1 if not. Line\u00a013 checks to see if every character in the pattern has been processed. If so, a match has been found and we return its starting index.</p> <p>If we assume that the length of the text is \\(n\\) characters and the length of the pattern is \\(m\\) characters, then it is easy to see that the complexity of this approach is \\(O(nm)\\). For each of the \\(n\\) characters we may have to compare against almost all \\(m\\) of the pattern characters. This is not so bad if the size of \\(n\\) and \\(m\\) are small. However, if we are considering thousands (or perhaps millions) of characters in our text in addition a large pattern, it will be necessary to look for a better approach.</p> <p>Our first approach is likely the solution that comes immediately to your mind for solving the DNA string pattern-matching problem. We will simply try all possibilities for matching the pattern to the text. <code>Figure\u00a01</code> shows how the algorithm will work. We will start out comparing the pattern from left to right with the text, starting at the first character in both. If there is a match, then we proceed to check the second character. Whenever a mismatch occurs, we simply slide the pattern one position to the right and start over.</p> <p> Figure\u00a01: A Simple Pattern-Matching Algorithm </p> <p>In this example, we have found a match on the sixth attempt, starting at position 5. The shaded characters denote the partial matches that occurred as we moved the pattern. <code>Listing\u00a0lst_simplematcher</code> shows the Python implementation for this method. It takes the pattern and the text as parameters. If there is a pattern match, it returns the position of the starting text character. Otherwise, it returns <code>-1</code> to signal that the search failed.</p> Listing\u00a0lst_simplematcher<pre><code>def simple_matcher(pattern, text):\n    i = j = 0\n\n    while True:\n        if text[i] == pattern[j]:\n            j = j + 1\n        else:\n            j = 0\n        i = i + 1\n\n        if i == len(text):\n            return -1\n        if j == len(pattern):\n            return i - j\n</code></pre> <p>The variables <code>i</code> and <code>j</code> serve as indices into the text and pattern respectively. The loop repeats until either the text or the pattern ends.</p> <p>Line\u00a05 checks for a match between the current text character and the current pattern character. If the match occurs, pattern index is incremented. If the match fails, we reset the pattern back to its beginning (line\u00a04). In both cases we move to the next position in the text. At every iteration of the loop we check if there is more text to process (line\u00a011) and return -1 if not. Line\u00a013 checks to see if every character in the pattern has been processed. If so, a match has been found and we return its starting index.</p> <p>If we assume that the length of the text is \\(n\\) characters and the length of the pattern is \\(m\\) characters, then it is easy to see that the complexity of this approach is \\(O(nm)\\). For each of the \\(n\\) characters we may have to compare against almost all \\(m\\) of the pattern characters. This is not so bad if the size of \\(n\\) and \\(m\\) are small. However, if we are considering thousands (or perhaps millions) of characters in our text in addition a large pattern, it will be necessary to look for a better approach.</p>"},{"location":"c8/s6/#863-\u4f7f\u7528\u56fe\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a","title":"8.6.3. \u4f7f\u7528\u56fe\uff1a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a","text":"<p>8.6.3. Using Graphs: Finite State Automata</p> \u4e2d\u6587\u82f1\u6587 <p>It is possible to create an \\(O(n)\\) pattern matcher if we are willing to do some preprocessing with the pattern. One approach is to build what is known as a deterministic finite automaton, or DFA, that represents the pattern as a graph. Each vertex of the DFA graph is a state, keeping track of the amount of the pattern that has been seen so far. Each edge of the graph represents a transition that takes place after processing a character from the text.</p> <p><code>Figure\u00a02</code> shows a DFA for the example pattern from the last section (ACATA). The first vertex (state 0) is known as the start state (or initial state) and denotes that we have not seen any matching pattern characters so far. Clearly, before processing the first text character, this is the situation.</p> <p> Figure\u00a02: A Deterministic Finite Automaton </p> <p>The DFA works in a very simple way. We keep track of our current state, setting it to 0 when we start. We read the next character from the text. Depending on the character, we follow the appropriate transition to the next state, which in turn becomes the new current state. By definition, each state has one and only one transition for each character in the alphabet. This means that for our DNA alphabet we know that each state has four possible transitions to a next state. Note that in the figure we have labeled some edges (transitions) with multiple alphabet symbols to denote more than one transition to the same state.</p> <p>We continue to follow transitions until a termination event occurs. If we enter state 5, known as the final state (the two concentric circles denote the final state in the DFA graph), we can stop and report success. The DFA graph has discovered an occurrence of the pattern. You might note that there are no transitions out of the final state, meaning that we must stop at that point. The location of the pattern can be computed from the location of the current character and the size of the pattern. On the other hand, if we run out of text characters and the current state is somewhere else in the DFA, known as a nonfinal state, we know that the pattern did not occur.</p> <p><code>Figure\u00a03</code> shows a step-by-step trace of the example DFA as it works through the text string ACGACACATA looking for the substring ACATA. The next state computed by the DFA always becomes the current state in the subsequent step. Since there is one and only one next state for every current state\u2013current character combination, the processing through the DFA graph is easy to follow.</p> <p> Figure\u00a03: A Trace of the DFA Pattern Matcher </p> <p>Since every character from the text is used once as input to the DFA graph, the complexity of this approach is \\(O(n)\\). However, we need to take into account the preprocessing step that builds the DFA. There are many well-known algorithms for producing a DFA graph from a pattern. Unfortunately, all of them are quite complex mostly due to the fact that each state (vertex) must have a transition (edge) accounting for each alphabet symbol. The question arises as to whether there might be a similar pattern matcher that employs a more streamlined set of edges.</p> <p>It is possible to create an \\(O(n)\\) pattern matcher if we are willing to do some preprocessing with the pattern. One approach is to build what is known as a deterministic finite automaton, or DFA, that represents the pattern as a graph. Each vertex of the DFA graph is a state, keeping track of the amount of the pattern that has been seen so far. Each edge of the graph represents a transition that takes place after processing a character from the text.</p> <p><code>Figure\u00a02</code> shows a DFA for the example pattern from the last section (ACATA). The first vertex (state 0) is known as the start state (or initial state) and denotes that we have not seen any matching pattern characters so far. Clearly, before processing the first text character, this is the situation.</p> <p> Figure\u00a02: A Deterministic Finite Automaton </p> <p>The DFA works in a very simple way. We keep track of our current state, setting it to 0 when we start. We read the next character from the text. Depending on the character, we follow the appropriate transition to the next state, which in turn becomes the new current state. By definition, each state has one and only one transition for each character in the alphabet. This means that for our DNA alphabet we know that each state has four possible transitions to a next state. Note that in the figure we have labeled some edges (transitions) with multiple alphabet symbols to denote more than one transition to the same state.</p> <p>We continue to follow transitions until a termination event occurs. If we enter state 5, known as the final state (the two concentric circles denote the final state in the DFA graph), we can stop and report success. The DFA graph has discovered an occurrence of the pattern. You might note that there are no transitions out of the final state, meaning that we must stop at that point. The location of the pattern can be computed from the location of the current character and the size of the pattern. On the other hand, if we run out of text characters and the current state is somewhere else in the DFA, known as a nonfinal state, we know that the pattern did not occur.</p> <p><code>Figure\u00a03</code> shows a step-by-step trace of the example DFA as it works through the text string ACGACACATA looking for the substring ACATA. The next state computed by the DFA always becomes the current state in the subsequent step. Since there is one and only one next state for every current state\u2013current character combination, the processing through the DFA graph is easy to follow.</p> <p> Figure\u00a03: A Trace of the DFA Pattern Matcher </p> <p>Since every character from the text is used once as input to the DFA graph, the complexity of this approach is \\(O(n)\\). However, we need to take into account the preprocessing step that builds the DFA. There are many well-known algorithms for producing a DFA graph from a pattern. Unfortunately, all of them are quite complex mostly due to the fact that each state (vertex) must have a transition (edge) accounting for each alphabet symbol. The question arises as to whether there might be a similar pattern matcher that employs a more streamlined set of edges.</p>"},{"location":"c8/s6/#864-\u4f7f\u7528\u56feknuth-morris-pratt\u7b97\u6cd5","title":"8.6.4. \u4f7f\u7528\u56fe\uff1aKnuth-Morris-Pratt\u7b97\u6cd5","text":"<p>8.6.4. Using Graphs: Knuth-Morris-Pratt</p> \u4e2d\u6587\u82f1\u6587 <p>Recall the simple pattern matcher presented earlier. Every possible substring of the text was tested against the pattern. In many cases this proved to be a waste of time since the actual starting point for the match was farther down the text string. A possible solution to this inefficiency would be to slide the pattern more than one text character if a mismatch occurs. <code>Figure\u00a04</code> shows this strategy using the rule that we slide the pattern over to the point where the previous mismatch happened.</p> <p> Figure 4: Simple Pattern Matcher with Longer Shifts </p> <p>In step 1, we find that the first two positions match. Since the mismatch occurs in the third character (the shaded character), we slide the entire pattern over and begin our next match at that point. In step 2, we fail immediately so there is no choice but to slide over to the next position. Now, the first three positions match. However, there is a problem. When the mismatch occurs, our algorithm says to slide over to that point. Unfortunately, this is too far and we miss the actual starting point for the pattern in the text string (position 5).</p> <p>The reason this solution failed is that we did not take advantage of information about the content of the pattern and the text that had been seen in a previously attempted match. Note that in step 3, the last two characters of the text string that occur at the time of the mismatch (positions 5 and 6) actually match the first two characters of the pattern. We say that a two-character prefix of the pattern matches a two-character suffix of the text string processed up to that point. This is valuable information. Had we been tracking the amount of overlap between prefixes and suffixes, we could have simply slid the pattern two characters, which would have put us in the right place to start step 4.</p> <p>This observation leads to a pattern matcher known as Knuth-Morris-Pratt (or KMP), named for the computer scientists who first presented it. The idea is to build a graph representation that will provide information as to the amount of \u201cslide\u201d that will be necessary when a mismatch occurs. The KMP graph will again consist of states and transitions (vertices and edges). However, unlike the DFA graph from the previous section, there will be only two transitions leaving each state.</p> <p><code>Figure\u00a05</code> shows the complete KMP graph for the example pattern. There are two special states for a KMP graph, the initial state and the final state. The initial state, marked \u201cget,\u201d is responsible for reading the next character from the input text. The subsequent transition, marked with an asterisk, is always taken. Note that the start transition enters this initial state, which means that we initially get the first character from the text and transition immediately to the next state (state 1). The final state (state 6), this time labeled with an \u201cF,\u201d again means success and represents a termination point for the graph.</p> <p> Figure 5: An Example KMP Graph </p> <p>Each remaining vertex is responsible for checking a particular character of the pattern against the current text character. For example, the vertex labeled \u201cC?\u201d asks whether the current text character is C. If so, then the edge labeled \u201cY\u201d is used. This means \u201cyes,\u201d there was a match. In addition, the next character is read. In general, whenever a state is successful in matching the character it is responsible for, the next character is read from the text.</p> <p>The remaining transitions, those labeled \u201cN,\u201d denote that a mismatch occurred. In this case, as was explained above, we need to know how many positions to slide the pattern. In essence, we want to keep the current text character and simply move back to a previous point in the pattern. To compute this, we use a simple algorithm that basically checks the pattern against itself, looking for overlap between a prefix and a suffix (see <code>Listing\u00a0lst_mismatchedlinks</code>). If such an overlap is found, its length tells us how far back to place the mismatched link in the KMP graph. It is important to note that new text characters are not processed when a mismatched link is used.</p> Listing\u00a0lst_mismatchedlinks<pre><code>def mismatched_links(pattern):\n    aug_pattern = \"0\" + pattern\n    links = {1: 0}\n    for k in range(2, len(aug_pattern)):\n        s = links[k - 1]\n        while s &gt;= 1:\n            if aug_pattern[s] == aug_pattern[k - 1]:\n                break\n            else:\n                s = links[s]\n        links[k] = s + 1\n    return links\n</code></pre> <p>Here is the example pattern as it is being processed by the <code>mismatched_links</code> method:</p> <pre><code>&gt;&gt;&gt; mismatched_links(\"ACATA\")\n{1: 0, 2: 1, 3: 1, 4: 2, 5: 1}\n&gt;&gt;&gt;\n</code></pre> <p>The value returned by the method is a dictionary containing key-value pairs where the key is the current vertex (state) and the value is its destination vertex for the mismatched link. It can be seen that each state, from 1 to 5 corresponding to each character in the pattern, has a transition back to a previous state in the KMP graph.</p> <p>As we noted earlier, the mismatched links can be computed by sliding the pattern past itself looking for the longest matching prefix and suffix. The method begins by augmenting the pattern so that the indices on the characters match the vertex labels in the KMP graph. Since the initial state is state 0, we have used the <code>\u201c0\u201d</code> symbol as a placeholder. Now the characters 1 to \\(m\\) in the augmented pattern correspond directly with the states 1 to \\(m\\) in the graph.</p> <p>Line\u00a03 creates the first dictionary entry, which is always a transition from vertex 1 back to the initial state where a new character is automatically read from the text string. The iteration that follows simply checks larger and larger pieces of the pattern, looking for prefix and suffix overlap. If such an overlap occurs, the length of the overlap can be used to set the next link.</p> <p><code>Figure\u00a06</code> shows the KMP graph as it is being used to locate the example pattern in the text string ACGACACATA. Again, notice that the current character changes only when a match link has been used. In the case of a mismatch, as in steps 4 and 5, the current character remains the same. It is not until step 6, when we have transitioned all the way back to state 0, that we get the next character and return to state 1.</p> <p>Steps 10 and 11 show the importance of the proper mismatched link. In step 10 the current character, C, does not match the symbol that state 4 needs to match. The result is a mismatched link. However, since we have seen a partial match at that point, the mismatched link reverts back to state 2 where there is a correct match. This eventually leads to a successful pattern match.</p> <p> Figure 6: A Trace of the KMP Pattern Matcher </p> <p>As with the DFA graph from the previous section, KMP pattern matching is \\(O(n)\\) since we process each character of the text string. However, the KMP graph is much easier to construct and requires much less storage as there are only two transitions from every vertex.</p> <p>Recall the simple pattern matcher presented earlier. Every possible substring of the text was tested against the pattern. In many cases this proved to be a waste of time since the actual starting point for the match was farther down the text string. A possible solution to this inefficiency would be to slide the pattern more than one text character if a mismatch occurs. <code>Figure\u00a04</code> shows this strategy using the rule that we slide the pattern over to the point where the previous mismatch happened.</p> <p> Figure 4: Simple Pattern Matcher with Longer Shifts </p> <p>In step 1, we find that the first two positions match. Since the mismatch occurs in the third character (the shaded character), we slide the entire pattern over and begin our next match at that point. In step 2, we fail immediately so there is no choice but to slide over to the next position. Now, the first three positions match. However, there is a problem. When the mismatch occurs, our algorithm says to slide over to that point. Unfortunately, this is too far and we miss the actual starting point for the pattern in the text string (position 5).</p> <p>The reason this solution failed is that we did not take advantage of information about the content of the pattern and the text that had been seen in a previously attempted match. Note that in step 3, the last two characters of the text string that occur at the time of the mismatch (positions 5 and 6) actually match the first two characters of the pattern. We say that a two-character prefix of the pattern matches a two-character suffix of the text string processed up to that point. This is valuable information. Had we been tracking the amount of overlap between prefixes and suffixes, we could have simply slid the pattern two characters, which would have put us in the right place to start step 4.</p> <p>This observation leads to a pattern matcher known as Knuth-Morris-Pratt (or KMP), named for the computer scientists who first presented it. The idea is to build a graph representation that will provide information as to the amount of \u201cslide\u201d that will be necessary when a mismatch occurs. The KMP graph will again consist of states and transitions (vertices and edges). However, unlike the DFA graph from the previous section, there will be only two transitions leaving each state.</p> <p><code>Figure\u00a05</code> shows the complete KMP graph for the example pattern. There are two special states for a KMP graph, the initial state and the final state. The initial state, marked \u201cget,\u201d is responsible for reading the next character from the input text. The subsequent transition, marked with an asterisk, is always taken. Note that the start transition enters this initial state, which means that we initially get the first character from the text and transition immediately to the next state (state 1). The final state (state 6), this time labeled with an \u201cF,\u201d again means success and represents a termination point for the graph.</p> <p> Figure 5: An Example KMP Graph </p> <p>Each remaining vertex is responsible for checking a particular character of the pattern against the current text character. For example, the vertex labeled \u201cC?\u201d asks whether the current text character is C. If so, then the edge labeled \u201cY\u201d is used. This means \u201cyes,\u201d there was a match. In addition, the next character is read. In general, whenever a state is successful in matching the character it is responsible for, the next character is read from the text.</p> <p>The remaining transitions, those labeled \u201cN,\u201d denote that a mismatch occurred. In this case, as was explained above, we need to know how many positions to slide the pattern. In essence, we want to keep the current text character and simply move back to a previous point in the pattern. To compute this, we use a simple algorithm that basically checks the pattern against itself, looking for overlap between a prefix and a suffix (see <code>Listing\u00a0lst_mismatchedlinks</code>). If such an overlap is found, its length tells us how far back to place the mismatched link in the KMP graph. It is important to note that new text characters are not processed when a mismatched link is used.</p> Listing\u00a0lst_mismatchedlinks<pre><code>def mismatched_links(pattern):\n    aug_pattern = \"0\" + pattern\n    links = {1: 0}\n    for k in range(2, len(aug_pattern)):\n        s = links[k - 1]\n        while s &gt;= 1:\n            if aug_pattern[s] == aug_pattern[k - 1]:\n                break\n            else:\n                s = links[s]\n        links[k] = s + 1\n    return links\n</code></pre> <p>Here is the example pattern as it is being processed by the <code>mismatched_links</code> method:</p> <pre><code>&gt;&gt;&gt; mismatched_links(\"ACATA\")\n{1: 0, 2: 1, 3: 1, 4: 2, 5: 1}\n&gt;&gt;&gt;\n</code></pre> <p>The value returned by the method is a dictionary containing key-value pairs where the key is the current vertex (state) and the value is its destination vertex for the mismatched link. It can be seen that each state, from 1 to 5 corresponding to each character in the pattern, has a transition back to a previous state in the KMP graph.</p> <p>As we noted earlier, the mismatched links can be computed by sliding the pattern past itself looking for the longest matching prefix and suffix. The method begins by augmenting the pattern so that the indices on the characters match the vertex labels in the KMP graph. Since the initial state is state 0, we have used the <code>\u201c0\u201d</code> symbol as a placeholder. Now the characters 1 to \\(m\\) in the augmented pattern correspond directly with the states 1 to \\(m\\) in the graph.</p> <p>Line\u00a03 creates the first dictionary entry, which is always a transition from vertex 1 back to the initial state where a new character is automatically read from the text string. The iteration that follows simply checks larger and larger pieces of the pattern, looking for prefix and suffix overlap. If such an overlap occurs, the length of the overlap can be used to set the next link.</p> <p><code>Figure\u00a06</code> shows the KMP graph as it is being used to locate the example pattern in the text string ACGACACATA. Again, notice that the current character changes only when a match link has been used. In the case of a mismatch, as in steps 4 and 5, the current character remains the same. It is not until step 6, when we have transitioned all the way back to state 0, that we get the next character and return to state 1.</p> <p>Steps 10 and 11 show the importance of the proper mismatched link. In step 10 the current character, C, does not match the symbol that state 4 needs to match. The result is a mismatched link. However, since we have seen a partial match at that point, the mismatched link reverts back to state 2 where there is a correct match. This eventually leads to a successful pattern match.</p> <p> Figure 6: A Trace of the KMP Pattern Matcher </p> <p>As with the DFA graph from the previous section, KMP pattern matching is \\(O(n)\\) since we process each character of the text string. However, the KMP graph is much easier to construct and requires much less storage as there are only two transitions from every vertex.</p>"}]}